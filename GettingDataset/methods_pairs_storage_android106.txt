727
#method_before
@Override
public void handleMessage(Message msg) {
    RILRequest rr;
    switch(msg.what) {
        case EVENT_WAKE_LOCK_TIMEOUT:
            synchronized (mRequestList) {
                if (msg.arg1 == mWlSequenceNum && clearWakeLock(FOR_WAKELOCK)) {
                    if (RILJ_LOGD) {
                        int count = mRequestList.size();
                        Rlog.d(RILJ_LOG_TAG, "WAKE_LOCK_TIMEOUT " + " mRequestList=" + count);
                        for (int i = 0; i < count; i++) {
                            rr = mRequestList.valueAt(i);
                            Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
                        }
                    }
                }
            }
            break;
        case EVENT_ACK_WAKE_LOCK_TIMEOUT:
            if (msg.arg1 == mAckWlSequenceNum && clearWakeLock(FOR_ACK_WAKELOCK)) {
                if (RILJ_LOGV) {
                    Rlog.d(RILJ_LOG_TAG, "ACK_WAKE_LOCK_TIMEOUT");
                }
            }
            break;
        case EVENT_BLOCKING_RESPONSE_TIMEOUT:
            int serial = msg.arg1;
            rr = findAndRemoveRequestFromList(serial);
            // If the request has already been processed, do nothing
            if (rr == null) {
                break;
            }
            // build a response if expected
            if (rr.mResult != null) {
                Object timeoutResponse = getResponseForTimedOutRILRequest(rr);
                AsyncResult.forMessage(rr.mResult, timeoutResponse, null);
                rr.mResult.sendToTarget();
                mMetrics.writeOnRilTimeoutResponse(mPhoneId, rr.mSerial, rr.mRequest);
            }
            decrementWakeLock(rr);
            rr.release();
            break;
        case EVENT_RADIO_PROXY_DEAD:
            riljLog("handleMessage: EVENT_RADIO_PROXY_DEAD cookie = " + msg.obj + " mRadioProxyCookie = " + mRadioProxyCookie.get());
            if ((long) msg.obj == mRadioProxyCookie.get()) {
                // increment the cookie so that more indications with the same cookie are
                // ignored
                mRadioProxyCookie.incrementAndGet();
                resetProxyAndRequestList();
                // todo: rild should be back up since message was sent with a delay. this is
                // a hack.
                getRadioProxy(null);
                getOemHookProxy(null);
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    RILRequest rr;
    switch(msg.what) {
        case EVENT_WAKE_LOCK_TIMEOUT:
            synchronized (mRequestList) {
                if (msg.arg1 == mWlSequenceNum && clearWakeLock(FOR_WAKELOCK)) {
                    if (RILJ_LOGD) {
                        int count = mRequestList.size();
                        Rlog.d(RILJ_LOG_TAG, "WAKE_LOCK_TIMEOUT " + " mRequestList=" + count);
                        for (int i = 0; i < count; i++) {
                            rr = mRequestList.valueAt(i);
                            Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
                        }
                    }
                }
            }
            break;
        case EVENT_ACK_WAKE_LOCK_TIMEOUT:
            if (msg.arg1 == mAckWlSequenceNum && clearWakeLock(FOR_ACK_WAKELOCK)) {
                if (RILJ_LOGV) {
                    Rlog.d(RILJ_LOG_TAG, "ACK_WAKE_LOCK_TIMEOUT");
                }
            }
            break;
        case EVENT_BLOCKING_RESPONSE_TIMEOUT:
            int serial = msg.arg1;
            rr = findAndRemoveRequestFromList(serial);
            // If the request has already been processed, do nothing
            if (rr == null) {
                break;
            }
            // build a response if expected
            if (rr.mResult != null) {
                Object timeoutResponse = getResponseForTimedOutRILRequest(rr);
                AsyncResult.forMessage(rr.mResult, timeoutResponse, null);
                rr.mResult.sendToTarget();
                mMetrics.writeOnRilTimeoutResponse(mPhoneId, rr.mSerial, rr.mRequest);
            }
            decrementWakeLock(rr);
            rr.release();
            break;
        case EVENT_RADIO_PROXY_DEAD:
            riljLog("handleMessage: EVENT_RADIO_PROXY_DEAD cookie = " + msg.obj + " mRadioProxyCookie = " + mRadioProxyCookie.get());
            if ((long) msg.obj == mRadioProxyCookie.get()) {
                resetProxyAndRequestList();
                // todo: rild should be back up since message was sent with a delay. this is
                // a hack.
                getRadioProxy(null);
                getOemHookProxy(null);
            }
            break;
    }
}
#end_block

#method_before
private void resetProxyAndRequestList() {
    mRadioProxy = null;
    mOemHookProxy = null;
    setRadioState(RadioState.RADIO_UNAVAILABLE);
    RILRequest.resetSerial();
    // Clear request list on close
    clearRequestList(RADIO_NOT_AVAILABLE, false);
// todo: need to get service right away so setResponseFunctions() can be called for
// unsolicited indications. getService() is not a blocking call, so it doesn't help to call
// it here. Current hack is to call getService() on death notification after a delay.
}
#method_after
private void resetProxyAndRequestList() {
    mRadioProxy = null;
    mOemHookProxy = null;
    // increment the cookie so that death notification can be ignored
    mRadioProxyCookie.incrementAndGet();
    setRadioState(RadioState.RADIO_UNAVAILABLE);
    RILRequest.resetSerial();
    // Clear request list on close
    clearRequestList(RADIO_NOT_AVAILABLE, false);
// todo: need to get service right away so setResponseFunctions() can be called for
// unsolicited indications. getService() is not a blocking call, so it doesn't help to call
// it here. Current hack is to call getService() on death notification after a delay.
}
#end_block

#method_before
private IRadio getRadioProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("getRadioProxy: Not calling getService(): wifi-only");
        return null;
    }
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(RIL_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: mRadioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        riljLoge("RadioProxy getService/setResponseFunctions: " + e);
    }
    if (mRadioProxy == null) {
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
    }
    return mRadioProxy;
}
#method_after
private IRadio getRadioProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("getRadioProxy: Not calling getService(): wifi-only");
        return null;
    }
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(RIL_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: mRadioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        riljLoge("RadioProxy getService/setResponseFunctions: " + e);
    }
    if (mRadioProxy == null) {
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.incrementAndGet()), IRADIO_GET_SERVICE_DELAY_MILLIS);
    }
    return mRadioProxy;
}
#end_block

#method_before
private IOemHook getOemHookProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("getOemHookProxy: Not calling getService(): wifi-only");
        return null;
    }
    if (mOemHookProxy != null) {
        return mOemHookProxy;
    }
    try {
        mOemHookProxy = IOemHook.getService(OEM_HOOK_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mOemHookProxy != null) {
            // not calling linkToDeath() as ril service runs in the same process and death
            // notification for that should be sufficient
            mOemHookProxy.setResponseFunctions(mOemHookResponse, mOemHookIndication);
        } else {
            riljLoge("getOemHookProxy: mOemHookProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mOemHookProxy = null;
        riljLoge("OemHookProxy getService/setResponseFunctions: " + e);
    }
    if (mOemHookProxy == null) {
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
    }
    return mOemHookProxy;
}
#method_after
private IOemHook getOemHookProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("getOemHookProxy: Not calling getService(): wifi-only");
        return null;
    }
    if (mOemHookProxy != null) {
        return mOemHookProxy;
    }
    try {
        mOemHookProxy = IOemHook.getService(OEM_HOOK_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mOemHookProxy != null) {
            // not calling linkToDeath() as ril service runs in the same process and death
            // notification for that should be sufficient
            mOemHookProxy.setResponseFunctions(mOemHookResponse, mOemHookIndication);
        } else {
            riljLoge("getOemHookProxy: mOemHookProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mOemHookProxy = null;
        riljLoge("OemHookProxy getService/setResponseFunctions: " + e);
    }
    if (mOemHookProxy == null) {
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.incrementAndGet()), IRADIO_GET_SERVICE_DELAY_MILLIS);
    }
    return mOemHookProxy;
}
#end_block

#method_before
private void handleRadioProxyExceptionForRR(RILRequest rr, String caller, Exception e) {
    riljLoge(caller + ": " + e);
    resetProxyAndRequestList();
}
#method_after
private void handleRadioProxyExceptionForRR(RILRequest rr, String caller, Exception e) {
    riljLoge(caller + ": " + e);
    resetProxyAndRequestList();
    // service most likely died, handle exception like death notification to try to get service
    // again
    mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.incrementAndGet()), IRADIO_GET_SERVICE_DELAY_MILLIS);
}
#end_block

#method_before
private void sendAck() {
    // TODO: Remove rr and clean up acquireWakelock for response and ack
    RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null, mRILDefaultWorkSource);
    acquireWakeLock(rr, RIL.FOR_ACK_WAKELOCK);
    IRadio radioProxy = getRadioProxy(null);
    if (radioProxy != null) {
        try {
            radioProxy.responseAcknowledgement();
        } catch (RemoteException | RuntimeException e) {
            resetProxyAndRequestList();
            riljLoge("sendAck: " + e);
        }
    } else {
        Rlog.e(RILJ_LOG_TAG, "Error trying to send ack, radioProxy = null");
    }
    rr.release();
}
#method_after
private void sendAck() {
    // TODO: Remove rr and clean up acquireWakelock for response and ack
    RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null, mRILDefaultWorkSource);
    acquireWakeLock(rr, RIL.FOR_ACK_WAKELOCK);
    IRadio radioProxy = getRadioProxy(null);
    if (radioProxy != null) {
        try {
            radioProxy.responseAcknowledgement();
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendAck", e);
            riljLoge("sendAck: " + e);
        }
    } else {
        Rlog.e(RILJ_LOG_TAG, "Error trying to send ack, radioProxy = null");
    }
    rr.release();
}
#end_block

#method_before
private String getTemplate(TestCaseName testCaseName) {
    if (testCaseName != null) {
        // will prevent CTS and AJUR from working properly; see b/36541809
        throw new IllegalStateException("@TestCaseName not currently supported as it breaks running tests in CTS");
    // return testCaseName.value();
    }
    return DEFAULT_TEMPLATE;
}
#method_after
private String getTemplate(TestCaseName testCaseName) {
    if (testCaseName != null) {
        // see b/36541809
        throw new IllegalStateException("@TestCaseName not currently supported as it breaks running tests in CTS");
    // return testCaseName.value();
    }
    return DEFAULT_TEMPLATE;
}
#end_block

#method_before
@Override
public WifiConfiguration getMatchingWifiConfig(ScanResult scanResult) {
    enforceAccessPermission();
    mLog.trace("getMatchingWifiConfig uid=%").c(Binder.getCallingUid()).flush();
    return mWifiStateMachine.syncGetMatchingWifiConfig(scanResult, mWifiStateMachineChannel);
}
#method_after
@Override
public WifiConfiguration getMatchingWifiConfig(ScanResult scanResult) {
    enforceAccessPermission();
    mLog.trace("getMatchingWifiConfig uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncGetMatchingWifiConfig(scanResult, mWifiStateMachineChannel);
}
#end_block

#method_before
@Override
public boolean addOrUpdatePasspointConfiguration(PasspointConfiguration config) {
    enforceChangePermission();
    mLog.trace("addorUpdatePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    return mWifiStateMachine.syncAddOrUpdatePasspointConfig(mWifiStateMachineChannel, config);
}
#method_after
@Override
public boolean addOrUpdatePasspointConfiguration(PasspointConfiguration config) {
    enforceChangePermission();
    mLog.trace("addorUpdatePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncAddOrUpdatePasspointConfig(mWifiStateMachineChannel, config);
}
#end_block

#method_before
@Override
public boolean removePasspointConfiguration(String fqdn) {
    enforceChangePermission();
    mLog.trace("removePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    return mWifiStateMachine.syncRemovePasspointConfig(mWifiStateMachineChannel, fqdn);
}
#method_after
@Override
public boolean removePasspointConfiguration(String fqdn) {
    enforceChangePermission();
    mLog.trace("removePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncRemovePasspointConfig(mWifiStateMachineChannel, fqdn);
}
#end_block

#method_before
@Override
public List<PasspointConfiguration> getPasspointConfigurations() {
    enforceAccessPermission();
    mLog.trace("getPasspointConfigurations uid=%").c(Binder.getCallingUid()).flush();
    return mWifiStateMachine.syncGetPasspointConfigs(mWifiStateMachineChannel);
}
#method_after
@Override
public List<PasspointConfiguration> getPasspointConfigurations() {
    enforceAccessPermission();
    mLog.trace("getPasspointConfigurations uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncGetPasspointConfigs(mWifiStateMachineChannel);
}
#end_block

#method_before
@Override
public void queryPasspointIcon(long bssid, String fileName) {
    enforceAccessPermission();
    mLog.trace("queryPasspointIcon uid=%").c(Binder.getCallingUid()).flush();
    mWifiStateMachine.syncQueryPasspointIcon(mWifiStateMachineChannel, bssid, fileName);
}
#method_after
@Override
public void queryPasspointIcon(long bssid, String fileName) {
    enforceAccessPermission();
    mLog.trace("queryPasspointIcon uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    mWifiStateMachine.syncQueryPasspointIcon(mWifiStateMachineChannel, bssid, fileName);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mPasspointManager.dump(pw);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    boolean timedOut;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            timedOut = message.arg1 > 0;
            reasonCode = message.arg2;
            Log.d(TAG, "Assocation Rejection event: bssid=" + bssid + " reason code=" + reasonCode + " timedOut=" + Boolean.toString(timedOut));
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what, mPasspointManager.getMatchingWifiConfig((ScanResult) message.obj));
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            // on disconnect.
            if (!mWifiNative.removeAllNetworks()) {
                loge("Failed to remove networks before WPS");
            }
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    boolean timedOut;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            timedOut = message.arg1 > 0;
            reasonCode = message.arg2;
            Log.d(TAG, "Assocation Rejection event: bssid=" + bssid + " reason code=" + reasonCode + " timedOut=" + Boolean.toString(timedOut));
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what, mPasspointManager.getMatchingWifiConfig((ScanResult) message.obj));
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else if (!mWifiConfigManager.enableNetwork(result.getNetworkId(), false, message.sendingUid)) {
                loge("ENABLE_NETWORK config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            // on disconnect.
            if (!mWifiNative.removeAllNetworks()) {
                loge("Failed to remove networks before WPS");
            }
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName, true);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName, true);
            setSupplicantLogLevel();
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
    // Disable wpa_supplicant from auto reconnecting.
    mWifiNative.enableStaAutoReconnect(false);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
    // Disable wpa_supplicant from auto reconnecting.
    mWifiNative.enableStaAutoReconnect(false);
    // STA has higher priority over P2P
    mWifiNative.setConcurrencyPriority(true);
}
#end_block

#method_before
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#method_after
@Override
public void enter() {
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on entering connect mode");
    }
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#end_block

#method_before
@Override
public void exit() {
    // Let the system know that wifi is not available since we are exiting client mode.
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#method_after
@Override
public void exit() {
    // Let the system know that wifi is not available since we are exiting client mode.
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on exiting connect mode");
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    boolean timedOut;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            timedOut = message.arg1 > 0;
            reasonCode = message.arg2;
            Log.d(TAG, "Assocation Rejection event: bssid=" + bssid + " reason code=" + reasonCode + " timedOut=" + Boolean.toString(timedOut));
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what, mPasspointManager.getMatchingWifiConfig((ScanResult) message.obj));
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    boolean timedOut;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            timedOut = message.arg1 > 0;
            reasonCode = message.arg2;
            Log.d(TAG, "Assocation Rejection event: bssid=" + bssid + " reason code=" + reasonCode + " timedOut=" + Boolean.toString(timedOut));
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what, mPasspointManager.getMatchingWifiConfig((ScanResult) message.obj));
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            // on disconnect.
            if (!mWifiNative.removeAllNetworks()) {
                loge("Failed to remove networks before WPS");
            }
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.WPS_SUCCESS_EVENT:
            // Ignore intermediate success, wait for full connection
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            replyToMessage(mSourceMessage, WifiManager.WPS_COMPLETED);
            mSourceMessage.recycle();
            mSourceMessage = null;
            deferMessage(message);
            transitionTo(mDisconnectedState);
            break;
        case WifiMonitor.WPS_OVERLAP_EVENT:
            replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_OVERLAP_ERROR);
            mSourceMessage.recycle();
            mSourceMessage = null;
            transitionTo(mDisconnectedState);
            break;
        case WifiMonitor.WPS_FAIL_EVENT:
            // Arg1 has the reason for the failure
            if ((message.arg1 != WifiManager.ERROR) || (message.arg2 != 0)) {
                replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, message.arg1);
                mSourceMessage.recycle();
                mSourceMessage = null;
                transitionTo(mDisconnectedState);
            } else {
                if (mVerboseLoggingEnabled) {
                    log("Ignore unspecified fail event during WPS connection");
                }
            }
            break;
        case WifiMonitor.WPS_TIMEOUT_EVENT:
            replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_TIMED_OUT);
            mSourceMessage.recycle();
            mSourceMessage = null;
            transitionTo(mDisconnectedState);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.IN_PROGRESS);
            break;
        case WifiManager.CANCEL_WPS:
            if (mWifiNative.cancelWps()) {
                replyToMessage(message, WifiManager.CANCEL_WPS_SUCCEDED);
            } else {
                replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.ERROR);
            }
            transitionTo(mDisconnectedState);
            break;
        /**
         * Defer all commands that can cause connections to a different network
         * or put the state machine out of connect mode
         */
        case CMD_SET_OPERATIONAL_MODE:
        case WifiManager.CONNECT_NETWORK:
        case CMD_ENABLE_NETWORK:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            deferMessage(message);
            break;
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection lost");
            handleNetworkDisconnect();
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            if (mVerboseLoggingEnabled) {
                log("Ignore Assoc reject event during WPS Connection");
            }
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            // event at the end of the sequence anyway.
            if (mVerboseLoggingEnabled)
                log("Ignore auth failure during WPS connection");
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            // a WPS success or failure
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.WPS_SUCCESS_EVENT:
            // Ignore intermediate success, wait for full connection
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (loadNetworksFromSupplicantAfterWps()) {
                replyToMessage(mSourceMessage, WifiManager.WPS_COMPLETED);
            } else {
                replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            mSourceMessage.recycle();
            mSourceMessage = null;
            deferMessage(message);
            transitionTo(mDisconnectedState);
            break;
        case WifiMonitor.WPS_OVERLAP_EVENT:
            replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_OVERLAP_ERROR);
            mSourceMessage.recycle();
            mSourceMessage = null;
            transitionTo(mDisconnectedState);
            break;
        case WifiMonitor.WPS_FAIL_EVENT:
            // Arg1 has the reason for the failure
            if ((message.arg1 != WifiManager.ERROR) || (message.arg2 != 0)) {
                replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, message.arg1);
                mSourceMessage.recycle();
                mSourceMessage = null;
                transitionTo(mDisconnectedState);
            } else {
                if (mVerboseLoggingEnabled) {
                    log("Ignore unspecified fail event during WPS connection");
                }
            }
            break;
        case WifiMonitor.WPS_TIMEOUT_EVENT:
            replyToMessage(mSourceMessage, WifiManager.WPS_FAILED, WifiManager.WPS_TIMED_OUT);
            mSourceMessage.recycle();
            mSourceMessage = null;
            transitionTo(mDisconnectedState);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.IN_PROGRESS);
            break;
        case WifiManager.CANCEL_WPS:
            if (mWifiNative.cancelWps()) {
                replyToMessage(message, WifiManager.CANCEL_WPS_SUCCEDED);
            } else {
                replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.ERROR);
            }
            transitionTo(mDisconnectedState);
            break;
        /**
         * Defer all commands that can cause connections to a different network
         * or put the state machine out of connect mode
         */
        case CMD_SET_OPERATIONAL_MODE:
        case WifiManager.CONNECT_NETWORK:
        case CMD_ENABLE_NETWORK:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            deferMessage(message);
            break;
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection lost");
            handleNetworkDisconnect();
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            if (mVerboseLoggingEnabled) {
                log("Ignore Assoc reject event during WPS Connection");
            }
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            // event at the end of the sequence anyway.
            if (mVerboseLoggingEnabled)
                log("Ignore auth failure during WPS connection");
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            // a WPS success or failure
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public WifiConfiguration getMatchingWifiConfig(ScanResult scanResult) {
    if (scanResult == null) {
        Log.e(TAG, "Attempt to get matching config for a null ScanResult");
        return null;
    }
    Pair<PasspointProvider, PasspointMatch> matchedProvider = matchProvider(scanResult);
    if (matchedProvider == null) {
        Log.d(TAG, "No provider found for " + scanResult.SSID);
        return null;
    }
    WifiConfiguration config = matchedProvider.first.getWifiConfig();
    config.SSID = ScanResultUtil.createQuotedSSID(scanResult.SSID);
    return config;
}
#method_after
public WifiConfiguration getMatchingWifiConfig(ScanResult scanResult) {
    if (scanResult == null) {
        Log.e(TAG, "Attempt to get matching config for a null ScanResult");
        return null;
    }
    Pair<PasspointProvider, PasspointMatch> matchedProvider = matchProvider(scanResult);
    if (matchedProvider == null) {
        return null;
    }
    WifiConfiguration config = matchedProvider.first.getWifiConfig();
    config.SSID = ScanResultUtil.createQuotedSSID(scanResult.SSID);
    return config;
}
#end_block

#method_before
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords " + this);
    // Unregister for all events
    mCi.unregisterForIccRefresh(this);
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    resetRecords();
    super.dispose();
}
#method_after
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords this=" + this);
    // Unregister for all events
    mCi.unregisterForIccRefresh(this);
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    mParentApp.unregisterForLocked(this);
    resetRecords();
    super.dispose();
}
#end_block

#method_before
protected void finalize() {
    if (DBG)
        log("finalized");
}
#method_after
@Override
protected void finalize() {
    if (DBG)
        log("finalized");
}
#end_block

#method_before
protected void resetRecords() {
    mImsi = null;
    msisdn = null;
    voiceMailNum = null;
    countVoiceMessages = 0;
    mncLength = UNINITIALIZED;
    iccid = null;
    // -1 means no EF_SPN found; treat accordingly.
    spnDisplayCondition = -1;
    efMWIS = null;
    efCPHS_MWI = null;
    spdiNetworks = null;
    pnnHomeName = null;
    gid1 = null;
    adnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, null);
    SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, null);
    SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, null);
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    recordsRequested = false;
}
#method_after
protected void resetRecords() {
    mImsi = null;
    mMsisdn = null;
    mVoiceMailNum = null;
    mMncLength = UNINITIALIZED;
    log("setting0 mMncLength" + mMncLength);
    mIccId = null;
    mFullIccId = null;
    // -1 means no EF_SPN found; treat accordingly.
    mSpnDisplayCondition = -1;
    mEfMWIS = null;
    mEfCPHS_MWI = null;
    mSpdiNetworks = null;
    mPnnHomeName = null;
    mGid1 = null;
    mGid2 = null;
    mAdnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    log("update icc_operator_numeric=" + null);
    mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), "");
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
}
#end_block

#method_before
public String getMsisdnNumber() {
    return msisdn;
}
#method_after
@Override
public String getMsisdnNumber() {
    return mMsisdn;
}
#end_block

#method_before
@Override
public String getGid1() {
    return gid1;
}
#method_after
@Override
public String getGid1() {
    return mGid1;
}
#end_block

#method_before
public void setMsisdnNumber(String alphaTag, String number, Message onComplete) {
    msisdn = number;
    msisdnTag = alphaTag;
    if (DBG)
        log("Set MSISDN: " + msisdnTag + " " + /*msisdn*/
        "xxxxxxx");
    AdnRecord adn = new AdnRecord(msisdnTag, msisdn);
    new AdnRecordLoader(mFh).updateEF(adn, EF_MSISDN, EF_EXT1, 1, null, obtainMessage(EVENT_SET_MSISDN_DONE, onComplete));
}
#method_after
@Override
public void setMsisdnNumber(String alphaTag, String number, Message onComplete) {
    // If the SIM card is locked by PIN, we will set EF_MSISDN fail.
    // In that case, msisdn and msisdnTag should not be update.
    mNewMsisdn = number;
    mNewMsisdnTag = alphaTag;
    if (DBG)
        log("Set MSISDN: " + mNewMsisdnTag + " " + /*mNewMsisdn*/
        "xxxxxxx");
    AdnRecord adn = new AdnRecord(mNewMsisdnTag, mNewMsisdn);
    new AdnRecordLoader(mFh).updateEF(adn, EF_MSISDN, getExtFromEf(EF_MSISDN), 1, null, obtainMessage(EVENT_SET_MSISDN_DONE, onComplete));
}
#end_block

#method_before
public String getMsisdnAlphaTag() {
    return msisdnTag;
}
#method_after
@Override
public String getMsisdnAlphaTag() {
    return mMsisdnTag;
}
#end_block

#method_before
public String getVoiceMailNumber() {
    return voiceMailNum;
}
#method_after
@Override
public String getVoiceMailNumber() {
    return mVoiceMailNum;
}
#end_block

#method_before
public void setVoiceMailNumber(String alphaTag, String voiceNumber, Message onComplete) {
    if (isVoiceMailFixed) {
        AsyncResult.forMessage((onComplete)).exception = new IccVmFixedException("Voicemail number is fixed by operator");
        onComplete.sendToTarget();
        return;
    }
    newVoiceMailNum = voiceNumber;
    newVoiceMailTag = alphaTag;
    AdnRecord adn = new AdnRecord(newVoiceMailTag, newVoiceMailNum);
    if (mailboxIndex != 0 && mailboxIndex != 0xff) {
        new AdnRecordLoader(mFh).updateEF(adn, EF_MBDN, EF_EXT6, mailboxIndex, null, obtainMessage(EVENT_SET_MBDN_DONE, onComplete));
    } else if (isCphsMailboxEnabled()) {
        new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onComplete));
    } else {
        AsyncResult.forMessage((onComplete)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
        onComplete.sendToTarget();
    }
}
#method_after
@Override
public void setVoiceMailNumber(String alphaTag, String voiceNumber, Message onComplete) {
    if (mIsVoiceMailFixed) {
        AsyncResult.forMessage((onComplete)).exception = new IccVmFixedException("Voicemail number is fixed by operator");
        onComplete.sendToTarget();
        return;
    }
    mNewVoiceMailNum = voiceNumber;
    mNewVoiceMailTag = alphaTag;
    AdnRecord adn = new AdnRecord(mNewVoiceMailTag, mNewVoiceMailNum);
    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
        new AdnRecordLoader(mFh).updateEF(adn, EF_MBDN, EF_EXT6, mMailboxIndex, null, obtainMessage(EVENT_SET_MBDN_DONE, onComplete));
    } else if (isCphsMailboxEnabled()) {
        new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onComplete));
    } else {
        AsyncResult.forMessage((onComplete)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
        onComplete.sendToTarget();
    }
}
#end_block

#method_before
public String getVoiceMailAlphaTag() {
    return voiceMailTag;
}
#method_after
@Override
public String getVoiceMailAlphaTag() {
    return mVoiceMailTag;
}
#end_block

#method_before
public void setVoiceMessageWaiting(int line, int countWaiting) {
    if (line != 1) {
        // only profile 1 is supported
        return;
    }
    // range check
    if (countWaiting < 0) {
        countWaiting = -1;
    } else if (countWaiting > 0xff) {
        // TS 23.040 9.2.3.24.2
        // "The value 255 shall be taken to mean 255 or greater"
        countWaiting = 0xff;
    }
    countVoiceMessages = countWaiting;
    mRecordsEventsRegistrants.notifyResult(EVENT_MWI);
    try {
        if (efMWIS != null) {
            // TS 51.011 10.3.45
            // lsb of byte 0 is 'voicemail' status
            efMWIS[0] = (byte) ((efMWIS[0] & 0xfe) | (countVoiceMessages == 0 ? 0 : 1));
            // byte 1 is the number of voice messages waiting
            if (countWaiting < 0) {
                // The spec does not define what this should be
                // if we don't know the count
                efMWIS[1] = 0;
            } else {
                efMWIS[1] = (byte) countWaiting;
            }
            mFh.updateEFLinearFixed(EF_MWIS, 1, efMWIS, null, obtainMessage(EVENT_UPDATE_DONE, EF_MWIS));
        }
        if (efCPHS_MWI != null) {
            // Refer CPHS4_2.WW6 B4.2.3
            efCPHS_MWI[0] = (byte) ((efCPHS_MWI[0] & 0xf0) | (countVoiceMessages == 0 ? 0x5 : 0xa));
            mFh.updateEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, efCPHS_MWI, obtainMessage(EVENT_UPDATE_DONE, EF_VOICE_MAIL_INDICATOR_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving voice mail state to SIM. Probably malformed SIM record", ex);
    }
}
#method_after
@Override
public void setVoiceMessageWaiting(int line, int countWaiting) {
    if (line != 1) {
        // only profile 1 is supported
        return;
    }
    try {
        if (mEfMWIS != null) {
            // TS 51.011 10.3.45
            // lsb of byte 0 is 'voicemail' status
            mEfMWIS[0] = (byte) ((mEfMWIS[0] & 0xfe) | (countWaiting == 0 ? 0 : 1));
            // byte 1 is the number of voice messages waiting
            if (countWaiting < 0) {
                // The spec does not define what this should be
                // if we don't know the count
                mEfMWIS[1] = 0;
            } else {
                mEfMWIS[1] = (byte) countWaiting;
            }
            mFh.updateEFLinearFixed(EF_MWIS, 1, mEfMWIS, null, obtainMessage(EVENT_UPDATE_DONE, EF_MWIS, 0));
        }
        if (mEfCPHS_MWI != null) {
            // Refer CPHS4_2.WW6 B4.2.3
            mEfCPHS_MWI[0] = (byte) ((mEfCPHS_MWI[0] & 0xf0) | (countWaiting == 0 ? 0x5 : 0xa));
            mFh.updateEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, mEfCPHS_MWI, obtainMessage(EVENT_UPDATE_DONE, EF_VOICE_MAIL_INDICATOR_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving voice mail state to SIM. Probably malformed SIM record", ex);
    }
}
#end_block

#method_before
private boolean validEfCfis(byte[] data) {
    return (data != null);
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean getVoiceCallForwardingFlag() {
    return callForwardingEnabled;
}
#method_after
@Override
public int getVoiceCallForwardingFlag() {
    return mCallForwardingStatus;
}
#end_block

#method_before
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable) {
    // only line 1 is supported
    if (line != 1)
        return;
    callForwardingEnabled = enable;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte 1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // TODO: Should really update other fields in EF_CFIS, eg,
            // dialing number.  We don't read or use it right now.
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call fowarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#method_after
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
    // only line 1 is supported
    if (line != 1)
        return;
    mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte 1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
            if (enable && !TextUtils.isEmpty(dialNumber)) {
                log("EF_CFIS: updating cf number, " + dialNumber);
                byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(dialNumber);
                System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
                mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
                mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
                mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
            }
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call forwarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#end_block

#method_before
public void onRefresh(boolean fileChanged, int[] fileList) {
    if (fileChanged) {
        // A future optimization would be to inspect fileList and
        // only reload those files that we care about.  For now,
        // just re-fetch all SIM records that we cache.
        fetchSimRecords();
    }
}
#method_after
@Override
public void onRefresh(boolean fileChanged, int[] fileList) {
    if (fileChanged) {
        // A future optimization would be to inspect fileList and
        // only reload those files that we care about.  For now,
        // just re-fetch all SIM records that we cache.
        fetchSimRecords();
    }
}
#end_block

#method_before
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mncLength == UNINITIALIZED || mncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    return mImsi.substring(0, 3 + mncLength);
}
#method_after
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    return mImsi.substring(0, 3 + mMncLength);
}
#end_block

#method_before
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: " + /* imsi.substring(0, 6) +*/
                "xxxxxxx");
                if (((mncLength == UNKNOWN) || (mncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mncLength = 3;
                            break;
                        }
                    }
                }
                if (mncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mncLength = MccTable.smallestDigitsMccForMnc(mcc);
                    } catch (NumberFormatException e) {
                        mncLength = UNKNOWN;
                        loge("Corrupt IMSI!");
                    }
                }
                if (mncLength != UNKNOWN && mncLength != UNINITIALIZED) {
                    // finally have both the imsi and the mncLength and can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mncLength));
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mailboxIndex = (int) data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mailboxIndex != 0 && mailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                recordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                voiceMailNum = null;
                voiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        recordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    recordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                voiceMailNum = adn.getNumber();
                voiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                msisdn = adn.getNumber();
                msisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*msisdn*/
                "xxxxxxx");
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_MWIS: " + IccUtils.bytesToHexString(data));
                efMWIS = data;
                if ((data[0] & 0xff) == 0xff) {
                    log("Uninitialized record MWIS");
                    break;
                }
                // Refer TS 51.011 Section 10.3.45 for the content description
                boolean voiceMailWaiting = ((data[0] & 0x01) != 0);
                countVoiceMessages = data[1] & 0xff;
                if (voiceMailWaiting && countVoiceMessages == 0) {
                    // Unknown count = -1
                    countVoiceMessages = -1;
                }
                mRecordsEventsRegistrants.notifyResult(EVENT_MWI);
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                efCPHS_MWI = data;
                if (efMWIS == null) {
                    int indicator = (int) (data[0] & 0xf);
                    // Refer CPHS4_2.WW6 B4.2.3
                    if (indicator == 0xA) {
                        // Unknown count = -1
                        countVoiceMessages = -1;
                    } else if (indicator == 0x5) {
                        countVoiceMessages = 0;
                    }
                    mRecordsEventsRegistrants.notifyResult(EVENT_MWI);
                }
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                iccid = IccUtils.bcdToString(data, 0, data.length);
                log("iccid: " + iccid);
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mncLength = (int) data[3] & 0xf;
                    if (mncLength == 0xf) {
                        mncLength = UNKNOWN;
                    }
                } finally {
                    if (((mncLength == UNINITIALIZED) || (mncLength == UNKNOWN) || (mncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mncLength = 3;
                                break;
                            }
                        }
                    }
                    if (mncLength == UNKNOWN || mncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            } catch (NumberFormatException e) {
                                mncLength = UNKNOWN;
                                loge("Corrupt IMSI!");
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mncLength = UNKNOWN;
                            log("MNC length not present in EF_AD");
                        }
                    }
                    if (mImsi != null && mncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mncLength));
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                mEfCff = data;
                if (validEfCfis(mEfCfis)) {
                    callForwardingEnabled = ((data[0] & CFF_LINE1_MASK) == CFF_UNCONDITIONAL_ACTIVE);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EVENT_GET_CFF_DONE: invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        pnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null)
                    break;
                handleSmses((ArrayList) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                int[] index = (int[]) ar.result;
                if (ar.exception != null || index.length != 1) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " length " + index.length);
                } else {
                    log("READ EF_SMS RECORD index=" + index[0]);
                    mFh.loadEFLinearFixed(EF_SMS, index[0], obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    voiceMailNum = newVoiceMailNum;
                    voiceMailTag = newVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(voiceMailTag, voiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                    * we only need notify caller once if both updating are
                    * successful.
                    *
                    * so if set_mbdn successful, notify caller here and set
                    * onCphsCompleted to null
                    */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    voiceMailNum = newVoiceMailNum;
                    voiceMailTag = newVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                if (validEfCfis(data)) {
                    mEfCfis = data;
                    // Refer TS 51.011 Section 10.3.46 for the content description
                    callForwardingEnabled = ((data[1] & 0x01) != 0);
                    log("EF_CFIS: callFordwardingEnabled=" + callForwardingEnabled);
                    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
                } else {
                    log("EF_CFIS: invalid data=" + IccUtils.bytesToHexString(data));
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    gid1 = null;
                    break;
                }
                gid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + gid1);
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxx");
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                "xxxxxxx");
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    log("setting4 mMncLength=" + mMncLength);
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 mMncLength=" + mMncLength);
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null)
                    break;
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                int[] index = (int[]) ar.result;
                if (ar.exception != null || index.length != 1) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " length " + index.length);
                } else {
                    log("READ EF_SMS RECORD index=" + index[0]);
                    mFh.loadEFLinearFixed(EF_SMS, index[0], obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                    * we only need notify caller once if both updating are
                    * successful.
                    *
                    * so if set_mbdn successful, notify caller here and set
                    * onCphsCompleted to null
                    */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        Resources resource = Resources.getSystem();
                        if (ar.exception != null && resource.getBoolean(com.android.internal.R.bool.editable_voicemailnumber)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
private void handleFileUpdate(int efid) {
    switch(efid) {
        case EF_MBDN:
            recordsToLoad++;
            new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
            break;
        case EF_MAILBOX_CPHS:
            recordsToLoad++;
            new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
            break;
        case EF_CSP_CPHS:
            recordsToLoad++;
            log("[CSP] SIM Refresh for EF_CSP_CPHS");
            mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
            break;
        default:
            // For now, fetch all records if this is not a
            // voicemail number.
            // TODO: Handle other cases, instead of fetching all.
            adnCache.reset();
            fetchSimRecords();
            break;
    }
}
#method_after
private void handleFileUpdate(int efid) {
    switch(efid) {
        case EF_MBDN:
            mRecordsToLoad++;
            new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
            break;
        case EF_MAILBOX_CPHS:
            mRecordsToLoad++;
            new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
            break;
        case EF_CSP_CPHS:
            mRecordsToLoad++;
            log("[CSP] SIM Refresh for EF_CSP_CPHS");
            mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
            break;
        case EF_FDN:
            if (DBG)
                log("SIM Refresh called for EF_FDN");
            mParentApp.queryFdn();
            break;
        case EF_MSISDN:
            mRecordsToLoad++;
            log("SIM Refresh called for EF_MSISDN");
            new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1, obtainMessage(EVENT_GET_MSISDN_DONE));
            break;
        case EF_CFIS:
        case EF_CFF_CPHS:
            log("SIM Refresh called for EF_CFIS or EF_CFF_CPHS");
            loadCallForwardingRecords();
            break;
        default:
            // For now, fetch all records if this is not a
            // voicemail number.
            // TODO: Handle other cases, instead of fetching all.
            mAdnCache.reset();
            fetchSimRecords();
            break;
    }
}
#end_block

#method_before
private void handleSimRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleSimRefresh received without input");
        return;
    }
    if (refreshResponse.aid != null && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleSimRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_INIT");
            // need to reload all files (that we care about)
            onIccRefreshInit();
            break;
        case IccRefreshResponse.REFRESH_RESULT_RESET:
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_RESET");
            mCi.setRadioPower(false, null);
            /* Note: no need to call setRadioPower(true).  Assuming the desired
                * radio power state is still ON (as tracked by ServiceStateTracker),
                * ServiceStateTracker will call setRadioPower when it receives the
                * RADIO_STATE_CHANGED notification for the power off.  And if the
                * desired power state has changed in the interim, we don't want to
                * override it with an unconditional power on.
                */
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleSimRefresh with unknown operation");
            break;
    }
}
#method_after
private void handleSimRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleSimRefresh received without input");
        return;
    }
    if (refreshResponse.aid != null && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleSimRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_INIT");
            // need to reload all files (that we care about)
            onIccRefreshInit();
            break;
        case IccRefreshResponse.REFRESH_RESULT_RESET:
            // Refresh reset is handled by the UiccCard object.
            if (DBG)
                log("handleSimRefresh with SIM_REFRESH_RESET");
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleSimRefresh with unknown operation");
            break;
    }
}
#end_block

#method_before
protected int dispatchGsmMessage(SmsMessageBase message) {
    mNewSmsRegistrants.notifyResult(message);
    return 0;
}
#method_after
private int dispatchGsmMessage(SmsMessage message) {
    mNewSmsRegistrants.notifyResult(message);
    return 0;
}
#end_block

#method_before
private void handleSms(byte[] ba) {
    if (ba[0] != 0)
        Rlog.d("ENF", "status : " + ba[0]);
    // 3 == "received by MS from network; message to be read"
    if (ba[0] == 3) {
        int n = ba.length;
        // Note: Data may include trailing FF's.  That's OK; message
        // should still parse correctly.
        byte[] pdu = new byte[n - 1];
        System.arraycopy(ba, 1, pdu, 0, n - 1);
        SmsMessage message = SmsMessage.createFromPdu(pdu);
        dispatchGsmMessage(message);
    }
}
#method_after
private void handleSms(byte[] ba) {
    if (ba[0] != 0)
        Rlog.d("ENF", "status : " + ba[0]);
    // 3 == "received by MS from network; message to be read"
    if (ba[0] == 3) {
        int n = ba.length;
        // Note: Data may include trailing FF's.  That's OK; message
        // should still parse correctly.
        byte[] pdu = new byte[n - 1];
        System.arraycopy(ba, 1, pdu, 0, n - 1);
        SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
        dispatchGsmMessage(message);
    }
}
#end_block

#method_before
private void handleSmses(ArrayList messages) {
    int count = messages.size();
    for (int i = 0; i < count; i++) {
        byte[] ba = (byte[]) messages.get(i);
        if (ba[0] != 0)
            Rlog.i("ENF", "status " + i + ": " + ba[0]);
        if (ba[0] == 3) {
            int n = ba.length;
            // Note: Data may include trailing FF's.  That's OK; message
            // should still parse correctly.
            byte[] pdu = new byte[n - 1];
            System.arraycopy(ba, 1, pdu, 0, n - 1);
            SmsMessage message = SmsMessage.createFromPdu(pdu);
            dispatchGsmMessage(message);
            // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
            // 1 == "received by MS from network; message read"
            ba[0] = 1;
            if (false) {
                // XXX writing seems to crash RdoServD
                mFh.updateEFLinearFixed(EF_SMS, i, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, i));
            }
        }
    }
}
#method_after
private void handleSmses(ArrayList<byte[]> messages) {
    int count = messages.size();
    for (int i = 0; i < count; i++) {
        byte[] ba = messages.get(i);
        if (ba[0] != 0)
            Rlog.i("ENF", "status " + i + ": " + ba[0]);
        if (ba[0] == 3) {
            int n = ba.length;
            // Note: Data may include trailing FF's.  That's OK; message
            // should still parse correctly.
            byte[] pdu = new byte[n - 1];
            System.arraycopy(ba, 1, pdu, 0, n - 1);
            SmsMessage message = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
            dispatchGsmMessage(message);
            // 3GPP TS 51.011 v5.0.0 (20011-12)  10.5.3
            // 1 == "received by MS from network; message read"
            ba[0] = 1;
            if (false) {
                // FIXME: writing seems to crash RdoServD
                mFh.updateEFLinearFixed(EF_SMS, i, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, i));
            }
        }
    }
}
#end_block

#method_before
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    recordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + recordsToLoad + " requested: " + recordsRequested);
    if (recordsToLoad == 0 && recordsRequested == true) {
        onAllRecordsLoaded();
    } else if (recordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        recordsToLoad = 0;
    }
}
#method_after
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        onAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#end_block

#method_before
protected void onAllRecordsLoaded() {
    String operator = getOperatorNumeric();
    // Some fields require more than one SIM record to set
    log("SIMRecords: onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
    SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, operator);
    if (mImsi != null) {
        SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3))));
    } else {
        loge("onAllRecordsLoaded: imsi is NULL!");
    }
    setVoiceMailByCountry(operator);
    setSpnFromConfig(operator);
    recordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#method_after
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEfLi, mEfPl);
    } else {
        if (DBG)
            log("Not using EF LI/EF PL");
    }
    setVoiceCallForwardingFlagFromSimRecords();
    if (mParentApp.getState() == AppState.APPSTATE_PIN || mParentApp.getState() == AppState.APPSTATE_PUK) {
        // reset recordsRequested, since sim is not loaded really
        mRecordsRequested = false;
        // lock state, only update language
        return;
    }
    // Some fields require more than one SIM record to set
    String operator = getOperatorNumeric();
    if (!TextUtils.isEmpty(operator)) {
        log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
        log("update icc_operator_numeric=" + operator);
        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
        final SubscriptionController subController = SubscriptionController.getInstance();
        subController.setMccMnc(operator, subController.getDefaultSubId());
    } else {
        log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
    }
    if (!TextUtils.isEmpty(mImsi)) {
        log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + mImsi) : ""));
        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3))));
    } else {
        log("onAllRecordsLoaded empty imsi skipping setting mcc");
    }
    setVoiceMailByCountry(operator);
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#end_block

#method_before
// ***** Private methods
private void setSpnFromConfig(String carrier) {
    if (mSpnOverride.containsCarrier(carrier)) {
        spn = mSpnOverride.getSpn(carrier);
    }
}
#method_after
private void setSpnFromConfig(String carrier) {
    if (mSpnOverride.containsCarrier(carrier)) {
        setServiceProviderName(mSpnOverride.getSpn(carrier));
        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), getServiceProviderName());
    }
}
#end_block

#method_before
private void setVoiceMailByCountry(String spn) {
    if (mVmConfig.containsCarrier(spn)) {
        isVoiceMailFixed = true;
        voiceMailNum = mVmConfig.getVoiceMailNumber(spn);
        voiceMailTag = mVmConfig.getVoiceMailTag(spn);
    }
}
#method_after
private void setVoiceMailByCountry(String spn) {
    if (mVmConfig.containsCarrier(spn)) {
        mIsVoiceMailFixed = true;
        mVoiceMailNum = mVmConfig.getVoiceMailNumber(spn);
        mVoiceMailTag = mVmConfig.getVoiceMailTag(spn);
    }
}
#end_block

#method_before
protected void fetchSimRecords() {
    recordsRequested = true;
    if (DBG)
        log("fetchSimRecords " + recordsToLoad);
    mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    recordsToLoad++;
    // FIXME should examine EF[MSISDN]'s capability configuration
    // to determine which is the voice/data/fax line
    new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, EF_EXT1, 1, obtainMessage(EVENT_GET_MSISDN_DONE));
    recordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
    recordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
    recordsToLoad++;
    // Also load CPHS-style voice mail indicator, which stores
    // the same info as EF[MWIS]. If both exist, both are updated
    // but the EF[MWIS] data is preferred
    // Please note this must be loaded after EF[MWIS]
    mFh.loadEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
    recordsToLoad++;
    // Same goes for Call Forward Status indicator: fetch both
    // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
    mFh.loadEFLinearFixed(EF_CFIS, 1, obtainMessage(EVENT_GET_CFIS_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_CFF_CPHS, obtainMessage(EVENT_GET_CFF_DONE));
    recordsToLoad++;
    getSpnFsm(true, null);
    mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
    recordsToLoad++;
    mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
    recordsToLoad++;
    mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
    recordsToLoad++;
    // XXX should seek instead of examining them all
    if (false) {
        // XXX
        mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
        recordsToLoad++;
    }
    if (CRASH_RIL) {
        String sms = "0107912160130310f20404d0110041007030208054832b0120" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "ffffffffffffffffffffffffffffff";
        byte[] ba = IccUtils.hexStringToBytes(sms);
        mFh.updateEFLinearFixed(EF_SMS, 1, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
    }
    if (DBG)
        log("fetchSimRecords " + recordsToLoad + " requested: " + recordsRequested);
}
#method_after
protected void fetchSimRecords() {
    mRecordsRequested = true;
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad);
    mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
    // FIXME should examine EF[MSISDN]'s capability configuration
    // to determine which is the voice/data/fax line
    new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1, obtainMessage(EVENT_GET_MSISDN_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
    mRecordsToLoad++;
    // Also load CPHS-style voice mail indicator, which stores
    // the same info as EF[MWIS]. If both exist, both are updated
    // but the EF[MWIS] data is preferred
    // Please note this must be loaded after EF[MWIS]
    mFh.loadEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
    mRecordsToLoad++;
    // Same goes for Call Forward Status indicator: fetch both
    // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
    loadCallForwardingRecords();
    getSpnFsm(true, null);
    mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
    mRecordsToLoad++;
    mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID2, obtainMessage(EVENT_GET_GID2_DONE));
    mRecordsToLoad++;
    loadEfLiAndEfPl();
    // XXX should seek instead of examining them all
    if (false) {
        // XXX
        mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
        mRecordsToLoad++;
    }
    if (CRASH_RIL) {
        String sms = "0107912160130310f20404d0110041007030208054832b0120" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "ffffffffffffffffffffffffffffff";
        byte[] ba = IccUtils.hexStringToBytes(sms);
        mFh.updateEFLinearFixed(EF_SMS, 1, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
    }
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    int rule;
    if (TextUtils.isEmpty(spn) || spnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (isOnMatchingPlmn(plmn)) {
        rule = SPN_RULE_SHOW_SPN;
        if ((spnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((spnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#method_after
@Override
public int getDisplayRule(String plmn) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (isOnMatchingPlmn(plmn)) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#end_block

#method_before
private boolean isOnMatchingPlmn(String plmn) {
    if (plmn == null)
        return false;
    if (plmn.equals(getOperatorNumeric())) {
        return true;
    }
    if (spdiNetworks != null) {
        for (String spdiNet : spdiNetworks) {
            if (plmn.equals(spdiNet)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isOnMatchingPlmn(String plmn) {
    if (plmn == null)
        return false;
    if (plmn.equals(getOperatorNumeric())) {
        return true;
    }
    if (mSpdiNetworks != null) {
        for (String spdiNet : mSpdiNetworks) {
            if (plmn.equals(spdiNet)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private void getSpnFsm(boolean start, AsyncResult ar) {
    byte[] data;
    if (start) {
        // SPN read
        if (spnState == Get_Spn_Fsm_State.READ_SPN_3GPP || spnState == Get_Spn_Fsm_State.READ_SPN_CPHS || spnState == Get_Spn_Fsm_State.READ_SPN_SHORT_CPHS || spnState == Get_Spn_Fsm_State.INIT) {
            // Set INIT then return so the INIT code
            // will run when the outstanding read done.
            spnState = Get_Spn_Fsm_State.INIT;
            return;
        } else {
            spnState = Get_Spn_Fsm_State.INIT;
        }
    }
    switch(spnState) {
        case INIT:
            spn = null;
            mFh.loadEFTransparent(EF_SPN, obtainMessage(EVENT_GET_SPN_DONE));
            recordsToLoad++;
            spnState = Get_Spn_Fsm_State.READ_SPN_3GPP;
            break;
        case READ_SPN_3GPP:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                spnDisplayCondition = 0xff & data[0];
                spn = IccUtils.adnStringFieldToString(data, 1, data.length - 1);
                if (DBG)
                    log("Load EF_SPN: " + spn + " spnDisplayCondition: " + spnDisplayCondition);
                SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, spn);
                spnState = Get_Spn_Fsm_State.IDLE;
            } else {
                mFh.loadEFTransparent(EF_SPN_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
                recordsToLoad++;
                spnState = Get_Spn_Fsm_State.READ_SPN_CPHS;
                // See TS 51.011 10.3.11.  Basically, default to
                // show PLMN always, and SPN also if roaming.
                spnDisplayCondition = -1;
            }
            break;
        case READ_SPN_CPHS:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                spn = IccUtils.adnStringFieldToString(data, 0, data.length);
                if (DBG)
                    log("Load EF_SPN_CPHS: " + spn);
                SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, spn);
                spnState = Get_Spn_Fsm_State.IDLE;
            } else {
                mFh.loadEFTransparent(EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
                recordsToLoad++;
                spnState = Get_Spn_Fsm_State.READ_SPN_SHORT_CPHS;
            }
            break;
        case READ_SPN_SHORT_CPHS:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                spn = IccUtils.adnStringFieldToString(data, 0, data.length);
                if (DBG)
                    log("Load EF_SPN_SHORT_CPHS: " + spn);
                SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, spn);
            } else {
                if (DBG)
                    log("No SPN loaded in either CHPS or 3GPP");
            }
            spnState = Get_Spn_Fsm_State.IDLE;
            break;
        default:
            spnState = Get_Spn_Fsm_State.IDLE;
    }
}
#method_after
private void getSpnFsm(boolean start, AsyncResult ar) {
    byte[] data;
    if (start) {
        // SPN read
        if (mSpnState == GetSpnFsmState.READ_SPN_3GPP || mSpnState == GetSpnFsmState.READ_SPN_CPHS || mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS || mSpnState == GetSpnFsmState.INIT) {
            // Set INIT then return so the INIT code
            // will run when the outstanding read done.
            mSpnState = GetSpnFsmState.INIT;
            return;
        } else {
            mSpnState = GetSpnFsmState.INIT;
        }
    }
    switch(mSpnState) {
        case INIT:
            setServiceProviderName(null);
            mFh.loadEFTransparent(EF_SPN, obtainMessage(EVENT_GET_SPN_DONE));
            mRecordsToLoad++;
            mSpnState = GetSpnFsmState.READ_SPN_3GPP;
            break;
        case READ_SPN_3GPP:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                mSpnDisplayCondition = 0xff & data[0];
                setServiceProviderName(IccUtils.adnStringFieldToString(data, 1, data.length - 1));
                // for card double-check and brand override
                // we have to do this:
                final String spn = getServiceProviderName();
                if (spn == null || spn.length() == 0) {
                    mSpnState = GetSpnFsmState.READ_SPN_CPHS;
                } else {
                    if (DBG)
                        log("Load EF_SPN: " + spn + " spnDisplayCondition: " + mSpnDisplayCondition);
                    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), spn);
                    mSpnState = GetSpnFsmState.IDLE;
                }
            } else {
                mSpnState = GetSpnFsmState.READ_SPN_CPHS;
            }
            if (mSpnState == GetSpnFsmState.READ_SPN_CPHS) {
                mFh.loadEFTransparent(EF_SPN_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
                mRecordsToLoad++;
                // See TS 51.011 10.3.11.  Basically, default to
                // show PLMN always, and SPN also if roaming.
                mSpnDisplayCondition = -1;
            }
            break;
        case READ_SPN_CPHS:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                setServiceProviderName(IccUtils.adnStringFieldToString(data, 0, data.length));
                // for card double-check and brand override
                // we have to do this:
                final String spn = getServiceProviderName();
                if (spn == null || spn.length() == 0) {
                    mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
                } else {
                    // Display CPHS Operator Name only when not roaming
                    mSpnDisplayCondition = 2;
                    if (DBG)
                        log("Load EF_SPN_CPHS: " + spn);
                    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), spn);
                    mSpnState = GetSpnFsmState.IDLE;
                }
            } else {
                mSpnState = GetSpnFsmState.READ_SPN_SHORT_CPHS;
            }
            if (mSpnState == GetSpnFsmState.READ_SPN_SHORT_CPHS) {
                mFh.loadEFTransparent(EF_SPN_SHORT_CPHS, obtainMessage(EVENT_GET_SPN_DONE));
                mRecordsToLoad++;
            }
            break;
        case READ_SPN_SHORT_CPHS:
            if (ar != null && ar.exception == null) {
                data = (byte[]) ar.result;
                setServiceProviderName(IccUtils.adnStringFieldToString(data, 0, data.length));
                // for card double-check and brand override
                // we have to do this:
                final String spn = getServiceProviderName();
                if (spn == null || spn.length() == 0) {
                    if (DBG)
                        log("No SPN loaded in either CHPS or 3GPP");
                } else {
                    // Display CPHS Operator Name only when not roaming
                    mSpnDisplayCondition = 2;
                    if (DBG)
                        log("Load EF_SPN_SHORT_CPHS: " + spn);
                    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), spn);
                }
            } else {
                setServiceProviderName(null);
                if (DBG)
                    log("No SPN loaded in either CHPS or 3GPP");
            }
            mSpnState = GetSpnFsmState.IDLE;
            break;
        default:
            mSpnState = GetSpnFsmState.IDLE;
    }
}
#end_block

#method_before
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    spdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            spdiNetworks.add(plmnCode);
        }
    }
}
#method_after
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            mSpdiNetworks.add(plmnCode);
        }
    }
}
#end_block

#method_before
protected void log(String s) {
    Rlog.d(LOG_TAG, "[SIMRecords] " + s);
}
#method_after
@Override
protected void log(String s) {
    Rlog.d(LOG_TAG, "[SIMRecords] " + s);
}
#end_block

#method_before
protected void loge(String s) {
    Rlog.e(LOG_TAG, "[SIMRecords] " + s);
}
#method_after
@Override
protected void loge(String s) {
    Rlog.e(LOG_TAG, "[SIMRecords] " + s);
}
#end_block

#method_before
public boolean isCspPlmnEnabled() {
    return mCspPlmnEnabled;
}
#method_after
@Override
public boolean isCspPlmnEnabled() {
    return mCspPlmnEnabled;
}
#end_block

#method_before
private void handleEfCspData(byte[] data) {
    // As per spec CPHS4_2.WW6, CPHS B.4.7.1, EF_CSP contains CPHS defined
    // 18 bytes (i.e 9 service groups info) and additional data specific to
    // operator. The valueAddedServicesGroup is not part of standard
    // services. This is operator specific and can be programmed any where.
    // Normally this is programmed as 10th service after the standard
    // services.
    int usedCspGroups = data.length / 2;
    // This is the "Servive Group Number" of "Value Added Services Group".
    byte valueAddedServicesGroup = (byte) 0xC0;
    mCspPlmnEnabled = true;
    for (int i = 0; i < usedCspGroups; i++) {
        if (data[2 * i] == valueAddedServicesGroup) {
            log("[CSP] found ValueAddedServicesGroup, value " + data[(2 * i) + 1]);
            if ((data[(2 * i) + 1] & 0x80) == 0x80) {
                // Bit 8 is for
                // "Restriction of menu options for manual PLMN selection".
                // Operator Selection menu should be enabled.
                mCspPlmnEnabled = true;
            } else {
                mCspPlmnEnabled = false;
                // Operator Selection menu should be disabled.
                // Operator Selection Mode should be set to Automatic.
                log("[CSP] Set Automatic Network Selection");
                mNetworkSelectionModeAutomaticRegistrants.notifyRegistrants();
            }
            return;
        }
    }
    log("[CSP] Value Added Service Group (0xC0), not found!");
}
#method_after
private void handleEfCspData(byte[] data) {
    // As per spec CPHS4_2.WW6, CPHS B.4.7.1, EF_CSP contains CPHS defined
    // 18 bytes (i.e 9 service groups info) and additional data specific to
    // operator. The valueAddedServicesGroup is not part of standard
    // services. This is operator specific and can be programmed any where.
    // Normally this is programmed as 10th service after the standard
    // services.
    int usedCspGroups = data.length / 2;
    // This is the "Service Group Number" of "Value Added Services Group".
    byte valueAddedServicesGroup = (byte) 0xC0;
    mCspPlmnEnabled = true;
    for (int i = 0; i < usedCspGroups; i++) {
        if (data[2 * i] == valueAddedServicesGroup) {
            log("[CSP] found ValueAddedServicesGroup, value " + data[(2 * i) + 1]);
            if ((data[(2 * i) + 1] & 0x80) == 0x80) {
                // Bit 8 is for
                // "Restriction of menu options for manual PLMN selection".
                // Operator Selection menu should be enabled.
                mCspPlmnEnabled = true;
            } else {
                mCspPlmnEnabled = false;
                // Operator Selection menu should be disabled.
                // Operator Selection Mode should be set to Automatic.
                log("[CSP] Set Automatic Network Selection");
                mNetworkSelectionModeAutomaticRegistrants.notifyRegistrants();
            }
            return;
        }
    }
    log("[CSP] Value Added Service Group (0xC0), not found!");
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" callForwardingEnabled=" + callForwardingEnabled);
    pw.println(" spnState=" + spnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" efMWIS[]=" + Arrays.toString(efMWIS));
    pw.println(" efCPHS_MWI[]=" + Arrays.toString(efCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" spnDisplayCondition=" + spnDisplayCondition);
    pw.println(" spdiNetworks[]=" + spdiNetworks);
    pw.println(" pnnHomeName=" + pnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" gid1=" + gid1);
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    pw.println(" mGid2=" + mGid2);
    pw.flush();
}
#end_block

#method_before
private CharSequence timeToLog(long timestamp) {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss ", timestamp);
}
#method_after
private CharSequence timeToLog(long timestamp) {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss", timestamp);
}
#end_block

#method_before
private void addCrashLog() {
    synchronized (mCrashTimes) {
        mCrashTimes.add(System.currentTimeMillis());
    }
}
#method_after
private void addCrashLog() {
    synchronized (mCrashTimestamps) {
        if (mCrashTimestamps.size() == CRASH_LOG_MAX_SIZE)
            mCrashTimestamps.removeFirst();
        mCrashTimestamps.add(System.currentTimeMillis());
        mCrashes++;
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        if (mActiveLogs.size() == 0) {
            writer.println("Bluetooth never enabled!");
        } else {
            writer.println("Enable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        int crashed = mCrashTimes.size();
        writer.println("Bluetooth crashed " + crashed + " time" + (crashed == 1 ? "" : "s"));
        for (Long time : mCrashTimes) {
            writer.println("  " + timeToLog(time.longValue()));
        }
        String bleAppString = "No BLE Apps registered.";
        if (mBleApps.size() == 1) {
            bleAppString = "1 BLE App registered:";
        } else if (mBleApps.size() > 1) {
            bleAppString = mBleApps.size() + " BLE Apps registered:";
        }
        writer.println("\n" + bleAppString);
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        if (mActiveLogs.size() == 0) {
            writer.println("Bluetooth never enabled!");
        } else {
            writer.println("Enable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        writer.println("Bluetooth crashed " + mCrashes + " time" + (mCrashes == 1 ? "" : "s"));
        if (mCrashes == CRASH_LOG_MAX_SIZE)
            writer.println("(last " + CRASH_LOG_MAX_SIZE + ")");
        for (Long time : mCrashTimestamps) {
            writer.println("  " + timeToLog(time.longValue()));
        }
        String bleAppString = "No BLE Apps registered.";
        if (mBleApps.size() == 1) {
            bleAppString = "1 BLE App registered:";
        } else if (mBleApps.size() > 1) {
            bleAppString = mBleApps.size() + " BLE Apps registered:";
        }
        writer.println("\n" + bleAppString);
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    context = getInstrumentation().getContext();
}
#method_after
@Before
public void setUp() throws Exception {
    context = getInstrumentation().getContext();
}
#end_block

#method_before
public static Matcher<View> isDisplayingAtLeast(final int areaPercentage) {
    checkState(areaPercentage <= 100, "Cannot have over 100 percent: %s", areaPercentage);
    checkState(areaPercentage > 0, "Must have a positive, non-zero value: %s", areaPercentage);
    return new TypeSafeMatcher<View>() {

        @Override
        public void describeTo(Description description) {
            description.appendText(String.format("at least %s percent of the view's area is displayed to the user.", areaPercentage));
        }

        @Override
        public boolean matchesSafely(View view) {
            Rect visibleParts = new Rect();
            boolean visibleAtAll = view.getGlobalVisibleRect(visibleParts);
            if (!visibleAtAll) {
                return false;
            }
            Rect screen = getScreenWithoutStatusBarActionBar(view);
            int viewHeight = (view.getHeight() > screen.height()) ? screen.height() : view.getHeight();
            int viewWidth = (view.getWidth() > screen.width()) ? screen.width() : view.getWidth();
            double maxArea = viewHeight * viewWidth;
            double visibleArea = visibleParts.height() * visibleParts.width();
            int displayedPercentage = (int) ((visibleArea / maxArea) * 100);
            return displayedPercentage >= areaPercentage && withEffectiveVisibility(Visibility.VISIBLE).matches(view);
        }

        private Rect getScreenWithoutStatusBarActionBar(View view) {
            DisplayMetrics m = new DisplayMetrics();
            ((WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(m);
            // Get status bar height
            int resourceId = view.getContext().getResources().getIdentifier("status_bar_height", "dimen", "android");
            int statusBarHeight = (resourceId > 0) ? view.getContext().getResources().getDimensionPixelSize(resourceId) : 0;
            // Get action bar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = (view.getContext().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) ? TypedValue.complexToDimensionPixelSize(tv.data, view.getContext().getResources().getDisplayMetrics()) : 0;
            return new Rect(0, 0, m.widthPixels, m.heightPixels - (statusBarHeight + actionBarHeight));
        }
    };
}
#method_after
public static Matcher<View> isDisplayingAtLeast(final int areaPercentage) {
    checkState(areaPercentage <= 100, "Cannot have over 100 percent: %s", areaPercentage);
    checkState(areaPercentage > 0, "Must have a positive, non-zero value: %s", areaPercentage);
    return new TypeSafeMatcher<View>() {

        @Override
        public void describeTo(Description description) {
            description.appendText(String.format("at least %s percent of the view's area is displayed to the user.", areaPercentage));
        }

        @Override
        public boolean matchesSafely(View view) {
            Rect visibleParts = new Rect();
            boolean visibleAtAll = view.getGlobalVisibleRect(visibleParts);
            if (!visibleAtAll) {
                return false;
            }
            Rect screen = getScreenWithoutStatusBarActionBar(view);
            float viewHeight = Math.min(view.getHeight() * view.getScaleY(), screen.height());
            float viewWidth = Math.min(view.getWidth() * view.getScaleX(), screen.width());
            double maxArea = viewHeight * viewWidth;
            double visibleArea = visibleParts.height() * visibleParts.width();
            int displayedPercentage = (int) ((visibleArea / maxArea) * 100);
            return displayedPercentage >= areaPercentage && withEffectiveVisibility(Visibility.VISIBLE).matches(view);
        }

        private Rect getScreenWithoutStatusBarActionBar(View view) {
            DisplayMetrics m = new DisplayMetrics();
            ((WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(m);
            // Get status bar height
            int resourceId = view.getContext().getResources().getIdentifier("status_bar_height", "dimen", "android");
            int statusBarHeight = (resourceId > 0) ? view.getContext().getResources().getDimensionPixelSize(resourceId) : 0;
            // Get action bar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = (view.getContext().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) ? TypedValue.complexToDimensionPixelSize(tv.data, view.getContext().getResources().getDisplayMetrics()) : 0;
            return new Rect(0, 0, m.widthPixels, m.heightPixels - (statusBarHeight + actionBarHeight));
        }
    };
}
#end_block

#method_before
public static Matcher<View> isDisplayingAtLeast(final int areaPercentage) {
    checkState(areaPercentage <= 100, "Cannot have over 100 percent: %s", areaPercentage);
    checkState(areaPercentage > 0, "Must have a positive, non-zero value: %s", areaPercentage);
    return new TypeSafeMatcher<View>() {

        @Override
        public void describeTo(Description description) {
            description.appendText(String.format("at least %s percent of the view's area is displayed to the user.", areaPercentage));
        }

        @Override
        public boolean matchesSafely(View view) {
            Rect visibleParts = new Rect();
            boolean visibleAtAll = view.getGlobalVisibleRect(visibleParts);
            if (!visibleAtAll) {
                return false;
            }
            Rect screen = getScreenWithoutStatusBarActionBar(view);
            int viewHeight = (view.getHeight() > screen.height()) ? screen.height() : view.getHeight();
            int viewWidth = (view.getWidth() > screen.width()) ? screen.width() : view.getWidth();
            double maxArea = viewHeight * viewWidth;
            double visibleArea = visibleParts.height() * visibleParts.width();
            int displayedPercentage = (int) ((visibleArea / maxArea) * 100);
            return displayedPercentage >= areaPercentage && withEffectiveVisibility(Visibility.VISIBLE).matches(view);
        }

        private Rect getScreenWithoutStatusBarActionBar(View view) {
            DisplayMetrics m = new DisplayMetrics();
            ((WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(m);
            // Get status bar height
            int resourceId = view.getContext().getResources().getIdentifier("status_bar_height", "dimen", "android");
            int statusBarHeight = (resourceId > 0) ? view.getContext().getResources().getDimensionPixelSize(resourceId) : 0;
            // Get action bar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = (view.getContext().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) ? TypedValue.complexToDimensionPixelSize(tv.data, view.getContext().getResources().getDisplayMetrics()) : 0;
            return new Rect(0, 0, m.widthPixels, m.heightPixels - (statusBarHeight + actionBarHeight));
        }
    };
}
#method_after
public static Matcher<View> isDisplayingAtLeast(final int areaPercentage) {
    checkState(areaPercentage <= 100, "Cannot have over 100 percent: %s", areaPercentage);
    checkState(areaPercentage > 0, "Must have a positive, non-zero value: %s", areaPercentage);
    return new TypeSafeMatcher<View>() {

        @Override
        public void describeTo(Description description) {
            description.appendText(String.format("at least %s percent of the view's area is displayed to the user.", areaPercentage));
        }

        @Override
        public boolean matchesSafely(View view) {
            Rect visibleParts = new Rect();
            boolean visibleAtAll = view.getGlobalVisibleRect(visibleParts);
            if (!visibleAtAll) {
                return false;
            }
            Rect screen = getScreenWithoutStatusBarActionBar(view);
            float viewHeight = Math.min(view.getHeight() * view.getScaleY(), screen.height());
            float viewWidth = Math.min(view.getWidth() * view.getScaleX(), screen.width());
            double maxArea = viewHeight * viewWidth;
            double visibleArea = visibleParts.height() * visibleParts.width();
            int displayedPercentage = (int) ((visibleArea / maxArea) * 100);
            return displayedPercentage >= areaPercentage && withEffectiveVisibility(Visibility.VISIBLE).matches(view);
        }

        private Rect getScreenWithoutStatusBarActionBar(View view) {
            DisplayMetrics m = new DisplayMetrics();
            ((WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(m);
            // Get status bar height
            int resourceId = view.getContext().getResources().getIdentifier("status_bar_height", "dimen", "android");
            int statusBarHeight = (resourceId > 0) ? view.getContext().getResources().getDimensionPixelSize(resourceId) : 0;
            // Get action bar height
            TypedValue tv = new TypedValue();
            int actionBarHeight = (view.getContext().getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) ? TypedValue.complexToDimensionPixelSize(tv.data, view.getContext().getResources().getDisplayMetrics()) : 0;
            return new Rect(0, 0, m.widthPixels, m.heightPixels - (statusBarHeight + actionBarHeight));
        }
    };
}
#end_block

#method_before
public static Matcher<View> hasTextColor(final int colorResId) {
    return new BoundedMatcher<View, TextView>(TextView.class) {

        private Context context = null;

        @Override
        protected boolean matchesSafely(TextView textView) {
            context = textView.getContext();
            int textViewColor = textView.getCurrentTextColor();
            int expectedColor;
            if (Build.VERSION.SDK_INT <= 22) {
                expectedColor = context.getResources().getColor(colorResId);
            } else {
                expectedColor = context.getColor(colorResId);
            }
            return textViewColor == expectedColor;
        }

        @Override
        public void describeTo(Description description) {
            String colorId = String.valueOf(colorResId);
            if (context != null) {
                colorId = context.getResources().getResourceName(colorResId);
            }
            description.appendText("has color with ID " + colorId);
        }
    };
}
#method_after
public static Matcher<View> hasTextColor(final int colorResId) {
    return new BoundedMatcher<View, TextView>(TextView.class) {

        private Context context;

        @Override
        protected boolean matchesSafely(TextView textView) {
            context = textView.getContext();
            int textViewColor = textView.getCurrentTextColor();
            int expectedColor;
            if (Build.VERSION.SDK_INT <= 22) {
                expectedColor = context.getResources().getColor(colorResId);
            } else {
                expectedColor = context.getColor(colorResId);
            }
            return textViewColor == expectedColor;
        }

        @Override
        public void describeTo(Description description) {
            String colorId = String.valueOf(colorResId);
            if (context != null) {
                colorId = context.getResources().getResourceName(colorResId);
            }
            description.appendText("has color with ID " + colorId);
        }
    };
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    context = getInstrumentation().getContext();
}
#method_after
@Before
public void setUp() throws Exception {
    context = getInstrumentation().getContext();
}
#end_block

#method_before
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on entering connect mode");
    }
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#method_after
@Override
public void enter() {
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on entering connect mode");
    }
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#end_block

#method_before
@Override
public void exit() {
    // Let the system know that wifi is not available since we are exiting client mode.
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on exiting connect mode");
    }
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#method_after
@Override
public void exit() {
    // Let the system know that wifi is not available since we are exiting client mode.
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
    if (!mWifiNative.removeAllNetworks()) {
        loge("Failed to remove networks on exiting connect mode");
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName, true);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName, true);
            setSupplicantLogLevel();
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private static String getEtwsPrimaryMessage(Context context, int category) {
    Resources r = context.getResources();
    switch(category) {
        case ETWS_WARNING_TYPE_EARTHQUAKE:
            return r.getString(R.string.etws_primary_default_message_earthquake);
        case ETWS_WARNING_TYPE_TSUNAMI:
            return r.getString(R.string.etws_primary_default_message_tsunami);
        case ETWS_WARNING_TYPE_EARTHQUAKE_AND_TSUNAMI:
            return r.getString(R.string.etws_primary_default_message_earthquake_and_tsunami);
        case ETWS_WARNING_TYPE_TEST_MESSAGE:
            return r.getString(R.string.etws_primary_default_message_test);
        case ETWS_WARNING_TYPE_OTHER_EMERGENCY:
            return r.getString(R.string.etws_primary_default_message_others);
        default:
            return "";
    }
}
#method_after
private static String getEtwsPrimaryMessage(Context context, int category) {
    final Resources r = context.getResources();
    switch(category) {
        case ETWS_WARNING_TYPE_EARTHQUAKE:
            return r.getString(R.string.etws_primary_default_message_earthquake);
        case ETWS_WARNING_TYPE_TSUNAMI:
            return r.getString(R.string.etws_primary_default_message_tsunami);
        case ETWS_WARNING_TYPE_EARTHQUAKE_AND_TSUNAMI:
            return r.getString(R.string.etws_primary_default_message_earthquake_and_tsunami);
        case ETWS_WARNING_TYPE_TEST_MESSAGE:
            return r.getString(R.string.etws_primary_default_message_test);
        case ETWS_WARNING_TYPE_OTHER_EMERGENCY:
            return r.getString(R.string.etws_primary_default_message_others);
        default:
            return "";
    }
}
#end_block

#method_before
@Override
public void capget(StructCapUserHeader hdr, StructCapUserData[] data) throws ErrnoException {
    os.capget(hdr, data);
}
#method_after
@Override
public StructCapUserData[] capget(StructCapUserHeader hdr) throws ErrnoException {
    return os.capget(hdr);
}
#end_block

#method_before
public static void capget(StructCapUserHeader hdr, StructCapUserData[] data) throws ErrnoException {
    Libcore.os.capget(hdr, data);
}
#method_after
public static StructCapUserData[] capget(StructCapUserHeader hdr) throws ErrnoException {
    return Libcore.os.capget(hdr);
}
#end_block

#method_before
private int getDeviceProperty(int property, long[] outIntValue, char[] outStringValue) {
    switch(property) {
        case MtpConstants.DEVICE_PROPERTY_SYNCHRONIZATION_PARTNER:
        case MtpConstants.DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME:
            // writable string properties kept in shared preferences
            String value = mDeviceProperties.getString(Integer.toString(property), "");
            int length = value.length();
            if (length > 255) {
                length = 255;
            }
            value.getChars(0, length, outStringValue, 0);
            outStringValue[length] = 0;
            return MtpConstants.RESPONSE_OK;
        case MtpConstants.DEVICE_PROPERTY_IMAGE_SIZE:
            // use screen size as max image size
            Display display = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
            int width = display.getMaximumSizeDimension();
            int height = display.getMaximumSizeDimension();
            String imageSize = Integer.toString(width) + "x" + Integer.toString(height);
            imageSize.getChars(0, imageSize.length(), outStringValue, 0);
            outStringValue[imageSize.length()] = 0;
            return MtpConstants.RESPONSE_OK;
        case MtpConstants.DEVICE_PROPERTY_PERCEIVED_DEVICE_TYPE:
            outIntValue[0] = 0x3;
            return MtpConstants.RESPONSE_OK;
        default:
            return MtpConstants.RESPONSE_DEVICE_PROP_NOT_SUPPORTED;
    }
}
#method_after
private int getDeviceProperty(int property, long[] outIntValue, char[] outStringValue) {
    switch(property) {
        case MtpConstants.DEVICE_PROPERTY_SYNCHRONIZATION_PARTNER:
        case MtpConstants.DEVICE_PROPERTY_DEVICE_FRIENDLY_NAME:
            // writable string properties kept in shared preferences
            String value = mDeviceProperties.getString(Integer.toString(property), "");
            int length = value.length();
            if (length > 255) {
                length = 255;
            }
            value.getChars(0, length, outStringValue, 0);
            outStringValue[length] = 0;
            return MtpConstants.RESPONSE_OK;
        case MtpConstants.DEVICE_PROPERTY_IMAGE_SIZE:
            // use screen size as max image size
            Display display = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
            int width = display.getMaximumSizeDimension();
            int height = display.getMaximumSizeDimension();
            String imageSize = Integer.toString(width) + "x" + Integer.toString(height);
            imageSize.getChars(0, imageSize.length(), outStringValue, 0);
            outStringValue[imageSize.length()] = 0;
            return MtpConstants.RESPONSE_OK;
        case MtpConstants.DEVICE_PROPERTY_PERCEIVED_DEVICE_TYPE:
            outIntValue[0] = mDeviceType;
            return MtpConstants.RESPONSE_OK;
        default:
            return MtpConstants.RESPONSE_DEVICE_PROP_NOT_SUPPORTED;
    }
}
#end_block

#method_before
public static Matcher<Intent> isSameIntent(final Intent expectedIntent) {
    return new TypeSafeMatcher<Intent>() {

        @Override
        public void describeTo(Description description) {
            description.appendText("is Intent: " + expectedIntent);
        }

        @Override
        public boolean matchesSafely(Intent intent) {
            return expectedIntent.filterEquals(intent);
        }
    };
}
#method_after
private static Matcher<Intent> isSameIntent(final Intent expectedIntent) {
    return new TypeSafeMatcher<Intent>() {

        @Override
        public void describeTo(Description description) {
            description.appendText("is Intent: " + expectedIntent);
        }

        @Override
        public boolean matchesSafely(Intent intent) {
            return expectedIntent.filterEquals(intent);
        }
    };
}
#end_block

#method_before
@Test
public void successHasResultData() {
    Intent intent = new Intent(Intent.ACTION_MAIN);
    Instrumentation.ActivityResult activityResult = new Instrumentation.ActivityResult(1, intent);
    assertThat(ActivityResultMatchers.hasResultData(isSameIntent(intent)).matches(activityResult), is(true));
}
#method_after
@Test
public void successHasResultData() {
    Intent intent = new Intent(Intent.ACTION_MAIN);
    ActivityResult activityResult = new ActivityResult(1, intent);
    assertThat(ActivityResultMatchers.hasResultData(isSameIntent(intent)).matches(activityResult), is(true));
}
#end_block

#method_before
@Test
public void failureHasResultData() {
    Intent intent = new Intent(Intent.ACTION_MAIN);
    Instrumentation.ActivityResult activityResult = new Instrumentation.ActivityResult(1, intent);
    assertThat(ActivityResultMatchers.hasResultData(isSameIntent(new Intent(Intent.ACTION_VIEW))).matches(activityResult), is(false));
}
#method_after
@Test
public void failureHasResultData() {
    Intent intent = new Intent(Intent.ACTION_MAIN);
    ActivityResult activityResult = new ActivityResult(1, intent);
    assertThat(ActivityResultMatchers.hasResultData(isSameIntent(new Intent(Intent.ACTION_VIEW))).matches(activityResult), is(false));
}
#end_block

#method_before
@Test
public void successHasResultCode() {
    Instrumentation.ActivityResult activityResult = new Instrumentation.ActivityResult(1, null);
    assertThat(ActivityResultMatchers.hasResultCode(1).matches(activityResult), is(true));
}
#method_after
@Test
public void successHasResultCode() {
    ActivityResult activityResult = new ActivityResult(1, null);
    assertThat(ActivityResultMatchers.hasResultCode(1).matches(activityResult), is(true));
}
#end_block

#method_before
@Test
public void failureHasResultCode() {
    Instrumentation.ActivityResult activityResult = new Instrumentation.ActivityResult(1, null);
    assertThat(ActivityResultMatchers.hasResultCode(2).matches(activityResult), is(false));
}
#method_after
@Test
public void failureHasResultCode() {
    ActivityResult activityResult = new ActivityResult(1, null);
    assertThat(ActivityResultMatchers.hasResultCode(2).matches(activityResult), is(false));
}
#end_block

#method_before
public static Matcher<? super Instrumentation.ActivityResult> hasResultData(final Matcher<Intent> intentMatcher) {
    return new TypeSafeMatcher<Instrumentation.ActivityResult>(Instrumentation.ActivityResult.class) {

        @Override
        public void describeTo(Description description) {
            description.appendDescriptionOf(intentMatcher);
        }

        @Override
        protected boolean matchesSafely(Instrumentation.ActivityResult item) {
            return intentMatcher.matches(item.getResultData());
        }

        @Override
        protected void describeMismatchSafely(Instrumentation.ActivityResult item, Description mismatchDescription) {
            intentMatcher.describeMismatch(item.getResultData(), mismatchDescription);
        }
    };
}
#method_after
public static Matcher<? super ActivityResult> hasResultData(final Matcher<Intent> intentMatcher) {
    return new TypeSafeMatcher<ActivityResult>(ActivityResult.class) {

        @Override
        public void describeTo(Description description) {
            description.appendDescriptionOf(intentMatcher);
        }

        @Override
        protected boolean matchesSafely(ActivityResult item) {
            return intentMatcher.matches(item.getResultData());
        }

        @Override
        protected void describeMismatchSafely(ActivityResult item, Description mismatchDescription) {
            intentMatcher.describeMismatch(item.getResultData(), mismatchDescription);
        }
    };
}
#end_block

#method_before
public static Matcher<? super Instrumentation.ActivityResult> hasResultCode(final int resultCode) {
    return new TypeSafeMatcher<Instrumentation.ActivityResult>(Instrumentation.ActivityResult.class) {

        @Override
        public void describeTo(Description description) {
            description.appendText("has result code " + resultCode);
        }

        @Override
        protected boolean matchesSafely(Instrumentation.ActivityResult activityResult) {
            return activityResult.getResultCode() == resultCode;
        }
    };
}
#method_after
public static Matcher<? super ActivityResult> hasResultCode(final int resultCode) {
    return new TypeSafeMatcher<ActivityResult>(ActivityResult.class) {

        @Override
        public void describeTo(Description description) {
            description.appendText("has result code " + resultCode);
        }

        @Override
        protected boolean matchesSafely(ActivityResult activityResult) {
            return activityResult.getResultCode() == resultCode;
        }
    };
}
#end_block

#method_before
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
public Instrumentation.ActivityResult getActivityResult() {
    T activity = getActivity();
    assertThat("Activity did not finish, getActivityResult must not called before the activity finished " + "(activity destroyed: " + activity.isDestroyed() + ")", activity.isFinishing());
    try {
        Field resultCodeField = Activity.class.getDeclaredField("mResultCode");
        resultCodeField.setAccessible(true);
        Field resultDataField = Activity.class.getDeclaredField("mResultData");
        resultDataField.setAccessible(true);
        return new Instrumentation.ActivityResult((int) resultCodeField.get(activity), (Intent) resultDataField.get(activity));
    } catch (NoSuchFieldException e) {
        throw new RuntimeException("Looks like the Android Activity class has changed it's" + "private fields for mResultCode or mResultData. Time to update the reflection code.", e);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public ActivityResult getActivityResult() {
    T activity = mActivity;
    checkState(activity.isFinishing());
    try {
        Field resultCodeField = Activity.class.getDeclaredField(FIELD_RESULT_CODE);
        resultCodeField.setAccessible(true);
        Field resultDataField = Activity.class.getDeclaredField(FIELD_RESULT_DATA);
        resultDataField.setAccessible(true);
        return new ActivityResult((int) resultCodeField.get(activity), (Intent) resultDataField.get(activity));
    } catch (NoSuchFieldException e) {
        throw new RuntimeException("Looks like the Android Activity class has changed its" + "private fields for mResultCode or mResultData. " + "Time to update the reflection code.", e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Field mResultCode or mResultData is not accessible", e);
    }
}
#end_block

#method_before
@Test
public void wrongNegativeColumnIndex() {
    expectedException.expect(IllegalArgumentException.class);
    withRowInt(-1, INTEGER_VALUE_MATCHER).matches(cursor);
    fail("Expected IllegalArgumentException");
}
#method_after
@Test
public void wrongNegativeColumnIndex() {
    expectedException.expect(IllegalArgumentException.class);
    withRowInt(-1, INTEGER_VALUE_MATCHER).matches(cursor);
}
#end_block

#method_before
@LargeTest
@Test
public void injectKeyEvent() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
                KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
                injectEventWorked.set(uiController.injectKeyEvent(events[0]));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("injectEvent threw a SecurityException", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#method_after
@Test
public void injectKeyEvent() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
                KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
                injectEventWorked.set(uiController.injectKeyEvent(events[0]));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("injectEvent threw a SecurityException", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void testInjectString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            Log.i("TEST", HumanReadables.describe(view));
            requestFocusSucceded.set(view.requestFocus() && view.hasWindowFocus());
            Log.i("TEST-post", HumanReadables.describe(view));
            focusLatch.countDown();
        }
    });
    getInstrumentation().waitForIdleSync();
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("Hello! \n&*$$$"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#method_after
@Test
public void testInjectString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            Log.i("TEST", HumanReadables.describe(view));
            requestFocusSucceded.set(view.requestFocus() && view.hasWindowFocus());
            Log.i("TEST-post", HumanReadables.describe(view));
            focusLatch.countDown();
        }
    });
    getInstrumentation().waitForIdleSync();
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("Hello! \n&*$$$"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void injectLargeString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            Log.i("TEST", HumanReadables.describe(view));
            requestFocusSucceded.set(view.requestFocus());
            Log.i("TEST-post", HumanReadables.describe(view));
            focusLatch.countDown();
        }
    });
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("This is a string with 32 chars!!"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#method_after
@Test
public void injectLargeString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            Log.i("TEST", HumanReadables.describe(view));
            requestFocusSucceded.set(view.requestFocus());
            Log.i("TEST-post", HumanReadables.describe(view));
            focusLatch.countDown();
        }
    });
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("This is a string with 32 chars!!"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void testInjectEmptyString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            requestFocusSucceded.set(view.requestFocus());
            focusLatch.countDown();
        }
    });
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString(""));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#method_after
@Test
public void testInjectEmptyString() throws InterruptedException {
    sendActivity = rule.getActivity();
    getInstrumentation().waitForIdleSync();
    final AtomicBoolean requestFocusSucceded = new AtomicBoolean(false);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            final View view = sendActivity.findViewById(R.id.send_data_to_call_edit_text);
            requestFocusSucceded.set(view.requestFocus());
            focusLatch.countDown();
        }
    });
    assertTrue("requestFocus timed out!", focusLatch.await(2, TimeUnit.SECONDS));
    assertTrue("requestFocus failed.", requestFocusSucceded.get());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString(""));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(20, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void injectStringSecurityException() throws InterruptedException {
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("Hello! \n&*$$$"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertTrue("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertFalse("Did NOT time out!", latch.await(3, TimeUnit.SECONDS));
    assertFalse(injectEventWorked.get());
}
#method_after
@Test
public void injectStringSecurityException() throws InterruptedException {
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            try {
                injectEventWorked.set(uiController.injectString("Hello! \n&*$$$"));
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertTrue("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertFalse("Did NOT time out!", latch.await(3, TimeUnit.SECONDS));
    assertFalse(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void injectMotionEvent() throws InterruptedException {
    sendActivity = rule.getActivity();
    final int[] xy = getCoordinatesInMiddleOfSendButton(sendActivity, getInstrumentation());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            long downTime = SystemClock.uptimeMillis();
            try {
                MotionEvent event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, xy[0], xy[1], 0);
                injectEventWorked.set(uiController.injectMotionEvent(event));
                event.recycle();
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#method_after
@Test
public void injectMotionEvent() throws InterruptedException {
    sendActivity = rule.getActivity();
    final int[] xy = getCoordinatesInMiddleOfSendButton(sendActivity, getInstrumentation());
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            long downTime = SystemClock.uptimeMillis();
            try {
                MotionEvent event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, xy[0], xy[1], 0);
                injectEventWorked.set(uiController.injectMotionEvent(event));
                event.recycle();
                latch.countDown();
            } catch (InjectEventSecurityException e) {
                injectEventThrewSecurityException.set(true);
            }
        }
    });
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertTrue(injectEventWorked.get());
}
#end_block

#method_before
@LargeTest
@Test
public void injectKeyEventUpWithNoDown() throws Exception {
    sendActivity = rule.launchActivity(null);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            View view = sendActivity.findViewById(R.id.send_data_edit_text);
            assertTrue(view.requestFocus());
            latch.countDown();
        }
    });
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    assertTrue(injector.injectKeyEvent(events[1]));
}
#method_after
@Test
public void injectKeyEventUpWithNoDown() throws Exception {
    sendActivity = rule.launchActivity(null);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            View view = sendActivity.findViewById(R.id.send_data_edit_text);
            assertTrue(view.requestFocus());
            latch.countDown();
        }
    });
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    assertTrue(injector.injectKeyEvent(events[1]));
}
#end_block

#method_before
@LargeTest
@Test
public void injectStaleKeyEvent() throws Exception {
    sendActivity = rule.launchActivity(null);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            View view = sendActivity.findViewById(R.id.send_data_edit_text);
            assertTrue(view.requestFocus());
            latch.countDown();
        }
    });
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    KeyEvent event = KeyEvent.changeTimeRepeat(events[0], 1, 0);
    // Stale event does not fail for API < 13.
    if (Build.VERSION.SDK_INT < 13) {
        assertTrue(injector.injectKeyEvent(event));
    } else {
        assertFalse(injector.injectKeyEvent(event));
    }
}
#method_after
@Test
public void injectStaleKeyEvent() throws Exception {
    sendActivity = rule.launchActivity(null);
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            View view = sendActivity.findViewById(R.id.send_data_edit_text);
            assertTrue(view.requestFocus());
            latch.countDown();
        }
    });
    assertTrue("Timed out!", latch.await(10, TimeUnit.SECONDS));
    assertFalse("SecurityException exception was thrown.", injectEventThrewSecurityException.get());
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    KeyEvent event = KeyEvent.changeTimeRepeat(events[0], 1, 0);
    // Stale event does not fail for API < 13.
    if (Build.VERSION.SDK_INT < 13) {
        assertTrue(injector.injectKeyEvent(event));
    } else {
        assertFalse(injector.injectKeyEvent(event));
    }
}
#end_block

#method_before
@LargeTest
@Test
public void injectKeyEvent_securityException() throws InjectEventSecurityException {
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    expectedException.expect(InjectEventSecurityException.class);
    injector.injectKeyEvent(events[0]);
}
#method_after
@Test
public void injectKeyEvent_securityException() throws InjectEventSecurityException {
    KeyCharacterMap keyCharacterMap = UiControllerImpl.getKeyCharacterMap();
    KeyEvent[] events = keyCharacterMap.getEvents("a".toCharArray());
    expectedException.expect(InjectEventSecurityException.class);
    injector.injectKeyEvent(events[0]);
}
#end_block

#method_before
@LargeTest
@Test
public void injectMotionEvent_securityException() throws Exception {
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            MotionEvent down = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 0, 0, 0);
            try {
                injector.injectMotionEvent(down);
            } catch (InjectEventSecurityException expected) {
                injectEventThrewSecurityException.set(true);
            }
            latch.countDown();
        }
    });
    latch.await(10, TimeUnit.SECONDS);
    assertTrue(injectEventThrewSecurityException.get());
}
#method_after
@Test
public void injectMotionEvent_securityException() throws Exception {
    getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            MotionEvent down = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 0, 0, 0);
            try {
                injector.injectMotionEvent(down);
            } catch (InjectEventSecurityException expected) {
                injectEventThrewSecurityException.set(true);
            }
            latch.countDown();
        }
    });
    latch.await(10, TimeUnit.SECONDS);
    assertTrue(injectEventThrewSecurityException.get());
}
#end_block

#method_before
@LargeTest
@Test
public void injectMotionEvent_upEventFailure() throws InterruptedException {
    final CountDownLatch activityStarted = new CountDownLatch(1);
    ActivityLifecycleCallback callback = new ActivityLifecycleCallback() {

        @Override
        public void onActivityLifecycleChanged(Activity activity, Stage stage) {
            if (Stage.RESUMED == stage && activity instanceof SendActivity) {
                activityStarted.countDown();
            }
        }
    };
    ActivityLifecycleMonitorRegistry.getInstance().addLifecycleCallback(callback);
    try {
        rule.launchActivity(null);
        assertTrue(activityStarted.await(20, TimeUnit.SECONDS));
        final int[] xy = UiControllerImplIntegrationTest.getCoordinatesInMiddleOfSendButton(rule.getActivity(), getInstrumentation());
        getInstrumentation().runOnMainSync(new Runnable() {

            @Override
            public void run() {
                MotionEvent up = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, xy[0], xy[1], 0);
                try {
                    injectEventWorked.set(injector.injectMotionEvent(up));
                } catch (InjectEventSecurityException e) {
                    Log.e(TAG, "injectEvent threw a SecurityException");
                }
                up.recycle();
                latch.countDown();
            }
        });
        latch.await(10, TimeUnit.SECONDS);
        assertFalse(injectEventWorked.get());
    } finally {
        ActivityLifecycleMonitorRegistry.getInstance().removeLifecycleCallback(callback);
    }
}
#method_after
@Test
public void injectMotionEvent_upEventFailure() throws InterruptedException {
    final CountDownLatch activityStarted = new CountDownLatch(1);
    ActivityLifecycleCallback callback = new ActivityLifecycleCallback() {

        @Override
        public void onActivityLifecycleChanged(Activity activity, Stage stage) {
            if (Stage.RESUMED == stage && activity instanceof SendActivity) {
                activityStarted.countDown();
            }
        }
    };
    ActivityLifecycleMonitorRegistry.getInstance().addLifecycleCallback(callback);
    try {
        rule.launchActivity(null);
        assertTrue(activityStarted.await(20, TimeUnit.SECONDS));
        final int[] xy = UiControllerImplIntegrationTest.getCoordinatesInMiddleOfSendButton(rule.getActivity(), getInstrumentation());
        getInstrumentation().runOnMainSync(new Runnable() {

            @Override
            public void run() {
                MotionEvent up = MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, xy[0], xy[1], 0);
                try {
                    injectEventWorked.set(injector.injectMotionEvent(up));
                } catch (InjectEventSecurityException e) {
                    Log.e(TAG, "injectEvent threw a SecurityException");
                }
                up.recycle();
                latch.countDown();
            }
        });
        latch.await(10, TimeUnit.SECONDS);
        assertFalse(injectEventWorked.get());
    } finally {
        ActivityLifecycleMonitorRegistry.getInstance().removeLifecycleCallback(callback);
    }
}
#end_block

#method_before
@LargeTest
@Test
public void loopMainThreadUntilIdle_timeout() throws InterruptedException {
    OnDemandIdlingResource goodResource = new OnDemandIdlingResource("GoodResource");
    OnDemandIdlingResource kindaCrappyResource = new OnDemandIdlingResource("KindaCrappyResource");
    OnDemandIdlingResource badResource = new OnDemandIdlingResource("VeryBadResource");
    idlingResourceRegistry.registerResources(Lists.newArrayList(goodResource, kindaCrappyResource, badResource));
    final CountDownLatch latch = new CountDownLatch(1);
    assertTrue(testThread.getHandler().post(new Runnable() {

        @Override
        public void run() {
            Log.i(TAG, "Hijacking thread and looping it.");
            try {
                uiController.get().loopMainThreadUntilIdle();
            } catch (IdlingResourceTimeoutException e) {
                latch.countDown();
            }
        }
    }));
    assertFalse("Should not have stopped looping the main thread yet!", latch.await(4, TimeUnit.SECONDS));
    goodResource.forceIdleNow();
    assertFalse("Should not have stopped looping the main thread yet!", latch.await(12, TimeUnit.SECONDS));
    kindaCrappyResource.forceIdleNow();
    assertTrue("Should have caught IdlingResourceTimeoutException", latch.await(11, TimeUnit.SECONDS));
}
#method_after
@Test
public void loopMainThreadUntilIdle_timeout() throws InterruptedException {
    OnDemandIdlingResource goodResource = new OnDemandIdlingResource("GoodResource");
    OnDemandIdlingResource kindaCrappyResource = new OnDemandIdlingResource("KindaCrappyResource");
    OnDemandIdlingResource badResource = new OnDemandIdlingResource("VeryBadResource");
    idlingResourceRegistry.registerResources(Lists.newArrayList(goodResource, kindaCrappyResource, badResource));
    final CountDownLatch latch = new CountDownLatch(1);
    assertTrue(testThread.getHandler().post(new Runnable() {

        @Override
        public void run() {
            Log.i(TAG, "Hijacking thread and looping it.");
            try {
                uiController.get().loopMainThreadUntilIdle();
            } catch (IdlingResourceTimeoutException e) {
                latch.countDown();
            }
        }
    }));
    assertFalse("Should not have stopped looping the main thread yet!", latch.await(4, TimeUnit.SECONDS));
    goodResource.forceIdleNow();
    assertFalse("Should not have stopped looping the main thread yet!", latch.await(12, TimeUnit.SECONDS));
    kindaCrappyResource.forceIdleNow();
    assertTrue("Should have caught IdlingResourceTimeoutException", latch.await(11, TimeUnit.SECONDS));
}
#end_block

#method_before
@LargeTest
@Test
public void allResourcesAreIdle_RepeatingToIdleTransitions() throws Exception {
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    registry.registerResources(Lists.newArrayList(r1));
    for (int i = 1; i <= 3; i++) {
        FutureTask<Boolean> resourcesIdle = createIdleCheckTask(registry);
        handler.post(resourcesIdle);
        assertFalse("Busy test " + i, resourcesIdle.get());
        r1.forceIdleNow();
        resourcesIdle = createIdleCheckTask(registry);
        handler.post(resourcesIdle);
        assertTrue("Idle transition test " + i, resourcesIdle.get());
        r1.reset();
    }
}
#method_after
@Test
public void allResourcesAreIdle_RepeatingToIdleTransitions() throws Exception {
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    registry.registerResources(Lists.newArrayList(r1));
    for (int i = 1; i <= 3; i++) {
        FutureTask<Boolean> resourcesIdle = createIdleCheckTask(registry);
        handler.post(resourcesIdle);
        assertFalse("Busy test " + i, resourcesIdle.get());
        r1.forceIdleNow();
        resourcesIdle = createIdleCheckTask(registry);
        handler.post(resourcesIdle);
        assertTrue("Idle transition test " + i, resourcesIdle.get());
        r1.reset();
    }
}
#end_block

#method_before
@LargeTest
@Test
public void notifyWhenAllResourcesAreIdle_success() throws InterruptedException {
    final CountDownLatch busyWarningLatch = new CountDownLatch(4);
    final CountDownLatch timeoutLatch = new CountDownLatch(1);
    final CountDownLatch allResourcesIdleLatch = new CountDownLatch(1);
    final AtomicReference<List<String>> busysFromWarning = new AtomicReference<List<String>>();
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    OnDemandIdlingResource r2 = new OnDemandIdlingResource("r2");
    OnDemandIdlingResource r3 = new OnDemandIdlingResource("r3");
    registry.registerResources(Lists.newArrayList(r1, r2, r3));
    handler.post(new Runnable() {

        @Override
        public void run() {
            registry.notifyWhenAllResourcesAreIdle(new IdleNotificationCallback() {

                private static final String TAG = "IdleNotificationCallback";

                @Override
                public void resourcesStillBusyWarning(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout warning: " + busyResourceNames);
                    busysFromWarning.set(busyResourceNames);
                    busyWarningLatch.countDown();
                }

                @Override
                public void resourcesHaveTimedOut(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout error: " + busyResourceNames);
                    timeoutLatch.countDown();
                }

                @Override
                public void allResourcesIdle() {
                    allResourcesIdleLatch.countDown();
                }
            });
        }
    });
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(3, busysFromWarning.get().size());
    r3.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(2, busysFromWarning.get().size());
    r2.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    r1.forceIdleNow();
    assertTrue(allResourcesIdleLatch.await(200, TimeUnit.MILLISECONDS));
    assertEquals(1, busyWarningLatch.getCount());
    assertEquals(1, timeoutLatch.getCount());
}
#method_after
@Test
public void notifyWhenAllResourcesAreIdle_success() throws InterruptedException {
    final CountDownLatch busyWarningLatch = new CountDownLatch(4);
    final CountDownLatch timeoutLatch = new CountDownLatch(1);
    final CountDownLatch allResourcesIdleLatch = new CountDownLatch(1);
    final AtomicReference<List<String>> busysFromWarning = new AtomicReference<List<String>>();
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    OnDemandIdlingResource r2 = new OnDemandIdlingResource("r2");
    OnDemandIdlingResource r3 = new OnDemandIdlingResource("r3");
    registry.registerResources(Lists.newArrayList(r1, r2, r3));
    handler.post(new Runnable() {

        @Override
        public void run() {
            registry.notifyWhenAllResourcesAreIdle(new IdleNotificationCallback() {

                private static final String TAG = "IdleNotificationCallback";

                @Override
                public void resourcesStillBusyWarning(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout warning: " + busyResourceNames);
                    busysFromWarning.set(busyResourceNames);
                    busyWarningLatch.countDown();
                }

                @Override
                public void resourcesHaveTimedOut(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout error: " + busyResourceNames);
                    timeoutLatch.countDown();
                }

                @Override
                public void allResourcesIdle() {
                    allResourcesIdleLatch.countDown();
                }
            });
        }
    });
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(3, busysFromWarning.get().size());
    r3.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(2, busysFromWarning.get().size());
    r2.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    r1.forceIdleNow();
    assertTrue(allResourcesIdleLatch.await(200, TimeUnit.MILLISECONDS));
    assertEquals(1, busyWarningLatch.getCount());
    assertEquals(1, timeoutLatch.getCount());
}
#end_block

#method_before
@LargeTest
@Test
public void notifyWhenAllResourcesAreIdle_timeout() throws InterruptedException {
    final CountDownLatch busyWarningLatch = new CountDownLatch(5);
    final CountDownLatch timeoutLatch = new CountDownLatch(1);
    final CountDownLatch allResourcesIdleLatch = new CountDownLatch(1);
    final AtomicReference<List<String>> busysFromWarning = new AtomicReference<List<String>>();
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    OnDemandIdlingResource r2 = new OnDemandIdlingResource("r2");
    OnDemandIdlingResource r3 = new OnDemandIdlingResource("r3");
    registry.registerResources(Lists.newArrayList(r1, r2, r3));
    handler.post(new Runnable() {

        @Override
        public void run() {
            registry.notifyWhenAllResourcesAreIdle(new IdleNotificationCallback() {

                private static final String TAG = "IdleNotificationCallback";

                @Override
                public void resourcesStillBusyWarning(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout warning: " + busyResourceNames);
                    busysFromWarning.set(busyResourceNames);
                    busyWarningLatch.countDown();
                }

                @Override
                public void resourcesHaveTimedOut(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout error: " + busyResourceNames);
                    timeoutLatch.countDown();
                }

                @Override
                public void allResourcesIdle() {
                    allResourcesIdleLatch.countDown();
                }
            });
        }
    });
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(3, busysFromWarning.get().size());
    r1.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(2, busysFromWarning.get().size());
    r2.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    assertTrue("Expected to finish count down", busyWarningLatch.await(8, TimeUnit.SECONDS));
    assertTrue("Should have timed out", timeoutLatch.await(2, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    assertEquals(1, allResourcesIdleLatch.getCount());
}
#method_after
@Test
public void notifyWhenAllResourcesAreIdle_timeout() throws InterruptedException {
    final CountDownLatch busyWarningLatch = new CountDownLatch(5);
    final CountDownLatch timeoutLatch = new CountDownLatch(1);
    final CountDownLatch allResourcesIdleLatch = new CountDownLatch(1);
    final AtomicReference<List<String>> busysFromWarning = new AtomicReference<List<String>>();
    OnDemandIdlingResource r1 = new OnDemandIdlingResource("r1");
    OnDemandIdlingResource r2 = new OnDemandIdlingResource("r2");
    OnDemandIdlingResource r3 = new OnDemandIdlingResource("r3");
    registry.registerResources(Lists.newArrayList(r1, r2, r3));
    handler.post(new Runnable() {

        @Override
        public void run() {
            registry.notifyWhenAllResourcesAreIdle(new IdleNotificationCallback() {

                private static final String TAG = "IdleNotificationCallback";

                @Override
                public void resourcesStillBusyWarning(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout warning: " + busyResourceNames);
                    busysFromWarning.set(busyResourceNames);
                    busyWarningLatch.countDown();
                }

                @Override
                public void resourcesHaveTimedOut(List<String> busyResourceNames) {
                    Log.w(TAG, "Timeout error: " + busyResourceNames);
                    timeoutLatch.countDown();
                }

                @Override
                public void allResourcesIdle() {
                    allResourcesIdleLatch.countDown();
                }
            });
        }
    });
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(3, busysFromWarning.get().size());
    r1.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(2, busysFromWarning.get().size());
    r2.forceIdleNow();
    assertFalse("Expected to timeout", busyWarningLatch.await(6, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    assertTrue("Expected to finish count down", busyWarningLatch.await(8, TimeUnit.SECONDS));
    assertTrue("Should have timed out", timeoutLatch.await(2, TimeUnit.SECONDS));
    assertEquals(1, busysFromWarning.get().size());
    assertEquals(1, allResourcesIdleLatch.getCount());
}
#end_block

#method_before
public void testPutCharBuffer() {
    CharBuffer other = CharBuffer.allocate(1);
    try {
        buf.put(other);
        // $NON-NLS-1$
        fail("Should throw ReadOnlyBufferException");
    } catch (ReadOnlyBufferException e) {
    // expected
    }
    try {
        buf.put((CharBuffer) null);
        // $NON-NLS-1$
        fail("Should throw ReadOnlyBufferException");
    } catch (ReadOnlyBufferException e) {
    // expected
    }
    try {
        buf.put(buf);
        // $NON-NLS-1$
        fail("Should throw ReadOnlyBufferException or IAE");
    } catch (IllegalArgumentException e) {
    // expected
    } catch (ReadOnlyBufferException e) {
    // expected
    }
}
#method_after
public void testPutCharBuffer() {
    CharBuffer other = CharBuffer.allocate(1);
    try {
        buf.put(other);
        // $NON-NLS-1$
        fail("Should throw ReadOnlyBufferException");
    } catch (ReadOnlyBufferException e) {
    // expected
    }
    try {
        buf.put((CharBuffer) null);
        // $NON-NLS-1$
        fail("Should throw ReadOnlyBufferException");
    } catch (ReadOnlyBufferException e) {
    // expected
    }
    try {
        buf.put(buf);
        // $NON-NLS-1$
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
}
#end_block

#method_before
private static void handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) throws Zygote.MethodAndArgsCaller {
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
    if (systemServerClasspath != null) {
        performSystemServerDexOpt(systemServerClasspath);
    }
    if (parsedArgs.invokeWith != null) {
        String[] args = parsedArgs.remainingArgs;
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = "-cp";
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);
        }
        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args);
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
            Thread.currentThread().setContextClassLoader(cl);
        }
        /*
             * Pass the remaining arguments to SystemServer.
             */
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
    }
/* should never reach here */
}
#method_after
private static void handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) throws Zygote.MethodAndArgsCaller {
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
    if (systemServerClasspath != null) {
        performSystemServerDexOpt(systemServerClasspath);
    }
    if (parsedArgs.invokeWith != null) {
        String[] args = parsedArgs.remainingArgs;
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = "-cp";
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(args, 0, amendedArgs, 2, args.length);
            args = amendedArgs;
        }
        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args);
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
            Thread.currentThread().setContextClassLoader(cl);
        }
        /*
             * Pass the remaining arguments to SystemServer.
             */
        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
    }
/* should never reach here */
}
#end_block

#method_before
private static boolean startSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller, RuntimeException {
    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_IPC_LOCK, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG, OsConstants.CAP_WAKE_ALARM);
    /* Containers run without this capability, so avoid setting it in that case */
    if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) {
        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);
    }
    /* Hardcoded command line to start the system server */
    String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010", "--capabilities=" + capabilities + "," + capabilities, "--nice-name=system_server", "--runtime-args", SYSTEMSERVER_CLASSNAME };
    ZygoteConnection.Arguments parsedArgs = null;
    int pid;
    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }
    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }
        zygoteServer.closeServerSocket();
        handleSystemServerProcess(parsedArgs);
    }
    return true;
}
#method_after
private static boolean startSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller, RuntimeException {
    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_IPC_LOCK, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG, OsConstants.CAP_WAKE_ALARM);
    /* Containers run without this capability, so avoid setting it in that case */
    if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) {
        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);
    }
    /* Hardcoded command line to start the system server */
    String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010", "--capabilities=" + capabilities + "," + capabilities, "--nice-name=system_server", "--runtime-args", "com.android.server.SystemServer" };
    ZygoteConnection.Arguments parsedArgs = null;
    int pid;
    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }
    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }
        zygoteServer.closeServerSocket();
        handleSystemServerProcess(parsedArgs);
    }
    return true;
}
#end_block

#method_before
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygoteInit");
        RuntimeInit.enableDdms();
        // Start profiling the zygote initialization.
        SamplingProfilerIntegration.start();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocket(socketName);
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload");
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
        preload();
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Finish profiling the zygote initialization.
        SamplingProfilerIntegration.writeZygoteSnapshot();
        // Do an initial gc to clean up after startup
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PostZygoteInitGC");
        gcAndFinalize();
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false);
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            startSystemServer(abiList, socketName, zygoteServer);
        }
        Log.i(TAG, "Accepting command socket connections");
        zygoteServer.runSelectLoop(abiList);
        zygoteServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        zygoteServer.closeServerSocket();
        throw ex;
    }
}
#method_after
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygoteInit");
        RuntimeInit.enableDdms();
        // Start profiling the zygote initialization.
        SamplingProfilerIntegration.start();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocket(socketName);
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload");
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
        preload();
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Finish profiling the zygote initialization.
        SamplingProfilerIntegration.writeZygoteSnapshot();
        // Do an initial gc to clean up after startup
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PostZygoteInitGC");
        gcAndFinalize();
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false);
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        // Set seccomp policy
        Seccomp.setPolicy();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            startSystemServer(abiList, socketName, zygoteServer);
        }
        Log.i(TAG, "Accepting command socket connections");
        zygoteServer.runSelectLoop(abiList);
        zygoteServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        zygoteServer.closeServerSocket();
        throw ex;
    }
}
#end_block

#method_before
public void setEnhanced4gLteModeSettingForSlot(boolean enabled) {
    int value = enabled ? 1 : 0;
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
    if (isNonTtyOrTtyOnVolteEnabledForSlot()) {
        try {
            setAdvanced4GMode(enabled);
        } catch (ImsException ie) {
        // do nothing
        }
    }
}
#method_after
public void setEnhanced4gLteModeSettingForSlot(boolean enabled) {
    // If false, we must always keep advanced 4G mode set to true (1).
    int value = getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL) ? (enabled ? 1 : 0) : 1;
    try {
        int prevSetting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
        if (prevSetting == value) {
            // Don't trigger setAdvanced4GMode if the setting hasn't changed.
            return;
        }
    } catch (Settings.SettingNotFoundException e) {
    // Setting doesn't exist yet, so set it below.
    }
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
    if (isNonTtyOrTtyOnVolteEnabledForSlot()) {
        try {
            setAdvanced4GMode(enabled);
        } catch (ImsException ie) {
        // do nothing
        }
    }
}
#end_block

#method_before
public void setWfcModeForSlot(int wfcMode, boolean roaming) {
    if (!roaming) {
        if (DBG)
            log("setWfcModeForSlot - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, wfcMode);
    } else {
        if (DBG)
            log("setWfcModeForSlot (roaming) - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, wfcMode);
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    if (roaming == tm.isNetworkRoaming()) {
        setWfcModeInternalForSlot(wfcMode);
    }
}
#method_after
public void setWfcModeForSlot(int wfcMode, boolean roaming) {
    if (!roaming) {
        if (DBG)
            log("setWfcModeForSlot - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, wfcMode);
    } else {
        if (DBG)
            log("setWfcModeForSlot (roaming) - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, wfcMode);
    }
    int[] subIds = SubscriptionManager.getSubId(mPhoneId);
    int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    if (subIds != null && subIds.length >= 1) {
        subId = subIds[0];
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    if (roaming == tm.isNetworkRoaming(subId)) {
        setWfcModeInternalForSlot(wfcMode);
    }
}
#end_block

#method_before
private boolean updateVideoCallFeatureValue() throws ImsException {
    boolean available = isVtEnabledByPlatformForSlot();
    boolean enabled = isVtEnabledByUserForSlot();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabledForSlot();
    boolean isDataEnabled = isDataEnabled();
    boolean isFeatureOn = available && enabled && isNonTty && isDataEnabled;
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty + ", data enabled = " + isDataEnabled);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    return isFeatureOn;
}
#method_after
private boolean updateVideoCallFeatureValue() throws ImsException {
    boolean available = isVtEnabledByPlatformForSlot();
    boolean enabled = isVtEnabledByUserForSlot();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabledForSlot();
    boolean isDataEnabled = isDataEnabled();
    boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    boolean isFeatureOn = available && enabled && isNonTty && (ignoreDataEnabledChanged || isDataEnabled);
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty + ", data enabled = " + isDataEnabled);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    return isFeatureOn;
}
#end_block

#method_before
private boolean getBooleanCarrierConfigForSlot(String key) {
    int[] subIds = SubscriptionManager.getSubId(mPhoneId);
    int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    if (subIds != null && subIds.length >= 1) {
        subId = subIds[0];
    }
    PersistableBundle b = null;
    if (mConfigManager != null) {
        // If an invalid subId is used, this method will contain default values.
        b = mConfigManager.getConfigForSubId(subId);
    }
    if (b != null) {
        return b.getBoolean(key);
    } else {
        // Return static default defined in CarrierConfigManager.
        return CarrierConfigManager.getDefaultConfig().getBoolean(key);
    }
}
#method_after
private boolean getBooleanCarrierConfigForSlot(String key) {
    int[] subIds = SubscriptionManager.getSubId(mPhoneId);
    int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    if (subIds != null && subIds.length >= 1) {
        subId = subIds[0];
    }
    PersistableBundle b = null;
    if (mConfigManager != null) {
        // If an invalid subId is used, this bundle will contain default values.
        b = mConfigManager.getConfigForSubId(subId);
    }
    if (b != null) {
        return b.getBoolean(key);
    } else {
        // Return static default defined in CarrierConfigManager.
        return CarrierConfigManager.getDefaultConfig().getBoolean(key);
    }
}
#end_block

#method_before
private int getIntCarrierConfigForSlot(String key) {
    PersistableBundle b = null;
    if (mConfigManager != null) {
        b = mConfigManager.getConfig();
    }
    if (b != null) {
        return b.getInt(key);
    } else {
        // Return static default defined in CarrierConfigManager.
        return CarrierConfigManager.getDefaultConfig().getInt(key);
    }
}
#method_after
private int getIntCarrierConfigForSlot(String key) {
    int[] subIds = SubscriptionManager.getSubId(mPhoneId);
    int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
    if (subIds != null && subIds.length >= 1) {
        subId = subIds[0];
    }
    PersistableBundle b = null;
    if (mConfigManager != null) {
        // If an invalid subId is used, this bundle will contain default values.
        b = mConfigManager.getConfigForSubId(subId);
    }
    if (b != null) {
        return b.getInt(key);
    } else {
        // Return static default defined in CarrierConfigManager.
        return CarrierConfigManager.getDefaultConfig().getInt(key);
    }
}
#end_block

#method_before
private void setLteFeatureValues(boolean turnOn) {
    log("setLteFeatureValues: " + turnOn);
    try {
        ImsConfig config = getConfigInterface();
        if (config != null) {
            config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, turnOn ? 1 : 0, mImsConfigListener);
            if (isVolteEnabledByPlatformForSlot()) {
                boolean enableViLte = turnOn && isVtEnabledByUserForSlot() && isDataEnabled();
                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, enableViLte ? 1 : 0, mImsConfigListener);
            }
        }
    } catch (ImsException e) {
        loge("setLteFeatureValues: exception ", e);
    }
}
#method_after
private void setLteFeatureValues(boolean turnOn) {
    log("setLteFeatureValues: " + turnOn);
    try {
        ImsConfig config = getConfigInterface();
        if (config != null) {
            config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, turnOn ? 1 : 0, mImsConfigListener);
            if (isVolteEnabledByPlatformForSlot()) {
                boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
                boolean enableViLte = turnOn && isVtEnabledByUserForSlot() && (ignoreDataEnabledChanged || isDataEnabled());
                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, enableViLte ? 1 : 0, mImsConfigListener);
            }
        }
    } catch (ImsException e) {
        loge("setLteFeatureValues: exception ", e);
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsManager:");
    pw.println("  mPhoneId = " + mPhoneId);
    pw.println("  mConfigUpdated = " + mConfigUpdated);
    pw.println("  mImsServiceProxy = " + mImsServiceProxy);
    pw.println("  mDataEnabled = " + isDataEnabled());
    pw.println("  isGbaValid = " + isGbaValidForSlot());
    pw.println("  isImsTurnOffAllowed = " + isImsTurnOffAllowed());
    pw.println("  isNonTtyOrTtyOnVolteEnabled = " + isNonTtyOrTtyOnVolteEnabledForSlot());
    pw.println("  isVolteEnabledByPlatform = " + isVolteEnabledByPlatformForSlot());
    pw.println("  isVolteProvisionedOnDevice = " + isVolteProvisionedOnDeviceForSlot());
    pw.println("  isEnhanced4gLteModeSettingEnabledByUser = " + isEnhanced4gLteModeSettingEnabledByUserForSlot());
    pw.println("  isVtEnabledByPlatform = " + isVtEnabledByPlatformForSlot());
    pw.println("  isVtEnabledByUser = " + isVtEnabledByUserForSlot());
    pw.println("  isWfcEnabledByPlatform = " + isWfcEnabledByPlatformForSlot());
    pw.println("  isWfcEnabledByUser = " + isWfcEnabledByUserForSlot());
    pw.println("  getWfcMode = " + getWfcModeForSlot());
    pw.println("  isWfcRoamingEnabledByUser = " + isWfcRoamingEnabledByUserForSlot());
    pw.println("  isVtProvisionedOnDevice = " + isVtProvisionedOnDeviceForSlot());
    pw.println("  isWfcProvisionedOnDevice = " + isWfcProvisionedOnDeviceForSlot());
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsManager:");
    pw.println("  mPhoneId = " + mPhoneId);
    pw.println("  mConfigUpdated = " + mConfigUpdated);
    pw.println("  mImsServiceProxy = " + mImsServiceProxy);
    pw.println("  mDataEnabled = " + isDataEnabled());
    pw.println("  ignoreDataEnabledChanged = " + getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS));
    pw.println("  isGbaValid = " + isGbaValidForSlot());
    pw.println("  isImsTurnOffAllowed = " + isImsTurnOffAllowed());
    pw.println("  isNonTtyOrTtyOnVolteEnabled = " + isNonTtyOrTtyOnVolteEnabledForSlot());
    pw.println("  isVolteEnabledByPlatform = " + isVolteEnabledByPlatformForSlot());
    pw.println("  isVolteProvisionedOnDevice = " + isVolteProvisionedOnDeviceForSlot());
    pw.println("  isEnhanced4gLteModeSettingEnabledByUser = " + isEnhanced4gLteModeSettingEnabledByUserForSlot());
    pw.println("  isVtEnabledByPlatform = " + isVtEnabledByPlatformForSlot());
    pw.println("  isVtEnabledByUser = " + isVtEnabledByUserForSlot());
    pw.println("  isWfcEnabledByPlatform = " + isWfcEnabledByPlatformForSlot());
    pw.println("  isWfcEnabledByUser = " + isWfcEnabledByUserForSlot());
    pw.println("  getWfcMode = " + getWfcModeForSlot());
    pw.println("  isWfcRoamingEnabledByUser = " + isWfcRoamingEnabledByUserForSlot());
    pw.println("  isVtProvisionedOnDevice = " + isVtProvisionedOnDeviceForSlot());
    pw.println("  isWfcProvisionedOnDevice = " + isWfcProvisionedOnDeviceForSlot());
    pw.flush();
}
#end_block

#method_before
@Override
public void onIconResponse(long bssid, String fileName, byte[] data) {
    Intent intent = new Intent(PASSPOINT_ICON_RECEIVED_ACTION);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(EXTRA_PASSPOINT_ICON_BSSID, bssid);
    intent.putExtra(EXTRA_PASSPOINT_ICON_FILE, fileName);
    if (data != null) {
        intent.putExtra(EXTRA_PASSPOINT_ICON_DATA, data);
    }
    mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
}
#method_after
@Override
public void onIconResponse(long bssid, String fileName, byte[] data) {
    Intent intent = new Intent(ACTION_PASSPOINT_ICON);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(EXTRA_BSSID_LONG, bssid);
    intent.putExtra(EXTRA_ICON_INFO, new IconInfo(fileName, data));
    mContext.sendBroadcastAsUser(intent, UserHandle.ALL, android.Manifest.permission.ACCESS_WIFI_STATE);
}
#end_block

#method_before
@Override
public void onWnmFrameReceived(WnmData event) {
    // %012x HS20-SUBSCRIPTION-REMEDIATION "%u %s", osu_method, url
    // %012x HS20-DEAUTH-IMMINENT-NOTICE "%u %u %s", code, reauth_delay, url
    Intent intent = new Intent(PASSPOINT_WNM_FRAME_RECEIVED_ACTION);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(EXTRA_PASSPOINT_WNM_BSSID, event.getBssid());
    intent.putExtra(EXTRA_PASSPOINT_WNM_URL, event.getUrl());
    if (event.isDeauthEvent()) {
        intent.putExtra(EXTRA_PASSPOINT_WNM_ESS, event.isEss());
        intent.putExtra(EXTRA_PASSPOINT_WNM_DELAY, event.getDelay());
    } else {
        intent.putExtra(EXTRA_PASSPOINT_WNM_METHOD, event.getMethod());
    // TODO(zqiu): set the passpoint matching status with the respect to the
    // current connected network (e.g. HomeProvider, RoamingProvider, None,
    // Declined).
    }
    mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
}
#method_after
@Override
public void onWnmFrameReceived(WnmData event) {
    // %012x HS20-SUBSCRIPTION-REMEDIATION "%u %s", osu_method, url
    // %012x HS20-DEAUTH-IMMINENT-NOTICE "%u %u %s", code, reauth_delay, url
    Intent intent;
    if (event.isDeauthEvent()) {
        intent = new Intent(ACTION_PASSPOINT_DEAUTH_IMMINENT);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        intent.putExtra(EXTRA_BSSID_LONG, event.getBssid());
        intent.putExtra(EXTRA_URL, event.getUrl());
        intent.putExtra(EXTRA_ESS, event.isEss());
        intent.putExtra(EXTRA_DELAY, event.getDelay());
    } else {
        intent = new Intent(ACTION_PASSPOINT_SUBSCRIPTION_REMEDIATION);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        intent.putExtra(EXTRA_BSSID_LONG, event.getBssid());
        intent.putExtra(EXTRA_SUBSCRIPTION_REMEDIATION_METHOD, event.getMethod());
        intent.putExtra(EXTRA_URL, event.getUrl());
    }
    mContext.sendBroadcastAsUser(intent, UserHandle.ALL, android.Manifest.permission.ACCESS_WIFI_STATE);
}
#end_block

#method_before
private void verifyIconIntent(long bssid, String fileName, byte[] data) {
    ArgumentCaptor<Intent> intent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext).sendBroadcastAsUser(intent.capture(), eq(UserHandle.ALL));
    assertEquals(PASSPOINT_ICON_RECEIVED_ACTION, intent.getValue().getAction());
    assertTrue(intent.getValue().getExtras().containsKey(EXTRA_PASSPOINT_ICON_BSSID));
    assertEquals(bssid, intent.getValue().getExtras().getLong(EXTRA_PASSPOINT_ICON_BSSID));
    assertTrue(intent.getValue().getExtras().containsKey(EXTRA_PASSPOINT_ICON_FILE));
    assertEquals(fileName, intent.getValue().getExtras().getString(EXTRA_PASSPOINT_ICON_FILE));
    if (data != null) {
        assertTrue(intent.getValue().getExtras().containsKey(EXTRA_PASSPOINT_ICON_DATA));
        assertEquals(data, intent.getValue().getExtras().getByteArray(EXTRA_PASSPOINT_ICON_DATA));
    }
}
#method_after
private void verifyIconIntent(long bssid, String fileName, byte[] data) {
    ArgumentCaptor<Intent> intent = ArgumentCaptor.forClass(Intent.class);
    verify(mContext).sendBroadcastAsUser(intent.capture(), eq(UserHandle.ALL), eq(android.Manifest.permission.ACCESS_WIFI_STATE));
    assertEquals(ACTION_PASSPOINT_ICON, intent.getValue().getAction());
    assertTrue(intent.getValue().getExtras().containsKey(EXTRA_BSSID_LONG));
    assertEquals(bssid, intent.getValue().getExtras().getLong(EXTRA_BSSID_LONG));
    assertTrue(intent.getValue().getExtras().containsKey(EXTRA_ICON_INFO));
    IconInfo expectedInfo = new IconInfo(fileName, data);
    assertEquals(new IconInfo(fileName, data), (IconInfo) intent.getValue().getExtras().getParcelable(EXTRA_ICON_INFO));
}
#end_block

#method_before
private WifiConfiguration createWifiConfigForProvider(PasspointProvider provider, ScanDetail scanDetail) {
    WifiConfiguration config = provider.getWifiConfig();
    config.SSID = ScanResultUtil.createQuotedSSID(scanDetail.getSSID());
    // Add the newly created WifiConfiguration to WifiConfigManager.
    NetworkUpdateResult result = mWifiConfigManager.addOrUpdateNetwork(config, Process.WIFI_UID);
    if (!result.isSuccess()) {
        localLog("Failed to add passpoint network");
        return null;
    }
    mWifiConfigManager.setNetworkCandidateScanResult(result.getNetworkId(), scanDetail.getScanResult(), 0);
    mWifiConfigManager.updateScanDetailForNetwork(result.getNetworkId(), scanDetail);
    return mWifiConfigManager.getConfiguredNetwork(result.getNetworkId());
}
#method_after
private WifiConfiguration createWifiConfigForProvider(PasspointProvider provider, ScanDetail scanDetail) {
    WifiConfiguration config = provider.getWifiConfig();
    config.SSID = ScanResultUtil.createQuotedSSID(scanDetail.getSSID());
    // Add the newly created WifiConfiguration to WifiConfigManager.
    NetworkUpdateResult result = mWifiConfigManager.addOrUpdateNetwork(config, Process.WIFI_UID);
    if (!result.isSuccess()) {
        localLog("Failed to add passpoint network");
        return null;
    }
    mWifiConfigManager.enableNetwork(result.getNetworkId(), false, Process.WIFI_UID);
    mWifiConfigManager.setNetworkCandidateScanResult(result.getNetworkId(), scanDetail.getScanResult(), 0);
    mWifiConfigManager.updateScanDetailForNetwork(result.getNetworkId(), scanDetail);
    return mWifiConfigManager.getConfiguredNetwork(result.getNetworkId());
}
#end_block

#method_before
@Test
public void evaluateScansWithNetworkMatchingHomeAndRoamingProvider() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> homeProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.HomeProvider);
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER2, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = new ArrayList<>();
    matchedProviders.add(homeProvider);
    matchedProviders.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return matchedProviders for the first ScanDetail (TEST_SSID1) and an empty list for
    // for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(matchedProviders).thenReturn(new ArrayList<Pair<PasspointProvider, PasspointMatch>>());
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
}
#method_after
@Test
public void evaluateScansWithNetworkMatchingHomeAndRoamingProvider() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> homeProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.HomeProvider);
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER2, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = new ArrayList<>();
    matchedProviders.add(homeProvider);
    matchedProviders.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return matchedProviders for the first ScanDetail (TEST_SSID1) and an empty list for
    // for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(matchedProviders).thenReturn(new ArrayList<Pair<PasspointProvider, PasspointMatch>>());
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
    verify(mWifiConfigManager).enableNetwork(eq(TEST_NETWORK_ID), eq(false), anyInt());
    verify(mWifiConfigManager).setNetworkCandidateScanResult(eq(TEST_NETWORK_ID), any(ScanResult.class), anyInt());
    verify(mWifiConfigManager).updateScanDetailForNetwork(eq(TEST_NETWORK_ID), any(ScanDetail.class));
}
#end_block

#method_before
@Test
public void evaluateScansWithNetworkMatchingRoamingProvider() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = new ArrayList<>();
    matchedProviders.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return matchedProviders for the first ScanDetail (TEST_SSID1) and an empty list for
    // for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(matchedProviders).thenReturn(new ArrayList<Pair<PasspointProvider, PasspointMatch>>());
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
}
#method_after
@Test
public void evaluateScansWithNetworkMatchingRoamingProvider() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = new ArrayList<>();
    matchedProviders.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return matchedProviders for the first ScanDetail (TEST_SSID1) and an empty list for
    // for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(matchedProviders).thenReturn(new ArrayList<Pair<PasspointProvider, PasspointMatch>>());
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
    verify(mWifiConfigManager).enableNetwork(eq(TEST_NETWORK_ID), eq(false), anyInt());
    verify(mWifiConfigManager).setNetworkCandidateScanResult(eq(TEST_NETWORK_ID), any(ScanResult.class), anyInt());
    verify(mWifiConfigManager).updateScanDetailForNetwork(eq(TEST_NETWORK_ID), any(ScanDetail.class));
}
#end_block

#method_before
@Test
public void evaluateScansWithHomeProviderNewtorkAndRoamingProviderNetwork() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> homeProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.HomeProvider);
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER2, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> providerForScanDetail1 = new ArrayList<>();
    providerForScanDetail1.add(homeProvider);
    List<Pair<PasspointProvider, PasspointMatch>> providerForScanDetail2 = new ArrayList<>();
    providerForScanDetail2.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return providerForScanDetail1 for the first ScanDetail (TEST_SSID1) and
    // providerForScanDetail2 for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(providerForScanDetail1).thenReturn(providerForScanDetail2);
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
}
#method_after
@Test
public void evaluateScansWithHomeProviderNewtorkAndRoamingProviderNetwork() throws Exception {
    List<ScanDetail> scanDetails = Arrays.asList(new ScanDetail[] { generateScanDetail(TEST_SSID1), generateScanDetail(TEST_SSID2) });
    // Setup matching providers for ScanDetail with TEST_SSID1.
    Pair<PasspointProvider, PasspointMatch> homeProvider = Pair.create(TEST_PROVIDER1, PasspointMatch.HomeProvider);
    Pair<PasspointProvider, PasspointMatch> roamingProvider = Pair.create(TEST_PROVIDER2, PasspointMatch.RoamingProvider);
    List<Pair<PasspointProvider, PasspointMatch>> providerForScanDetail1 = new ArrayList<>();
    providerForScanDetail1.add(homeProvider);
    List<Pair<PasspointProvider, PasspointMatch>> providerForScanDetail2 = new ArrayList<>();
    providerForScanDetail2.add(roamingProvider);
    List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks = new ArrayList<>();
    // Return providerForScanDetail1 for the first ScanDetail (TEST_SSID1) and
    // providerForScanDetail2 for the second (TEST_SSID2);
    when(mPasspointManager.matchProvider(any(ScanResult.class))).thenReturn(providerForScanDetail1).thenReturn(providerForScanDetail2);
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(TEST_NETWORK_ID));
    when(mWifiConfigManager.getConfiguredNetwork(TEST_NETWORK_ID)).thenReturn(TEST_CONFIG1);
    assertNotNull(mEvaluator.evaluateNetworks(scanDetails, null, null, false, false, connectableNetworks));
    assertEquals(1, connectableNetworks.size());
    // Verify the content of the WifiConfiguration that was added to WifiConfigManager.
    ArgumentCaptor<WifiConfiguration> addedConfig = ArgumentCaptor.forClass(WifiConfiguration.class);
    verify(mWifiConfigManager).addOrUpdateNetwork(addedConfig.capture(), anyInt());
    assertEquals(ScanResultUtil.createQuotedSSID(TEST_SSID1), addedConfig.getValue().SSID);
    assertEquals(TEST_FQDN1, addedConfig.getValue().FQDN);
    verify(mWifiConfigManager).enableNetwork(eq(TEST_NETWORK_ID), eq(false), anyInt());
    verify(mWifiConfigManager).setNetworkCandidateScanResult(eq(TEST_NETWORK_ID), any(ScanResult.class), anyInt());
    verify(mWifiConfigManager).updateScanDetailForNetwork(eq(TEST_NETWORK_ID), any(ScanDetail.class));
}
#end_block

#method_before
public void testConnectTimeouts() throws IOException {
    // RFC 5737
    URLConnection urlConnection = new URL("http://192.0.2.0:80/").openConnection();
    int timeout = 1000;
    urlConnection.setConnectTimeout(timeout);
    long start = System.currentTimeMillis();
    try {
        urlConnection.getInputStream();
        fail();
    } catch (SocketTimeoutException expected) {
        long elapsed = System.currentTimeMillis() - start;
        // one per IP address
        int attempts = InetAddress.getAllByName("localhost").length;
        assertTrue("timeout=" + timeout + ", elapsed=" + elapsed + ", attempts=" + attempts, Math.abs((attempts * timeout) - elapsed) < 500);
    }
}
#method_after
public void testConnectTimeouts() throws IOException {
    // This test is suppressed in M branches via libcore/expectations/brokentests.txt.
    // This test has been modified in M to remove a dependency on StuckServer testing
    // infrastructure. It is not expected to work in M.
    // The 192.0.2.0 address is an unreachable address from RFC 5737.
    URLConnection urlConnection = new URL("http://192.0.2.0:80/").openConnection();
    int timeout = 1000;
    urlConnection.setConnectTimeout(timeout);
    long start = System.currentTimeMillis();
    try {
        urlConnection.getInputStream();
        fail();
    } catch (SocketTimeoutException expected) {
        long elapsed = System.currentTimeMillis() - start;
        // one per IP address
        int attempts = InetAddress.getAllByName("localhost").length;
        assertTrue("timeout=" + timeout + ", elapsed=" + elapsed + ", attempts=" + attempts, Math.abs((attempts * timeout) - elapsed) < 500);
    }
}
#end_block

#method_before
@Override
public List<WifiConfiguration> getConfiguredNetworks() {
    enforceAccessPermission();
    mLog.trace("getConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        return mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#method_after
@Override
public ParceledListSlice<WifiConfiguration> getConfiguredNetworks() {
    enforceAccessPermission();
    mLog.trace("getConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
        if (configs != null) {
            return new ParceledListSlice<WifiConfiguration>(configs);
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
    }
    return null;
}
#end_block

#method_before
@Override
public List<WifiConfiguration> getPrivilegedConfiguredNetworks() {
    enforceReadCredentialPermission();
    enforceAccessPermission();
    mLog.trace("getPrivilegedConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        return mWifiStateMachine.syncGetPrivilegedConfiguredNetwork(mWifiStateMachineChannel);
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#method_after
@Override
public ParceledListSlice<WifiConfiguration> getPrivilegedConfiguredNetworks() {
    enforceReadCredentialPermission();
    enforceAccessPermission();
    mLog.trace("getPrivilegedConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetPrivilegedConfiguredNetwork(mWifiStateMachineChannel);
        if (configs != null) {
            return new ParceledListSlice<WifiConfiguration>(configs);
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
    }
    return null;
}
#end_block

#method_before
@Override
public void setCountryCode(String countryCode, boolean persist) {
    Slog.i(TAG, "WifiService trying to set country code to " + countryCode + " with persist set to " + persist);
    enforceConnectivityInternalPermission();
    mLog.trace("setCountryCode uid=%").c(Binder.getCallingUid()).flush();
    final long token = Binder.clearCallingIdentity();
    try {
        mCountryCode.setCountryCode(countryCode);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void setCountryCode(String countryCode, boolean persist) {
    Slog.i(TAG, "WifiService trying to set country code to " + countryCode + " with persist set to " + persist);
    enforceConnectivityInternalPermission();
    mLog.trace("setCountryCode uid=%").c(Binder.getCallingUid()).flush();
    final long token = Binder.clearCallingIdentity();
    mCountryCode.setCountryCode(countryCode);
    Binder.restoreCallingIdentity(token);
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    mLog.trace("factoryReset uid=%").c(Binder.getCallingUid()).flush();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        try {
            setWifiEnabled(mContext.getOpPackageName(), true);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
        // Delete all Wifi SSIDs
        List<WifiConfiguration> networks = getConfiguredNetworks();
        if (networks != null) {
            for (WifiConfiguration config : networks) {
                removeNetwork(config.networkId);
            }
            saveConfiguration();
        }
    }
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    mLog.trace("factoryReset uid=%").c(Binder.getCallingUid()).flush();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        try {
            setWifiEnabled(mContext.getOpPackageName(), true);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
        // Delete all Wifi SSIDs
        if (mWifiStateMachineChannel != null) {
            List<WifiConfiguration> networks = mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
            if (networks != null) {
                for (WifiConfiguration config : networks) {
                    removeNetwork(config.networkId);
                }
                saveConfiguration();
            }
        }
    }
}
#end_block

#method_before
@Deprecated
public Boolean wifiConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException {
    try {
        wifiConnectByConfig(config);
    } catch (GeneralSecurityException e) {
        String msg = "Caught GeneralSecurityException with the provided" + "configuration";
        throw new RuntimeException(msg);
    }
    return true;
}
#method_after
@Rpc(description = "Connects to the network with the given configuration")
@Deprecated
public Boolean wifiConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException {
    try {
        wifiConnectByConfig(config);
    } catch (GeneralSecurityException e) {
        String msg = "Caught GeneralSecurityException with the provided" + "configuration";
        throw new RuntimeException(msg);
    }
    return true;
}
#end_block

#method_before
@Deprecated
public Boolean wifiEnterpriseConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException, GeneralSecurityException {
    try {
        wifiConnectByConfig(config);
    } catch (GeneralSecurityException e) {
        throw e;
    }
    return true;
}
#method_after
@Rpc(description = "Connects to the network with the given configuration")
@Deprecated
public Boolean wifiEnterpriseConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException, GeneralSecurityException {
    try {
        wifiConnectByConfig(config);
    } catch (GeneralSecurityException e) {
        throw e;
    }
    return true;
}
#end_block

#method_before
@Override
public WifiConfiguration getWifiApConfiguration() {
    enforceAccessPermission();
    mLog.trace("getWifiApConfiguration uid=%").c(Binder.getCallingUid()).flush();
    return mWifiStateMachine.syncGetWifiApConfiguration();
}
#method_after
@Override
public WifiConfiguration getWifiApConfiguration() {
    enforceAccessPermission();
    int uid = Binder.getCallingUid();
    // only allow Settings UI to get the saved SoftApConfig
    if (!mWifiPermissionsUtil.checkConfigOverridePermission(uid)) {
        // random apps should not be allowed to read the user specified config
        throw new SecurityException("App not allowed to read or update stored WiFi Ap config " + "(uid = " + uid + ")");
    }
    mLog.trace("getWifiApConfiguration uid=%").c(uid).flush();
    return mWifiStateMachine.syncGetWifiApConfiguration();
}
#end_block

#method_before
@Override
public void setWifiApConfiguration(WifiConfiguration wifiConfig) {
    enforceChangePermission();
    mLog.trace("setWifiApConfiguration uid=%").c(Binder.getCallingUid()).flush();
    if (wifiConfig == null)
        return;
    if (isValid(wifiConfig)) {
        mWifiStateMachine.setWifiApConfiguration(wifiConfig);
    } else {
        Slog.e(TAG, "Invalid WifiConfiguration");
    }
}
#method_after
@Override
public void setWifiApConfiguration(WifiConfiguration wifiConfig) {
    enforceChangePermission();
    int uid = Binder.getCallingUid();
    // only allow Settings UI to write the stored SoftApConfig
    if (!mWifiPermissionsUtil.checkConfigOverridePermission(uid)) {
        // random apps should not be allowed to read the user specified config
        throw new SecurityException("App not allowed to read or update stored WiFi AP config " + "(uid = " + uid + ")");
    }
    mLog.trace("setWifiApConfiguration uid=%").c(uid).flush();
    if (wifiConfig == null)
        return;
    if (isValid(wifiConfig)) {
        mWifiStateMachine.setWifiApConfiguration(wifiConfig);
    } else {
        Slog.e(TAG, "Invalid WifiConfiguration");
    }
}
#end_block

#method_before
@Override
public ParceledListSlice<WifiConfiguration> getConfiguredNetworks() {
    enforceAccessPermission();
    mLog.trace("getConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
        return new ParceledListSlice<WifiConfiguration>(configs);
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#method_after
@Override
public ParceledListSlice<WifiConfiguration> getConfiguredNetworks() {
    enforceAccessPermission();
    mLog.trace("getConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
        if (configs != null) {
            return new ParceledListSlice<WifiConfiguration>(configs);
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
    }
    return null;
}
#end_block

#method_before
@Override
public ParceledListSlice<WifiConfiguration> getPrivilegedConfiguredNetworks() {
    enforceReadCredentialPermission();
    enforceAccessPermission();
    mLog.trace("getPrivilegedConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetPrivilegedConfiguredNetwork(mWifiStateMachineChannel);
        return new ParceledListSlice<WifiConfiguration>(configs);
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#method_after
@Override
public ParceledListSlice<WifiConfiguration> getPrivilegedConfiguredNetworks() {
    enforceReadCredentialPermission();
    enforceAccessPermission();
    mLog.trace("getPrivilegedConfiguredNetworks uid=%").c(Binder.getCallingUid()).flush();
    if (mWifiStateMachineChannel != null) {
        List<WifiConfiguration> configs = mWifiStateMachine.syncGetPrivilegedConfiguredNetwork(mWifiStateMachineChannel);
        if (configs != null) {
            return new ParceledListSlice<WifiConfiguration>(configs);
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
    }
    return null;
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    mLog.trace("factoryReset uid=%").c(Binder.getCallingUid()).flush();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        try {
            setWifiEnabled(mContext.getOpPackageName(), true);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
        // Delete all Wifi SSIDs
        ParceledListSlice<WifiConfiguration> parceledList = getConfiguredNetworks();
        if (parceledList != null) {
            List<WifiConfiguration> networks = parceledList.getList();
            if (networks != null) {
                for (WifiConfiguration config : networks) {
                    removeNetwork(config.networkId);
                }
                saveConfiguration();
            }
        }
    }
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    mLog.trace("factoryReset uid=%").c(Binder.getCallingUid()).flush();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        try {
            setWifiEnabled(mContext.getOpPackageName(), true);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
        // Delete all Wifi SSIDs
        if (mWifiStateMachineChannel != null) {
            List<WifiConfiguration> networks = mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(), mWifiStateMachineChannel);
            if (networks != null) {
                for (WifiConfiguration config : networks) {
                    removeNetwork(config.networkId);
                }
                saveConfiguration();
            }
        }
    }
}
#end_block

#method_before
@Override
public WifiScanner.ScanData[] getLatestBatchedScanResults(boolean flush) {
    return mWifiNative.getBgScanResults(flush);
}
#method_after
@Override
public WifiScanner.ScanData[] getLatestBatchedScanResults(boolean flush) {
    return mWifiNative.getBgScanResults();
}
#end_block

#method_before
public WifiScanner.ScanData[] getBgScanResults(boolean flush) {
    return mWifiVendorHal.getBgScanResults();
}
#method_after
public WifiScanner.ScanData[] getBgScanResults() {
    return mWifiVendorHal.getBgScanResults();
}
#end_block

#method_before
@Test
public void testLinkLayerStatsAssignment() throws Exception {
    Random r = new Random(1775968256);
    StaLinkLayerStats stats = new StaLinkLayerStats();
    randomizePacketStats(r, stats.iface.wmeBePktStats);
    randomizePacketStats(r, stats.iface.wmeBkPktStats);
    randomizePacketStats(r, stats.iface.wmeViPktStats);
    randomizePacketStats(r, stats.iface.wmeVoPktStats);
    randomizeRadioStats(r, stats.radio);
    // currently dropped in conversion
    stats.timeStampInMs = 42;
    String expected = numbersOnly(stats.toString());
    WifiLinkLayerStats converted = WifiVendorHal.frameworkFromHalLinkLayerStats(stats);
    String actual = numbersOnly(converted.toString());
    // Do the required fixups to the both expected and actual
    expected = rmValue(expected, stats.radio.rxTimeInMs);
    expected = rmValue(expected, stats.radio.onTimeInMsForScan);
    actual = rmValue(actual, stats.radio.rxTimeInMs);
    actual = rmValue(actual, stats.radio.onTimeInMsForScan);
    actual = actual + "42 ";
    // The remaining fields should agree
    assertEquals(expected, actual);
}
#method_after
@Test
public void testLinkLayerStatsAssignment() throws Exception {
    Random r = new Random(1775968256);
    StaLinkLayerStats stats = new StaLinkLayerStats();
    randomizePacketStats(r, stats.iface.wmeBePktStats);
    randomizePacketStats(r, stats.iface.wmeBkPktStats);
    randomizePacketStats(r, stats.iface.wmeViPktStats);
    randomizePacketStats(r, stats.iface.wmeVoPktStats);
    randomizeRadioStats(r, stats.radios);
    // currently dropped in conversion
    stats.timeStampInMs = 42;
    String expected = numbersOnly(stats.toString());
    WifiLinkLayerStats converted = WifiVendorHal.frameworkFromHalLinkLayerStats(stats);
    String actual = numbersOnly(converted.toString());
    // Do the required fixups to the both expected and actual
    expected = rmValue(expected, stats.radios.get(0).rxTimeInMs);
    expected = rmValue(expected, stats.radios.get(0).onTimeInMsForScan);
    actual = rmValue(actual, stats.radios.get(0).rxTimeInMs);
    actual = rmValue(actual, stats.radios.get(0).onTimeInMsForScan);
    actual = actual + "42 ";
    // The remaining fields should agree
    assertEquals(expected, actual);
}
#end_block

#method_before
private static void randomizeRadioStats(Random r, StaLinkLayerRadioStats rstats) {
    rstats.onTimeInMs = r.nextInt() & 0xFFFFFF;
    rstats.txTimeInMs = r.nextInt() & 0xFFFFFF;
    for (int i = 0; i < 4; i++) {
        Integer v = r.nextInt() & 0xFFFFFF;
        rstats.txTimeInMsPerLevel.add(v);
    }
    rstats.rxTimeInMs = r.nextInt() & 0xFFFFFF;
    rstats.onTimeInMsForScan = r.nextInt() & 0xFFFFFF;
}
#method_after
private static void randomizeRadioStats(Random r, ArrayList<StaLinkLayerRadioStats> rstats) {
    StaLinkLayerRadioStats rstat = new StaLinkLayerRadioStats();
    rstat.onTimeInMs = r.nextInt() & 0xFFFFFF;
    rstat.txTimeInMs = r.nextInt() & 0xFFFFFF;
    for (int i = 0; i < 4; i++) {
        Integer v = r.nextInt() & 0xFFFFFF;
        rstat.txTimeInMsPerLevel.add(v);
    }
    rstat.rxTimeInMs = r.nextInt() & 0xFFFFFF;
    rstat.onTimeInMsForScan = r.nextInt() & 0xFFFFFF;
    rstats.add(rstat);
}
#end_block

#method_before
@VisibleForTesting
static WifiLinkLayerStats frameworkFromHalLinkLayerStats(StaLinkLayerStats stats) {
    if (stats == null)
        return null;
    WifiLinkLayerStats out = new WifiLinkLayerStats();
    // unpopulated: out.status, out.SSID, out.BSSID
    out.beacon_rx = stats.iface.beaconRx;
    out.rssi_mgmt = stats.iface.avgRssiMgmt;
    // Statistics are broken out by Wireless Multimedia Extensions categories
    // WME Best Effort Access Category
    out.rxmpdu_be = stats.iface.wmeBePktStats.rxMpdu;
    out.txmpdu_be = stats.iface.wmeBePktStats.txMpdu;
    out.lostmpdu_be = stats.iface.wmeBePktStats.lostMpdu;
    out.retries_be = stats.iface.wmeBePktStats.retries;
    // WME Background Access Category
    out.rxmpdu_bk = stats.iface.wmeBkPktStats.rxMpdu;
    out.txmpdu_bk = stats.iface.wmeBkPktStats.txMpdu;
    out.lostmpdu_bk = stats.iface.wmeBkPktStats.lostMpdu;
    out.retries_bk = stats.iface.wmeBkPktStats.retries;
    // WME Video Access Category
    out.rxmpdu_vi = stats.iface.wmeViPktStats.rxMpdu;
    out.txmpdu_vi = stats.iface.wmeViPktStats.txMpdu;
    out.lostmpdu_vi = stats.iface.wmeViPktStats.lostMpdu;
    out.retries_vi = stats.iface.wmeViPktStats.retries;
    // WME Voice Access Category
    out.rxmpdu_vo = stats.iface.wmeVoPktStats.rxMpdu;
    out.txmpdu_vo = stats.iface.wmeVoPktStats.txMpdu;
    out.lostmpdu_vo = stats.iface.wmeVoPktStats.lostMpdu;
    out.retries_vo = stats.iface.wmeVoPktStats.retries;
    out.on_time = stats.radio.onTimeInMs;
    out.tx_time = stats.radio.txTimeInMs;
    out.tx_time_per_level = new int[stats.radio.txTimeInMsPerLevel.size()];
    for (int i = 0; i < out.tx_time_per_level.length; i++) {
        out.tx_time_per_level[i] = stats.radio.txTimeInMsPerLevel.get(i);
    }
    out.rx_time = stats.radio.rxTimeInMs;
    out.on_time_scan = stats.radio.onTimeInMsForScan;
    // unused: stats.timeStampInMs;
    return out;
}
#method_after
@VisibleForTesting
static WifiLinkLayerStats frameworkFromHalLinkLayerStats(StaLinkLayerStats stats) {
    if (stats == null)
        return null;
    WifiLinkLayerStats out = new WifiLinkLayerStats();
    // unpopulated: out.status, out.SSID, out.BSSID
    out.beacon_rx = stats.iface.beaconRx;
    out.rssi_mgmt = stats.iface.avgRssiMgmt;
    // Statistics are broken out by Wireless Multimedia Extensions categories
    // WME Best Effort Access Category
    out.rxmpdu_be = stats.iface.wmeBePktStats.rxMpdu;
    out.txmpdu_be = stats.iface.wmeBePktStats.txMpdu;
    out.lostmpdu_be = stats.iface.wmeBePktStats.lostMpdu;
    out.retries_be = stats.iface.wmeBePktStats.retries;
    // WME Background Access Category
    out.rxmpdu_bk = stats.iface.wmeBkPktStats.rxMpdu;
    out.txmpdu_bk = stats.iface.wmeBkPktStats.txMpdu;
    out.lostmpdu_bk = stats.iface.wmeBkPktStats.lostMpdu;
    out.retries_bk = stats.iface.wmeBkPktStats.retries;
    // WME Video Access Category
    out.rxmpdu_vi = stats.iface.wmeViPktStats.rxMpdu;
    out.txmpdu_vi = stats.iface.wmeViPktStats.txMpdu;
    out.lostmpdu_vi = stats.iface.wmeViPktStats.lostMpdu;
    out.retries_vi = stats.iface.wmeViPktStats.retries;
    // WME Voice Access Category
    out.rxmpdu_vo = stats.iface.wmeVoPktStats.rxMpdu;
    out.txmpdu_vo = stats.iface.wmeVoPktStats.txMpdu;
    out.lostmpdu_vo = stats.iface.wmeVoPktStats.lostMpdu;
    out.retries_vo = stats.iface.wmeVoPktStats.retries;
    // TODO(b/36176141): Figure out how to coalesce this info for multi radio devices.
    if (stats.radios.size() > 0) {
        StaLinkLayerRadioStats radioStats = stats.radios.get(0);
        out.on_time = radioStats.onTimeInMs;
        out.tx_time = radioStats.txTimeInMs;
        out.tx_time_per_level = new int[radioStats.txTimeInMsPerLevel.size()];
        for (int i = 0; i < out.tx_time_per_level.length; i++) {
            out.tx_time_per_level[i] = radioStats.txTimeInMsPerLevel.get(i);
        }
        out.rx_time = radioStats.rxTimeInMs;
        out.on_time_scan = radioStats.onTimeInMsForScan;
    }
    // unused: stats.timeStampInMs;
    return out;
}
#end_block

#method_before
@VisibleForTesting
static RttManager.RttResult frameworkRttResultFromHalRttResult(RttResult result) {
    RttManager.RttResult ans = new RttManager.RttResult();
    ans.bssid = NativeUtil.macAddressFromByteArray(result.addr);
    ans.burstNumber = result.burstNum;
    ans.measurementFrameNumber = result.measurementNumber;
    ans.successMeasurementFrameNumber = result.successNumber;
    ans.frameNumberPerBurstPeer = result.numberPerBurstPeer;
    // TODO(b/34901744) - don't assume identity translation
    ans.status = result.status;
    ans.retryAfterDuration = result.retryAfterDuration;
    ans.measurementType = result.type;
    ans.rssi = result.rssi;
    ans.rssiSpread = result.rssiSpread;
    // TODO(b/35138520) Fix HAL and framework to use the same units
    ans.txRate = result.txRate.bitRateInKbps;
    ans.rxRate = result.rxRate.bitRateInKbps;
    ans.rtt = result.rtt;
    ans.rttStandardDeviation = result.rttSd;
    ans.rttSpread = result.rttSpread;
    // TODO(b/35138520) These divide-by-10s were in the legacy Hal
    // Convert cm to mm
    ans.distance = result.distanceInMm / 10;
    // Convert cm to mm
    ans.distanceStandardDeviation = result.distanceSdInMm / 10;
    ans.distanceSpread = result.distanceSpreadInMm / 10;
    ans.ts = result.timeStampInUs;
    ans.burstDuration = result.burstDurationInMs;
    ans.negotiatedBurstNum = result.negotiatedBurstNum;
    ans.LCI = ieFromHal(result.lci);
    ans.LCR = ieFromHal(result.lcr);
    // Not present in HIDL HAL
    ans.secure = false;
    return ans;
}
#method_after
@VisibleForTesting
static RttManager.RttResult frameworkRttResultFromHalRttResult(RttResult result) {
    RttManager.RttResult ans = new RttManager.RttResult();
    ans.bssid = NativeUtil.macAddressFromByteArray(result.addr);
    ans.burstNumber = result.burstNum;
    ans.measurementFrameNumber = result.measurementNumber;
    ans.successMeasurementFrameNumber = result.successNumber;
    ans.frameNumberPerBurstPeer = result.numberPerBurstPeer;
    // TODO(b/35138520) - don't assume identity translation
    ans.status = result.status;
    ans.retryAfterDuration = result.retryAfterDuration;
    ans.measurementType = result.type;
    ans.rssi = result.rssi;
    ans.rssiSpread = result.rssiSpread;
    // TODO(b/35138520) Fix HAL and framework to use the same units
    ans.txRate = result.txRate.bitRateInKbps;
    ans.rxRate = result.rxRate.bitRateInKbps;
    ans.rtt = result.rtt;
    ans.rttStandardDeviation = result.rttSd;
    ans.rttSpread = result.rttSpread;
    // TODO(b/35138520) These divide-by-10s were in the legacy Hal
    // Convert cm to mm
    ans.distance = result.distanceInMm / 10;
    // Convert cm to mm
    ans.distanceStandardDeviation = result.distanceSdInMm / 10;
    ans.distanceSpread = result.distanceSpreadInMm / 10;
    ans.ts = result.timeStampInUs;
    ans.burstDuration = result.burstDurationInMs;
    ans.negotiatedBurstNum = result.negotiatedBurstNum;
    ans.LCI = ieFromHal(result.lci);
    ans.LCR = ieFromHal(result.lcr);
    // Not present in HIDL HAL
    ans.secure = false;
    return ans;
}
#end_block

#method_before
public boolean installPacketFilter(byte[] filter) {
    // TODO(b/34901818) We only aspire to support one program at a time
    int cmdId = 0;
    if (filter == null)
        return boolResult(false);
    // Copy the program before taking the lock.
    ArrayList<Byte> program = NativeUtil.byteArrayToArrayList(filter);
    enter("filter length %").c(filter.length).flush();
    synchronized (sLock) {
        try {
            if (mIWifiStaIface == null)
                return boolResult(false);
            WifiStatus status = mIWifiStaIface.installApfPacketFilter(cmdId, program);
            if (!ok(status))
                return false;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean installPacketFilter(byte[] filter) {
    // We only aspire to support one program at a time
    int cmdId = 0;
    if (filter == null)
        return boolResult(false);
    // Copy the program before taking the lock.
    ArrayList<Byte> program = NativeUtil.byteArrayToArrayList(filter);
    enter("filter length %").c(filter.length).flush();
    synchronized (sLock) {
        try {
            if (mIWifiStaIface == null)
                return boolResult(false);
            WifiStatus status = mIWifiStaIface.installApfPacketFilter(cmdId, program);
            if (!ok(status))
                return false;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
@Override
public void onDisconnected(byte[] bssid, boolean locallyGenerated, int reasonCode) {
    logCallback("onDisconnected");
    synchronized (mLock) {
        if (mVerboseLoggingEnabled) {
            Log.e(TAG, "onDisconnected 4way=" + mStateIsFourway + " locallyGenerated=" + locallyGenerated + " reasonCode=" + reasonCode);
        }
        if (mStateIsFourway && (locallyGenerated || reasonCode != WLAN_REASON_IE_IN_4WAY_DIFFERS)) {
            mWifiMonitor.broadcastAuthenticationFailureEvent(mIfaceName, WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        }
        mWifiMonitor.broadcastNetworkDisconnectionEvent(mIfaceName, locallyGenerated ? 1 : 0, reasonCode, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#method_after
@Override
public void onDisconnected(byte[] bssid, boolean locallyGenerated, int reasonCode) {
    logCallback("onDisconnected");
    synchronized (mLock) {
        if (mVerboseLoggingEnabled) {
            Log.e(TAG, "onDisconnected 4way=" + mStateIsFourway + " locallyGenerated=" + locallyGenerated + " reasonCode=" + reasonCode);
        }
        if (mStateIsFourway && (!locallyGenerated || reasonCode != WLAN_REASON_IE_IN_4WAY_DIFFERS)) {
            mWifiMonitor.broadcastAuthenticationFailureEvent(mIfaceName, WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        }
        mWifiMonitor.broadcastNetworkDisconnectionEvent(mIfaceName, locallyGenerated ? 1 : 0, reasonCode, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#end_block

#method_before
@Override
public void onAssociationRejected(byte[] bssid, int statusCode, boolean timedOut) {
    logCallback("onAssociationRejected");
    synchronized (mLock) {
        // TODO(b/35464954): Need to figure out when to trigger
        // |WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD|
        mWifiMonitor.broadcastAssociationRejectionEvent(mIfaceName, statusCode, timedOut, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#method_after
@Override
public void onAssociationRejected(byte[] bssid, int statusCode, boolean timedOut) {
    logCallback("onAssociationRejected");
    synchronized (mLock) {
        mWifiMonitor.broadcastAssociationRejectionEvent(mIfaceName, statusCode, timedOut, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#end_block

#method_before
private void updateSavedNetworkSelectionStatus() {
    List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks();
    if (savedNetworks.size() == 0) {
        localLog("No saved networks.");
        return;
    }
    StringBuffer sbuf = new StringBuffer("Saved Networks List: \n");
    for (WifiConfiguration network : savedNetworks) {
        /**
         * Ignore Passpoint networks.  Passpoint networks are also considered as "saved"
         * network, but without being persisted to the storage.  They are managed
         * by {@link PasspointNetworkEvaluator}.
         */
        if (network.isPasspoint()) {
            continue;
        }
        WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
        // If a configuration is temporarily disabled, re-enable it before trying
        // to connect to it.
        mWifiConfigManager.tryEnableNetwork(network.networkId);
        // TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED
        // state.
        // Clear the cached candidate, score and seen.
        mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId);
        sbuf.append(" ").append(WifiNetworkSelector.toNetworkString(network)).append(" ").append(" User Preferred BSSID: ").append(network.BSSID).append(" FQDN: ").append(network.FQDN).append(" ").append(status.getNetworkStatusString()).append(" Disable account: ");
        for (int index = WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE; index < WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_DISABLED_MAX; index++) {
            sbuf.append(status.getDisableReasonCounter(index)).append(" ");
        }
        sbuf.append("Connect Choice: ").append(status.getConnectChoice()).append(" set time: ").append(status.getConnectChoiceTimestamp()).append("\n");
    }
    localLog(sbuf.toString());
}
#method_after
private void updateSavedNetworkSelectionStatus() {
    List<WifiConfiguration> savedNetworks = mWifiConfigManager.getSavedNetworks();
    if (savedNetworks.size() == 0) {
        localLog("No saved networks.");
        return;
    }
    StringBuffer sbuf = new StringBuffer("Saved Networks List: \n");
    for (WifiConfiguration network : savedNetworks) {
        /**
         * Ignore Passpoint networks. Passpoint networks are also considered as "saved"
         * network, but without being persisted to the storage. They are managed
         * by {@link PasspointNetworkEvaluator}.
         */
        if (network.isPasspoint()) {
            continue;
        }
        WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
        // If a configuration is temporarily disabled, re-enable it before trying
        // to connect to it.
        mWifiConfigManager.tryEnableNetwork(network.networkId);
        // TODO(b/30928589): Enable "permanently" disabled networks if we are in DISCONNECTED
        // state.
        // Clear the cached candidate, score and seen.
        mWifiConfigManager.clearNetworkCandidateScanResult(network.networkId);
        sbuf.append(" ").append(WifiNetworkSelector.toNetworkString(network)).append(" ").append(" User Preferred BSSID: ").append(network.BSSID).append(" FQDN: ").append(network.FQDN).append(" ").append(status.getNetworkStatusString()).append(" Disable account: ");
        for (int index = WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE; index < WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_DISABLED_MAX; index++) {
            sbuf.append(status.getDisableReasonCounter(index)).append(" ");
        }
        sbuf.append("Connect Choice: ").append(status.getConnectChoice()).append(" set time: ").append(status.getConnectChoiceTimestamp()).append("\n");
    }
    localLog(sbuf.toString());
}
#end_block

#method_before
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    int highestScore = Integer.MIN_VALUE;
    ScanResult scanResultCandidate = null;
    WifiConfiguration candidate = null;
    StringBuffer scoreHistory = new StringBuffer();
    for (ScanDetail scanDetail : scanDetails) {
        ScanResult scanResult = scanDetail.getScanResult();
        int highestScoreOfScanResult = Integer.MIN_VALUE;
        int candidateIdOfScanResult = WifiConfiguration.INVALID_NETWORK_ID;
        // One ScanResult can be associated with more than one networks, hence we calculate all
        // the scores and use the highest one as the ScanResult's score.
        List<WifiConfiguration> associatedConfigurations = null;
        WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        if (associatedConfiguration == null) {
            continue;
        } else {
            associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration));
        }
        for (WifiConfiguration network : associatedConfigurations) {
            /**
             * Ignore Passpoint networks.  Passpoint networks are also considered as "saved"
             * network, but without being persisted to the storage.  They are being evaluated
             * by {@link PasspointNetworkEvaluator}.
             */
            if (network.isPasspoint()) {
                continue;
            }
            WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
            status.setSeenInLastQualifiedNetworkSelection(true);
            if (!status.isNetworkEnabled()) {
                continue;
            } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) {
                // App has specified the only BSSID to connect for this
                // configuration. So only the matching ScanResult can be a candidate.
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has specified BSSID " + network.BSSID + ". Skip " + scanResult.BSSID);
                continue;
            }
            int score = calculateBssidScore(scanResult, network, currentNetwork, currentBssid, scoreHistory);
            // user connect choice networks to RecommendedNetworkEvaluator.
            if (score > status.getCandidateScore() || (score == status.getCandidateScore() && status.getCandidate() != null && scanResult.level > status.getCandidate().level)) {
                mWifiConfigManager.setNetworkCandidateScanResult(network.networkId, scanResult, score);
            }
            // curate saved open networks enabled, do not consider it for network selection.
            if (network.useExternalScores) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has external score.");
                continue;
            }
            if (mCurateSavedOpenNetworks && WifiConfigurationUtil.isConfigForOpenNetwork(network)) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " is open and CURATE_SAVED_OPEN_NETWORKS is enabled.");
                continue;
            }
            if (score > highestScoreOfScanResult) {
                highestScoreOfScanResult = score;
                candidateIdOfScanResult = network.networkId;
            }
        }
        if (connectableNetworks != null) {
            connectableNetworks.add(Pair.create(scanDetail, mWifiConfigManager.getConfiguredNetwork(candidateIdOfScanResult)));
        }
        if (highestScoreOfScanResult > highestScore || (highestScoreOfScanResult == highestScore && scanResultCandidate != null && scanResult.level > scanResultCandidate.level)) {
            highestScore = highestScoreOfScanResult;
            scanResultCandidate = scanResult;
            mWifiConfigManager.setNetworkCandidateScanResult(candidateIdOfScanResult, scanResultCandidate, highestScore);
            // Reload the network config with the updated info.
            candidate = mWifiConfigManager.getConfiguredNetwork(candidateIdOfScanResult);
        }
    }
    if (scoreHistory.length() > 0) {
        localLog("\n" + scoreHistory.toString());
    }
    if (scanResultCandidate == null) {
        localLog("did not see any good candidates.");
    }
    return candidate;
}
#method_after
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    int highestScore = Integer.MIN_VALUE;
    ScanResult scanResultCandidate = null;
    WifiConfiguration candidate = null;
    StringBuffer scoreHistory = new StringBuffer();
    for (ScanDetail scanDetail : scanDetails) {
        ScanResult scanResult = scanDetail.getScanResult();
        int highestScoreOfScanResult = Integer.MIN_VALUE;
        int candidateIdOfScanResult = WifiConfiguration.INVALID_NETWORK_ID;
        // One ScanResult can be associated with more than one networks, hence we calculate all
        // the scores and use the highest one as the ScanResult's score.
        List<WifiConfiguration> associatedConfigurations = null;
        WifiConfiguration associatedConfiguration = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        if (associatedConfiguration == null) {
            continue;
        } else {
            associatedConfigurations = new ArrayList<>(Arrays.asList(associatedConfiguration));
        }
        for (WifiConfiguration network : associatedConfigurations) {
            /**
             * Ignore Passpoint networks. Passpoint networks are also considered as "saved"
             * network, but without being persisted to the storage. They are being evaluated
             * by {@link PasspointNetworkEvaluator}.
             */
            if (network.isPasspoint()) {
                continue;
            }
            WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
            status.setSeenInLastQualifiedNetworkSelection(true);
            if (!status.isNetworkEnabled()) {
                continue;
            } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) {
                // App has specified the only BSSID to connect for this
                // configuration. So only the matching ScanResult can be a candidate.
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has specified BSSID " + network.BSSID + ". Skip " + scanResult.BSSID);
                continue;
            }
            int score = calculateBssidScore(scanResult, network, currentNetwork, currentBssid, scoreHistory);
            // user connect choice networks to RecommendedNetworkEvaluator.
            if (score > status.getCandidateScore() || (score == status.getCandidateScore() && status.getCandidate() != null && scanResult.level > status.getCandidate().level)) {
                mWifiConfigManager.setNetworkCandidateScanResult(network.networkId, scanResult, score);
            }
            // curate saved open networks enabled, do not consider it for network selection.
            if (network.useExternalScores) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has external score.");
                continue;
            }
            if (mCurateSavedOpenNetworks && WifiConfigurationUtil.isConfigForOpenNetwork(network)) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " is open and CURATE_SAVED_OPEN_NETWORKS is enabled.");
                continue;
            }
            if (score > highestScoreOfScanResult) {
                highestScoreOfScanResult = score;
                candidateIdOfScanResult = network.networkId;
            }
        }
        if (connectableNetworks != null) {
            connectableNetworks.add(Pair.create(scanDetail, mWifiConfigManager.getConfiguredNetwork(candidateIdOfScanResult)));
        }
        if (highestScoreOfScanResult > highestScore || (highestScoreOfScanResult == highestScore && scanResultCandidate != null && scanResult.level > scanResultCandidate.level)) {
            highestScore = highestScoreOfScanResult;
            scanResultCandidate = scanResult;
            mWifiConfigManager.setNetworkCandidateScanResult(candidateIdOfScanResult, scanResultCandidate, highestScore);
            // Reload the network config with the updated info.
            candidate = mWifiConfigManager.getConfiguredNetwork(candidateIdOfScanResult);
        }
    }
    if (scoreHistory.length() > 0) {
        localLog("\n" + scoreHistory.toString());
    }
    if (scanResultCandidate == null) {
        localLog("did not see any good candidates.");
    }
    return candidate;
}
#end_block

#method_before
private FrameworkFacade getFrameworkFacade() throws Exception {
    FrameworkFacade facade = mock(FrameworkFacade.class);
    when(facade.getService(Context.NETWORKMANAGEMENT_SERVICE)).thenReturn(mockWithInterfaces(IBinder.class, INetworkManagementService.class));
    IBinder p2pBinder = mockService(WifiP2pServiceImpl.class, IWifiP2pManager.class);
    when(facade.getService(Context.WIFI_P2P_SERVICE)).thenReturn(p2pBinder);
    WifiP2pServiceImpl p2pm = (WifiP2pServiceImpl) p2pBinder.queryLocalInterface(IWifiP2pManager.class.getCanonicalName());
    final CountDownLatch untilDone = new CountDownLatch(1);
    mP2pThread = new HandlerThread("WifiP2pMockThread") {

        @Override
        protected void onLooperPrepared() {
            untilDone.countDown();
        }
    };
    mP2pThread.start();
    untilDone.await();
    Handler handler = new Handler(mP2pThread.getLooper());
    when(p2pm.getP2pStateMachineMessenger()).thenReturn(new Messenger(handler));
    IBinder batteryStatsBinder = mockService(BatteryStats.class, IBatteryStats.class);
    when(facade.getService(BatteryStats.SERVICE_NAME)).thenReturn(batteryStatsBinder);
    when(facade.makeIpManager(any(Context.class), anyString(), any(IpManager.Callback.class))).then(new AnswerWithArguments() {

        public IpManager answer(Context context, String ifname, IpManager.Callback callback) {
            mTestIpManager = new TestIpManager(context, ifname, callback);
            return mTestIpManager;
        }
    });
    when(facade.checkUidPermission(eq(android.Manifest.permission.OVERRIDE_WIFI_CONFIG), anyInt())).thenReturn(PackageManager.PERMISSION_GRANTED);
    return facade;
}
#method_after
private FrameworkFacade getFrameworkFacade() throws Exception {
    FrameworkFacade facade = mock(FrameworkFacade.class);
    when(facade.getService(Context.NETWORKMANAGEMENT_SERVICE)).thenReturn(mockWithInterfaces(IBinder.class, INetworkManagementService.class));
    IBinder p2pBinder = mockService(WifiP2pServiceImpl.class, IWifiP2pManager.class);
    when(facade.getService(Context.WIFI_P2P_SERVICE)).thenReturn(p2pBinder);
    WifiP2pServiceImpl p2pm = (WifiP2pServiceImpl) p2pBinder.queryLocalInterface(IWifiP2pManager.class.getCanonicalName());
    final CountDownLatch untilDone = new CountDownLatch(1);
    mP2pThread = new HandlerThread("WifiP2pMockThread") {

        @Override
        protected void onLooperPrepared() {
            untilDone.countDown();
        }
    };
    mP2pThread.start();
    untilDone.await();
    Handler handler = new Handler(mP2pThread.getLooper());
    when(p2pm.getP2pStateMachineMessenger()).thenReturn(new Messenger(handler));
    IBinder batteryStatsBinder = mockService(BatteryStats.class, IBatteryStats.class);
    when(facade.getService(BatteryStats.SERVICE_NAME)).thenReturn(batteryStatsBinder);
    when(facade.makeIpManager(any(Context.class), anyString(), any(IpManager.Callback.class))).then(new AnswerWithArguments() {

        public IpManager answer(Context context, String ifname, IpManager.Callback callback) {
            mTestIpManager = new TestIpManager(context, ifname, callback);
            return mTestIpManager;
        }
    });
    return facade;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(new Clock());
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiInjector.getPasspointManager()).thenReturn(mPasspointManager);
    when(mWifiNative.setupForClientMode()).thenReturn(mClientInterface);
    when(mWifiNative.setupForSoftApMode()).thenReturn(mApInterface);
    when(mWifiInjector.getWifiStateTracker()).thenReturn(mWifiStateTracker);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiNative.enableSupplicant()).thenReturn(true);
    when(mWifiNative.disableSupplicant()).thenReturn(true);
    when(mWifiNative.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#method_after
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(new Clock());
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiInjector.getPasspointManager()).thenReturn(mPasspointManager);
    when(mWifiInjector.getWifiStateTracker()).thenReturn(mWifiStateTracker);
    when(mWifiInjector.getWifiMonitor()).thenReturn(mWifiMonitor);
    when(mWifiInjector.getWifiNative()).thenReturn(mWifiNative);
    when(mWifiNative.setupForClientMode()).thenReturn(mClientInterface);
    when(mWifiNative.setupForSoftApMode()).thenReturn(mApInterface);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiNative.enableSupplicant()).thenReturn(true);
    when(mWifiNative.disableSupplicant()).thenReturn(true);
    when(mWifiNative.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#end_block

#method_before
@Test
public void connect() throws Exception {
    addNetworkAndVerifySuccess();
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    mLooper.startAutoDispatch();
    mWsm.syncEnableNetwork(mWsmAsyncChannel, 0, true);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).enableNetwork(eq(0), eq(true), anyInt());
    mWsm.sendMessage(WifiMonitor.NETWORK_CONNECTION_EVENT, 0, 0, sBSSID);
    mLooper.dispatchAll();
    mWsm.sendMessage(WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, 0, 0, new StateChangeResult(0, sWifiSsid, sBSSID, SupplicantState.COMPLETED));
    mLooper.dispatchAll();
    assertEquals("ObtainingIpState", getCurrentState().getName());
    DhcpResults dhcpResults = new DhcpResults();
    dhcpResults.setGateway("1.2.3.4");
    dhcpResults.setIpAddress("192.168.1.100", 0);
    dhcpResults.addDns("8.8.8.8");
    dhcpResults.setLeaseDuration(3600);
    mTestIpManager.injectDhcpSuccess(dhcpResults);
    mLooper.dispatchAll();
    assertEquals("ConnectedState", getCurrentState().getName());
}
#method_after
@Test
public void connect() throws Exception {
    addNetworkAndVerifySuccess();
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    mLooper.startAutoDispatch();
    assertTrue(mWsm.syncEnableNetwork(mWsmAsyncChannel, 0, true));
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).enableNetwork(eq(0), eq(true), anyInt());
    mWsm.sendMessage(WifiMonitor.NETWORK_CONNECTION_EVENT, 0, 0, sBSSID);
    mLooper.dispatchAll();
    mWsm.sendMessage(WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, 0, 0, new StateChangeResult(0, sWifiSsid, sBSSID, SupplicantState.COMPLETED));
    mLooper.dispatchAll();
    assertEquals("ObtainingIpState", getCurrentState().getName());
    DhcpResults dhcpResults = new DhcpResults();
    dhcpResults.setGateway("1.2.3.4");
    dhcpResults.setIpAddress("192.168.1.100", 0);
    dhcpResults.addDns("8.8.8.8");
    dhcpResults.setLeaseDuration(3600);
    mTestIpManager.injectDhcpSuccess(dhcpResults);
    mLooper.dispatchAll();
    assertEquals("ConnectedState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void connectWithNoEnablePermission() throws Exception {
    addNetworkAndVerifySuccess();
    when(mWifiConfigManager.enableNetwork(eq(0), eq(true), anyInt())).thenReturn(false);
    when(mWifiConfigManager.checkAndUpdateLastConnectUid(eq(0), anyInt())).thenReturn(false);
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    mLooper.startAutoDispatch();
    mWsm.syncEnableNetwork(mWsmAsyncChannel, 0, true);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).enableNetwork(eq(0), eq(true), anyInt());
    mWsm.sendMessage(WifiMonitor.NETWORK_CONNECTION_EVENT, 0, 0, sBSSID);
    mLooper.dispatchAll();
    mWsm.sendMessage(WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, 0, 0, new StateChangeResult(0, sWifiSsid, sBSSID, SupplicantState.COMPLETED));
    mLooper.dispatchAll();
    assertEquals("ObtainingIpState", getCurrentState().getName());
    DhcpResults dhcpResults = new DhcpResults();
    dhcpResults.setGateway("1.2.3.4");
    dhcpResults.setIpAddress("192.168.1.100", 0);
    dhcpResults.addDns("8.8.8.8");
    dhcpResults.setLeaseDuration(3600);
    mTestIpManager.injectDhcpSuccess(dhcpResults);
    mLooper.dispatchAll();
    assertEquals("ConnectedState", getCurrentState().getName());
}
#method_after
@Test
public void connectWithNoEnablePermission() throws Exception {
    addNetworkAndVerifySuccess();
    when(mWifiConfigManager.enableNetwork(eq(0), eq(true), anyInt())).thenReturn(false);
    when(mWifiConfigManager.checkAndUpdateLastConnectUid(eq(0), anyInt())).thenReturn(false);
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    mLooper.startAutoDispatch();
    assertTrue(mWsm.syncEnableNetwork(mWsmAsyncChannel, 0, true));
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).enableNetwork(eq(0), eq(true), anyInt());
    mWsm.sendMessage(WifiMonitor.NETWORK_CONNECTION_EVENT, 0, 0, sBSSID);
    mLooper.dispatchAll();
    mWsm.sendMessage(WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT, 0, 0, new StateChangeResult(0, sWifiSsid, sBSSID, SupplicantState.COMPLETED));
    mLooper.dispatchAll();
    assertEquals("ObtainingIpState", getCurrentState().getName());
    DhcpResults dhcpResults = new DhcpResults();
    dhcpResults.setGateway("1.2.3.4");
    dhcpResults.setIpAddress("192.168.1.100", 0);
    dhcpResults.addDns("8.8.8.8");
    dhcpResults.setLeaseDuration(3600);
    mTestIpManager.injectDhcpSuccess(dhcpResults);
    mLooper.dispatchAll();
    assertEquals("ConnectedState", getCurrentState().getName());
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid) || !mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        logi("connectToUserSelectNetwork Allowing uid " + uid + " with insufficient permissions to connect=" + netId);
    }
    // Trigger an immediate connection to the specified network. We're also noting the user
    // connect choice here, so that it will be considered in the next network selection.
    mWifiConnectivityManager.setUserConnectChoice(netId);
    if (mWifiInfo.getNetworkId() == netId) {
        // We're already connected to the user specified network, don't trigger a
        // reconnection.
        logi("connectToUserSelectNetwork already connecting/connected=" + netId);
    } else {
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (mWifiConfigManager.getConfiguredNetwork(netId) == null) {
        loge("connectToUserSelectNetwork Invalid network Id=" + netId);
        return false;
    }
    if (!mWifiConfigManager.enableNetwork(netId, true, uid) || !mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        logi("connectToUserSelectNetwork Allowing uid " + uid + " with insufficient permissions to connect=" + netId);
    }
    // Trigger an immediate connection to the specified network. We're also noting the user
    // connect choice here, so that it will be considered in the next network selection.
    mWifiConnectivityManager.setUserConnectChoice(netId);
    if (mWifiInfo.getNetworkId() == netId) {
        // We're already connected to the user specified network, don't trigger a
        // reconnection.
        logi("connectToUserSelectNetwork already connecting/connected=" + netId);
    } else {
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
private void sendConnectedState() {
    // If this network was explicitly selected by the user, evaluate whether to call
    // explicitlySelected() so the system can treat it appropriately.
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (mWifiConfigManager.getLastSelectedNetwork() == config.networkId) {
        boolean prompt = mWifiConfigManager.checkConfigOverridePermission(config.lastConnectUid);
        if (mVerboseLoggingEnabled) {
            log("Network selected by UID " + config.lastConnectUid + " prompt=" + prompt);
        }
        if (prompt) {
            // really want to switch, or has already confirmed and selected "Don't ask again".
            if (mVerboseLoggingEnabled) {
                log("explictlySelected acceptUnvalidated=" + config.noInternetAccessExpected);
            }
            mNetworkAgent.explicitlySelected(config.noInternetAccessExpected);
        }
    }
    setNetworkDetailedState(DetailedState.CONNECTED);
    mWifiConfigManager.updateNetworkAfterConnect(mLastNetworkId);
    sendNetworkStateChangeBroadcast(mLastBssid);
}
#method_after
private void sendConnectedState() {
    // If this network was explicitly selected by the user, evaluate whether to call
    // explicitlySelected() so the system can treat it appropriately.
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (mWifiConfigManager.getLastSelectedNetwork() == config.networkId) {
        boolean prompt = mWifiPermissionsUtil.checkConfigOverridePermission(config.lastConnectUid);
        if (mVerboseLoggingEnabled) {
            log("Network selected by UID " + config.lastConnectUid + " prompt=" + prompt);
        }
        if (prompt) {
            // really want to switch, or has already confirmed and selected "Don't ask again".
            if (mVerboseLoggingEnabled) {
                log("explictlySelected acceptUnvalidated=" + config.noInternetAccessExpected);
            }
            mNetworkAgent.explicitlySelected(config.noInternetAccessExpected);
        }
    }
    setNetworkDetailedState(DetailedState.CONNECTED);
    mWifiConfigManager.updateNetworkAfterConnect(mLastNetworkId);
    sendNetworkStateChangeBroadcast(mLastBssid);
}
#end_block

#method_before
void handleGsmAuthRequest(SimAuthRequestData requestData) {
    if (targetWificonfiguration == null || targetWificonfiguration.networkId == lookupFrameworkNetworkId(requestData.networkId)) {
        logd("id matches targetWifiConfiguration");
    } else {
        logd("id does not match targetWifiConfiguration");
        return;
    }
    String response = TelephonyUtil.getGsmSimAuthResponse(requestData.data, getTelephonyManager());
    if (response == null) {
        mWifiNative.simAuthFailedResponse(requestData.networkId);
    } else {
        logv("Supplicant Response -" + response);
        mWifiNative.simAuthResponse(requestData.networkId, "GSM-AUTH", response);
    }
}
#method_after
void handleGsmAuthRequest(SimAuthRequestData requestData) {
    if (targetWificonfiguration == null || targetWificonfiguration.networkId == lookupFrameworkNetworkId(requestData.networkId)) {
        logd("id matches targetWifiConfiguration");
    } else {
        logd("id does not match targetWifiConfiguration");
        return;
    }
    String response = TelephonyUtil.getGsmSimAuthResponse(requestData.data, getTelephonyManager());
    if (response == null) {
        mWifiNative.simAuthFailedResponse(requestData.networkId);
    } else {
        logv("Supplicant Response -" + response);
        mWifiNative.simAuthResponse(requestData.networkId, WifiNative.SIM_AUTH_RESP_TYPE_GSM_AUTH, response);
    }
}
#end_block

#method_before
private void processCellLocationInfo(CellLocation cellLocation, VoiceRegStateResult voiceRegStateResult) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.GSM:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityGsm.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityGsm cellIdentityGsm = voiceRegStateResult.cellIdentity.cellIdentityGsm.get(0);
                        cid = cellIdentityGsm.cid;
                        lac = cellIdentityGsm.lac;
                    }
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityWcdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityWcdma cellIdentityWcdma = voiceRegStateResult.cellIdentity.cellIdentityWcdma.get(0);
                        cid = cellIdentityWcdma.cid;
                        lac = cellIdentityWcdma.lac;
                        psc = cellIdentityWcdma.psc;
                    }
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityTdscdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityTdscdma cellIdentityTdscdma = voiceRegStateResult.cellIdentity.cellIdentityTdscdma.get(0);
                        cid = cellIdentityTdscdma.cid;
                        lac = cellIdentityTdscdma.lac;
                    }
                    break;
                }
            case CellInfoType.LTE:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = voiceRegStateResult.cellIdentity.cellIdentityLte.get(0);
                        cid = cellIdentityLte.ci;
                        lac = cellIdentityLte.tac;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.CDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        baseStationId = cellIdentityCdma.baseStationId;
                        baseStationLatitude = cellIdentityCdma.latitude;
                        baseStationLongitude = cellIdentityCdma.longitude;
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#method_after
private void processCellLocationInfo(CellLocation cellLocation, VoiceRegStateResult voiceRegStateResult) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.GSM:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityGsm.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityGsm cellIdentityGsm = voiceRegStateResult.cellIdentity.cellIdentityGsm.get(0);
                        cid = cellIdentityGsm.cid;
                        lac = cellIdentityGsm.lac;
                    }
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityWcdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityWcdma cellIdentityWcdma = voiceRegStateResult.cellIdentity.cellIdentityWcdma.get(0);
                        cid = cellIdentityWcdma.cid;
                        lac = cellIdentityWcdma.lac;
                        psc = cellIdentityWcdma.psc;
                    }
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityTdscdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityTdscdma cellIdentityTdscdma = voiceRegStateResult.cellIdentity.cellIdentityTdscdma.get(0);
                        cid = cellIdentityTdscdma.cid;
                        lac = cellIdentityTdscdma.lac;
                    }
                    break;
                }
            case CellInfoType.LTE:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = voiceRegStateResult.cellIdentity.cellIdentityLte.get(0);
                        cid = cellIdentityLte.ci;
                        /* Continuing the historical behaviour of using tac as lac. */
                        lac = cellIdentityLte.tac;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.CDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        baseStationId = cellIdentityCdma.baseStationId;
                        baseStationLatitude = cellIdentityCdma.latitude;
                        baseStationLongitude = cellIdentityCdma.longitude;
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = convertRILRegStateToServiceState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = convertRILRegStateToServiceState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
private int regCodeToServiceState(int code) {
    switch(code) {
        case 0:
        // 2 is "searching"
        case 2:
        // 3 is "registration denied"
        case 3:
        // 4 is "unknown" no vaild in current baseband
        case 4:
        // same as 0, but indicates that emergency call is possible.
        case 10:
        // same as 2, but indicates that emergency call is possible.
        case 12:
        // same as 3, but indicates that emergency call is possible.
        case 13:
        case // same as 4, but indicates that emergency call is possible.
        14:
            return ServiceState.STATE_OUT_OF_SERVICE;
        case 1:
        case // 5 is "registered, roaming"
        5:
            return ServiceState.STATE_IN_SERVICE;
        default:
            loge("regCodeToServiceState: unexpected service state " + code);
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#method_after
private int regCodeToServiceState(int code) {
    switch(code) {
        case ServiceState.RIL_REG_STATE_HOME:
        case ServiceState.RIL_REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#end_block

#method_before
private void onSetComplete(Message msg, AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof CommandException) {
            CommandException.Error err = ((CommandException) (ar.exception)).getCommandError();
            if (err == CommandException.Error.PASSWORD_INCORRECT) {
                if (isPinPukCommand()) {
                    // the message accordingly.
                    if (mSc.equals(SC_PUK) || mSc.equals(SC_PUK2)) {
                        sb.append(mContext.getText(com.android.internal.R.string.badPuk));
                    } else {
                        sb.append(mContext.getText(com.android.internal.R.string.badPin));
                    }
                    // Get the No. of retries remaining to unlock PUK/PUK2
                    int attemptsRemaining = msg.arg1;
                    if (attemptsRemaining <= 0) {
                        Rlog.d(LOG_TAG, "onSetComplete: PUK locked," + " cancel as lock screen will handle this");
                        mState = State.CANCELLED;
                    } else if (attemptsRemaining > 0) {
                        Rlog.d(LOG_TAG, "onSetComplete: attemptsRemaining=" + attemptsRemaining);
                        sb.append(mContext.getResources().getQuantityString(com.android.internal.R.plurals.pinpuk_attempts, attemptsRemaining, attemptsRemaining));
                    }
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.passwordIncorrect));
                }
            } else if (err == CommandException.Error.SIM_PUK2) {
                sb.append(mContext.getText(com.android.internal.R.string.badPin));
                sb.append("\n");
                sb.append(mContext.getText(com.android.internal.R.string.needPuk2));
            } else if (err == CommandException.Error.REQUEST_NOT_SUPPORTED) {
                if (mSc.equals(SC_PIN)) {
                    sb.append(mContext.getText(com.android.internal.R.string.enablePin));
                }
            } else if (err == CommandException.Error.FDN_CHECK_FAILURE) {
                Rlog.i(LOG_TAG, "FDN_CHECK_FAILURE");
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.mmiError));
        }
    } else if (isActivate()) {
        mState = State.COMPLETE;
        if (mIsCallFwdReg) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
        }
        // Record CLIR setting
        if (mSc.equals(SC_CLIR)) {
            mPhone.saveClirSetting(CommandsInterface.CLIR_INVOCATION);
        }
    } else if (isDeactivate()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
        // Record CLIR setting
        if (mSc.equals(SC_CLIR)) {
            mPhone.saveClirSetting(CommandsInterface.CLIR_SUPPRESSION);
        }
    } else if (isRegister()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
    } else if (isErasure()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceErased));
    } else {
        mState = State.FAILED;
        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
    }
    mMessage = sb;
    mPhone.onMMIDone(this);
}
#method_after
private void onSetComplete(Message msg, AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof CommandException) {
            CommandException.Error err = ((CommandException) (ar.exception)).getCommandError();
            if (err == CommandException.Error.PASSWORD_INCORRECT) {
                if (isPinPukCommand()) {
                    // the message accordingly.
                    if (mSc.equals(SC_PUK) || mSc.equals(SC_PUK2)) {
                        sb.append(mContext.getText(com.android.internal.R.string.badPuk));
                    } else {
                        sb.append(mContext.getText(com.android.internal.R.string.badPin));
                    }
                    // Get the No. of retries remaining to unlock PUK/PUK2
                    int attemptsRemaining = msg.arg1;
                    if (attemptsRemaining <= 0) {
                        Rlog.d(LOG_TAG, "onSetComplete: PUK locked," + " cancel as lock screen will handle this");
                        mState = State.CANCELLED;
                    } else if (attemptsRemaining > 0) {
                        Rlog.d(LOG_TAG, "onSetComplete: attemptsRemaining=" + attemptsRemaining);
                        sb.append(mContext.getResources().getQuantityString(com.android.internal.R.plurals.pinpuk_attempts, attemptsRemaining, attemptsRemaining));
                    }
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.passwordIncorrect));
                }
            } else if (err == CommandException.Error.SIM_PUK2) {
                sb.append(mContext.getText(com.android.internal.R.string.badPin));
                sb.append("\n");
                sb.append(mContext.getText(com.android.internal.R.string.needPuk2));
            } else if (err == CommandException.Error.REQUEST_NOT_SUPPORTED) {
                if (mSc.equals(SC_PIN)) {
                    sb.append(mContext.getText(com.android.internal.R.string.enablePin));
                }
            } else if (err == CommandException.Error.FDN_CHECK_FAILURE) {
                Rlog.i(LOG_TAG, "FDN_CHECK_FAILURE");
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (err == CommandException.Error.MODEM_ERR) {
                // and will return an error from the modem.
                if (isServiceCodeCallForwarding(mSc) && mPhone.getServiceState().getVoiceRoaming() && !mPhone.supports3gppCallForwardingWhileRoaming()) {
                    sb.append(mContext.getText(com.android.internal.R.string.mmiErrorWhileRoaming));
                } else {
                    sb.append(getErrorMessage(ar));
                }
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.mmiError));
        }
    } else if (isActivate()) {
        mState = State.COMPLETE;
        if (mIsCallFwdReg) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
        }
        // Record CLIR setting
        if (mSc.equals(SC_CLIR)) {
            mPhone.saveClirSetting(CommandsInterface.CLIR_INVOCATION);
        }
    } else if (isDeactivate()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
        // Record CLIR setting
        if (mSc.equals(SC_CLIR)) {
            mPhone.saveClirSetting(CommandsInterface.CLIR_SUPPRESSION);
        }
    } else if (isRegister()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
    } else if (isErasure()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceErased));
    } else {
        mState = State.FAILED;
        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
    }
    mMessage = sb;
    mPhone.onMMIDone(this);
}
#end_block

#method_before
/**
 * TODO: It would be nice to have a method here that can take in a dialstring and
 * figure out if there is an MMI code embedded within it.  This code would replace
 * some of the string parsing functionality in the Phone App's
 * SpecialCharSequenceMgr class.
 */
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("GsmMmiCode {");
    sb.append("State=" + getState());
    if (mAction != null)
        sb.append(" action=" + mAction);
    if (mSc != null)
        sb.append(" sc=" + mSc);
    // Refrain from logging user personal information like phone number in user build.
    if (DBG_BUILD) {
        if (mSia != null)
            sb.append(" sia=" + mSia);
        if (mSib != null)
            sb.append(" sib=" + mSib);
        if (mSic != null)
            sb.append(" sic=" + mSic);
        if (mPoundString != null)
            sb.append(" poundString=" + mPoundString);
        if (mDialingNumber != null)
            sb.append(" dialingNumber=" + mDialingNumber);
        if (mPwd != null)
            sb.append(" pwd=" + mPwd);
    }
    sb.append("}");
    return sb.toString();
}
#method_after
/**
 * TODO: It would be nice to have a method here that can take in a dialstring and
 * figure out if there is an MMI code embedded within it.  This code would replace
 * some of the string parsing functionality in the Phone App's
 * SpecialCharSequenceMgr class.
 */
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("GsmMmiCode {");
    sb.append("State=" + getState());
    if (mAction != null)
        sb.append(" action=" + mAction);
    if (mSc != null)
        sb.append(" sc=" + mSc);
    if (mSia != null)
        sb.append(" sia=" + Rlog.pii(LOG_TAG, mSia));
    if (mSib != null)
        sb.append(" sib=" + Rlog.pii(LOG_TAG, mSib));
    if (mSic != null)
        sb.append(" sic=" + Rlog.pii(LOG_TAG, mSic));
    if (mPoundString != null)
        sb.append(" poundString=" + Rlog.pii(LOG_TAG, mPoundString));
    if (mDialingNumber != null)
        sb.append(" dialingNumber=" + mDialingNumber);
    if (mPwd != null)
        sb.append(" pwd=" + mPwd);
    sb.append("}");
    return sb.toString();
}
#end_block

#method_before
public Connection takeIncomingCall(Object incomingCall) {
    // this may be true of GsmCdmaPhone too!!!
    synchronized (SipPhone.class) {
        if (!(incomingCall instanceof SipAudioCall)) {
            if (DBG)
                log("takeIncomingCall: ret=null, not a SipAudioCall");
            return null;
        }
        if (mRingingCall.getState().isAlive()) {
            if (DBG)
                log("takeIncomingCall: ret=null, ringingCall not alive");
            return null;
        }
        // both foreground and background are active
        if (mForegroundCall.getState().isAlive() && mBackgroundCall.getState().isAlive()) {
            if (DBG) {
                log("takeIncomingCall: ret=null," + " foreground and background both alive");
            }
            return null;
        }
        try {
            SipAudioCall sipAudioCall = (SipAudioCall) incomingCall;
            // Refrain from logging user personal information like phone number in user build.
            if (DBG && DBG_BUILD) {
                log("takeIncomingCall: taking call from: " + sipAudioCall.getPeerProfile().getUriString());
            }
            String localUri = sipAudioCall.getLocalProfile().getUriString();
            if (localUri.equals(mProfile.getUriString())) {
                boolean makeCallWait = mForegroundCall.getState().isAlive();
                SipConnection connection = mRingingCall.initIncomingCall(sipAudioCall, makeCallWait);
                if (sipAudioCall.getState() != SipSession.State.INCOMING_CALL) {
                    // Peer cancelled the call!
                    if (DBG)
                        log("    takeIncomingCall: call cancelled !!");
                    mRingingCall.reset();
                    connection = null;
                }
                return connection;
            }
        } catch (Exception e) {
            // that happens.
            if (DBG)
                log("    takeIncomingCall: exception e=" + e);
            mRingingCall.reset();
        }
        if (DBG)
            log("takeIncomingCall: NOT taking !!");
        return null;
    }
}
#method_after
public Connection takeIncomingCall(Object incomingCall) {
    // this may be true of GsmCdmaPhone too!!!
    synchronized (SipPhone.class) {
        if (!(incomingCall instanceof SipAudioCall)) {
            if (DBG)
                log("takeIncomingCall: ret=null, not a SipAudioCall");
            return null;
        }
        if (mRingingCall.getState().isAlive()) {
            if (DBG)
                log("takeIncomingCall: ret=null, ringingCall not alive");
            return null;
        }
        // both foreground and background are active
        if (mForegroundCall.getState().isAlive() && mBackgroundCall.getState().isAlive()) {
            if (DBG) {
                log("takeIncomingCall: ret=null," + " foreground and background both alive");
            }
            return null;
        }
        try {
            SipAudioCall sipAudioCall = (SipAudioCall) incomingCall;
            if (DBG)
                log("takeIncomingCall: taking call from: " + hidePii(sipAudioCall.getPeerProfile().getUriString()));
            String localUri = sipAudioCall.getLocalProfile().getUriString();
            if (localUri.equals(mProfile.getUriString())) {
                boolean makeCallWait = mForegroundCall.getState().isAlive();
                SipConnection connection = mRingingCall.initIncomingCall(sipAudioCall, makeCallWait);
                if (sipAudioCall.getState() != SipSession.State.INCOMING_CALL) {
                    // Peer cancelled the call!
                    if (DBG)
                        log("    takeIncomingCall: call cancelled !!");
                    mRingingCall.reset();
                    connection = null;
                }
                return connection;
            }
        } catch (Exception e) {
            // that happens.
            if (DBG)
                log("    takeIncomingCall: exception e=" + e);
            mRingingCall.reset();
        }
        if (DBG)
            log("takeIncomingCall: NOT taking !!");
        return null;
    }
}
#end_block

#method_before
@Override
public void hangup() throws CallStateException {
    synchronized (SipPhone.class) {
        if (SCN_DBG) {
            // like phone number in user build.
            if (DBG_BUILD) {
                log("hangup: conn=" + mPeer.getUriString() + ": " + mState + ": on phone " + getPhone().getPhoneName());
            } else {
                log("hangup: " + mState + ": on phone " + getPhone().getPhoneName());
            }
        }
        if (!mState.isAlive())
            return;
        try {
            SipAudioCall sipAudioCall = mSipAudioCall;
            if (sipAudioCall != null) {
                sipAudioCall.setListener(null);
                sipAudioCall.endCall();
            }
        } catch (SipException e) {
            throw new CallStateException("hangup(): " + e);
        } finally {
            mAdapter.onCallEnded(((mState == Call.State.INCOMING) || (mState == Call.State.WAITING)) ? DisconnectCause.INCOMING_REJECTED : DisconnectCause.LOCAL);
        }
    }
}
#method_after
@Override
public void hangup() throws CallStateException {
    synchronized (SipPhone.class) {
        if (SCN_DBG) {
            log("hangup: conn=" + hidePii(mPeer.getUriString()) + ": " + mState + ": on phone " + getPhone().getPhoneName());
        }
        if (!mState.isAlive())
            return;
        try {
            SipAudioCall sipAudioCall = mSipAudioCall;
            if (sipAudioCall != null) {
                sipAudioCall.setListener(null);
                sipAudioCall.endCall();
            }
        } catch (SipException e) {
            throw new CallStateException("hangup(): " + e);
        } finally {
            mAdapter.onCallEnded(((mState == Call.State.INCOMING) || (mState == Call.State.WAITING)) ? DisconnectCause.INCOMING_REJECTED : DisconnectCause.LOCAL);
        }
    }
}
#end_block

#method_before
public static String hidePii(String s) {
    return VDBG ? s : "xxxxx";
}
#method_after
public static String hidePii(String s) {
    return VDBG ? Rlog.pii(LOG_TAG, s) : "xxxxx";
}
#end_block

#method_before
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (httpResponseCode == 204) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#method_after
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (httpResponseCode == 204) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#end_block

#method_before
protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) {
    if (DBG)
        log("onReceive " + intent);
    String action = intent.getAction();
    if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) {
        // the process of CellBroadcastReceiver gets killed every time once the job is done.
        if (UserManager.get(context).isSystemUser()) {
            startConfigService(context.getApplicationContext());
        } else {
            Log.e(TAG, "Not system user. Ignored the intent " + action);
        }
    } else if (Telephony.Sms.Intents.SMS_EMERGENCY_CB_RECEIVED_ACTION.equals(action) || Telephony.Sms.Intents.SMS_CB_RECEIVED_ACTION.equals(action)) {
        // permission-checked route, so we just ignore it.
        if (privileged) {
            intent.setClass(context, CellBroadcastAlertService.class);
            context.startService(intent);
        } else {
            loge("ignoring unprivileged action received " + action);
        }
    } else if (Telephony.Sms.Intents.SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED_ACTION.equals(action)) {
        if (privileged) {
            CdmaSmsCbProgramData[] programDataList = (CdmaSmsCbProgramData[]) intent.getParcelableArrayExtra("program_data_list");
            if (programDataList != null) {
                handleCdmaSmsCbProgramData(context, programDataList);
            } else {
                loge("SCPD intent received with no program_data_list");
            }
        } else {
            loge("ignoring unprivileged action received " + action);
        }
    } else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
        String simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
        // countries/carriers might have different interval settings.
        if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_LOADED)) {
            adjustReminderInterval(context.getApplicationContext());
        }
    } else {
        Log.w(TAG, "onReceive() unexpected action " + action);
    }
}
#method_after
protected void onReceiveWithPrivilege(Context context, Intent intent, boolean privileged) {
    if (DBG)
        log("onReceive " + intent);
    String action = intent.getAction();
    if (TelephonyIntents.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED.equals(action) || CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(action) || CELLBROADCAST_START_CONFIG_ACTION.equals(action)) {
        // the process of CellBroadcastReceiver gets killed every time once the job is done.
        if (UserManager.get(context).isSystemUser()) {
            startConfigService(context.getApplicationContext());
            // Whenever carrier changes, we need to adjust the emergency alert
            // reminder interval list because it might change since different
            // countries/carriers might have different interval settings.
            adjustReminderInterval(context);
        } else {
            Log.e(TAG, "Not system user. Ignored the intent " + action);
        }
    } else if (Telephony.Sms.Intents.SMS_EMERGENCY_CB_RECEIVED_ACTION.equals(action) || Telephony.Sms.Intents.SMS_CB_RECEIVED_ACTION.equals(action)) {
        // permission-checked route, so we just ignore it.
        if (privileged) {
            intent.setClass(context, CellBroadcastAlertService.class);
            context.startService(intent);
        } else {
            loge("ignoring unprivileged action received " + action);
        }
    } else if (Telephony.Sms.Intents.SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED_ACTION.equals(action)) {
        if (privileged) {
            CdmaSmsCbProgramData[] programDataList = (CdmaSmsCbProgramData[]) intent.getParcelableArrayExtra("program_data_list");
            if (programDataList != null) {
                handleCdmaSmsCbProgramData(context, programDataList);
            } else {
                loge("SCPD intent received with no program_data_list");
            }
        } else {
            loge("ignoring unprivileged action received " + action);
        }
    } else {
        Log.w(TAG, "onReceive() unexpected action " + action);
    }
}
#end_block

#method_before
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        try {
            final String profileName = new String(mKeyStore.get(Credentials.LOCKDOWN_VPN));
            final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
            if (profile == null) {
                Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
                setLockdownTracker(null);
                return true;
            }
            int user = UserHandle.getUserId(Binder.getCallingUid());
            synchronized (mVpns) {
                Vpn vpn = mVpns.get(user);
                if (vpn == null) {
                    Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                    return false;
                }
                setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
            }
        } catch (NullPointerException e) {
            Slog.e(TAG, "Couldn't read LOCKDOWN_VPN blob from KeyStore(maybe oldblob)");
            return false;
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#method_after
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        byte[] profileTag = mKeyStore.get(Credentials.LOCKDOWN_VPN);
        if (profileTag == null) {
            Slog.e(TAG, "Lockdown VPN configured but cannot be read from keystore");
            return false;
        }
        String profileName = new String(profileTag);
        final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
        if (profile == null) {
            Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
            setLockdownTracker(null);
            return true;
        }
        int user = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (mVpns) {
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#end_block

#method_before
@Override
public void onAssociationRejected(byte[] bssid, int statusCode, boolean timedOut) {
    logCallback("onAssociationRejected");
    synchronized (mLock) {
        // TODO(b/35464954): Need to figure out when to trigger
        // |WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD|
        mWifiMonitor.broadcastAssociationRejectionEvent(mIfaceName, statusCode, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#method_after
@Override
public void onAssociationRejected(byte[] bssid, int statusCode, boolean timedOut) {
    logCallback("onAssociationRejected");
    synchronized (mLock) {
        // TODO(b/35464954): Need to figure out when to trigger
        // |WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD|
        mWifiMonitor.broadcastAssociationRejectionEvent(mIfaceName, statusCode, timedOut, NativeUtil.macAddressFromByteArray(bssid));
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean setPairingConfirmation(boolean confirm) {
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return sService.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setPairingConfirmation(boolean confirm) {
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return sService.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) {
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this, transport);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) {
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(iGatt, this, transport);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#end_block

#method_before
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess())
        return null;
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "Bluetooth LE advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#method_after
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isEnabled() {
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isEnabled() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@SystemApi
public boolean isLeEnabled() {
    final int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_ON");
    } else if (state == BluetoothAdapter.STATE_BLE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_BLE_ON");
    } else {
        if (DBG)
            Log.d(TAG, "STATE_OFF");
        return false;
    }
    return true;
}
#method_after
@SystemApi
public boolean isLeEnabled() {
    final int state = getLeState();
    if (DBG)
        Log.d(TAG, "isLeEnabled(): " + BluetoothAdapter.nameForState(state));
    return (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON);
}
#end_block

#method_before
@SystemApi
public boolean disableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_ON: shouldn't disable");
        try {
            mManagerService.updateBleAppCount(mToken, false);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        return true;
    } else if (state == BluetoothAdapter.STATE_BLE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_BLE_ON");
        int bleAppCnt = 0;
        try {
            bleAppCnt = mManagerService.updateBleAppCount(mToken, false);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        if (bleAppCnt == 0) {
            // Disable only if there are no other clients
            notifyUserAction(false);
        }
        return true;
    }
    if (DBG)
        Log.d(TAG, "STATE_OFF: Already disabled");
    return false;
}
#method_after
@SystemApi
public boolean disableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON) {
        String packageName = ActivityThread.currentPackageName();
        if (DBG)
            Log.d(TAG, "disableBLE(): de-registering " + packageName);
        try {
            mManagerService.updateBleAppCount(mToken, false, packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        return true;
    }
    if (DBG)
        Log.d(TAG, "disableBLE(): Already disabled");
    return false;
}
#end_block

#method_before
@SystemApi
public boolean enableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    if (isLeEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enableBLE(): BT is already enabled..!");
        try {
            mManagerService.updateBleAppCount(mToken, true);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
        return true;
    }
    try {
        if (DBG)
            Log.d(TAG, "Calling enableBLE");
        mManagerService.updateBleAppCount(mToken, true);
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@SystemApi
public boolean enableBLE() {
    if (!isBleScanAlwaysAvailable())
        return false;
    try {
        String packageName = ActivityThread.currentPackageName();
        mManagerService.updateBleAppCount(mToken, true, packageName);
        if (isLeEnabled()) {
            if (DBG)
                Log.d(TAG, "enableBLE(): Bluetooth already enabled");
            return true;
        }
        if (DBG)
            Log.d(TAG, "enableBLE(): Calling enable");
        return mManagerService.enable(packageName);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getState() {
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
                // consider all internal states as OFF
                if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
                    if (VDBG)
                        Log.d(TAG, "Consider internal state as OFF");
                    state = BluetoothAdapter.STATE_OFF;
                }
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return STATE_OFF;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, "Consider " + BluetoothAdapter.nameForState(state) + " state as OFF");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, "" + hashCode() + ": getState(). Returning " + BluetoothAdapter.nameForState(state));
    return state;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getLeState() {
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "getLeState() returning " + state);
                return state;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BluetoothAdapter.STATE_OFF;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getLeState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG)
        Log.d(TAG, "getLeState() returning " + BluetoothAdapter.nameForState(state));
    return state;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean enable() {
    int state = STATE_OFF;
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enable(): BT is already enabled..!");
        return true;
    }
    // Use service interface to get the exact state
    if (mService != null) {
        try {
            state = mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    if (state == BluetoothAdapter.STATE_BLE_ON) {
        Log.e(TAG, "BT is in BLE_ON State");
        notifyUserAction(true);
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean enable() {
    if (isEnabled()) {
        if (DBG)
            Log.d(TAG, "enable(): BT already enabled!");
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean disable() {
    try {
        return mManagerService.disable(true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean disable() {
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean disable(boolean persist) {
    try {
        return mManagerService.disable(persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean disable(boolean persist) {
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean configHciSnoopLog(boolean enable) {
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.configHciSnoopLog(enable);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean configHciSnoopLog(boolean enable) {
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.configHciSnoopLog(enable);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean factoryReset() {
    try {
        if (mService != null) {
            return mService.factoryReset();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean factoryReset() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.factoryReset();
        }
        SystemProperties.set("persist.bluetooth.factoryreset", "true");
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON)
        return null;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getUuids();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON)
        return null;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getUuids();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean setName(String name) {
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean setName(String name) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@ScanMode
public int getScanMode() {
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return SCAN_MODE_NONE;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@ScanMode
public int getScanMode() {
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}
#end_block

#method_before
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.setScanMode(mode, duration);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setScanMode(mode, duration);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON)
        return -1;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getDiscoverableTimeout();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return -1;
}
#method_after
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON)
        return -1;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getDiscoverableTimeout();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#end_block

#method_before
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON)
        return;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                mService.setDiscoverableTimeout(timeout);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
#method_after
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON)
        return;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            mService.setDiscoverableTimeout(timeout);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean cancelDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean cancelDiscovery() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isDiscovering() {
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public boolean isDiscovering() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isMultipleAdvertisementSupported() {
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    }
    return false;
}
#method_after
public boolean isMultipleAdvertisementSupported() {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isOffloadedFilteringSupported() {
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    }
    return false;
}
#method_after
public boolean isOffloadedFilteringSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean isOffloadedScanBatchingSupported() {
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    }
    return false;
}
#method_after
public boolean isOffloadedScanBatchingSupported() {
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public BluetoothActivityEnergyInfo getControllerActivityEnergyInfo(int updateType) {
    if (getState() != STATE_ON)
        return null;
    try {
        BluetoothActivityEnergyInfo record;
        if (!mService.isActivityAndEnergyReportingSupported()) {
            return null;
        }
        synchronized (this) {
            if (updateType == ACTIVITY_ENERGY_INFO_REFRESHED) {
                mService.getActivityEnergyInfoFromController();
                wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);
            }
            record = mService.reportActivityInfo();
            if (record.isValid()) {
                return record;
            } else {
                return null;
            }
        }
    } catch (InterruptedException e) {
        Log.e(TAG, "getControllerActivityEnergyInfoCallback wait interrupted: " + e);
    } catch (RemoteException e) {
        Log.e(TAG, "getControllerActivityEnergyInfoCallback: " + e);
    }
    return null;
}
#method_after
@Deprecated
public BluetoothActivityEnergyInfo getControllerActivityEnergyInfo(int updateType) {
    SynchronousResultReceiver receiver = new SynchronousResultReceiver();
    requestControllerActivityEnergyInfo(receiver);
    try {
        SynchronousResultReceiver.Result result = receiver.awaitResult(1000);
        if (result.bundle != null) {
            return result.bundle.getParcelable(BatteryStats.RESULT_RECEIVER_CONTROLLER_KEY);
        }
    } catch (TimeoutException e) {
        Log.e(TAG, "getControllerActivityEnergyInfo timed out");
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public Set<BluetoothDevice> getBondedDevices() {
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public Set<BluetoothDevice> getBondedDevices() {
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return toDeviceSet(mService.getBondedDevices());
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
public int getConnectionState() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getAdapterConnectionState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#method_after
public int getConnectionState() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getAdapterConnectionState();
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public int getProfileConnectionState(int profile) {
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public int getProfileConnectionState(int profile) {
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#end_block

#method_before
public Pair<byte[], byte[]> readOutOfBandData() {
    if (getState() != STATE_ON)
        return null;
    /*
        try {
            byte[] hash;
            byte[] randomizer;

            byte[] ret = mService.readOutOfBandData();

            if (ret  == null || ret.length != 32) return null;

            hash = Arrays.copyOfRange(ret, 0, 16);
            randomizer = Arrays.copyOfRange(ret, 16, 32);

            if (DBG) {
                Log.d(TAG, "readOutOfBandData:" + Arrays.toString(hash) +
                  ":" + Arrays.toString(randomizer));
            }
            return new Pair<byte[], byte[]>(hash, randomizer);

        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
    return null;
}
#method_after
public Pair<byte[], byte[]> readOutOfBandData() {
    return null;
}
#end_block

#method_before
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getProfileProxy(Context context, BluetoothProfile.ServiceListener listener, int profile) {
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_HOST) {
        BluetoothInputHost iHost = new BluetoothInputHost(context, listener);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
    }
}
#method_after
public void closeProfileProxy(int profile, BluetoothProfile proxy) {
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}
#end_block

#method_before
public boolean enableNoAutoConnect() {
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enableNoAutoConnect(): BT is already enabled..!");
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
public boolean enableNoAutoConnect() {
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enableNoAutoConnect(): BT already enabled!");
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean changeApplicationBluetoothState(boolean on, BluetoothStateChangeCallback callback) {
    if (callback == null)
        return false;
    /*
        try {
            return mService.changeApplicationBluetoothState(on, new
                    StateChangeCallbackWrapper(callback), new Binder());
        } catch (RemoteException e) {
            Log.e(TAG, "changeBluetoothState", e);
        }*/
    return false;
}
#method_after
public boolean changeApplicationBluetoothState(boolean on, BluetoothStateChangeCallback callback) {
    return false;
}
#end_block

#method_before
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback) {
    if (DBG)
        Log.d(TAG, "startLeScan(): " + serviceUuids);
    if (callback == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: null callback");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: cannot get BluetoothLeScanner");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, "LE Scan has already started");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, "LE Scan has already started");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, "uuids does not match");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    return false;
}
#method_after
@Deprecated
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public boolean startLeScan(final UUID[] serviceUuids, final LeScanCallback callback) {
    if (DBG)
        Log.d(TAG, "startLeScan(): " + Arrays.toString(serviceUuids));
    if (callback == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: null callback");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, "startLeScan: cannot get BluetoothLeScanner");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, "LE Scan has already started");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, "LE Scan has already started");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, "uuids does not match");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    return false;
}
#end_block

#method_before
private void startSocketListener() {
    if (D)
        Log.d(TAG, "start Socket Listeners");
    stopListeners();
    mSocketListener = new BluetoothOppRfcommListener(mAdapter);
    mL2cSocketListener = new BluetoothOppL2capListener(mAdapter);
    if (mSocketListener != null && mL2cSocketListener != null) {
        if ((mSocketListener.openRfcommSocket() != null) && (mL2cSocketListener.openL2capSocket() != null) && SdpManager.getDefaultManager() != null) {
            mOppSdpHandle = SdpManager.getDefaultManager().createOppOpsRecord("OBEX Object Push", mSocketListener.getRfcommChannel(), mL2cSocketListener.getL2capPsm(), 0x0102, SdpManager.OPP_FORMAT_ALL);
            mSocketListener.start(mHandler);
            mL2cSocketListener.start(mHandler);
        } else {
            Log.e(TAG, "ERROR:serversocket object is NULL");
        }
    }
}
#method_after
private void startSocketListener() {
    if (D)
        Log.d(TAG, "start Socket Listeners");
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SdpManager.OPP_FORMAT_ALL);
}
#end_block

#method_before
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport);
    mServerSession.preStart();
    if (D)
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
}
#method_after
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport, mServerSocket);
    mServerSession.preStart();
    if (D)
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
}
#end_block

#method_before
private void stopListeners() {
    if (D)
        Log.d(TAG, "stopListeners mSocketListener :" + mSocketListener + " mL2cSocketListener :" + mL2cSocketListener);
    if (mSocketListener != null) {
        mSocketListener.stop();
        mSocketListener = null;
    }
    if (mL2cSocketListener != null) {
        mL2cSocketListener.stop();
        mL2cSocketListener = null;
    }
}
#method_after
private void stopListeners() {
    if (mServerSocket != null) {
        mServerSocket.shutdown(false);
        mServerSocket = null;
    }
    if (D)
        Log.d(TAG, "stopListeners   mServerSocket :" + mServerSocket);
}
#end_block

#method_before
/*
     * NOTE
     * For outbound transfer
     * 1) Check Bluetooth status
     * 2) Start handler thread
     * 3) new a thread to connect to target device
     * 3.1) Try a few times to do SDP query for target device OPUSH channel
     * 3.2) Try a few seconds to connect to target socket
     * 4) After BluetoothSocket is connected,create an instance of RfcommTransport
     * 5) Create an instance of BluetoothOppClientSession
     * 6) Start the session and process the first share in batch
     * For inbound transfer
     * The transfer already has session and transport setup, just start it
     * 1) Check Bluetooth status
     * 2) Start handler thread
     * 3) Start the session and process the first share in batch
     */
public void start() {
    /*
         * normally it's impossible to reach here if BT is disabled. Just check
         * for safety
         */
    if (!mAdapter.isEnabled()) {
        Log.e(TAG, "Can't start transfer when Bluetooth is disabled for " + mBatch.mId);
        markBatchFailed();
        mBatch.mStatus = Constants.BATCH_STATUS_FAILED;
        return;
    }
    if (mHandlerThread == null) {
        if (V)
            Log.v(TAG, "Create handler thread for batch " + mBatch.mId);
        mHandlerThread = new HandlerThread("BtOpp Transfer Handler", Process.THREAD_PRIORITY_BACKGROUND);
        mHandlerThread.start();
        mSessionHandler = new EventHandler(mHandlerThread.getLooper());
        if (mBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
            /* for outbound transfer, we do connect first */
            startConnectSession();
        } else if (mBatch.mDirection == BluetoothShare.DIRECTION_INBOUND) {
            /*
                 * for inbound transfer, it's already connected, so we start
                 * OBEX session directly
                 */
            startObexSession();
        }
    }
}
#method_after
/*
     * NOTE
     * For outbound transfer
     * 1) Check Bluetooth status
     * 2) Start handler thread
     * 3) new a thread to connect to target device
     * 3.1) Try a few times to do SDP query for target device OPUSH channel
     * 3.2) Try a few seconds to connect to target socket
     * 4) After BluetoothSocket is connected,create an instance of RfcommTransport
     * 5) Create an instance of BluetoothOppClientSession
     * 6) Start the session and process the first share in batch
     * For inbound transfer
     * The transfer already has session and transport setup, just start it
     * 1) Check Bluetooth status
     * 2) Start handler thread
     * 3) Start the session and process the first share in batch
     */
public void start() {
    /*
         * normally it's impossible to reach here if BT is disabled. Just check
         * for safety
         */
    if (!mAdapter.isEnabled()) {
        Log.e(TAG, "Can't start transfer when Bluetooth is disabled for " + mBatch.mId);
        markBatchFailed();
        mBatch.mStatus = Constants.BATCH_STATUS_FAILED;
        return;
    }
    if (mHandlerThread == null) {
        if (V)
            Log.v(TAG, "Create handler thread for batch " + mBatch.mId);
        mHandlerThread = new HandlerThread("BtOpp Transfer Handler", Process.THREAD_PRIORITY_BACKGROUND);
        mHandlerThread.start();
        mSessionHandler = new EventHandler(mHandlerThread.getLooper());
        if (mBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
            /* for outbound transfer, we do connect first */
            startConnectSession();
        } else if (mBatch.mDirection == BluetoothShare.DIRECTION_INBOUND) {
            /*
                 * for inbound transfer, it's already connected, so we start
                 * OBEX session directly
                 */
            startObexSession();
        }
    }
    registerConnectionreceiver();
}
#end_block

#method_before
private void startObexSession() {
    mBatch.mStatus = Constants.BATCH_STATUS_RUNNING;
    mCurrentShare = mBatch.getPendingShare();
    if (mCurrentShare == null) {
        /*
             * TODO catch this error
             */
        Log.e(TAG, "Unexpected error happened !");
        return;
    }
    if (V)
        Log.v(TAG, "Start session for info " + mCurrentShare.mId + " for batch " + mBatch.mId);
    if (mBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
        if (V)
            Log.v(TAG, "Create Client session with transport " + mTransport.toString());
        mSession = new BluetoothOppObexClientSession(mContext, mTransport);
    } else if (mBatch.mDirection == BluetoothShare.DIRECTION_INBOUND) {
        /*
             * For inbounds transfer, a server session should already exists
             * before BluetoothOppTransfer is initialized. We should pass in a
             * mSession instance.
             */
        if (mSession == null) {
            /**
             * set current share as error
             */
            Log.e(TAG, "Unexpected error happened !");
            markBatchFailed();
            mBatch.mStatus = Constants.BATCH_STATUS_FAILED;
            return;
        }
        if (V)
            Log.v(TAG, "Transfer has Server session" + mSession.toString());
    }
    mSession.start(mSessionHandler, mBatch.getNumShares());
    processCurrentShare();
    /* OBEX channel need to be monitored for unexpected ACL disconnection
         * such as Remote Battery removal
         */
    synchronized (this) {
        try {
            IntentFilter filter = new IntentFilter();
            filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
            mContext.registerReceiver(mBluetoothReceiver, filter);
            if (V)
                Log.v(TAG, "Registered mBluetoothReceiver");
        } catch (IllegalArgumentException e) {
        }
    }
}
#method_after
private void startObexSession() {
    mBatch.mStatus = Constants.BATCH_STATUS_RUNNING;
    mCurrentShare = mBatch.getPendingShare();
    if (mCurrentShare == null) {
        /*
             * TODO catch this error
             */
        Log.e(TAG, "Unexpected error happened !");
        return;
    }
    if (V)
        Log.v(TAG, "Start session for info " + mCurrentShare.mId + " for batch " + mBatch.mId);
    if (mBatch.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
        if (V)
            Log.v(TAG, "Create Client session with transport " + mTransport.toString());
        mSession = new BluetoothOppObexClientSession(mContext, mTransport);
    } else if (mBatch.mDirection == BluetoothShare.DIRECTION_INBOUND) {
        /*
             * For inbounds transfer, a server session should already exists
             * before BluetoothOppTransfer is initialized. We should pass in a
             * mSession instance.
             */
        if (mSession == null) {
            /**
             * set current share as error
             */
            Log.e(TAG, "Unexpected error happened !");
            markBatchFailed();
            mBatch.mStatus = Constants.BATCH_STATUS_FAILED;
            return;
        }
        if (V)
            Log.v(TAG, "Transfer has Server session" + mSession.toString());
    }
    mSession.start(mSessionHandler, mBatch.getNumShares());
    processCurrentShare();
}
#end_block

#method_before
private void startConnectSession() {
    if (Constants.USE_TCP_DEBUG) {
        mConnectThread = new SocketConnectThread("localhost", Constants.TCP_DEBUG_PORT, 0);
        mConnectThread.start();
    } else {
        mDevice = mBatch.mDestination;
        if (!mBatch.mDestination.sdpSearch(BluetoothUuid.ObexObjectPush)) {
            /* update bd address as sdp could not be started */
            mDevice = null;
            /* SDP failed, start rfcomm connect directly */
            mConnectThread = new SocketConnectThread(mBatch.mDestination, false, false, -1);
            mConnectThread.start();
        } else {
            /* SDP sucessfully started, start l2cap connect after sdp completes */
            synchronized (this) {
                try {
                    IntentFilter filter = new IntentFilter();
                    filter.addAction(BluetoothDevice.ACTION_SDP_RECORD);
                    mContext.registerReceiver(mBluetoothReceiver, filter);
                    if (V)
                        Log.v(TAG, "Registered mBluetoothReceiver");
                } catch (IllegalArgumentException e) {
                }
            }
        }
    }
}
#method_after
private void startConnectSession() {
    mDevice = mBatch.mDestination;
    if (!mBatch.mDestination.sdpSearch(BluetoothUuid.ObexObjectPush)) {
        if (D)
            Log.d(TAG, "SDP failed, start rfcomm connect directly");
        /* update bd address as sdp could not be started */
        mDevice = null;
        /* SDP failed, start rfcomm connect directly */
        mConnectThread = new SocketConnectThread(mBatch.mDestination, false, false, -1);
        mConnectThread.start();
    }
}
#end_block

#method_before
public void interrupt() {
    Log.d(TAG, "start interrupt :" + btSocket);
    if (!Constants.USE_TCP_DEBUG) {
        isInterrupted = true;
        if (btSocket != null) {
            try {
                btSocket.close();
            } catch (IOException e) {
                Log.v(TAG, "Error when close socket");
            }
        }
    }
}
#method_after
public void interrupt() {
    if (D)
        Log.d(TAG, "start interrupt :" + btSocket);
    isInterrupted = true;
    if (btSocket != null) {
        try {
            btSocket.close();
        } catch (IOException e) {
            Log.v(TAG, "Error when close socket");
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    timestamp = System.currentTimeMillis();
    if (Constants.USE_TCP_DEBUG) {
        /* Use TCP socket to connect */
        Socket s = new Socket();
        // Try to connect for 50 seconds
        int result = 0;
        for (int i = 0; i < CONNECT_RETRY_TIME && result == 0; i++) {
            try {
                s.connect(new InetSocketAddress(host, channel), CONNECT_WAIT_TIMEOUT);
            } catch (UnknownHostException e) {
                Log.e(TAG, "TCP socket connect unknown host ");
            } catch (IOException e) {
                Log.e(TAG, "TCP socket connect failed ");
            }
            if (s.isConnected()) {
                if (D)
                    Log.d(TAG, "TCP socket connected ");
                isConnected = true;
                break;
            }
            if (isInterrupted()) {
                Log.e(TAG, "TCP socket connect interrupted ");
                markConnectionFailed(s);
                return;
            }
        }
        if (!isConnected) {
            Log.e(TAG, "TCP socket connect failed after 20 seconds");
            markConnectionFailed(s);
            return;
        }
        if (V)
            Log.v(TAG, "TCP Socket connection attempt took " + (System.currentTimeMillis() - timestamp) + " ms");
        TestTcpTransport transport;
        transport = new TestTcpTransport(s);
        if (isInterrupted()) {
            isConnected = false;
            markConnectionFailed(s);
            transport = null;
            return;
        }
        if (!isConnected) {
            transport = null;
            Log.e(TAG, "TCP connect session error: ");
            markConnectionFailed(s);
            return;
        } else {
            if (D)
                Log.d(TAG, "Send transport message " + transport.toString());
            mSessionHandler.obtainMessage(TRANSPORT_CONNECTED, transport).sendToTarget();
        }
    } else {
        Log.d(TAG, "sdp initiated = " + mSdpInitiated);
        // directly to rfcomm
        if (!mSdpInitiated || l2cChannel < 0) {
            /* sdp failed for some reason, connect on rfcomm */
            Log.d(TAG, "sdp not initiated, connecting on rfcomm");
            connectRfcommSocket();
            return;
        }
        /* Reset the flag */
        mSdpInitiated = false;
        /* Use BluetoothSocket to connect */
        try {
            if (isInterrupted) {
                Log.e(TAG, "btSocket connect interrupted ");
                markConnectionFailed(btSocket);
                return;
            } else {
                btSocket = device.createInsecureL2capSocket(l2cChannel);
            }
            if (l2cChannel > 0) {
                Log.d(TAG, "Connecting to l2cap psm = " + l2cChannel);
                btSocket = device.createInsecureL2capSocket(l2cChannel);
            } else {
                Log.d(TAG, "L2cap psm not found, connecting on rfcomm");
                connectRfcommSocket();
                return;
            }
        } catch (IOException e1) {
            Log.e(TAG, "L2cap socket create error", e1);
            connectRfcommSocket();
            return;
        }
        try {
            btSocket.connect();
            if (V)
                Log.v(TAG, "L2cap socket connection attempt took " + (System.currentTimeMillis() - timestamp) + " ms");
            BluetoothObexTransport transport;
            transport = new BluetoothObexTransport(btSocket);
            BluetoothOppPreference.getInstance(mContext).setName(device, device.getName());
            if (V)
                Log.v(TAG, "Send transport message " + transport.toString());
            mSessionHandler.obtainMessage(TRANSPORT_CONNECTED, transport).sendToTarget();
        } catch (IOException e) {
            Log.e(TAG, "L2cap socket connect exception", e);
            try {
                btSocket.close();
            } catch (IOException e3) {
                Log.e(TAG, "Bluetooth socket close error ", e3);
            }
            connectRfcommSocket();
            return;
        }
    }
}
#method_after
@Override
public void run() {
    timestamp = System.currentTimeMillis();
    if (D)
        Log.d(TAG, "sdp initiated = " + mSdpInitiated + " l2cChannel :" + l2cChannel);
    // directly to rfcomm
    if (!mSdpInitiated || l2cChannel < 0) {
        /* sdp failed for some reason, connect on rfcomm */
        Log.d(TAG, "sdp not initiated, connecting on rfcomm");
        connectRfcommSocket();
        return;
    }
    /* Reset the flag */
    mSdpInitiated = false;
    /* Use BluetoothSocket to connect */
    try {
        if (isInterrupted) {
            Log.e(TAG, "btSocket connect interrupted ");
            markConnectionFailed(btSocket);
            return;
        } else {
            btSocket = device.createInsecureL2capSocket(l2cChannel);
        }
    } catch (IOException e1) {
        Log.e(TAG, "L2cap socket create error", e1);
        connectRfcommSocket();
        return;
    }
    try {
        btSocket.connect();
        if (V)
            Log.v(TAG, "L2cap socket connection attempt took " + (System.currentTimeMillis() - timestamp) + " ms");
        BluetoothObexTransport transport;
        transport = new BluetoothObexTransport(btSocket);
        BluetoothOppPreference.getInstance(mContext).setName(device, device.getName());
        if (V)
            Log.v(TAG, "Send transport message " + transport.toString());
        mSessionHandler.obtainMessage(TRANSPORT_CONNECTED, transport).sendToTarget();
    } catch (IOException e) {
        Log.e(TAG, "L2cap socket connect exception", e);
        try {
            btSocket.close();
        } catch (IOException e3) {
            Log.e(TAG, "Bluetooth socket close error ", e3);
        }
        connectRfcommSocket();
        return;
    }
}
#end_block

#method_before
@Test
public void testEnterLogging() {
    mWifiVendorHal.mErrLog = spy(mWifiLog);
    mWifiVendorHal.enableVerboseLogging(true);
    mWifiVendorHal.installPacketFilter(new byte[0]);
    verify(mWifiVendorHal.mErrLog).trace("% filter length %");
}
#method_after
@Test
public void testEnterLogging() {
    mWifiVendorHal.mLog = spy(mWifiLog);
    mWifiVendorHal.enableVerboseLogging(true);
    mWifiVendorHal.installPacketFilter(new byte[0]);
    verify(mWifiVendorHal.mLog).trace(eq("% filter length %"));
}
#end_block

#method_before
@Test
public void testBoolResultFalse() {
    mWifiLog = spy(mWifiLog);
    mWifiVendorHal.mErrLog = mWifiLog;
    mWifiVendorHal.mLog = mWifiLog;
    assertFalse(mWifiVendorHal.getScanCapabilities(new WifiNative.ScanCapabilities()));
    verify(mWifiLog).err("% returns %");
}
#method_after
@Test
public void testBoolResultFalse() {
    mWifiLog = spy(mWifiLog);
    mWifiVendorHal.mLog = mWifiLog;
    mWifiVendorHal.mVerboseLog = mWifiLog;
    assertFalse(mWifiVendorHal.getScanCapabilities(new WifiNative.ScanCapabilities()));
    verify(mWifiLog).err("% returns %");
}
#end_block

#method_before
@Test
public void testRemoteExceptionIsHandled() throws Exception {
    mWifiLog = spy(mWifiLog);
    mWifiVendorHal.mErrLog = mWifiLog;
    when(mIWifiApIface.setCountryCode(any())).thenThrow(new RemoteException("oops"));
    assertTrue(mWifiVendorHal.startVendorHalAp());
    assertFalse(mWifiVendorHal.setCountryCodeHal("CA"));
    verify(mWifiLog).err(any());
}
#method_after
@Test
public void testRemoteExceptionIsHandled() throws Exception {
    mWifiLog = spy(mWifiLog);
    mWifiVendorHal.mLog = mWifiLog;
    when(mIWifiApIface.setCountryCode(any())).thenThrow(new RemoteException("oops"));
    assertTrue(mWifiVendorHal.startVendorHalAp());
    assertFalse(mWifiVendorHal.setCountryCodeHal("CA"));
    verify(mWifiLog).err(any());
}
#end_block

#method_before
public void enableVerboseLogging(boolean verbose) {
    synchronized (sLock) {
        if (verbose) {
            mLog = mErrLog;
            enter("verbose=true").flush();
        } else {
            enter("verbose=false").flush();
            mLog = sNoLog;
        }
    }
}
#method_after
public void enableVerboseLogging(boolean verbose) {
    synchronized (sLock) {
        if (verbose) {
            mVerboseLog = mLog;
            enter("verbose=true").flush();
        } else {
            enter("verbose=false").flush();
            mVerboseLog = sNoLog;
        }
    }
}
#end_block

#method_before
private boolean ok(WifiStatus status) {
    if (status.code == WifiStatusCode.SUCCESS)
        return true;
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    mErrLog.err("% failed %").c(niceMethodName(trace, 3)).c(status.toString()).flush();
    return false;
}
#method_after
private boolean ok(WifiStatus status) {
    if (status.code == WifiStatusCode.SUCCESS)
        return true;
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    mLog.err("% failed %").c(niceMethodName(trace, 3)).c(status.toString()).flush();
    return false;
}
#end_block

#method_before
private boolean boolResult(boolean result) {
    if (mLog == sNoLog)
        return result;
    // Currently only seen if verbose logging is on
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    mLog.err("% returns %").c(niceMethodName(trace, 3)).c(result).flush();
    return result;
}
#method_after
private boolean boolResult(boolean result) {
    if (mVerboseLog == sNoLog)
        return result;
    // Currently only seen if verbose logging is on
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    mVerboseLog.err("% returns %").c(niceMethodName(trace, 3)).c(result).flush();
    return result;
}
#end_block

#method_before
private WifiLog.LogMessage enter(String format) {
    if (mLog == sNoLog)
        return sNoLog.info(format);
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    return mLog.trace("% " + format).c(trace[3].getMethodName());
}
#method_after
private WifiLog.LogMessage enter(String format) {
    if (mVerboseLog == sNoLog)
        return sNoLog.info(format);
    Thread cur = Thread.currentThread();
    StackTraceElement[] trace = cur.getStackTrace();
    return mVerboseLog.trace("% " + format).c(trace[3].getMethodName());
}
#end_block

#method_before
private void handleRemoteException(RemoteException e) {
    String methodName = niceMethodName(Thread.currentThread().getStackTrace(), 3);
    mErrLog.err("% RemoteException in HIDL call %").c(methodName).c(e.toString()).flush();
}
#method_after
private void handleRemoteException(RemoteException e) {
    String methodName = niceMethodName(Thread.currentThread().getStackTrace(), 3);
    mLog.err("% RemoteException in HIDL call %").c(methodName).c(e.toString()).flush();
}
#end_block

#method_before
public boolean startVendorHal(boolean isStaMode) {
    if (!mHalDeviceManager.start()) {
        mErrLog.e("Failed to start the vendor HAL");
        return false;
    }
    IWifiIface iface;
    if (isStaMode) {
        mIWifiStaIface = mHalDeviceManager.createStaIface(null, null);
        if (mIWifiStaIface == null) {
            mErrLog.e("Failed to create STA Iface. Vendor Hal start failed");
            mHalDeviceManager.stop();
            return false;
        }
        iface = (IWifiIface) mIWifiStaIface;
        if (!registerStaIfaceCallback()) {
            mErrLog.e("Failed to register sta iface callback");
            mHalDeviceManager.stop();
            return false;
        }
        mIWifiRttController = mHalDeviceManager.createRttController(iface);
        if (mIWifiRttController == null) {
            mErrLog.e("Failed to create RTT controller. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        enableLinkLayerStats();
    } else {
        mIWifiApIface = mHalDeviceManager.createApIface(null, null);
        if (mIWifiApIface == null) {
            mErrLog.e("Failed to create AP Iface. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        iface = (IWifiIface) mIWifiApIface;
    }
    mIWifiChip = mHalDeviceManager.getChip(iface);
    if (mIWifiChip == null) {
        mErrLog.e("Failed to get the chip created for the Iface. Vendor Hal start failed");
        stopVendorHal();
        return false;
    }
    if (!registerChipCallback()) {
        mErrLog.e("Failed to register chip callback");
        mHalDeviceManager.stop();
        return false;
    }
    mErrLog.i("Vendor Hal started successfully");
    return true;
}
#method_after
public boolean startVendorHal(boolean isStaMode) {
    if (!mHalDeviceManager.start()) {
        mLog.e("Failed to start the vendor HAL");
        return false;
    }
    IWifiIface iface;
    if (isStaMode) {
        mIWifiStaIface = mHalDeviceManager.createStaIface(null, null);
        if (mIWifiStaIface == null) {
            mLog.e("Failed to create STA Iface. Vendor Hal start failed");
            mHalDeviceManager.stop();
            return false;
        }
        iface = (IWifiIface) mIWifiStaIface;
        if (!registerStaIfaceCallback()) {
            mLog.e("Failed to register sta iface callback");
            mHalDeviceManager.stop();
            return false;
        }
        mIWifiRttController = mHalDeviceManager.createRttController(iface);
        if (mIWifiRttController == null) {
            mLog.e("Failed to create RTT controller. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        enableLinkLayerStats();
    } else {
        mIWifiApIface = mHalDeviceManager.createApIface(null, null);
        if (mIWifiApIface == null) {
            mLog.e("Failed to create AP Iface. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        iface = (IWifiIface) mIWifiApIface;
    }
    mIWifiChip = mHalDeviceManager.getChip(iface);
    if (mIWifiChip == null) {
        mLog.e("Failed to get the chip created for the Iface. Vendor Hal start failed");
        stopVendorHal();
        return false;
    }
    if (!registerChipCallback()) {
        mLog.e("Failed to register chip callback");
        mHalDeviceManager.stop();
        return false;
    }
    mLog.i("Vendor Hal started successfully");
    return true;
}
#end_block

#method_before
public void stopVendorHal() {
    mHalDeviceManager.stop();
    mErrLog.i("Vendor Hal stopped");
}
#method_after
public void stopVendorHal() {
    mHalDeviceManager.stop();
    mLog.i("Vendor Hal stopped");
}
#end_block

#method_before
public boolean getScanCapabilities(WifiNative.ScanCapabilities capabilities) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            MutableBoolean ans = new MutableBoolean(false);
            WifiNative.ScanCapabilities out = capabilities;
            mIWifiStaIface.getBackgroundScanCapabilities((status, cap) -> {
                if (!ok(status))
                    return;
                mLog.info("scan capabilities %").c(cap.toString()).flush();
                out.max_scan_cache_size = cap.maxCacheSize;
                out.max_ap_cache_per_scan = cap.maxApCachePerScan;
                out.max_scan_buckets = cap.maxBuckets;
                out.max_rssi_sample_size = 0;
                out.max_scan_reporting_threshold = cap.maxReportingThreshold;
                out.max_hotlist_bssids = 0;
                out.max_significant_wifi_change_aps = 0;
                out.max_bssid_history_entries = 0;
                out.max_number_epno_networks = 0;
                out.max_number_epno_networks_by_ssid = 0;
                out.max_number_of_white_listed_ssid = 0;
                ans.value = true;
            });
            return ans.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean getScanCapabilities(WifiNative.ScanCapabilities capabilities) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            MutableBoolean ans = new MutableBoolean(false);
            WifiNative.ScanCapabilities out = capabilities;
            mIWifiStaIface.getBackgroundScanCapabilities((status, cap) -> {
                if (!ok(status))
                    return;
                mVerboseLog.info("scan capabilities %").c(cap.toString()).flush();
                out.max_scan_cache_size = cap.maxCacheSize;
                out.max_ap_cache_per_scan = cap.maxApCachePerScan;
                out.max_scan_buckets = cap.maxBuckets;
                out.max_rssi_sample_size = 0;
                out.max_scan_reporting_threshold = cap.maxReportingThreshold;
                out.max_hotlist_bssids = 0;
                out.max_significant_wifi_change_aps = 0;
                out.max_bssid_history_entries = 0;
                out.max_number_epno_networks = 0;
                out.max_number_epno_networks_by_ssid = 0;
                out.max_number_of_white_listed_ssid = 0;
                ans.value = true;
            });
            return ans.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
private void enableLinkLayerStats() {
    synchronized (sLock) {
        try {
            WifiStatus status;
            status = mIWifiStaIface.enableLinkLayerStatsCollection(mLinkLayerStatsDebug);
            if (!ok(status)) {
                mErrLog.e("unable to enable link layer stats collection");
            }
        } catch (RemoteException e) {
            handleRemoteException(e);
        }
    }
}
#method_after
private void enableLinkLayerStats() {
    synchronized (sLock) {
        try {
            WifiStatus status;
            status = mIWifiStaIface.enableLinkLayerStatsCollection(mLinkLayerStatsDebug);
            if (!ok(status)) {
                mLog.e("unable to enable link layer stats collection");
            }
        } catch (RemoteException e) {
            handleRemoteException(e);
        }
    }
}
#end_block

#method_before
/* RTT related commands/events */
public RttManager.RttCapabilities getRttCapabilities() {
    class AnswerBox {

        public RttManager.RttCapabilities value = null;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            mIWifiRttController.getCapabilities((status, capabilities) -> {
                if (!ok(status))
                    return;
                mLog.info("rtt capabilites %").c(capabilities.toString()).flush();
                RttManager.RttCapabilities ans = new RttManager.RttCapabilities();
                ans.oneSidedRttSupported = capabilities.rttOneSidedSupported;
                ans.twoSided11McRttSupported = capabilities.rttFtmSupported;
                ans.lciSupported = capabilities.lciSupported;
                ans.lcrSupported = capabilities.lcrSupported;
                ans.preambleSupported = frameworkPreambleFromHalPreamble(capabilities.preambleSupport);
                ans.bwSupported = frameworkBwFromHalBw(capabilities.bwSupport);
                ans.responderSupported = capabilities.responderSupported;
                ans.secureRttSupported = false;
                ans.mcVersion = ((int) capabilities.mcVersion) & 0xff;
                box.value = ans;
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#method_after
/* RTT related commands/events */
public RttManager.RttCapabilities getRttCapabilities() {
    class AnswerBox {

        public RttManager.RttCapabilities value = null;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            mIWifiRttController.getCapabilities((status, capabilities) -> {
                if (!ok(status))
                    return;
                mVerboseLog.info("rtt capabilites %").c(capabilities.toString()).flush();
                RttManager.RttCapabilities ans = new RttManager.RttCapabilities();
                ans.oneSidedRttSupported = capabilities.rttOneSidedSupported;
                ans.twoSided11McRttSupported = capabilities.rttFtmSupported;
                ans.lciSupported = capabilities.lciSupported;
                ans.lcrSupported = capabilities.lcrSupported;
                ans.preambleSupported = frameworkPreambleFromHalPreamble(capabilities.preambleSupport);
                ans.bwSupported = frameworkBwFromHalBw(capabilities.bwSupport);
                ans.responderSupported = capabilities.responderSupported;
                ans.secureRttSupported = false;
                ans.mcVersion = ((int) capabilities.mcVersion) & 0xff;
                box.value = ans;
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    RttResponder info = getRttResponder();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        if (mRttResponderCmdId != 0) {
            mErrLog.e("responder mode already enabled - this shouldn't happen");
            return null;
        }
        ResponderConfig config = null;
        int id = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            WifiStatus status = mIWifiRttController.enableResponder(/* cmdId */
            id, /* WifiChannelInfo channelHint */
            null, timeoutSeconds, info);
            if (ok(status)) {
                mRttResponderCmdId = id;
                config = frameworkResponderConfigFromHalRttResponder(info);
                mLog.i("enabling rtt " + mRttResponderCmdId);
            }
            return config;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#method_after
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    RttResponder info = getRttResponder();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        if (mRttResponderCmdId != 0) {
            mLog.e("responder mode already enabled - this shouldn't happen");
            return null;
        }
        ResponderConfig config = null;
        int id = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            WifiStatus status = mIWifiRttController.enableResponder(/* cmdId */
            id, /* WifiChannelInfo channelHint */
            null, timeoutSeconds, info);
            if (ok(status)) {
                mRttResponderCmdId = id;
                config = frameworkResponderConfigFromHalRttResponder(info);
                mVerboseLog.i("enabling rtt " + mRttResponderCmdId);
            }
            return config;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    if (handler == null)
        return boolResult(false);
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mLogEventHandler != null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (!ok(status))
                return false;
            mLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    if (handler == null)
        return boolResult(false);
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mVerboseLogEventHandler != null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (!ok(status))
                return false;
            mVerboseLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean resetLogHandler() {
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mLogEventHandler == null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (!ok(status))
                return false;
            status = mIWifiChip.stopLoggingToDebugRingBuffer();
            if (!ok(status))
                return false;
            mLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean resetLogHandler() {
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mVerboseLogEventHandler == null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (!ok(status))
                return false;
            status = mIWifiChip.stopLoggingToDebugRingBuffer();
            if (!ok(status))
                return false;
            mVerboseLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
private void requestChipDebugInfo() {
    mDriverDescription = null;
    mFirmwareDescription = null;
    try {
        if (mIWifiChip == null)
            return;
        mIWifiChip.requestChipDebugInfo((status, chipDebugInfo) -> {
            if (!ok(status))
                return;
            mDriverDescription = chipDebugInfo.driverDescription;
            mFirmwareDescription = chipDebugInfo.firmwareDescription;
        });
    } catch (RemoteException e) {
        handleRemoteException(e);
        return;
    }
    mErrLog.info("Driver: % Firmware: %").c(mDriverDescription).c(mFirmwareDescription).flush();
}
#method_after
private void requestChipDebugInfo() {
    mDriverDescription = null;
    mFirmwareDescription = null;
    try {
        if (mIWifiChip == null)
            return;
        mIWifiChip.requestChipDebugInfo((status, chipDebugInfo) -> {
            if (!ok(status))
                return;
            mDriverDescription = chipDebugInfo.driverDescription;
            mFirmwareDescription = chipDebugInfo.firmwareDescription;
        });
    } catch (RemoteException e) {
        handleRemoteException(e);
        return;
    }
    mLog.info("Driver: % Firmware: %").c(mDriverDescription).c(mFirmwareDescription).flush();
}
#end_block

#method_before
public int enableFirmwareRoaming(int state) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return WifiStatusCode.ERROR_NOT_STARTED;
        try {
            byte val;
            switch(state) {
                case WifiNative.DISABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.DISABLED;
                    break;
                case WifiNative.ENABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.ENABLED;
                    break;
                default:
                    mErrLog.e("enableFirmwareRoaming invalid argument " + state);
                    return WifiStatusCode.ERROR_INVALID_ARGS;
            }
            WifiStatus status = mIWifiStaIface.setRoamingState(val);
            mLog.d("setRoamingState returned " + status.code);
            return status.code;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return WifiStatusCode.ERROR_UNKNOWN;
        }
    }
}
#method_after
public int enableFirmwareRoaming(int state) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return WifiStatusCode.ERROR_NOT_STARTED;
        try {
            byte val;
            switch(state) {
                case WifiNative.DISABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.DISABLED;
                    break;
                case WifiNative.ENABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.ENABLED;
                    break;
                default:
                    mLog.e("enableFirmwareRoaming invalid argument " + state);
                    return WifiStatusCode.ERROR_INVALID_ARGS;
            }
            WifiStatus status = mIWifiStaIface.setRoamingState(val);
            mVerboseLog.d("setRoamingState returned " + status.code);
            return status.code;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return WifiStatusCode.ERROR_UNKNOWN;
        }
    }
}
#end_block

#method_before
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mErrLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
        return true;
    }
}
#method_after
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
        return true;
    }
}
#end_block

#method_before
@Override
public void onBackgroundScanFailure(int cmdId) {
    mLog.d("onBackgroundScanFailure " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
    }
    eventHandler.onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#method_after
@Override
public void onBackgroundScanFailure(int cmdId) {
    mVerboseLog.d("onBackgroundScanFailure " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
    }
    eventHandler.onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#end_block

#method_before
@Override
public void onBackgroundFullScanResult(int cmdId, int bucketsScanned, StaScanResult result) {
    mLog.d("onBackgroundFullScanResult " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
    }
    eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), bucketsScanned);
}
#method_after
@Override
public void onBackgroundFullScanResult(int cmdId, int bucketsScanned, StaScanResult result) {
    mVerboseLog.d("onBackgroundFullScanResult " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
    }
    eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), bucketsScanned);
}
#end_block

#method_before
@Override
public void onBackgroundScanResults(int cmdId, ArrayList<StaScanData> scanDatas) {
    mLog.d("onBackgroundScanResults " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    // locally. This will then be returned to WifiScanner via getScanResults.
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
        mScan.latestScanResults = hidlToFrameworkScanDatas(cmdId, scanDatas);
    }
    eventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
}
#method_after
@Override
public void onBackgroundScanResults(int cmdId, ArrayList<StaScanData> scanDatas) {
    mVerboseLog.d("onBackgroundScanResults " + cmdId);
    WifiNative.ScanEventHandler eventHandler;
    // locally. This will then be returned to WifiScanner via getScanResults.
    synchronized (sLock) {
        if (mScan == null || cmdId != mScan.cmdId)
            return;
        eventHandler = mScan.eventHandler;
        mScan.latestScanResults = hidlToFrameworkScanDatas(cmdId, scanDatas);
    }
    eventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
}
#end_block

#method_before
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    mLog.d("onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
    WifiNative.WifiRssiEventHandler eventHandler;
    synchronized (sLock) {
        if (mWifiRssiEventHandler == null || cmdId != sRssiMonCmdId)
            return;
        eventHandler = mWifiRssiEventHandler;
    }
    eventHandler.onRssiThresholdBreached((byte) currRssi);
}
#method_after
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    mVerboseLog.d("onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
    WifiNative.WifiRssiEventHandler eventHandler;
    synchronized (sLock) {
        if (mWifiRssiEventHandler == null || cmdId != sRssiMonCmdId)
            return;
        eventHandler = mWifiRssiEventHandler;
    }
    eventHandler.onRssiThresholdBreached((byte) currRssi);
}
#end_block

#method_before
@Override
public void onChipReconfigured(int modeId) {
    mLog.d("onChipReconfigured " + modeId);
}
#method_after
@Override
public void onChipReconfigured(int modeId) {
    mVerboseLog.d("onChipReconfigured " + modeId);
}
#end_block

#method_before
@Override
public void onChipReconfigureFailure(WifiStatus status) {
    mLog.d("onChipReconfigureFailure " + status);
}
#method_after
@Override
public void onChipReconfigureFailure(WifiStatus status) {
    mVerboseLog.d("onChipReconfigureFailure " + status);
}
#end_block

#method_before
public void onIfaceAdded(int type, String name) {
    mLog.d("onIfaceAdded " + type + ", name: " + name);
}
#method_after
public void onIfaceAdded(int type, String name) {
    mVerboseLog.d("onIfaceAdded " + type + ", name: " + name);
}
#end_block

#method_before
@Override
public void onIfaceRemoved(int type, String name) {
    mLog.d("onIfaceRemoved " + type + ", name: " + name);
}
#method_after
@Override
public void onIfaceRemoved(int type, String name) {
    mVerboseLog.d("onIfaceRemoved " + type + ", name: " + name);
}
#end_block

#method_before
@Override
public void onDebugRingBufferDataAvailable(WifiDebugRingBufferStatus status, java.util.ArrayList<Byte> data) {
    // TODO(b/35875078) Reinstate logging when execessive callbacks are fixed
    // mLog.d("onDebugRingBufferDataAvailable " + status);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mLogEventHandler == null || status == null || data == null)
            return;
        eventHandler = mLogEventHandler;
    }
    eventHandler.onRingBufferData(ringBufferStatus(status), NativeUtil.byteArrayFromArrayList(data));
}
#method_after
@Override
public void onDebugRingBufferDataAvailable(WifiDebugRingBufferStatus status, java.util.ArrayList<Byte> data) {
    // TODO(b/35875078) Reinstate logging when execessive callbacks are fixed
    // mVerboseLog.d("onDebugRingBufferDataAvailable " + status);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mVerboseLogEventHandler == null || status == null || data == null)
            return;
        eventHandler = mVerboseLogEventHandler;
    }
    eventHandler.onRingBufferData(ringBufferStatus(status), NativeUtil.byteArrayFromArrayList(data));
}
#end_block

#method_before
@Override
public void onDebugErrorAlert(int errorCode, java.util.ArrayList<Byte> debugData) {
    mLog.d("onDebugErrorAlert " + errorCode);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mLogEventHandler == null || debugData == null)
            return;
        eventHandler = mLogEventHandler;
    }
    eventHandler.onWifiAlert(errorCode, NativeUtil.byteArrayFromArrayList(debugData));
}
#method_after
@Override
public void onDebugErrorAlert(int errorCode, java.util.ArrayList<Byte> debugData) {
    mVerboseLog.d("onDebugErrorAlert " + errorCode);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mVerboseLogEventHandler == null || debugData == null)
            return;
        eventHandler = mVerboseLogEventHandler;
    }
    eventHandler.onWifiAlert(errorCode, NativeUtil.byteArrayFromArrayList(debugData));
}
#end_block

#method_before
@Override
public void onStatusChanged() {
    boolean isReady = mHalDeviceManager.isReady();
    boolean isStarted = mHalDeviceManager.isStarted();
    mLog.i("Device Manager onStatusChanged. isReady(): " + isReady + ", isStarted(): " + isStarted);
    // TODO(b/33384303) it could be dicey not having this grab the lock
    if (!isReady || !isStarted) {
        mIWifiChip = null;
        mIWifiStaIface = null;
        mIWifiApIface = null;
        mIWifiRttController = null;
        mDriverDescription = null;
        mFirmwareDescription = null;
    // TODO(b/33384303) likely other things to clear out
    }
}
#method_after
@Override
public void onStatusChanged() {
    boolean isReady = mHalDeviceManager.isReady();
    boolean isStarted = mHalDeviceManager.isStarted();
    mVerboseLog.i("Device Manager onStatusChanged. isReady(): " + isReady + ", isStarted(): " + isStarted);
    // TODO(b/33384303) it could be dicey not having this grab the lock
    if (!isReady || !isStarted) {
        mIWifiChip = null;
        mIWifiStaIface = null;
        mIWifiApIface = null;
        mIWifiRttController = null;
        mDriverDescription = null;
        mFirmwareDescription = null;
    // TODO(b/33384303) likely other things to clear out
    }
}
#end_block

#method_before
public int getMcc(int sid, int tz, int DSTflag, boolean isNitzTimeZone) {
    int tmpMcc = 0;
    // check if SID exists in arbitrary_mcc_sid_match table.
    // these SIDs are assigned to more than 1 operators, but they are known to
    // be used by a specific operator, other operators having the same SID are
    // not using it currently, if that SID is in this table, we don't need to
    // check other tables.
    String[] projection2 = { ArbitraryMccSidMatch.MCC };
    Cursor c2 = resolver.query(ArbitraryMccSidMatch.CONTENT_URI, projection2, ArbitraryMccSidMatch.SID + "=" + sid, null, null);
    if (c2 != null) {
        int c2Counter = c2.getCount();
        if (DBG) {
            Rlog.d(LOG_TAG, "Query unresolved arbitrary table, entries are " + c2Counter);
        }
        if (c2Counter == 1) {
            if (DBG) {
                Rlog.d(LOG_TAG, "Query Unresolved arbitrary returned the cursor " + c2);
            }
            c2.moveToFirst();
            tmpMcc = c2.getInt(0);
            if (DBG) {
                Rlog.d(LOG_TAG, "MCC found in arbitrary_mcc_sid_match: " + tmpMcc);
            }
            c2.close();
            return tmpMcc;
        }
        c2.close();
    }
    // Then check if SID exists in mcc_sid_conflict table.
    // and use the timezone in mcc_lookup table to check which MCC matches.
    String[] projection3 = { MccSidConflicts.MCC };
    Cursor c3 = resolver.query(MccSidConflicts.CONTENT_URI, projection3, MccSidConflicts.SID_CONFLICT + "=" + sid + " and (((" + MccLookup.GMT_OFFSET_LOW + "<=" + tz + ") and (" + tz + "<=" + MccLookup.GMT_OFFSET_HIGH + ") and (" + "0=" + DSTflag + ")) or ((" + MccLookup.GMT_DST_LOW + "<=" + tz + ") and (" + tz + "<=" + MccLookup.GMT_DST_HIGH + ") and (" + "1=" + DSTflag + ")))", null, null);
    if (c3 != null) {
        int c3Counter = c3.getCount();
        if (c3Counter > 0) {
            if (c3Counter > 1) {
                Rlog.w(LOG_TAG, "something wrong, get more results for 1 conflict SID: " + c3);
            }
            if (DBG)
                Rlog.d(LOG_TAG, "Query conflict sid returned the cursor " + c3);
            c3.moveToFirst();
            tmpMcc = c3.getInt(0);
            if (DBG) {
                Rlog.d(LOG_TAG, "MCC found in mcc_lookup_table. Return tmpMcc = " + tmpMcc);
            }
            c3.close();
            if (isNitzTimeZone) {
                return tmpMcc;
            } else {
                // time zone is not accurate, it may get wrong mcc, ignore it.
                if (DBG) {
                    Rlog.d(LOG_TAG, "time zone is not accurate, mcc may be " + tmpMcc);
                }
                return 0;
            }
        }
        c3.close();
    }
    // if there is no conflict, then check if SID is in mcc_sid_range.
    String[] projection5 = { MccSidRange.MCC };
    Cursor c5 = resolver.query(MccSidRange.CONTENT_URI, projection5, MccSidRange.RANGE_LOW + "<=" + sid + " and " + MccSidRange.RANGE_HIGH + ">=" + sid, null, null);
    if (c5 != null) {
        if (c5.getCount() > 0) {
            if (DBG)
                Rlog.d(LOG_TAG, "Query Range returned the cursor " + c5);
            c5.moveToFirst();
            tmpMcc = c5.getInt(0);
            if (DBG)
                Rlog.d(LOG_TAG, "SID found in mcc_sid_range. Return tmpMcc = " + tmpMcc);
            c5.close();
            return tmpMcc;
        }
        c5.close();
    }
    if (DBG)
        Rlog.d(LOG_TAG, "SID NOT found in mcc_sid_range.");
    if (DBG)
        Rlog.d(LOG_TAG, "Exit getMccByOtherFactors. Return tmpMcc =  " + tmpMcc);
    // If unknown MCC still could not be resolved,
    return tmpMcc;
}
#method_after
public int getMcc(int sid, int tz, int DSTflag, boolean isNitzTimeZone) {
    int tmpMcc = 0;
    // check if SID exists in arbitrary_mcc_sid_match table.
    // these SIDs are assigned to more than 1 operators, but they are known to
    // be used by a specific operator, other operators having the same SID are
    // not using it currently, if that SID is in this table, we don't need to
    // check other tables.
    String[] projection2 = { ArbitraryMccSidMatch.MCC };
    Cursor c2 = resolver.query(ArbitraryMccSidMatch.CONTENT_URI, projection2, ArbitraryMccSidMatch.SID + "=" + sid, null, null);
    if (c2 != null) {
        int c2Counter = c2.getCount();
        if (DBG) {
            Rlog.d(LOG_TAG, "Query unresolved arbitrary table, entries are " + c2Counter);
        }
        if (c2Counter == 1) {
            if (DBG) {
                Rlog.d(LOG_TAG, "Query Unresolved arbitrary returned the cursor " + c2);
            }
            c2.moveToFirst();
            tmpMcc = c2.getInt(0);
            if (DBG) {
                Rlog.d(LOG_TAG, "MCC found in arbitrary_mcc_sid_match: " + tmpMcc);
            }
            c2.close();
            return tmpMcc;
        }
        c2.close();
    }
    // Then check if SID exists in mcc_sid_conflict table.
    // and use the timezone in mcc_lookup table to check which MCC matches.
    String[] projection3 = { MccSidConflicts.MCC };
    Cursor c3 = resolver.query(MccSidConflicts.CONTENT_URI, projection3, MccSidConflicts.SID_CONFLICT + "=" + sid + " and (((" + MccLookup.GMT_OFFSET_LOW + "<=" + tz + ") and (" + tz + "<=" + MccLookup.GMT_OFFSET_HIGH + ") and (" + "0=" + DSTflag + ")) or ((" + MccLookup.GMT_DST_LOW + "<=" + tz + ") and (" + tz + "<=" + MccLookup.GMT_DST_HIGH + ") and (" + "1=" + DSTflag + ")))", null, null);
    if (c3 != null) {
        int c3Counter = c3.getCount();
        if (c3Counter > 0) {
            if (c3Counter > 1) {
                Rlog.w(LOG_TAG, "something wrong, get more results for 1 conflict SID: " + c3);
            }
            if (DBG)
                Rlog.d(LOG_TAG, "Query conflict sid returned the cursor " + c3);
            c3.moveToFirst();
            tmpMcc = c3.getInt(0);
            if (DBG) {
                Rlog.d(LOG_TAG, "MCC found in mcc_lookup_table. Return tmpMcc = " + tmpMcc);
            }
            if (!isNitzTimeZone) {
                // time zone is not accurate, it may get wrong mcc, ignore it.
                if (DBG) {
                    Rlog.d(LOG_TAG, "time zone is not accurate, mcc may be " + tmpMcc);
                }
                tmpMcc = 0;
            }
            c3.close();
            return tmpMcc;
        } else {
            c3.close();
        }
    }
    // if there is no conflict, then check if SID is in mcc_sid_range.
    String[] projection5 = { MccSidRange.MCC };
    Cursor c5 = resolver.query(MccSidRange.CONTENT_URI, projection5, MccSidRange.RANGE_LOW + "<=" + sid + " and " + MccSidRange.RANGE_HIGH + ">=" + sid, null, null);
    if (c5 != null) {
        if (c5.getCount() > 0) {
            if (DBG)
                Rlog.d(LOG_TAG, "Query Range returned the cursor " + c5);
            c5.moveToFirst();
            tmpMcc = c5.getInt(0);
            if (DBG)
                Rlog.d(LOG_TAG, "SID found in mcc_sid_range. Return tmpMcc = " + tmpMcc);
            c5.close();
            return tmpMcc;
        }
        c5.close();
    }
    if (DBG)
        Rlog.d(LOG_TAG, "SID NOT found in mcc_sid_range.");
    if (DBG)
        Rlog.d(LOG_TAG, "Exit getMccByOtherFactors. Return tmpMcc =  " + tmpMcc);
    // If unknown MCC still could not be resolved,
    return tmpMcc;
}
#end_block

#method_before
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        final String profileName = new String(mKeyStore.get(Credentials.LOCKDOWN_VPN));
        final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
        if (profile == null) {
            Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
            setLockdownTracker(null);
            return true;
        }
        int user = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (mVpns) {
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#method_after
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        byte[] profileTag = mKeyStore.get(Credentials.LOCKDOWN_VPN);
        if (profileTag == null) {
            Slog.e(TAG, "Lockdown VPN configured but cannot be read from keystore");
            return false;
        }
        String profileName = new String(profileTag);
        final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
        if (profile == null) {
            Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
            setLockdownTracker(null);
            return true;
        }
        int user = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (mVpns) {
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0 || timeoutMs > ConnectivityManager.MAX_NETWORK_REQUEST_TIMEOUT_MS) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkCapabilities.getNetworkSpecifier())) {
        throw new IllegalArgumentException("Invalid network specifier - must not be '" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + "'");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkCapabilities.getNetworkSpecifier())) {
        throw new IllegalArgumentException("Invalid network specifier - must not be '" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + "'");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkCallback(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        synchronized (ConnectivityService.this) {
            // to reconnect over the new network
            if (mNetTransitionWakeLock.isHeld()) {
                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK, mNetTransitionWakeLockSerialNumber, 0), 1000);
            }
        }
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkCallback(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        synchronized (ConnectivityService.this) {
            // to reconnect over the new network
            if (mNetTransitionWakeLock.isHeld()) {
                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK, mNetTransitionWakeLockSerialNumber, 0), 1000);
            }
        }
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (oldInfo != null && oldInfo.getState() == state) {
        if (oldInfo.isRoaming() != newInfo.isRoaming()) {
            if (VDBG)
                log("roaming status changed, notifying NetworkStatsService");
            notifyIfacesChangedForNetworkStats();
        } else if (VDBG)
            log("ignoring duplicate network state non-change");
        // In either case, no further work should be needed.
        return;
    }
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        updateLinkProperties(networkAgent, null);
        notifyIfacesChangedForNetworkStats();
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (oldInfo != null && oldInfo.getState() == state) {
        if (oldInfo.isRoaming() != newInfo.isRoaming()) {
            if (VDBG)
                log("roaming status changed, notifying NetworkStatsService");
            notifyIfacesChangedForNetworkStats();
        } else if (VDBG)
            log("ignoring duplicate network state non-change");
        // In either case, no further work should be needed.
        return;
    }
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        updateLinkProperties(networkAgent, null);
        notifyIfacesChangedForNetworkStats();
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
public String toString() {
    return String.format("%s (%s)", state, network);
}
#method_after
public String toString() {
    return String.format("%s (%s) (%s)", state, network, arg);
}
#end_block

#method_before
void expectCallback(CallbackState state, MockNetworkAgent mockAgent, int timeoutMs) {
    CallbackInfo expected = new CallbackInfo(state, (mockAgent != null) ? mockAgent.getNetwork() : null, 0);
    CallbackInfo actual = nextCallback(timeoutMs);
    assertEquals("Unexpected callback:", expected, actual);
    if (state == CallbackState.LOSING) {
        String msg = String.format("Invalid linger time value %d, must be between %d and %d", actual.arg, 0, TEST_LINGER_DELAY_MS);
        int maxMsToLive = (Integer) actual.arg;
        assertTrue(msg, 0 <= maxMsToLive && maxMsToLive <= TEST_LINGER_DELAY_MS);
    }
}
#method_after
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent agent, int timeoutMs) {
    final Network expectedNetwork = (agent != null) ? agent.getNetwork() : null;
    CallbackInfo expected = new CallbackInfo(state, expectedNetwork, 0);
    CallbackInfo actual = nextCallback(timeoutMs);
    assertEquals("Unexpected callback:", expected, actual);
    if (state == CallbackState.LOSING) {
        String msg = String.format("Invalid linger time value %d, must be between %d and %d", actual.arg, 0, TEST_LINGER_DELAY_MS);
        int maxMsToLive = (Integer) actual.arg;
        assertTrue(msg, 0 <= maxMsToLive && maxMsToLive <= TEST_LINGER_DELAY_MS);
    }
    return actual;
}
#end_block

#method_before
void expectCallback(CallbackState state, MockNetworkAgent mockAgent) {
    expectCallback(state, mockAgent, TIMEOUT_MS);
}
#method_after
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent agent) {
    return expectCallback(state, agent, TIMEOUT_MS);
}
#end_block

#method_before
@SmallTest
public void testStateChangeNetworkCallbacks() throws Exception {
    final TestNetworkCallback genericNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback wifiNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest genericRequest = new NetworkRequest.Builder().clearCapabilities().build();
    final NetworkRequest wifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(genericRequest, genericNetworkCallback);
    mCm.registerNetworkCallback(wifiRequest, wifiNetworkCallback);
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    // Test unvalidated networks
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(false);
    genericNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    genericNetworkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // Test validated networks
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    genericNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    genericNetworkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    genericNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
}
#method_after
@SmallTest
public void testStateChangeNetworkCallbacks() throws Exception {
    final TestNetworkCallback genericNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback wifiNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest genericRequest = new NetworkRequest.Builder().clearCapabilities().build();
    final NetworkRequest wifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(genericRequest, genericNetworkCallback);
    mCm.registerNetworkCallback(wifiRequest, wifiNetworkCallback);
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    // Test unvalidated networks
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // Test validated networks
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    genericNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    genericNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
}
#end_block

#method_before
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectCallback(CallbackState.AVAILABLE, newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    defaultCallback.assertNoCallback();
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#method_after
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mEthernetNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mEthernetNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectAvailableCallbacks(newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    // We expect a notification about the capabilities change, and nothing else.
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_NOT_METERED, mWiFiNetworkAgent);
    defaultCallback.assertNoCallback();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#end_block

#method_before
@SmallTest
public void testMMSonWiFi() throws Exception {
    // Test bringing up cellular without MMS NetworkRequest gets reaped
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    ConditionVariable cv = mCellNetworkAgent.getDisconnectedCV();
    mCellNetworkAgent.connectWithoutInternet();
    waitFor(cv);
    mService.waitForIdle();
    assertEquals(0, mCm.getAllNetworks().length);
    verifyNoNetwork();
    // Test bringing up validated WiFi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    cv = waitForConnectivityBroadcasts(1);
    mWiFiNetworkAgent.connect(true);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_WIFI);
    // Register MMS NetworkRequest
    NetworkRequest.Builder builder = new NetworkRequest.Builder();
    builder.addCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(builder.build(), networkCallback);
    // Test bringing up unvalidated cellular with MMS
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    mCellNetworkAgent.connectWithoutInternet();
    networkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    verifyActiveNetwork(TRANSPORT_WIFI);
    // Test releasing NetworkRequest disconnects cellular with MMS
    cv = mCellNetworkAgent.getDisconnectedCV();
    mCm.unregisterNetworkCallback(networkCallback);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_WIFI);
}
#method_after
@SmallTest
public void testMMSonWiFi() throws Exception {
    // Test bringing up cellular without MMS NetworkRequest gets reaped
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    ConditionVariable cv = mCellNetworkAgent.getDisconnectedCV();
    mCellNetworkAgent.connectWithoutInternet();
    waitFor(cv);
    mService.waitForIdle();
    assertEquals(0, mCm.getAllNetworks().length);
    verifyNoNetwork();
    // Test bringing up validated WiFi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    cv = waitForConnectivityBroadcasts(1);
    mWiFiNetworkAgent.connect(true);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_WIFI);
    // Register MMS NetworkRequest
    NetworkRequest.Builder builder = new NetworkRequest.Builder();
    builder.addCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(builder.build(), networkCallback);
    // Test bringing up unvalidated cellular with MMS
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    mCellNetworkAgent.connectWithoutInternet();
    networkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    verifyActiveNetwork(TRANSPORT_WIFI);
    // Test releasing NetworkRequest disconnects cellular with MMS
    cv = mCellNetworkAgent.getDisconnectedCV();
    mCm.unregisterNetworkCallback(networkCallback);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_WIFI);
}
#end_block

#method_before
@SmallTest
public void testMMSonCell() throws Exception {
    // Test bringing up cellular without MMS
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.connect(false);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
    // Register MMS NetworkRequest
    NetworkRequest.Builder builder = new NetworkRequest.Builder();
    builder.addCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(builder.build(), networkCallback);
    // Test bringing up MMS cellular network
    MockNetworkAgent mmsNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mmsNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    mmsNetworkAgent.connectWithoutInternet();
    networkCallback.expectCallback(CallbackState.AVAILABLE, mmsNetworkAgent);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
    // Test releasing MMS NetworkRequest does not disconnect main cellular NetworkAgent
    cv = mmsNetworkAgent.getDisconnectedCV();
    mCm.unregisterNetworkCallback(networkCallback);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
}
#method_after
@SmallTest
public void testMMSonCell() throws Exception {
    // Test bringing up cellular without MMS
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.connect(false);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
    // Register MMS NetworkRequest
    NetworkRequest.Builder builder = new NetworkRequest.Builder();
    builder.addCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(builder.build(), networkCallback);
    // Test bringing up MMS cellular network
    MockNetworkAgent mmsNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mmsNetworkAgent.addCapability(NET_CAPABILITY_MMS);
    mmsNetworkAgent.connectWithoutInternet();
    networkCallback.expectAvailableCallbacks(mmsNetworkAgent);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
    // Test releasing MMS NetworkRequest does not disconnect main cellular NetworkAgent
    cv = mmsNetworkAgent.getDisconnectedCV();
    mCm.unregisterNetworkCallback(networkCallback);
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_CELLULAR);
}
#end_block

#method_before
@SmallTest
public void testCaptivePortal() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    captivePortalCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), firstRedirectUrl);
    // Take down network.
    // Expect onLost callback.
    mWiFiNetworkAgent.disconnect();
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    captivePortalCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), secondRedirectUrl);
    // Make captive portal disappear then revalidate.
    // Expect onLost callback because network no longer provides NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 204;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // Break network connectivity.
    // Expect NET_CAPABILITY_VALIDATED onLost callback.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 500;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), false);
    validatedCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
}
#method_after
@SmallTest
public void testCaptivePortal() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), firstRedirectUrl);
    // Take down network.
    // Expect onLost callback.
    mWiFiNetworkAgent.disconnect();
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), secondRedirectUrl);
    // Make captive portal disappear then revalidate.
    // Expect onLost callback because network no longer provides NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 204;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate only sending available callbacks.
    validatedCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // Break network connectivity.
    // Expect NET_CAPABILITY_VALIDATED onLost callback.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 500;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), false);
    validatedCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
}
#end_block

#method_before
@SmallTest
public void testAvoidOrIgnoreCaptivePortals() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_AVOID);
    // Bring up a network with a captive portal.
    // Expect it to fail to connect and not result in any callbacks.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    ConditionVariable disconnectCv = mWiFiNetworkAgent.getDisconnectedCV();
    ConditionVariable avoidCv = mWiFiNetworkAgent.getPreventReconnectReceived();
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    waitFor(disconnectCv);
    waitFor(avoidCv);
    assertNoCallbacks(captivePortalCallback, validatedCallback);
    // Now test ignore mode.
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_IGNORE);
    // Bring up a network with a captive portal.
    // Since we're ignoring captive portals, the network will validate.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // But there should be no CaptivePortal callback.
    captivePortalCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testAvoidOrIgnoreCaptivePortals() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_AVOID);
    // Bring up a network with a captive portal.
    // Expect it to fail to connect and not result in any callbacks.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    ConditionVariable disconnectCv = mWiFiNetworkAgent.getDisconnectedCV();
    ConditionVariable avoidCv = mWiFiNetworkAgent.getPreventReconnectReceived();
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    waitFor(disconnectCv);
    waitFor(avoidCv);
    assertNoCallbacks(captivePortalCallback, validatedCallback);
    // Now test ignore mode.
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_IGNORE);
    // Bring up a network with a captive portal.
    // Since we're ignoring captive portals, the network will validate.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // But there should be no CaptivePortal callback.
    captivePortalCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testRegisterDefaultNetworkCallback() throws Exception {
    final TestNetworkCallback defaultNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultNetworkCallback);
    defaultNetworkCallback.assertNoCallback();
    // Create a TRANSPORT_CELLULAR request to keep the mobile interface up
    // whenever Wi-Fi is up. Without this, the mobile network agent is
    // reaped before any other activity can take place.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    cellNetworkCallback.assertNoCallback();
    // Bring up cell and expect CALLBACK_AVAILABLE.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Bring up wifi and expect CALLBACK_AVAILABLE.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // Bring down cell. Expect no default network callback, since it wasn't the default.
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring up cell. Expect no default network callback, since it won't be the default.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring down wifi. Expect the default network callback to notified of LOST wifi
    // followed by AVAILABLE cell.
    mWiFiNetworkAgent.disconnect();
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
}
#method_after
@SmallTest
public void testRegisterDefaultNetworkCallback() throws Exception {
    final TestNetworkCallback defaultNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultNetworkCallback);
    defaultNetworkCallback.assertNoCallback();
    // Create a TRANSPORT_CELLULAR request to keep the mobile interface up
    // whenever Wi-Fi is up. Without this, the mobile network agent is
    // reaped before any other activity can take place.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    cellNetworkCallback.assertNoCallback();
    // Bring up cell and expect CALLBACK_AVAILABLE.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    // Bring up wifi and expect CALLBACK_AVAILABLE.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    // Bring down cell. Expect no default network callback, since it wasn't the default.
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring up cell. Expect no default network callback, since it won't be the default.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring down wifi. Expect the default network callback to notified of LOST wifi
    // followed by AVAILABLE cell.
    mWiFiNetworkAgent.disconnect();
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
}
#end_block

#method_before
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    mService.waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    cellCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Because the network is already up.
    callback.assertNoCallback();
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#method_after
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    mService.waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    // NOTE: This request causes the network's capabilities to change. This
    // is currently delivered before the onAvailable() callbacks.
    // TODO: Fix this.
    cellCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    cellCallback.expectAvailableCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Expect a network capabilities update with FOREGROUND, because the most recent
    // request causes its state to change.
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#end_block

#method_before
@SmallTest
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setMobileDataAlwaysOn(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertEquals(1, mCm.getAllNetworks().length);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    mService.waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertEquals(2, mCm.getAllNetworks().length);
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setMobileDataAlwaysOn(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertEquals(1, mCm.getAllNetworks().length);
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#method_after
@SmallTest
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setMobileDataAlwaysOn(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertEquals(1, mCm.getAllNetworks().length);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    mService.waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertEquals(2, mCm.getAllNetworks().length);
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setMobileDataAlwaysOn(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertEquals(1, mCm.getAllNetworks().length);
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#end_block

#method_before
@SmallTest
public void testAvoidBadWifi() throws Exception {
    final ContentResolver cr = mServiceContext.getContentResolver();
    final WrappedMultinetworkPolicyTracker tracker = mService.getMultinetworkPolicyTracker();
    // Pretend we're on a carrier that restricts switching away from bad wifi.
    tracker.configRestrictsAvoidBadWifi = true;
    // File a request for cell to ensure it doesn't go down.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    NetworkRequest validatedWifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).addCapability(NET_CAPABILITY_VALIDATED).build();
    TestNetworkCallback validatedWifiCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(validatedWifiRequest, validatedWifiCallback);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 0);
    tracker.reevaluate();
    // Bring up validated cell.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    Network cellNetwork = mCellNetworkAgent.getNetwork();
    // Bring up validated wifi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    Network wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Because avoid bad wifi is off, we don't switch to cellular.
    defaultCallback.assertNoCallback();
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate switching to a carrier that does not restrict avoiding bad wifi, and expect
    // that we switch back to cell.
    tracker.configRestrictsAvoidBadWifi = false;
    tracker.reevaluate();
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Switch back to a restrictive carrier.
    tracker.configRestrictsAvoidBadWifi = true;
    tracker.reevaluate();
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate the user selecting "switch" on the dialog, and check that we switch to cell.
    mCm.setAvoidUnvalidated(wifiNetwork);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Disconnect and reconnect wifi to clear the one-time switch above.
    mWiFiNetworkAgent.disconnect();
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi and expect the dialog to appear.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Simulate the user selecting "switch" and checking the don't ask again checkbox.
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    // We now switch to cell.
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Simulate the user turning the cellular fallback setting off and then on.
    // We switch to wifi and then to cell.
    Settings.Global.putString(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
    tracker.reevaluate();
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // If cell goes down, we switch to wifi.
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    validatedWifiCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    mCm.unregisterNetworkCallback(validatedWifiCallback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#method_after
@SmallTest
public void testAvoidBadWifi() throws Exception {
    final ContentResolver cr = mServiceContext.getContentResolver();
    final WrappedMultinetworkPolicyTracker tracker = mService.getMultinetworkPolicyTracker();
    // Pretend we're on a carrier that restricts switching away from bad wifi.
    tracker.configRestrictsAvoidBadWifi = true;
    // File a request for cell to ensure it doesn't go down.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    NetworkRequest validatedWifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).addCapability(NET_CAPABILITY_VALIDATED).build();
    TestNetworkCallback validatedWifiCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(validatedWifiRequest, validatedWifiCallback);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 0);
    tracker.reevaluate();
    // Bring up validated cell.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    Network cellNetwork = mCellNetworkAgent.getNetwork();
    // Bring up validated wifi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    Network wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Because avoid bad wifi is off, we don't switch to cellular.
    defaultCallback.assertNoCallback();
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate switching to a carrier that does not restrict avoiding bad wifi, and expect
    // that we switch back to cell.
    tracker.configRestrictsAvoidBadWifi = false;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Switch back to a restrictive carrier.
    tracker.configRestrictsAvoidBadWifi = true;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate the user selecting "switch" on the dialog, and check that we switch to cell.
    mCm.setAvoidUnvalidated(wifiNetwork);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Disconnect and reconnect wifi to clear the one-time switch above.
    mWiFiNetworkAgent.disconnect();
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi and expect the dialog to appear.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Simulate the user selecting "switch" and checking the don't ask again checkbox.
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    // We now switch to cell.
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Simulate the user turning the cellular fallback setting off and then on.
    // We switch to wifi and then to cell.
    Settings.Global.putString(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // If cell goes down, we switch to wifi.
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    mCm.unregisterNetworkCallback(validatedWifiCallback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#end_block

#method_before
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int timeoutMs = 150;
    mCm.requestNetwork(nr, networkCallback, timeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, timeoutMs);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int timeoutMs = 150;
    mCm.requestNetwork(nr, networkCallback, timeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, timeoutMs);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int requestTimeoutMs = 100;
    mCm.requestNetwork(nr, networkCallback, requestTimeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    final int assertTimeoutMs = 150;
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, assertTimeoutMs);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(100);
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int requestTimeoutMs = 100;
    mCm.requestNetwork(nr, networkCallback, requestTimeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    final int assertTimeoutMs = 150;
    networkCallback.expectAvailableCallbacks(mWiFiNetworkAgent, false, assertTimeoutMs);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(100);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
public String toString() {
    return android.text.format.DateFormat.format("MM-dd hh:mm:ss ", mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " by " + mPackageName;
}
#method_after
public String toString() {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss ", mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " by " + mPackageName;
}
#end_block

#method_before
public int updateBleAppCount(IBinder token, boolean enable, String packageName) {
    ClientDeathRecipient r = mBleApps.get(token);
    if (r == null && enable) {
        ClientDeathRecipient deathRec = new ClientDeathRecipient(packageName);
        try {
            token.linkToDeath(deathRec, 0);
        } catch (RemoteException ex) {
            throw new IllegalArgumentException("BLE app (" + packageName + ") already dead!");
        }
        mBleApps.put(token, deathRec);
        if (DBG)
            Slog.d(TAG, "Registered for death of " + packageName);
    } else if (!enable && r != null) {
        // Unregister death recipient as the app goes away.
        token.unlinkToDeath(r, 0);
        mBleApps.remove(token);
        if (DBG)
            Slog.d(TAG, "Unregistered for death of " + packageName);
    }
    int appCount = mBleApps.size();
    if (DBG)
        Slog.d(TAG, appCount + " registered Ble Apps");
    // [NOTE][MSB]: In all of my testing mEnable is always false at this point
    if (appCount == 0 && mEnable) {
        disableBleScanMode();
    }
    if (appCount == 0 && mShouldContinueTurningOff) {
        // Reset flag
        mShouldContinueTurningOff = false;
        // [NOTE][MSB]: b/34707848
        // Issue: service teardown is never continued/completed
        // Solution: hold flag, and switch on flag
        // Info:
        // When the adapter is toggled off; when there are BLE apps registered, a
        // request is sent to unregister all of the BLE apps.  Upon unregister each app
        // will call through to this function via a callback.  When this gets called if
        // the ble app count is 0, we can disable everything.  I am keeping track of the
        // flag so that we know explicitly where we are coming from.
        // 
        // Call stack:
        // - BluetoothAdapter#enableBLE/disableBLE
        // - updateBleAppCount(...)
        // Lets resend now
        sendBrEdrDownCallback();
    }
    return appCount;
}
#method_after
public int updateBleAppCount(IBinder token, boolean enable, String packageName) {
    ClientDeathRecipient r = mBleApps.get(token);
    if (r == null && enable) {
        ClientDeathRecipient deathRec = new ClientDeathRecipient(packageName);
        try {
            token.linkToDeath(deathRec, 0);
        } catch (RemoteException ex) {
            throw new IllegalArgumentException("BLE app (" + packageName + ") already dead!");
        }
        mBleApps.put(token, deathRec);
        if (DBG)
            Slog.d(TAG, "Registered for death of " + packageName);
    } else if (!enable && r != null) {
        // Unregister death recipient as the app goes away.
        token.unlinkToDeath(r, 0);
        mBleApps.remove(token);
        if (DBG)
            Slog.d(TAG, "Unregistered for death of " + packageName);
    }
    int appCount = mBleApps.size();
    if (DBG)
        Slog.d(TAG, appCount + " registered Ble Apps");
    if (appCount == 0 && mEnable) {
        disableBleScanMode();
    }
    if (appCount == 0 && !mEnableExternal) {
        sendBrEdrDownCallback();
    }
    return appCount;
}
#end_block

#method_before
private void sendBrEdrDownCallback() {
    if (DBG)
        Slog.d(TAG, "Calling sendBrEdrDownCallback callbacks");
    if (mBluetooth == null) {
        Slog.w(TAG, "Bluetooth handle is null");
        return;
    }
    if (isBleAppPresent()) {
        // Need to stay at BLE ON. Disconnect all Gatt connections
        try {
            // FLAG NEED TO CONTINUE SHUTDOWN
            mShouldContinueTurningOff = true;
            mBluetoothGatt.unregAll();
        } catch (RemoteException e) {
            Slog.e(TAG, "Unable to disconnect all apps.", e);
        }
    } else {
        try {
            mBluetoothLock.readLock().lock();
            if (mBluetooth != null)
                mBluetooth.onBrEdrDown();
        } catch (RemoteException e) {
            Slog.e(TAG, "Call to onBrEdrDown() failed.", e);
        } finally {
            mBluetoothLock.readLock().unlock();
        }
    }
}
#method_after
private void sendBrEdrDownCallback() {
    if (DBG)
        Slog.d(TAG, "Calling sendBrEdrDownCallback callbacks");
    if (mBluetooth == null) {
        Slog.w(TAG, "Bluetooth handle is null");
        return;
    }
    if (isBleAppPresent()) {
        // Need to stay at BLE ON. Disconnect all Gatt connections
        try {
            mBluetoothGatt.unregAll();
        } catch (RemoteException e) {
            Slog.e(TAG, "Unable to disconnect all apps.", e);
        }
    } else {
        try {
            mBluetoothLock.readLock().lock();
            if (mBluetooth != null)
                mBluetooth.onBrEdrDown();
        } catch (RemoteException e) {
            Slog.e(TAG, "Call to onBrEdrDown() failed.", e);
        } finally {
            mBluetoothLock.readLock().unlock();
        }
    }
}
#end_block

#method_before
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    PackageManagerService packageManagerService = (PackageManagerService) ServiceManager.getService("package");
    if (packageManagerService != null && !packageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, "system boot");
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#method_after
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    PackageManagerService packageManagerService = (PackageManagerService) ServiceManager.getService("package");
    if (packageManagerService != null && !packageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, REASON_SYSTEM_BOOT);
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#end_block

#method_before
public String toString() {
    return android.text.format.DateFormat.format("MM-dd hh:mm:ss ", mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " by " + mPackageName;
}
#method_after
public String toString() {
    return android.text.format.DateFormat.format("MM-dd HH:mm:ss ", mTimestamp) + (mEnable ? "  Enabled " : " Disabled ") + " by " + mPackageName;
}
#end_block

#method_before
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    PackageManagerService packageManagerService = (PackageManagerService) ServiceManager.getService("package");
    if (packageManagerService != null && !packageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, "system boot");
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#method_after
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    PackageManagerService packageManagerService = (PackageManagerService) ServiceManager.getService("package");
    if (packageManagerService != null && !packageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, REASON_SYSTEM_BOOT);
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#end_block

#method_before
public void testIfPresent() {
    IntConsumer alwaysFails = new IntConsumer() {

        @Override
        public void accept(int value) {
            fail();
        }
    };
    OptionalInt.empty().ifPresent(alwaysFails);
    final AtomicInteger reference = new AtomicInteger();
    IntConsumer recorder = new IntConsumer() {

        @Override
        public void accept(int value) {
            reference.set(value);
        }
    };
    OptionalInt.of(56).ifPresent(recorder);
    assertEquals(56, reference.get());
}
#method_after
public void testIfPresent() {
    IntConsumer alwaysFails = value -> fail();
    OptionalInt.empty().ifPresent(alwaysFails);
    final AtomicInteger reference = new AtomicInteger();
    IntConsumer recorder = value -> reference.set(value);
    ;
    OptionalInt.of(56).ifPresent(recorder);
    assertEquals(56, reference.get());
}
#end_block

#method_before
public void testOrElseGet() {
    IntSupplier alwaysFails = new IntSupplier() {

        @Override
        public int getAsInt() {
            fail();
            // unreachable;
            return 57;
        }
    };
    assertEquals(56, OptionalInt.of(56).orElseGet(alwaysFails));
    IntSupplier supplies57 = new IntSupplier() {

        @Override
        public int getAsInt() {
            return 57;
        }
    };
    assertEquals(57, OptionalInt.empty().orElseGet(supplies57));
}
#method_after
public void testOrElseGet() {
    IntSupplier alwaysFails = () -> {
        fail();
        return 57;
    };
    assertEquals(56, OptionalInt.of(56).orElseGet(alwaysFails));
    IntSupplier supplies57 = () -> 57;
    assertEquals(57, OptionalInt.empty().orElseGet(supplies57));
}
#end_block

#method_before
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = new Supplier<IOException>() {

        @Override
        public IOException get() {
            return bar;
        }
    };
    assertEquals(57, OptionalInt.of(57).orElseThrow(barSupplier));
    try {
        OptionalInt.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#method_after
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = () -> bar;
    assertEquals(57, OptionalInt.of(57).orElseThrow(barSupplier));
    try {
        OptionalInt.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#end_block

#method_before
public void testIfPresent() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Consumer<String> alwaysFail = new Consumer<String>() {

        @Override
        public void accept(String s) {
            fail();
        }
    };
    // alwaysFail must never be called.
    empty.ifPresent(alwaysFail);
    ofNull.ifPresent(alwaysFail);
    final AtomicReference<String> reference = new AtomicReference<>();
    String foo = "foo";
    Optional.of(foo).ifPresent(new Consumer<String>() {

        @Override
        public void accept(String s) {
            reference.set(s);
        }
    });
    assertSame(foo, reference.get());
}
#method_after
public void testIfPresent() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Consumer<String> alwaysFail = s -> fail();
    // alwaysFail must never be called.
    empty.ifPresent(alwaysFail);
    ofNull.ifPresent(alwaysFail);
    final AtomicReference<String> reference = new AtomicReference<>();
    String foo = "foo";
    Optional.of(foo).ifPresent(s -> reference.set(s));
    assertSame(foo, reference.get());
}
#end_block

#method_before
public void testFilter() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Predicate<String> alwaysFail = new Predicate<String>() {

        @Override
        public boolean test(String s) {
            fail();
            // unreachable.
            return true;
        }
    };
    // If isPresent() == false, optional always return itself (!!).
    assertSame(empty, empty.filter(alwaysFail));
    assertSame(empty, empty.filter(alwaysFail));
    assertSame(ofNull, ofNull.filter(alwaysFail));
    assertSame(ofNull, ofNull.filter(alwaysFail));
    final String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Predicate<String> alwaysTrue = new Predicate<String>() {

        @Override
        public boolean test(String s) {
            return true;
        }
    };
    Predicate<String> alwaysFalse = new Predicate<String>() {

        @Override
        public boolean test(String s) {
            return false;
        }
    };
    assertSame(empty, optionalFoo.filter(alwaysFalse));
    assertSame(optionalFoo, optionalFoo.filter(alwaysTrue));
    final AtomicReference<String> reference = new AtomicReference<>();
    optionalFoo.filter(new Predicate<String>() {

        @Override
        public boolean test(String s) {
            reference.set(s);
            return true;
        }
    });
    assertSame(foo, reference.get());
}
#method_after
public void testFilter() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Predicate<String> alwaysFail = s -> {
        fail();
        return true;
    };
    // If isPresent() == false, optional always returns itself (!!).
    assertSame(empty, empty.filter(alwaysFail));
    assertSame(empty, empty.filter(alwaysFail));
    assertSame(ofNull, ofNull.filter(alwaysFail));
    assertSame(ofNull, ofNull.filter(alwaysFail));
    final String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Predicate<String> alwaysTrue = s -> true;
    Predicate<String> alwaysFalse = s -> false;
    assertSame(empty, optionalFoo.filter(alwaysFalse));
    assertSame(optionalFoo, optionalFoo.filter(alwaysTrue));
    final AtomicReference<String> reference = new AtomicReference<>();
    optionalFoo.filter(s -> {
        reference.set(s);
        return true;
    });
    assertSame(foo, reference.get());
}
#end_block

#method_before
public void testMap() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Function<String, String> alwaysFail = new Function<String, String>() {

        @Override
        public String apply(String s) {
            fail();
            // unreachable.
            return "";
        }
    };
    // Should return Optional.empty() if the value isn't present.
    assertSame(empty, empty.map(alwaysFail));
    assertSame(empty, ofNull.map(alwaysFail));
    final AtomicReference<String> reference = new AtomicReference<>();
    Function<String, String> identity = new Function<String, String>() {

        @Override
        public String apply(String s) {
            reference.set(s);
            return s;
        }
    };
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Optional<String> mapped = optionalFoo.map(identity);
    assertSame(foo, mapped.get());
    assertSame(foo, reference.get());
    Function<String, String> alwaysNull = new Function<String, String>() {

        @Override
        public String apply(String s) {
            return null;
        }
    };
    assertSame(empty, optionalFoo.map(alwaysNull));
}
#method_after
public void testMap() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Function<String, String> alwaysFail = s -> {
        fail();
        return "";
    };
    // Should return Optional.empty() if the value isn't present.
    assertSame(empty, empty.map(alwaysFail));
    assertSame(empty, ofNull.map(alwaysFail));
    final AtomicReference<String> reference = new AtomicReference<>();
    Function<String, String> identity = (String s) -> {
        reference.set(s);
        return s;
    };
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Optional<String> mapped = optionalFoo.map(identity);
    assertSame(foo, mapped.get());
    assertSame(foo, reference.get());
    Function<String, String> alwaysNull = s -> null;
    assertSame(empty, optionalFoo.map(alwaysNull));
}
#end_block

#method_before
public void testFlatMap() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Function<String, Optional<String>> alwaysFail = new Function<String, Optional<String>>() {

        @Override
        public Optional<String> apply(String s) {
            fail();
            // unreachable.
            return Optional.empty();
        }
    };
    // Should return Optional.empty() if the value isn't present.
    assertSame(empty, empty.flatMap(alwaysFail));
    assertSame(empty, ofNull.flatMap(alwaysFail));
    final AtomicReference<String> reference = new AtomicReference<>();
    Function<String, Optional<String>> identity = new Function<String, Optional<String>>() {

        @Override
        public Optional<String> apply(String s) {
            reference.set(s);
            return Optional.of(s);
        }
    };
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Optional<String> mapped = optionalFoo.flatMap(identity);
    assertSame(foo, mapped.get());
    assertSame(foo, reference.get());
    Function<String, Optional<String>> alwaysNull = new Function<String, Optional<String>>() {

        @Override
        public Optional<String> apply(String s) {
            return null;
        }
    };
    try {
        optionalFoo.flatMap(alwaysNull);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void testFlatMap() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    Function<String, Optional<String>> alwaysFail = s -> {
        fail();
        return Optional.empty();
    };
    // Should return Optional.empty() if the value isn't present.
    assertSame(empty, empty.flatMap(alwaysFail));
    assertSame(empty, ofNull.flatMap(alwaysFail));
    final AtomicReference<String> reference = new AtomicReference<>();
    Function<String, Optional<String>> identity = s -> {
        reference.set(s);
        return Optional.of(s);
    };
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    Optional<String> mapped = optionalFoo.flatMap(identity);
    assertSame(foo, mapped.get());
    assertSame(foo, reference.get());
    Function<String, Optional<String>> alwaysNull = s -> null;
    try {
        optionalFoo.flatMap(alwaysNull);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        optionalFoo.flatMap(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void testOrElseGet() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    final String bar = "bar";
    Supplier<String> barSupplier = new Supplier<String>() {

        @Override
        public String get() {
            return bar;
        }
    };
    assertSame(bar, empty.orElseGet(barSupplier));
    assertSame(bar, ofNull.orElseGet(barSupplier));
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    assertSame(foo, optionalFoo.orElseGet(barSupplier));
}
#method_after
public void testOrElseGet() {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    final String bar = "bar";
    Supplier<String> barSupplier = () -> bar;
    assertSame(bar, empty.orElseGet(barSupplier));
    assertSame(bar, ofNull.orElseGet(barSupplier));
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    assertSame(foo, optionalFoo.orElseGet(barSupplier));
}
#end_block

#method_before
public void testOrElseThrow() throws Exception {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = new Supplier<IOException>() {

        @Override
        public IOException get() {
            return bar;
        }
    };
    try {
        empty.orElseThrow(barSupplier);
        fail();
    } catch (IOException ioe) {
        assertSame(bar, ioe);
    }
    try {
        ofNull.orElseThrow(barSupplier);
        fail();
    } catch (IOException ioe) {
        assertSame(bar, ioe);
    }
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    assertSame(foo, optionalFoo.orElseThrow(barSupplier));
}
#method_after
public void testOrElseThrow() throws Exception {
    Optional<String> empty = Optional.empty();
    Optional<String> ofNull = Optional.ofNullable(null);
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = () -> bar;
    try {
        empty.orElseThrow(barSupplier);
        fail();
    } catch (IOException ioe) {
        assertSame(bar, ioe);
    }
    try {
        ofNull.orElseThrow(barSupplier);
        fail();
    } catch (IOException ioe) {
        assertSame(bar, ioe);
    }
    String foo = "foo";
    Optional<String> optionalFoo = Optional.of(foo);
    assertSame(foo, optionalFoo.orElseThrow(barSupplier));
}
#end_block

#method_before
public void testIfPresent() {
    LongConsumer alwaysFails = new LongConsumer() {

        @Override
        public void accept(long value) {
            fail();
        }
    };
    OptionalLong.empty().ifPresent(alwaysFails);
    final AtomicLong reference = new AtomicLong();
    LongConsumer recorder = new LongConsumer() {

        @Override
        public void accept(long value) {
            reference.set(value);
        }
    };
    OptionalLong.of(56).ifPresent(recorder);
    assertEquals(56, reference.get());
}
#method_after
public void testIfPresent() {
    LongConsumer alwaysFails = value -> fail();
    OptionalLong.empty().ifPresent(alwaysFails);
    final AtomicLong reference = new AtomicLong();
    LongConsumer recorder = (long value) -> reference.set(value);
    OptionalLong.of(56).ifPresent(recorder);
    assertEquals(56, reference.get());
}
#end_block

#method_before
public void testOrElseGet() {
    LongSupplier alwaysFails = new LongSupplier() {

        @Override
        public long getAsLong() {
            fail();
            // unreachable;
            return 57;
        }
    };
    assertEquals(56, OptionalLong.of(56).orElseGet(alwaysFails));
    LongSupplier supplies57 = new LongSupplier() {

        @Override
        public long getAsLong() {
            return 57;
        }
    };
    assertEquals(57, OptionalLong.empty().orElseGet(supplies57));
}
#method_after
public void testOrElseGet() {
    LongSupplier alwaysFails = () -> {
        fail();
        return 57;
    };
    assertEquals(56, OptionalLong.of(56).orElseGet(alwaysFails));
    LongSupplier supplies57 = () -> 57;
    assertEquals(57, OptionalLong.empty().orElseGet(supplies57));
}
#end_block

#method_before
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = new Supplier<IOException>() {

        @Override
        public IOException get() {
            return bar;
        }
    };
    assertEquals(57, OptionalLong.of(57).orElseThrow(barSupplier));
    try {
        OptionalLong.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#method_after
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = () -> bar;
    assertEquals(57, OptionalLong.of(57).orElseThrow(barSupplier));
    try {
        OptionalLong.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#end_block

#method_before
public void testIfPresent() {
    DoubleConsumer alwaysFails = new DoubleConsumer() {

        @Override
        public void accept(double value) {
            fail();
        }
    };
    OptionalDouble.empty().ifPresent(alwaysFails);
    final AtomicReference<Double> reference = new AtomicReference<>();
    DoubleConsumer recorder = new DoubleConsumer() {

        @Override
        public void accept(double value) {
            reference.set(Double.valueOf(value));
        }
    };
    OptionalDouble.of(56.0).ifPresent(recorder);
    assertEquals(56.0, reference.get().doubleValue());
}
#method_after
public void testIfPresent() {
    DoubleConsumer alwaysFails = value -> fail();
    OptionalDouble.empty().ifPresent(alwaysFails);
    final AtomicReference<Double> reference = new AtomicReference<>();
    DoubleConsumer recorder = value -> reference.set(value);
    OptionalDouble.of(56.0).ifPresent(recorder);
    assertEquals(56.0, reference.get().doubleValue());
}
#end_block

#method_before
public void testOrElseGet() {
    DoubleSupplier alwaysFails = new DoubleSupplier() {

        @Override
        public double getAsDouble() {
            fail();
            // unreachable;
            return 57.0;
        }
    };
    assertEquals(56.0, OptionalDouble.of(56.0).orElseGet(alwaysFails));
    DoubleSupplier supplies57 = new DoubleSupplier() {

        @Override
        public double getAsDouble() {
            return 57.0;
        }
    };
    assertEquals(57.0, OptionalDouble.empty().orElseGet(supplies57));
}
#method_after
public void testOrElseGet() {
    DoubleSupplier alwaysFails = () -> {
        fail();
        return 57.0;
    };
    assertEquals(56.0, OptionalDouble.of(56.0).orElseGet(alwaysFails));
    DoubleSupplier supplies57 = () -> 57.0;
    assertEquals(57.0, OptionalDouble.empty().orElseGet(supplies57));
}
#end_block

#method_before
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = new Supplier<IOException>() {

        @Override
        public IOException get() {
            return bar;
        }
    };
    assertEquals(57.0, OptionalDouble.of(57.0).orElseThrow(barSupplier));
    try {
        OptionalDouble.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#method_after
public void testOrElseThrow() throws IOException {
    final IOException bar = new IOException("bar");
    Supplier<IOException> barSupplier = () -> bar;
    assertEquals(57.0, OptionalDouble.of(57.0).orElseThrow(barSupplier));
    try {
        OptionalDouble.empty().orElseThrow(barSupplier);
        fail();
    } catch (IOException expected) {
        assertSame(bar, expected);
    }
}
#end_block

#method_before
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (mLteRsrp > threshRsrp[5])
        rsrpIconLevel = -1;
    else if (mLteRsrp >= threshRsrp[4])
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= threshRsrp[3])
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= threshRsrp[2])
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= threshRsrp[1])
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= threshRsrp[0])
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#method_after
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5])
            rsrpIconLevel = -1;
        else if (mLteRsrp >= threshRsrp[4])
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        else if (mLteRsrp >= threshRsrp[3])
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        else if (mLteRsrp >= threshRsrp[2])
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        else if (mLteRsrp >= threshRsrp[1])
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        else if (mLteRsrp >= threshRsrp[0])
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#end_block

#method_before
public void fillInNotifierBundle(Bundle m) {
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", Boolean.valueOf(isGsm));
}
#method_after
public void fillInNotifierBundle(Bundle m) {
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", isGsm);
}
#end_block

#method_before
@Test
public void loadComponentsInStaMode() throws Exception {
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
    when(mWifiNative.setDeviceName(anyString())).thenReturn(true);
    when(mWifiNative.setManufacturer(anyString())).thenReturn(true);
    when(mWifiNative.setModelName(anyString())).thenReturn(true);
    when(mWifiNative.setModelNumber(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setConfigMethods(anyString())).thenReturn(true);
    when(mWifiNative.setDeviceType(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setScanningMacOui(any(byte[].class))).thenReturn(true);
    mWsm.sendMessage(WifiMonitor.SUP_CONNECTION_EVENT);
    mLooper.dispatchAll();
    assertEquals("DisconnectedState", getCurrentState().getName());
}
#method_after
@Test
public void loadComponentsInStaMode() throws Exception {
    startSupplicantAndDispatchMessages();
    assertEquals("DisconnectedState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void checkStartInCorrectStateAfterChangingInitialState() throws Exception {
    when(mWifiNative.startHal(anyBoolean())).thenReturn(true);
    // Check initial state
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // Update the mode
    mWsm.setOperationalMode(WifiStateMachine.SCAN_ONLY_MODE);
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.SCAN_ONLY_MODE, mWsm.getOperationalModeForTest());
    // Start supplicant so we move to the next state
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
    when(mWifiNative.setDeviceName(anyString())).thenReturn(true);
    when(mWifiNative.setManufacturer(anyString())).thenReturn(true);
    when(mWifiNative.setModelName(anyString())).thenReturn(true);
    when(mWifiNative.setModelNumber(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setConfigMethods(anyString())).thenReturn(true);
    when(mWifiNative.setDeviceType(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setScanningMacOui(any(byte[].class))).thenReturn(true);
    mWsm.sendMessage(WifiMonitor.SUP_CONNECTION_EVENT);
    mLooper.dispatchAll();
    assertEquals("ScanModeState", getCurrentState().getName());
}
#method_after
@Test
public void checkStartInCorrectStateAfterChangingInitialState() throws Exception {
    when(mWifiNative.startHal(anyBoolean())).thenReturn(true);
    // Check initial state
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // Update the mode
    mWsm.setOperationalMode(WifiStateMachine.SCAN_ONLY_MODE);
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.SCAN_ONLY_MODE, mWsm.getOperationalModeForTest());
    // Start supplicant so we move to the next state
    startSupplicantAndDispatchMessages();
    assertEquals("ScanModeState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void normalLogRecSizeIsUsedByDefault() {
    for (int i = 0; i < WifiStateMachine.NUM_LOG_RECS_NORMAL * 2; i++) {
        mWsm.sendMessage(WifiStateMachine.CMD_DISCONNECT);
    }
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.NUM_LOG_RECS_NORMAL, mWsm.getLogRecSize());
}
#method_after
@Test
public void normalLogRecSizeIsUsedByDefault() {
    assertEquals(WifiStateMachine.NUM_LOG_RECS_NORMAL, mWsm.getLogRecMaxSize());
}
#end_block

#method_before
public boolean syncAddOrUpdatePasspointConfig(AsyncChannel channel, PasspointConfiguration config) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_ADD_OR_UPDATE_PASSPOINT_CONFIG, config);
    boolean result = resultMsg.arg1 == SUCCESS;
    resultMsg.recycle();
    return result;
}
#method_after
public boolean syncAddOrUpdatePasspointConfig(AsyncChannel channel, PasspointConfiguration config) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_ADD_OR_UPDATE_PASSPOINT_CONFIG, config);
    boolean result = (resultMsg.arg1 == SUCCESS);
    resultMsg.recycle();
    return result;
}
#end_block

#method_before
public boolean syncRemovePasspointConfig(AsyncChannel channel, String fqdn) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_REMOVE_PASSPOINT_CONFIG, fqdn);
    boolean result = resultMsg.arg1 == SUCCESS;
    resultMsg.recycle();
    return result;
}
#method_after
public boolean syncRemovePasspointConfig(AsyncChannel channel, String fqdn) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_REMOVE_PASSPOINT_CONFIG, fqdn);
    boolean result = (resultMsg.arg1 == SUCCESS);
    resultMsg.recycle();
    return result;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_REMOVE_NETWORK:
            deleteNetworkConfigAndSendReply(message, false);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            deleteNetworkConfigAndSendReply(message, true);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_ADD_OR_UPDATE_PASSPOINT_CONFIG:
            int addResult = mPasspointManager.addOrUpdateProvider((PasspointConfiguration) message.obj) ? SUCCESS : FAILURE;
            replyToMessage(message, message.what, addResult);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            int removeResult = mPasspointManager.removeProvider((String) message.obj) ? SUCCESS : FAILURE;
            replyToMessage(message, message.what, removeResult);
            break;
        case CMD_GET_PASSPOINT_CONFIGS:
            replyToMessage(message, message.what, mPasspointManager.getProviderConfigs());
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_REMOVE_NETWORK:
            deleteNetworkConfigAndSendReply(message, false);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            deleteNetworkConfigAndSendReply(message, true);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_ADD_OR_UPDATE_PASSPOINT_CONFIG:
            int addResult = mPasspointManager.addOrUpdateProvider((PasspointConfiguration) message.obj) ? SUCCESS : FAILURE;
            replyToMessage(message, message.what, addResult);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            int removeResult = mPasspointManager.removeProvider((String) message.obj) ? SUCCESS : FAILURE;
            replyToMessage(message, message.what, removeResult);
            break;
        case CMD_GET_PASSPOINT_CONFIGS:
            replyToMessage(message, message.what, mPasspointManager.getProviderConfigs());
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public void enter() {
    /* Send any reset commands to supplicant before shutting it down */
    handleNetworkDisconnect();
    String suppState = System.getProperty("init.svc.wpa_supplicant");
    if (suppState == null)
        suppState = "unknown";
    logd("SupplicantStoppingState: stopSupplicant " + " init.svc.wpa_supplicant=" + suppState);
    mWifiMonitor.stopSupplicant();
    /* Send ourselves a delayed message to indicate failure after a wait time */
    sendMessageDelayed(obtainMessage(CMD_STOP_SUPPLICANT_FAILED, ++mSupplicantStopFailureToken, 0), SUPPLICANT_RESTART_INTERVAL_MSECS);
    setWifiState(WIFI_STATE_DISABLING);
    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
}
#method_after
@Override
public void enter() {
    /* Send any reset commands to supplicant before shutting it down */
    handleNetworkDisconnect();
    String suppState = System.getProperty("init.svc.wpa_supplicant");
    if (suppState == null)
        suppState = "unknown";
    setWifiState(WIFI_STATE_DISABLING);
    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
    logd("SupplicantStoppingState: disableSupplicant " + " init.svc.wpa_supplicant=" + suppState);
    if (mWifiNative.disableSupplicant()) {
        mWifiNative.closeSupplicantConnection();
        sendSupplicantConnectionChangedBroadcast(false);
        setWifiState(WIFI_STATE_DISABLED);
    } else {
        // Failed to disable supplicant
        handleSupplicantConnectionLoss(true);
    }
    transitionTo(mInitialState);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 == CONNECT_MODE) {
                if (mLastOperationMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    setWifiState(WIFI_STATE_ENABLED);
                    // Load and re-enable networks when going back to enabled state
                    // This is essential for networks to show up after restore
                    mWifiConfigManager.loadFromStore();
                    p2pSendMessage(CMD_ENABLE_P2P);
                }
                mOperationalMode = CONNECT_MODE;
                transitionTo(mDisconnectedState);
            } else if (message.arg1 == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            // Nothing to do
            break;
        // handled only in ConnectModeState
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            if (mVerboseLoggingEnabled)
                log("SupplicantState= " + state);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 == CONNECT_MODE) {
                mOperationalMode = CONNECT_MODE;
                transitionTo(mDisconnectedState);
            } else if (message.arg1 == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            // Nothing to do
            break;
        // handled only in ConnectModeState
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            if (mVerboseLoggingEnabled)
                log("SupplicantState= " + state);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_REMOVE_PASSPOINT_CONFIG:
            String fqdn = (String) message.obj;
            if (mPasspointManager.removeProvider(fqdn)) {
                if (isProviderOwnedNetwork(mTargetNetworkId, fqdn) || isProviderOwnedNetwork(mLastNetworkId, fqdn)) {
                    logd("Disconnect from current network since its provider is removed");
                    sendMessage(CMD_DISCONNECT);
                }
                replyToMessage(message, message.what, SUCCESS);
            } else {
                replyToMessage(message, message.what, FAILURE);
            }
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                } else if (mOperationalMode == SCAN_ONLY_MODE) {
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (!mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (!mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#end_block

#method_before
public boolean addOrUpdateProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.getCredential().getSimCredential() != null) {
        if (mSimAccessor.getMatchingImsis(IMSIParameter.build(config.getCredential().getSimCredential().getImsi())) == null) {
            Log.e(TAG, "IMSI does not match any SIM card");
            return false;
        }
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mSimAccessor, mProviderIndex++);
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Remove existing provider with the same FQDN.
    if (mProviders.containsKey(config.getHomeSp().getFqdn())) {
        Log.d(TAG, "Replacing configuration for " + config.getHomeSp().getFqdn());
        mProviders.get(config.getHomeSp().getFqdn()).uninstallCertsAndKeys();
        mProviders.remove(config.getHomeSp().getFqdn());
    }
    mProviders.put(config.getHomeSp().getFqdn(), newProvider);
    mWifiConfigManager.saveToStore(true);
    return true;
}
#method_after
public boolean addOrUpdateProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mSimAccessor, mProviderIndex++);
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Remove existing provider with the same FQDN.
    if (mProviders.containsKey(config.getHomeSp().getFqdn())) {
        Log.d(TAG, "Replacing configuration for " + config.getHomeSp().getFqdn());
        mProviders.get(config.getHomeSp().getFqdn()).uninstallCertsAndKeys();
        mProviders.remove(config.getHomeSp().getFqdn());
    }
    mProviders.put(config.getHomeSp().getFqdn(), newProvider);
    mWifiConfigManager.saveToStore(true);
    return true;
}
#end_block

#method_before
public static PasspointConfiguration convertFromWifiConfig(WifiConfiguration wifiConfig) {
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    // Setup HomeSP.
    HomeSp homeSp = new HomeSp();
    if (TextUtils.isEmpty(wifiConfig.FQDN)) {
        Log.e(TAG, "Missing FQDN");
        return null;
    }
    homeSp.setFqdn(wifiConfig.FQDN);
    homeSp.setFriendlyName(wifiConfig.providerFriendlyName);
    if (wifiConfig.roamingConsortiumIds != null) {
        homeSp.setRoamingConsortiumOis(Arrays.copyOf(wifiConfig.roamingConsortiumIds, wifiConfig.roamingConsortiumIds.length));
    }
    passpointConfig.setHomeSp(homeSp);
    // Setup Credential.
    Credential credential = new Credential();
    credential.setRealm(wifiConfig.enterpriseConfig.getRealm());
    switch(wifiConfig.enterpriseConfig.getEapMethod()) {
        case WifiEnterpriseConfig.Eap.TTLS:
            credential.setUserCredential(buildUserCredentialFromEnterpriseConfig(wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.TLS:
            Credential.CertificateCredential certCred = new Credential.CertificateCredential();
            certCred.setCertType("x509v3");
            credential.setCertCredential(certCred);
            break;
        case WifiEnterpriseConfig.Eap.SIM:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_SIM, wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.AKA:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_AKA, wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.AKA_PRIME:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_AKA_PRIME, wifiConfig.enterpriseConfig));
            break;
        default:
            Log.e(TAG, "Unsupport EAP method: " + wifiConfig.enterpriseConfig.getEapMethod());
            return null;
    }
    if (credential.getUserCredential() == null && credential.getCertCredential() == null && credential.getSimCredential() == null) {
        Log.e(TAG, "Missing credential");
        return null;
    }
    passpointConfig.setCredential(credential);
    return passpointConfig;
}
#method_after
public static PasspointConfiguration convertFromWifiConfig(WifiConfiguration wifiConfig) {
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    // Setup HomeSP.
    HomeSp homeSp = new HomeSp();
    if (TextUtils.isEmpty(wifiConfig.FQDN)) {
        Log.e(TAG, "Missing FQDN");
        return null;
    }
    homeSp.setFqdn(wifiConfig.FQDN);
    homeSp.setFriendlyName(wifiConfig.providerFriendlyName);
    if (wifiConfig.roamingConsortiumIds != null) {
        homeSp.setRoamingConsortiumOis(Arrays.copyOf(wifiConfig.roamingConsortiumIds, wifiConfig.roamingConsortiumIds.length));
    }
    passpointConfig.setHomeSp(homeSp);
    // Setup Credential.
    Credential credential = new Credential();
    credential.setRealm(wifiConfig.enterpriseConfig.getRealm());
    switch(wifiConfig.enterpriseConfig.getEapMethod()) {
        case WifiEnterpriseConfig.Eap.TTLS:
            credential.setUserCredential(buildUserCredentialFromEnterpriseConfig(wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.TLS:
            Credential.CertificateCredential certCred = new Credential.CertificateCredential();
            certCred.setCertType(Credential.CertificateCredential.CERT_TYPE_X509V3);
            credential.setCertCredential(certCred);
            break;
        case WifiEnterpriseConfig.Eap.SIM:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_SIM, wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.AKA:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_AKA, wifiConfig.enterpriseConfig));
            break;
        case WifiEnterpriseConfig.Eap.AKA_PRIME:
            credential.setSimCredential(buildSimCredentialFromEnterpriseConfig(EAPConstants.EAP_AKA_PRIME, wifiConfig.enterpriseConfig));
            break;
        default:
            Log.e(TAG, "Unsupport EAP method: " + wifiConfig.enterpriseConfig.getEapMethod());
            return null;
    }
    if (credential.getUserCredential() == null && credential.getCertCredential() == null && credential.getSimCredential() == null) {
        Log.e(TAG, "Missing credential");
        return null;
    }
    passpointConfig.setCredential(credential);
    return passpointConfig;
}
#end_block

#method_before
private void buildEnterpriseConfigForUserCredential(WifiEnterpriseConfig config, Credential.UserCredential credential) {
    byte[] pwOctets = Base64.decode(credential.getPassword(), Base64.DEFAULT);
    String decodedPassword = new String(pwOctets, StandardCharsets.UTF_8);
    config.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
    config.setIdentity(credential.getUsername());
    config.setPassword(decodedPassword);
    config.setCaCertificateAlias(mCaCertificateAlias);
    int phase2Method = WifiEnterpriseConfig.Phase2.NONE;
    switch(credential.getNonEapInnerMethod()) {
        case "PAP":
            phase2Method = WifiEnterpriseConfig.Phase2.PAP;
            break;
        case "MS-CHAP":
            phase2Method = WifiEnterpriseConfig.Phase2.MSCHAP;
            break;
        case "MS-CHAP-V2":
            phase2Method = WifiEnterpriseConfig.Phase2.MSCHAPV2;
            break;
        default:
            // Should never happen since this is already validated when the provider is
            // added.
            Log.wtf(TAG, "Unsupported Auth: " + credential.getNonEapInnerMethod());
            break;
    }
    config.setPhase2Method(phase2Method);
}
#method_after
private void buildEnterpriseConfigForUserCredential(WifiEnterpriseConfig config, Credential.UserCredential credential) {
    byte[] pwOctets = Base64.decode(credential.getPassword(), Base64.DEFAULT);
    String decodedPassword = new String(pwOctets, StandardCharsets.UTF_8);
    config.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
    config.setIdentity(credential.getUsername());
    config.setPassword(decodedPassword);
    config.setCaCertificateAlias(mCaCertificateAlias);
    int phase2Method = WifiEnterpriseConfig.Phase2.NONE;
    switch(credential.getNonEapInnerMethod()) {
        case Credential.UserCredential.AUTH_METHOD_PAP:
            phase2Method = WifiEnterpriseConfig.Phase2.PAP;
            break;
        case Credential.UserCredential.AUTH_METHOD_MSCHAP:
            phase2Method = WifiEnterpriseConfig.Phase2.MSCHAP;
            break;
        case Credential.UserCredential.AUTH_METHOD_MSCHAPV2:
            phase2Method = WifiEnterpriseConfig.Phase2.MSCHAPV2;
            break;
        default:
            // Should never happen since this is already validated when the provider is
            // added.
            Log.wtf(TAG, "Unsupported Auth: " + credential.getNonEapInnerMethod());
            break;
    }
    config.setPhase2Method(phase2Method);
}
#end_block

#method_before
private static Credential.UserCredential buildUserCredentialFromEnterpriseConfig(WifiEnterpriseConfig config) {
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setEapType(EAPConstants.EAP_TTLS);
    if (TextUtils.isEmpty(config.getIdentity())) {
        Log.e(TAG, "Missing username for user credential");
        return null;
    }
    userCredential.setUsername(config.getIdentity());
    if (TextUtils.isEmpty(config.getPassword())) {
        Log.e(TAG, "Missing password for user credential");
        return null;
    }
    String encodedPassword = new String(Base64.encode(config.getPassword().getBytes(StandardCharsets.UTF_8), Base64.DEFAULT), StandardCharsets.UTF_8);
    userCredential.setPassword(encodedPassword);
    switch(config.getPhase2Method()) {
        case WifiEnterpriseConfig.Phase2.PAP:
            userCredential.setNonEapInnerMethod("PAP");
            break;
        case WifiEnterpriseConfig.Phase2.MSCHAP:
            userCredential.setNonEapInnerMethod("MS-CHAP");
            break;
        case WifiEnterpriseConfig.Phase2.MSCHAPV2:
            userCredential.setNonEapInnerMethod("MS-CHAP-V2");
            break;
        default:
            Log.e(TAG, "Unsupported phase2 method for TTLS: " + config.getPhase2Method());
            return null;
    }
    return userCredential;
}
#method_after
private static Credential.UserCredential buildUserCredentialFromEnterpriseConfig(WifiEnterpriseConfig config) {
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setEapType(EAPConstants.EAP_TTLS);
    if (TextUtils.isEmpty(config.getIdentity())) {
        Log.e(TAG, "Missing username for user credential");
        return null;
    }
    userCredential.setUsername(config.getIdentity());
    if (TextUtils.isEmpty(config.getPassword())) {
        Log.e(TAG, "Missing password for user credential");
        return null;
    }
    String encodedPassword = new String(Base64.encode(config.getPassword().getBytes(StandardCharsets.UTF_8), Base64.DEFAULT), StandardCharsets.UTF_8);
    userCredential.setPassword(encodedPassword);
    switch(config.getPhase2Method()) {
        case WifiEnterpriseConfig.Phase2.PAP:
            userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_PAP);
            break;
        case WifiEnterpriseConfig.Phase2.MSCHAP:
            userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAP);
            break;
        case WifiEnterpriseConfig.Phase2.MSCHAPV2:
            userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
            break;
        default:
            Log.e(TAG, "Unsupported phase2 method for TTLS: " + config.getPhase2Method());
            return null;
    }
    return userCredential;
}
#end_block

#method_before
@Test
public void matchFQDNWithoutNAIRealm() throws Exception {
    String testDomain = "test.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup ANQP elements.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    assertEquals(PasspointMatch.HomeProvider, mProvider.match(anqpElementMap));
}
#method_after
@Test
public void matchFQDNWithoutNAIRealm() throws Exception {
    String testDomain = "test.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup ANQP elements.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    assertEquals(PasspointMatch.HomeProvider, mProvider.match(anqpElementMap));
}
#end_block

#method_before
@Test
public void matchFQDNWithNAIRealmMatch() throws Exception {
    String testDomain = "test.com";
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Domain Name ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS, new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
    assertEquals(PasspointMatch.HomeProvider, mProvider.match(anqpElementMap));
}
#method_after
@Test
public void matchFQDNWithNAIRealmMatch() throws Exception {
    String testDomain = "test.com";
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Domain Name ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS, new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
    assertEquals(PasspointMatch.HomeProvider, mProvider.match(anqpElementMap));
}
#end_block

#method_before
@Test
public void matchFQDNWithNAIRealmMismatch() throws Exception {
    String testDomain = "test.com";
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Domain Name ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TLS, null));
    assertEquals(PasspointMatch.None, mProvider.match(anqpElementMap));
}
#method_after
@Test
public void matchFQDNWithNAIRealmMismatch() throws Exception {
    String testDomain = "test.com";
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(testDomain);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Domain Name ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPDomName, createDomainNameElement(new String[] { testDomain }));
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TLS, null));
    assertEquals(PasspointMatch.None, mProvider.match(anqpElementMap));
}
#end_block

#method_before
@Test
public void matchRoamingConsortium() throws Exception {
    long[] providerRCOIs = new long[] { 0x1234L, 0x2345L };
    Long[] anqpRCOIs = new Long[] { 0x1234L, 0x2133L };
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setRoamingConsortiumOis(providerRCOIs);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Roaming Consortium ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium, createRoamingConsortiumElement(anqpRCOIs));
    assertEquals(PasspointMatch.RoamingProvider, mProvider.match(anqpElementMap));
}
#method_after
@Test
public void matchRoamingConsortium() throws Exception {
    long[] providerRCOIs = new long[] { 0x1234L, 0x2345L };
    Long[] anqpRCOIs = new Long[] { 0x1234L, 0x2133L };
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setRoamingConsortiumOis(providerRCOIs);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup Roaming Consortium ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium, createRoamingConsortiumElement(anqpRCOIs));
    assertEquals(PasspointMatch.RoamingProvider, mProvider.match(anqpElementMap));
}
#end_block

#method_before
@Test
public void matchNAIRealm() throws Exception {
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    config.setHomeSp(new HomeSp());
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup NAI Realm ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS, new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
    assertEquals(PasspointMatch.RoamingProvider, mProvider.match(anqpElementMap));
}
#method_after
@Test
public void matchNAIRealm() throws Exception {
    String testRealm = "realm.com";
    // Setup test provider.
    PasspointConfiguration config = new PasspointConfiguration();
    config.setHomeSp(new HomeSp());
    Credential credential = new Credential();
    credential.setRealm(testRealm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Setup NAI Realm ANQP element.
    Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
    anqpElementMap.put(ANQPElementType.ANQPNAIRealm, createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS, new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
    assertEquals(PasspointMatch.RoamingProvider, mProvider.match(anqpElementMap));
}
#end_block

#method_before
@Test
public void getWifiConfigWithUserCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    String username = "username";
    String password = "password";
    byte[] base64EncodedPw = Base64.encode(password.getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
    String encodedPasswordStr = new String(base64EncodedPw, StandardCharsets.UTF_8);
    // Create provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(realm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setUsername(username);
    userCredential.setPassword(encodedPasswordStr);
    userCredential.setNonEapInnerMethod("MS-CHAP-V2");
    credential.setUserCredential(userCredential);
    credential.setCaCertificate(FakeKeys.CA_CERT0);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Install certificate.
    when(mKeyStore.putCertInKeyStore(CA_CERTIFICATE_NAME, FakeKeys.CA_CERT0)).thenReturn(true);
    assertTrue(mProvider.installCertsAndKeys());
    // Retrieve the WifiConfiguration associated with the provider, and verify the content of
    // the configuration.  Need to verify field by field since WifiConfiguration doesn't
    // override equals() function.
    WifiConfiguration wifiConfig = mProvider.getWifiConfig();
    WifiEnterpriseConfig wifiEnterpriseConfig = wifiConfig.enterpriseConfig;
    assertEquals(fqdn, wifiConfig.FQDN);
    assertEquals(friendlyName, wifiConfig.providerFriendlyName);
    assertTrue(Arrays.equals(rcOIs, wifiConfig.roamingConsortiumIds));
    assertTrue(wifiConfig.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP));
    assertTrue(wifiConfig.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X));
    assertEquals(realm, wifiEnterpriseConfig.getRealm());
    assertEquals("anonymous@" + realm, wifiEnterpriseConfig.getAnonymousIdentity());
    assertEquals(WifiEnterpriseConfig.Eap.TTLS, wifiEnterpriseConfig.getEapMethod());
    assertEquals(WifiEnterpriseConfig.Phase2.MSCHAPV2, wifiEnterpriseConfig.getPhase2Method());
    assertEquals(username, wifiEnterpriseConfig.getIdentity());
    assertEquals(password, wifiEnterpriseConfig.getPassword());
    assertEquals(CA_CERTIFICATE_ALIAS, wifiEnterpriseConfig.getCaCertificateAlias());
}
#method_after
@Test
public void getWifiConfigWithUserCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    String username = "username";
    String password = "password";
    byte[] base64EncodedPw = Base64.encode(password.getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
    String encodedPasswordStr = new String(base64EncodedPw, StandardCharsets.UTF_8);
    // Create provider.
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(realm);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setUsername(username);
    userCredential.setPassword(encodedPasswordStr);
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
    credential.setUserCredential(userCredential);
    credential.setCaCertificate(FakeKeys.CA_CERT0);
    config.setCredential(credential);
    mProvider = createProvider(config);
    // Install certificate.
    when(mKeyStore.putCertInKeyStore(CA_CERTIFICATE_NAME, FakeKeys.CA_CERT0)).thenReturn(true);
    assertTrue(mProvider.installCertsAndKeys());
    // Retrieve the WifiConfiguration associated with the provider, and verify the content of
    // the configuration.  Need to verify field by field since WifiConfiguration doesn't
    // override equals() function.
    WifiConfiguration wifiConfig = mProvider.getWifiConfig();
    WifiEnterpriseConfig wifiEnterpriseConfig = wifiConfig.enterpriseConfig;
    assertEquals(fqdn, wifiConfig.FQDN);
    assertEquals(friendlyName, wifiConfig.providerFriendlyName);
    assertTrue(Arrays.equals(rcOIs, wifiConfig.roamingConsortiumIds));
    assertTrue(wifiConfig.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP));
    assertTrue(wifiConfig.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X));
    assertEquals(realm, wifiEnterpriseConfig.getRealm());
    assertEquals("anonymous@" + realm, wifiEnterpriseConfig.getAnonymousIdentity());
    assertEquals(WifiEnterpriseConfig.Eap.TTLS, wifiEnterpriseConfig.getEapMethod());
    assertEquals(WifiEnterpriseConfig.Phase2.MSCHAPV2, wifiEnterpriseConfig.getPhase2Method());
    assertEquals(username, wifiEnterpriseConfig.getIdentity());
    assertEquals(password, wifiEnterpriseConfig.getPassword());
    assertEquals(CA_CERTIFICATE_ALIAS, wifiEnterpriseConfig.getCaCertificateAlias());
}
#end_block

#method_before
@Test
public void convertFromWifiConfigWithCertCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    // Setup WifiConfiguration for legacy Passpoint configuraiton.
    WifiConfiguration wifiConfig = new WifiConfiguration();
    wifiConfig.FQDN = fqdn;
    wifiConfig.providerFriendlyName = friendlyName;
    wifiConfig.roamingConsortiumIds = rcOIs;
    wifiConfig.enterpriseConfig.setRealm(realm);
    wifiConfig.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
    // Setup expected {@link PasspointConfiguration}
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    passpointConfig.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    certCredential.setCertType("x509v3");
    credential.setCertCredential(certCredential);
    credential.setRealm(realm);
    passpointConfig.setCredential(credential);
    assertEquals(passpointConfig, PasspointProvider.convertFromWifiConfig(wifiConfig));
}
#method_after
@Test
public void convertFromWifiConfigWithCertCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    // Setup WifiConfiguration for legacy Passpoint configuraiton.
    WifiConfiguration wifiConfig = new WifiConfiguration();
    wifiConfig.FQDN = fqdn;
    wifiConfig.providerFriendlyName = friendlyName;
    wifiConfig.roamingConsortiumIds = rcOIs;
    wifiConfig.enterpriseConfig.setRealm(realm);
    wifiConfig.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
    // Setup expected {@link PasspointConfiguration}
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    passpointConfig.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    certCredential.setCertType(Credential.CertificateCredential.CERT_TYPE_X509V3);
    credential.setCertCredential(certCredential);
    credential.setRealm(realm);
    passpointConfig.setCredential(credential);
    assertEquals(passpointConfig, PasspointProvider.convertFromWifiConfig(wifiConfig));
}
#end_block

#method_before
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config.enterpriseConfig.getEapMethod());
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#method_after
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config);
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#end_block

#method_before
private PasspointConfiguration createTestConfigWithUserCredential() {
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(TEST_FQDN);
    homeSp.setFriendlyName(TEST_FRIENDLY_NAME);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(TEST_REALM);
    credential.setCaCertificate(FakeKeys.CA_CERT0);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setUsername("username");
    userCredential.setPassword("password");
    userCredential.setEapType(EAPConstants.EAP_TTLS);
    userCredential.setNonEapInnerMethod("MS-CHAP");
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    return config;
}
#method_after
private PasspointConfiguration createTestConfigWithUserCredential() {
    PasspointConfiguration config = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(TEST_FQDN);
    homeSp.setFriendlyName(TEST_FRIENDLY_NAME);
    config.setHomeSp(homeSp);
    Credential credential = new Credential();
    credential.setRealm(TEST_REALM);
    credential.setCaCertificate(FakeKeys.CA_CERT0);
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setUsername("username");
    userCredential.setPassword("password");
    userCredential.setEapType(EAPConstants.EAP_TTLS);
    userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAP);
    credential.setUserCredential(userCredential);
    config.setCredential(credential);
    return config;
}
#end_block

#method_before
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = createTestConfigWithSimCredential();
    when(mSimAccessor.getMatchingImsis(TEST_IMSI_PARAM)).thenReturn(new ArrayList<String>());
    PasspointProvider provider = createMockProvider(config);
    when(mObjectFactory.makePasspointProvider(eq(config), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(provider);
    assertTrue(mManager.addOrUpdateProvider(config));
    verifyInstalledConfig(config);
    verify(mWifiConfigManager).saveToStore(true);
    reset(mWifiConfigManager);
    // Verify content in the data source.
    List<PasspointProvider> providers = mDataSource.getProviders();
    assertEquals(1, providers.size());
    assertEquals(config, providers.get(0).getConfig());
    // Provider index start with 0, should be 1 after adding a provider.
    assertEquals(1, mDataSource.getProviderIndex());
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    verify(mWifiConfigManager).saveToStore(true);
    assertTrue(mManager.getProviderConfigs().isEmpty());
    // Verify content in the data source.
    assertTrue(mDataSource.getProviders().isEmpty());
    // Removing a provider should not change the provider index.
    assertEquals(1, mDataSource.getProviderIndex());
}
#method_after
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = createTestConfigWithSimCredential();
    PasspointProvider provider = createMockProvider(config);
    when(mObjectFactory.makePasspointProvider(eq(config), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(provider);
    assertTrue(mManager.addOrUpdateProvider(config));
    verifyInstalledConfig(config);
    verify(mWifiConfigManager).saveToStore(true);
    reset(mWifiConfigManager);
    // Verify content in the data source.
    List<PasspointProvider> providers = mDataSource.getProviders();
    assertEquals(1, providers.size());
    assertEquals(config, providers.get(0).getConfig());
    // Provider index start with 0, should be 1 after adding a provider.
    assertEquals(1, mDataSource.getProviderIndex());
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    verify(mWifiConfigManager).saveToStore(true);
    assertTrue(mManager.getProviderConfigs().isEmpty());
    // Verify content in the data source.
    assertTrue(mDataSource.getProviders().isEmpty());
    // Removing a provider should not change the provider index.
    assertEquals(1, mDataSource.getProviderIndex());
}
#end_block

#method_before
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = createTestConfigWithSimCredential();
    when(mSimAccessor.getMatchingImsis(TEST_IMSI_PARAM)).thenReturn(new ArrayList<String>());
    PasspointProvider origProvider = createMockProvider(origConfig);
    when(mObjectFactory.makePasspointProvider(eq(origConfig), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(origProvider);
    assertTrue(mManager.addOrUpdateProvider(origConfig));
    verifyInstalledConfig(origConfig);
    verify(mWifiConfigManager).saveToStore(true);
    reset(mWifiConfigManager);
    // Verify data source content.
    List<PasspointProvider> origProviders = mDataSource.getProviders();
    assertEquals(1, origProviders.size());
    assertEquals(origConfig, origProviders.get(0).getConfig());
    assertEquals(1, mDataSource.getProviderIndex());
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = createTestConfigWithUserCredential();
    PasspointProvider newProvider = createMockProvider(newConfig);
    when(mObjectFactory.makePasspointProvider(eq(newConfig), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(newProvider);
    assertTrue(mManager.addOrUpdateProvider(newConfig));
    verifyInstalledConfig(newConfig);
    verify(mWifiConfigManager).saveToStore(true);
    // Verify data source content.
    List<PasspointProvider> newProviders = mDataSource.getProviders();
    assertEquals(1, newProviders.size());
    assertEquals(newConfig, newProviders.get(0).getConfig());
    assertEquals(2, mDataSource.getProviderIndex());
}
#method_after
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = createTestConfigWithSimCredential();
    PasspointProvider origProvider = createMockProvider(origConfig);
    when(mObjectFactory.makePasspointProvider(eq(origConfig), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(origProvider);
    assertTrue(mManager.addOrUpdateProvider(origConfig));
    verifyInstalledConfig(origConfig);
    verify(mWifiConfigManager).saveToStore(true);
    reset(mWifiConfigManager);
    // Verify data source content.
    List<PasspointProvider> origProviders = mDataSource.getProviders();
    assertEquals(1, origProviders.size());
    assertEquals(origConfig, origProviders.get(0).getConfig());
    assertEquals(1, mDataSource.getProviderIndex());
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = createTestConfigWithUserCredential();
    PasspointProvider newProvider = createMockProvider(newConfig);
    when(mObjectFactory.makePasspointProvider(eq(newConfig), eq(mWifiKeyStore), eq(mSimAccessor), anyLong())).thenReturn(newProvider);
    assertTrue(mManager.addOrUpdateProvider(newConfig));
    verifyInstalledConfig(newConfig);
    verify(mWifiConfigManager).saveToStore(true);
    // Verify data source content.
    List<PasspointProvider> newProviders = mDataSource.getProviders();
    assertEquals(1, newProviders.size());
    assertEquals(newConfig, newProviders.get(0).getConfig());
    assertEquals(2, mDataSource.getProviderIndex());
}
#end_block

#method_before
@Test
public void addLegacyPasspointConfigWithCertCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    String caCertificateAlias = "CaCert";
    String clientCertificateAlias = "ClientCert";
    // Setup WifiConfiguration for legacy Passpoint configuraiton.
    WifiConfiguration wifiConfig = new WifiConfiguration();
    wifiConfig.FQDN = fqdn;
    wifiConfig.providerFriendlyName = friendlyName;
    wifiConfig.roamingConsortiumIds = rcOIs;
    wifiConfig.enterpriseConfig.setRealm(realm);
    wifiConfig.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
    wifiConfig.enterpriseConfig.setCaCertificateAlias(caCertificateAlias);
    wifiConfig.enterpriseConfig.setClientCertificateAlias(clientCertificateAlias);
    // Setup expected {@link PasspointConfiguration}
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    passpointConfig.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    certCredential.setCertType("x509v3");
    credential.setCertCredential(certCredential);
    credential.setRealm(realm);
    passpointConfig.setCredential(credential);
    assertTrue(PasspointManager.addLegacyPasspointConfig(wifiConfig));
    verifyInstalledConfig(passpointConfig);
}
#method_after
@Test
public void addLegacyPasspointConfigWithCertCredential() throws Exception {
    // Test data.
    String fqdn = "test.com";
    String friendlyName = "Friendly Name";
    long[] rcOIs = new long[] { 0x1234L, 0x2345L };
    String realm = "realm.com";
    String caCertificateAlias = "CaCert";
    String clientCertificateAlias = "ClientCert";
    // Setup WifiConfiguration for legacy Passpoint configuraiton.
    WifiConfiguration wifiConfig = new WifiConfiguration();
    wifiConfig.FQDN = fqdn;
    wifiConfig.providerFriendlyName = friendlyName;
    wifiConfig.roamingConsortiumIds = rcOIs;
    wifiConfig.enterpriseConfig.setRealm(realm);
    wifiConfig.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
    wifiConfig.enterpriseConfig.setCaCertificateAlias(caCertificateAlias);
    wifiConfig.enterpriseConfig.setClientCertificateAlias(clientCertificateAlias);
    // Setup expected {@link PasspointConfiguration}
    PasspointConfiguration passpointConfig = new PasspointConfiguration();
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn(fqdn);
    homeSp.setFriendlyName(friendlyName);
    homeSp.setRoamingConsortiumOis(rcOIs);
    passpointConfig.setHomeSp(homeSp);
    Credential credential = new Credential();
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    certCredential.setCertType(Credential.CertificateCredential.CERT_TYPE_X509V3);
    credential.setCertCredential(certCredential);
    credential.setRealm(realm);
    passpointConfig.setCredential(credential);
    assertTrue(PasspointManager.addLegacyPasspointConfig(wifiConfig));
    verifyInstalledConfig(passpointConfig);
}
#end_block

#method_before
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config.enterpriseConfig.getEapMethod());
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#method_after
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config);
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#end_block

#method_before
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config.enterpriseConfig.getEapMethod());
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#method_after
public void resetSimNetworks() {
    if (mVerboseLoggingEnabled)
        localLog("resetSimNetworks");
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (TelephonyUtil.isSimConfig(config)) {
            String currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager, config);
            // Update the loaded config
            config.enterpriseConfig.setIdentity(currentIdentity);
            config.enterpriseConfig.setAnonymousIdentity("");
        }
    }
}
#end_block

#method_before
public boolean loadFromStore() {
    if (!mWifiConfigStore.areStoresPresent()) {
        Log.d(TAG, "New store files not found. No saved networks loaded!");
        if (!mWifiConfigStoreLegacy.areStoresPresent()) {
            // No legacy store files either, so reset the pending store read flag.
            mPendingStoreRead = false;
        }
        return true;
    }
    // configurations for the current user will also being loaded.
    if (mDeferredUserUnlockRead) {
        Log.i(TAG, "Handling user unlock after loading from store.");
        mWifiConfigStore.setUserStore(WifiConfigStore.createUserFile(mCurrentUserId));
        mDeferredUserUnlockRead = false;
    }
    try {
        mWifiConfigStore.read();
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved networks are lost!", e);
        return false;
    }
    loadInternalData(mNetworkListStoreData.getSharedConfigurations(), mNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    return true;
}
#method_after
public boolean loadFromStore() {
    if (!mWifiConfigStore.areStoresPresent()) {
        Log.d(TAG, "New store files not found. No saved networks loaded!");
        if (!mWifiConfigStoreLegacy.areStoresPresent()) {
            // No legacy store files either, so reset the pending store read flag.
            mPendingStoreRead = false;
        }
        return true;
    }
    // configurations for the current user will also being loaded.
    if (mDeferredUserUnlockRead) {
        Log.i(TAG, "Handling user unlock before loading from store.");
        mWifiConfigStore.setUserStore(WifiConfigStore.createUserFile(mCurrentUserId));
        mDeferredUserUnlockRead = false;
    }
    try {
        mWifiConfigStore.read();
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved networks are lost!", e);
        return false;
    }
    loadInternalData(mNetworkListStoreData.getSharedConfigurations(), mNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    return true;
}
#end_block

#method_before
private boolean isScreenOn() {
    // Note that we don't listen to Intent.SCREEN_ON and Intent.SCREEN_OFF because they are no
    // longer adequate for monitoring the screen state since they are not sent in cases where
    // the screen is turned off transiently such as due to the proximity sensor.
    DisplayManager dm = (DisplayManager) mPhone.getContext().getSystemService(Context.DISPLAY_SERVICE);
    Display[] displays = dm.getDisplays();
    if (displays != null) {
        for (Display display : displays) {
            // STATE_DOZE_SUSPEND, etc...
            if (display.getState() == Display.STATE_ON) {
                log("Screen " + Display.typeToString(display.getType()) + " on", true);
                return true;
            }
        }
        log("Screens all off", true);
        return false;
    }
    log("No displays found", true);
    return false;
}
#method_after
private boolean isScreenOn() {
    // Note that we don't listen to Intent.SCREEN_ON and Intent.SCREEN_OFF because they are no
    // longer adequate for monitoring the screen state since they are not sent in cases where
    // the screen is turned off transiently such as due to the proximity sensor.
    final DisplayManager dm = (DisplayManager) mPhone.getContext().getSystemService(Context.DISPLAY_SERVICE);
    Display[] displays = dm.getDisplays();
    if (displays != null) {
        for (Display display : displays) {
            // STATE_DOZE_SUSPEND, etc...
            if (display.getState() == Display.STATE_ON) {
                log("Screen " + Display.typeToString(display.getType()) + " on", true);
                return true;
            }
        }
        log("Screens all off", true);
        return false;
    }
    log("No displays found", true);
    return false;
}
#end_block

#method_before
@Rpc(description = "Ping to host(URL or IP), return success (true) or fail (false).")
public // The optional timeout parameter is in unit of second.
Boolean pingHost(@RpcParameter(name = "host") String hostString, @RpcParameter(name = "timeout") @RpcOptional Integer timeout, @RpcParameter(name = "ping") String pingType) {
    try {
        String host;
        try {
            URL url = new URL(hostString);
            host = url.getHost();
        } catch (java.net.MalformedURLException e) {
            Log.d("hostString is not URL, it may be IP address.");
            host = hostString;
        }
        Log.d("Host:" + host);
        String pingCmdString = "ping -c 1 ";
        if (pingType == "ping6") {
            pingCmdString = "ping6 -c 1 ";
        }
        if (timeout != null) {
            pingCmdString = pingCmdString + "-W " + timeout + " ";
        }
        pingCmdString = pingCmdString + host;
        Log.d("Execute command: " + pingCmdString);
        Process p1 = java.lang.Runtime.getRuntime().exec(pingCmdString);
        int returnVal = p1.waitFor();
        boolean reachable = (returnVal == 0);
        Log.d("Ping return Value:" + returnVal);
        return reachable;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }
/*TODO see b/18899134 for more information.
        */
}
#method_after
@Rpc(description = "Ping to host(URL or IP), return success (true) or fail (false).")
public // The optional timeout parameter is in unit of second.
Boolean pingHost(@RpcParameter(name = "host") String hostString, @RpcParameter(name = "timeout") @RpcOptional Integer timeout, @RpcParameter(name = "ping") @RpcOptional String pingType) {
    try {
        String host;
        try {
            URL url = new URL(hostString);
            host = url.getHost();
        } catch (java.net.MalformedURLException e) {
            Log.d("hostString is not URL, it may be IP address.");
            host = hostString;
        }
        Log.d("Host:" + host);
        String pingCmdString = "ping -c 1 ";
        if (pingType != null && pingType.equals("ping6")) {
            pingCmdString = "ping6 -c 1 ";
        }
        if (timeout != null) {
            pingCmdString = pingCmdString + "-W " + timeout + " ";
        }
        pingCmdString = pingCmdString + host;
        Log.d("Execute command: " + pingCmdString);
        Process p1 = java.lang.Runtime.getRuntime().exec(pingCmdString);
        int returnVal = p1.waitFor();
        boolean reachable = (returnVal == 0);
        Log.d("Ping return Value:" + returnVal);
        return reachable;
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }
/*TODO see b/18899134 for more information.
        */
}
#end_block

#method_before
public boolean loadNetworks(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
    List<Integer> networkIds = listNetworks();
    if (networkIds == null) {
        Log.e(TAG, "Failed to list networks");
        return false;
    }
    for (Integer networkId : networkIds) {
        SupplicantStaNetworkHal network = getNetwork(networkId);
        if (network == null) {
            Log.e(TAG, "Failed to get network with ID: " + networkId);
            return false;
        }
        WifiConfiguration config = new WifiConfiguration();
        Map<String, String> networkExtra = new HashMap<>();
        boolean loadSuccess = false;
        try {
            loadSuccess = network.loadWifiConfiguration(config, networkExtra);
        } catch (Exception e) {
            Log.wtf(TAG, "Exception while loading config params: " + config, e);
        }
        if (!loadSuccess) {
            Log.e(TAG, "Failed to load wifi configuration for network with ID: " + networkId + ". Skipping...");
            continue;
        }
        // Set the default IP assignments.
        config.setIpAssignment(IpConfiguration.IpAssignment.DHCP);
        config.setProxySettings(IpConfiguration.ProxySettings.NONE);
        networkExtras.put(networkId, networkExtra);
        String configKey = networkExtra.get(SupplicantStaNetworkHal.ID_STRING_KEY_CONFIG_KEY);
        final WifiConfiguration duplicateConfig = configs.put(configKey, config);
        if (duplicateConfig != null) {
            // The network is already known. Overwrite the duplicate entry.
            Log.i(TAG, "Replacing duplicate network: " + duplicateConfig.networkId);
            removeNetwork(duplicateConfig.networkId);
            networkExtras.remove(duplicateConfig.networkId);
        }
    }
    return true;
}
#method_after
public boolean loadNetworks(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
    List<Integer> networkIds = listNetworks();
    if (networkIds == null) {
        Log.e(TAG, "Failed to list networks");
        return false;
    }
    for (Integer networkId : networkIds) {
        SupplicantStaNetworkHal network = getNetwork(networkId);
        if (network == null) {
            Log.e(TAG, "Failed to get network with ID: " + networkId);
            return false;
        }
        WifiConfiguration config = new WifiConfiguration();
        Map<String, String> networkExtra = new HashMap<>();
        boolean loadSuccess = false;
        try {
            loadSuccess = network.loadWifiConfiguration(config, networkExtra);
        } catch (IllegalArgumentException e) {
            Log.wtf(TAG, "Exception while loading config params: " + config, e);
        }
        if (!loadSuccess) {
            Log.e(TAG, "Failed to load wifi configuration for network with ID: " + networkId + ". Skipping...");
            continue;
        }
        // Set the default IP assignments.
        config.setIpAssignment(IpConfiguration.IpAssignment.DHCP);
        config.setProxySettings(IpConfiguration.ProxySettings.NONE);
        networkExtras.put(networkId, networkExtra);
        String configKey = networkExtra.get(SupplicantStaNetworkHal.ID_STRING_KEY_CONFIG_KEY);
        final WifiConfiguration duplicateConfig = configs.put(configKey, config);
        if (duplicateConfig != null) {
            // The network is already known. Overwrite the duplicate entry.
            Log.i(TAG, "Replacing duplicate network: " + duplicateConfig.networkId);
            removeNetwork(duplicateConfig.networkId);
            networkExtras.remove(duplicateConfig.networkId);
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void testLoadNetworksFailedDueToExceptionInLoadWifiConfiguration() throws Exception {
    executeAndValidateInitializationSequence();
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public void answer(ISupplicantStaIface.listNetworksCallback cb) {
            cb.onValues(mStatusSuccess, new ArrayList<>(NETWORK_ID_TO_SSID.keySet()));
        }
    }).when(mISupplicantStaIfaceMock).listNetworks(any(ISupplicantStaIface.listNetworksCallback.class));
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public void answer(final int networkId, ISupplicantStaIface.getNetworkCallback cb) {
            cb.onValues(mStatusSuccess, mock(ISupplicantStaNetwork.class));
            return;
        }
    }).when(mISupplicantStaIfaceMock).getNetwork(anyInt(), any(ISupplicantStaIface.getNetworkCallback.class));
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public boolean answer(WifiConfiguration config, Map<String, String> networkExtra) throws Exception {
            throw new Exception();
        }
    }).when(mSupplicantStaNetworkMock).loadWifiConfiguration(any(WifiConfiguration.class), any(Map.class));
    Map<String, WifiConfiguration> configs = new HashMap<>();
    SparseArray<Map<String, String>> extras = new SparseArray<>();
    assertTrue(mDut.loadNetworks(configs, extras));
    assertTrue(configs.isEmpty());
}
#method_after
@Test
public void testLoadNetworksFailedDueToExceptionInLoadWifiConfiguration() throws Exception {
    executeAndValidateInitializationSequence();
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public void answer(ISupplicantStaIface.listNetworksCallback cb) {
            cb.onValues(mStatusSuccess, new ArrayList<>(NETWORK_ID_TO_SSID.keySet()));
        }
    }).when(mISupplicantStaIfaceMock).listNetworks(any(ISupplicantStaIface.listNetworksCallback.class));
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public void answer(final int networkId, ISupplicantStaIface.getNetworkCallback cb) {
            cb.onValues(mStatusSuccess, mock(ISupplicantStaNetwork.class));
            return;
        }
    }).when(mISupplicantStaIfaceMock).getNetwork(anyInt(), any(ISupplicantStaIface.getNetworkCallback.class));
    doAnswer(new MockAnswerUtil.AnswerWithArguments() {

        public boolean answer(WifiConfiguration config, Map<String, String> networkExtra) throws Exception {
            throw new IllegalArgumentException();
        }
    }).when(mSupplicantStaNetworkMock).loadWifiConfiguration(any(WifiConfiguration.class), any(Map.class));
    Map<String, WifiConfiguration> configs = new HashMap<>();
    SparseArray<Map<String, String>> extras = new SparseArray<>();
    assertTrue(mDut.loadNetworks(configs, extras));
    assertTrue(configs.isEmpty());
}
#end_block

#method_before
@Override
public void enter() {
    /* Send any reset commands to supplicant before shutting it down */
    handleNetworkDisconnect();
    String suppState = System.getProperty("init.svc.wpa_supplicant");
    if (suppState == null)
        suppState = "unknown";
    setWifiState(WIFI_STATE_DISABLING);
    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
    logd("SupplicantStoppingState: disableSupplicant " + " init.svc.wpa_supplicant=" + suppState);
    if (mWifiNative.disableSupplicant()) {
        mWifiNative.closeSupplicantConnection();
        sendSupplicantConnectionChangedBroadcast(false);
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mInitialState);
    } else {
        // Failed to disable supplicant
        handleSupplicantConnectionLoss(true);
        transitionTo(mInitialState);
    }
}
#method_after
@Override
public void enter() {
    /* Send any reset commands to supplicant before shutting it down */
    handleNetworkDisconnect();
    String suppState = System.getProperty("init.svc.wpa_supplicant");
    if (suppState == null)
        suppState = "unknown";
    setWifiState(WIFI_STATE_DISABLING);
    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
    logd("SupplicantStoppingState: disableSupplicant " + " init.svc.wpa_supplicant=" + suppState);
    if (mWifiNative.disableSupplicant()) {
        mWifiNative.closeSupplicantConnection();
        sendSupplicantConnectionChangedBroadcast(false);
        setWifiState(WIFI_STATE_DISABLED);
    } else {
        // Failed to disable supplicant
        handleSupplicantConnectionLoss(true);
    }
    transitionTo(mInitialState);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mPhoneId == null || mPhoneId == 0) {
                rilSocket = RIL_SERVICE_NAME[0];
            } else {
                rilSocket = RIL_SERVICE_NAME[mPhoneId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    riljLoge("Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                riljLoge("Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#method_after
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mPhoneId == null || mPhoneId == 0) {
                rilSocket = RIL_SERVICE_NAME[0];
            } else {
                rilSocket = RIL_SERVICE_NAME[mPhoneId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    riljLoge("Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    // processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                riljLoge("Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    /* todo: hidlize
        IRadio radioProxy = getRadioProxy(result);
        if (radioProxy != null) {
            RILRequest rr = obtainRequest(RIL_REQUEST_SETUP_DATA_CALL, result,
                    mRILDefaultWorkSource);

            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> "
                        + requestToString(rr.mRequest) + " radioTechnology = " + radioTechnology
                        + " profile = " + profile + " apn = " + apn + " user = " + user
                        + " password = " + password + " authType = " + authType + " protocol = "
                        + protocol);
            }

            try {
                radioProxy.setupDataCall(rr.mSerial, radioTechnology + 2, profile,
                        convertNullToEmptyString(apn), convertNullToEmptyString(user),
                        convertNullToEmptyString(password), authType,
                        convertNullToEmptyString(protocol));
                mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial,
                        radioTechnology, profile, apn, authType, protocol);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setupDataCall", e);
            }
        } */
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result, mRILDefaultWorkSource);
    rr.mParcel.writeInt(7);
    rr.mParcel.writeString(Integer.toString(radioTechnology + 2));
    rr.mParcel.writeString(Integer.toString(profile));
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(user);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(authType));
    rr.mParcel.writeString(protocol);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + radioTechnology + " " + profile + " " + apn + " " + user + " " + password + " " + authType + " " + protocol);
    mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial, radioTechnology, profile, apn, authType, protocol);
    send(rr);
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SETUP_DATA_CALL, result, mRILDefaultWorkSource);
        // Convert to HAL data profile
        DataProfileInfo dpi = convertToHalDataProfile(dataProfile);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ",radioTechnology=" + radioTechnology + ",isRoaming=" + isRoaming + ",allowRoaming=" + allowRoaming + "," + dataProfile);
        }
        try {
            radioProxy.setupDataCall(rr.mSerial, radioTechnology, dpi, dataProfile.modemCognitive, allowRoaming, isRoaming);
            mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial, radioTechnology, dpi.profileId, dpi.apn, dpi.authType, dpi.protocol);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setupDataCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
    /* todo: hidlize
        IRadio radioProxy = getRadioProxy(result);
        if (radioProxy != null) {
            RILRequest rr = obtainRequest(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result,
                    mRILDefaultWorkSource);

            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
                        + " apn = " + apn + " protocol = " + protocol + " authType = " + authType
                        + " username = " + username + " password = " + password);
            }

            try {
                radioProxy.setInitialAttachApn(rr.mSerial,
                        convertNullToEmptyString(apn),
                        convertNullToEmptyString(protocol),
                        authType,
                        convertNullToEmptyString(username),
                        convertNullToEmptyString(password));
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setInitialAttachApn", e);
            }
        }
        */
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result, mRILDefaultWorkSource);
    if (RILJ_LOGD)
        riljLog("Set RIL_REQUEST_SET_INITIAL_ATTACH_APN");
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(protocol);
    rr.mParcel.writeInt(authType);
    rr.mParcel.writeString(username);
    rr.mParcel.writeString(password);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ", apn:" + apn + ", protocol:" + protocol + ", authType:" + authType + ", username:" + username + ", password:" + password);
    send(rr);
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + dataProfile);
        }
        try {
            radioProxy.setInitialAttachApn(rr.mSerial, convertToHalDataProfile(dataProfile), dataProfile.modemCognitive, isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setInitialAttachApn", e);
        }
    }
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
    /* todo - hidlize
        IRadio radioProxy = getRadioProxy(result);
        if (radioProxy != null) {
            RILRequest rr = obtainRequest(RIL_REQUEST_SET_DATA_PROFILE, result,
                    mRILDefaultWorkSource);

            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
                        + " with " + dps + " Data Profiles : ");
                for (int i = 0; i < dps.length; i++) {
                    riljLog(dps[i].toString());
                }
            }

            ArrayList<DataProfileInfo> dpInfos = new ArrayList<>();
            DataProfileInfo info;

            for (int i = 0; i < dps.length; i++) {
                info = new DataProfileInfo();
                info.profileId = dps[i].profileId;
                info.apn = convertNullToEmptyString(dps[i].apn);
                info.protocol = convertNullToEmptyString(dps[i].protocol);
                info.authType = dps[i].authType;
                info.user = convertNullToEmptyString(dps[i].user);
                info.password = convertNullToEmptyString(dps[i].password);
                info.type = dps[i].type;
                info.maxConnsTime = dps[i].maxConnsTime;
                info.maxConns = dps[i].maxConns;
                info.waitTime = dps[i].waitTime;
                info.enabled = dps[i].enabled;
                dpInfos.add(info);
            }

            try {
                radioProxy.setDataProfile(rr.mSerial, dpInfos);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setDataProfile", e);
            }
        } */
    if (RILJ_LOGD)
        riljLog("Set RIL_REQUEST_SET_DATA_PROFILE");
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_PROFILE, null, mRILDefaultWorkSource);
    DataProfile.toParcel(rr.mParcel, dps);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + dps + " Data Profiles : ");
        for (int i = 0; i < dps.length; i++) {
            riljLog(dps[i].toString());
        }
    }
    send(rr);
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_DATA_PROFILE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with data profiles : ");
            for (DataProfile profile : dps) {
                riljLog(profile.toString());
            }
        }
        ArrayList<DataProfileInfo> dpis = new ArrayList<>();
        for (DataProfile dp : dps) {
            dpis.add(convertToHalDataProfile(dp));
        }
        try {
            radioProxy.setDataProfile(rr.mSerial, dpis, isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setDataProfile", e);
        }
    }
}
#end_block

#method_before
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = ci.getMcc();
            c.mnc = ci.getMnc();
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = matchData;
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#method_after
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = convertNullToEmptyString(ci.getMcc());
            c.mnc = convertNullToEmptyString(ci.getMnc());
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = convertNullToEmptyString(matchData);
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendDeviceState(DeviceStateMonitor.DeviceStateType stateType, boolean state, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_DEVICE_STATE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + stateType + ":" + state);
        }
        try {
            radioProxy.sendDeviceState(rr.mSerial, convertDeviceStateType(stateType), state);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendDeviceState", e);
        }
    }
}
#method_after
@Override
public void sendDeviceState(int stateType, boolean state, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_DEVICE_STATE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + stateType + ":" + state);
        }
        try {
            radioProxy.sendDeviceState(rr.mSerial, stateType, state);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendDeviceState", e);
        }
    }
}
#end_block

#method_before
public void dataCallListChanged(int indicationType, ArrayList<SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    ArrayList<DataCallResponse> response = RIL.convertHalDcList(dcList);
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, response);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#method_after
public void dataCallListChanged(int indicationType, ArrayList<SetupDataCallResult> dcList) {
    mRil.processIndication(indicationType);
    ArrayList<DataCallResponse> response = new ArrayList<>();
    for (SetupDataCallResult dcResult : dcList) {
        response.add(RIL.convertDataCallResult(dcResult));
    }
    if (RIL.RILJ_LOGD)
        mRil.unsljLogRet(RIL_UNSOL_DATA_CALL_LIST_CHANGED, response);
    mRil.mDataCallListChangedRegistrants.notifyRegistrants(new AsyncResult(null, response, null));
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void sendDeviceState(DeviceStateType stateType, boolean state, Message result) {
}
#method_after
@Override
public void sendDeviceState(int stateType, boolean state, Message result) {
}
#end_block

#method_before
private boolean isLowDataExpected() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsTetheringOn && !mIsInteractive);
}
#method_after
private boolean isLowDataExpected() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsTetheringOn && !mIsScreenStateOn);
}
#end_block

#method_before
private boolean shouldTurnOffSignalStrength() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsInteractive);
}
#method_after
private boolean shouldTurnOffSignalStrength() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsScreenStateOn);
}
#end_block

#method_before
private boolean shouldTurnOffFullNetworkUpdate() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsInteractive && !mIsTetheringOn);
}
#method_after
private boolean shouldTurnOffFullNetworkUpdate() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsScreenStateOn && !mIsTetheringOn);
}
#end_block

#method_before
private boolean shouldTurnOffDormancyUpdate() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsTetheringOn && !mIsInteractive);
}
#method_after
private boolean shouldTurnOffDormancyUpdate() {
    return mIsPowerSaveOn || (!mIsCharging && !mIsTetheringOn && !mIsScreenStateOn);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (DBG)
        log("handleMessage msg=" + msg);
    switch(msg.what) {
        case EVENT_RIL_CONNECTED:
            onRilConnected();
            break;
        default:
            updateDeviceState(msg.what, msg.arg1 != 0);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    log("handleMessage msg=" + msg, false);
    switch(msg.what) {
        case EVENT_RIL_CONNECTED:
            onRilConnected();
            break;
        default:
            updateDeviceState(msg.what, msg.arg1 != 0);
    }
}
#end_block

#method_before
private void updateDeviceState(int eventType, boolean state) {
    switch(eventType) {
        case EVENT_SCREEN_STATE_CHANGED:
            if (mIsInteractive == state)
                return;
            mIsInteractive = state;
            break;
        case EVENT_CHARGING_STATE_CHANGED:
            if (mIsCharging == state)
                return;
            mIsCharging = state;
            sendDeviceState(CHARGING_STATE, mIsCharging);
            break;
        case EVENT_TETHERING_STATE_CHANGED:
            if (mIsTetheringOn == state)
                return;
            mIsTetheringOn = state;
            break;
        case EVENT_POWER_SAVE_MODE_CHANGED:
            if (mIsPowerSaveOn == state)
                return;
            mIsPowerSaveOn = state;
            sendDeviceState(POWER_SAVE_MODE, mIsPowerSaveOn);
            break;
        default:
            return;
    }
    if (mIsLowDataExpected != isLowDataExpected()) {
        mIsLowDataExpected = !mIsLowDataExpected;
        sendDeviceState(LOW_DATA_EXPECTED, mIsLowDataExpected);
    }
    if (mLegacyScreenState != shouldInvokeLegacyScreenOn()) {
        mLegacyScreenState = !mLegacyScreenState;
        // TODO: Once all vendor RILs support the new API RIL_REQUEST_SEND_DEVICE_STATE and
        // RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER, we should not invoke this legacy
        // screen state API anymore.
        updateLegacyScreenState(mLegacyScreenState);
    }
    int newFilter = 0;
    if (shouldTurnOffSignalStrength()) {
        newFilter &= ~UnsolicitedResponseFilter.SIGNAL_STRENGTH.getValue();
    } else {
        newFilter |= UnsolicitedResponseFilter.SIGNAL_STRENGTH.getValue();
    }
    if (shouldTurnOffFullNetworkUpdate()) {
        newFilter &= ~UnsolicitedResponseFilter.FULL_NETWORK_STATE.getValue();
    } else {
        newFilter |= UnsolicitedResponseFilter.FULL_NETWORK_STATE.getValue();
    }
    if (shouldTurnOffDormancyUpdate()) {
        newFilter &= ~UnsolicitedResponseFilter.DATA_CALL_DORMANCY_CHANGED.getValue();
    } else {
        newFilter |= UnsolicitedResponseFilter.DATA_CALL_DORMANCY_CHANGED.getValue();
    }
    if (DBG)
        log("old filter: " + mUnsolicitedResponseFilter + ", new filter: " + newFilter);
    if (newFilter != mUnsolicitedResponseFilter) {
        setUnsolResponseFilter(newFilter);
        mUnsolicitedResponseFilter = newFilter;
    }
}
#method_after
private void updateDeviceState(int eventType, boolean state) {
    switch(eventType) {
        case EVENT_SCREEN_STATE_CHANGED:
            if (mIsScreenStateOn == state)
                return;
            mIsScreenStateOn = state;
            break;
        case EVENT_CHARGING_STATE_CHANGED:
            if (mIsCharging == state)
                return;
            mIsCharging = state;
            sendDeviceState(CHARGING_STATE, mIsCharging);
            break;
        case EVENT_TETHERING_STATE_CHANGED:
            if (mIsTetheringOn == state)
                return;
            mIsTetheringOn = state;
            break;
        case EVENT_POWER_SAVE_MODE_CHANGED:
            if (mIsPowerSaveOn == state)
                return;
            mIsPowerSaveOn = state;
            sendDeviceState(POWER_SAVE_MODE, mIsPowerSaveOn);
            break;
        default:
            return;
    }
    if (mIsLowDataExpected != isLowDataExpected()) {
        mIsLowDataExpected = !mIsLowDataExpected;
        sendDeviceState(LOW_DATA_EXPECTED, mIsLowDataExpected);
    }
    int newFilter = 0;
    if (!shouldTurnOffSignalStrength()) {
        newFilter |= IndicationFilter.SIGNAL_STRENGTH;
    }
    if (!shouldTurnOffFullNetworkUpdate()) {
        newFilter |= IndicationFilter.FULL_NETWORK_STATE;
    }
    if (!shouldTurnOffDormancyUpdate()) {
        newFilter |= IndicationFilter.DATA_CALL_DORMANCY_CHANGED;
    }
    setUnsolResponseFilter(newFilter, false);
}
#end_block

#method_before
private void onRilConnected() {
    if (DBG)
        log("RIL connected.");
    mLocalLog.log("RIL connected.");
    updateLegacyScreenState(mLegacyScreenState);
    sendDeviceState(CHARGING_STATE, mIsCharging);
    sendDeviceState(LOW_DATA_EXPECTED, mIsLowDataExpected);
    sendDeviceState(POWER_SAVE_MODE, mIsPowerSaveOn);
    setUnsolResponseFilter(mUnsolicitedResponseFilter);
}
#method_after
private void onRilConnected() {
    log("RIL connected.", true);
    sendDeviceState(CHARGING_STATE, mIsCharging);
    sendDeviceState(LOW_DATA_EXPECTED, mIsLowDataExpected);
    sendDeviceState(POWER_SAVE_MODE, mIsPowerSaveOn);
    setUnsolResponseFilter(mUnsolicitedResponseFilter, true);
}
#end_block

#method_before
private void sendDeviceState(DeviceStateType type, boolean state) {
    mLocalLog.log("send type: " + type + ", state=" + state);
    mPhone.mCi.sendDeviceState(type, state, null);
}
#method_after
private void sendDeviceState(int type, boolean state) {
    log("send type: " + deviceTypeToString(type) + ", state=" + state, true);
    mPhone.mCi.sendDeviceState(type, state, null);
}
#end_block

#method_before
private void setUnsolResponseFilter(int filter) {
    mLocalLog.log("set filter: " + filter);
    mPhone.mCi.setUnsolResponseFilter(filter, null);
}
#method_after
private void setUnsolResponseFilter(int newFilter, boolean force) {
    if (force || newFilter != mUnsolicitedResponseFilter) {
        log("old filter: " + mUnsolicitedResponseFilter + ", new filter: " + newFilter, true);
        mPhone.mCi.setUnsolResponseFilter(newFilter, null);
        mUnsolicitedResponseFilter = newFilter;
    }
}
#end_block

#method_before
private boolean isPowerSaveModeOn() {
    PowerManager pm = (PowerManager) mPhone.getContext().getSystemService(Context.POWER_SERVICE);
    return pm.isPowerSaveMode();
}
#method_after
private boolean isPowerSaveModeOn() {
    final PowerManager pm = (PowerManager) mPhone.getContext().getSystemService(Context.POWER_SERVICE);
    return pm.isPowerSaveMode();
}
#end_block

#method_before
private boolean isDeviceCharging() {
    BatteryManager bm = (BatteryManager) mPhone.getContext().getSystemService(Context.BATTERY_SERVICE);
    return bm.isCharging();
}
#method_after
private boolean isDeviceCharging() {
    final BatteryManager bm = (BatteryManager) mPhone.getContext().getSystemService(Context.BATTERY_SERVICE);
    return bm.isCharging();
}
#end_block

#method_before
private void log(String msg) {
    Rlog.d(TAG, msg);
}
#method_after
private void log(String msg, boolean logIntoLocalLog) {
    if (DBG)
        Rlog.d(TAG, msg);
    if (logIntoLocalLog) {
        mLocalLog.log(msg);
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("DeviceStateMonitor:");
    pw.println("  mIsTetheringOn=" + mIsTetheringOn);
    pw.println("  mIsInteractive=" + mIsInteractive);
    pw.println("  mIsCharging=" + mIsCharging);
    pw.println("  mIsPowerSaveOn=" + mIsPowerSaveOn);
    pw.println("  mLegacyScreenState=" + mLegacyScreenState);
    pw.println("  mIsLowDataExpected=" + mIsLowDataExpected);
    pw.println("  mUnsolicitedResponseFilter=" + mUnsolicitedResponseFilter);
    pw.println("++++++++++++++++++++++++++++++++");
    mLocalLog.dump(fd, pw, args);
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    final IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    ipw.println("mIsTetheringOn=" + mIsTetheringOn);
    ipw.println("mIsScreenStateOn=" + mIsScreenStateOn);
    ipw.println("mIsCharging=" + mIsCharging);
    ipw.println("mIsPowerSaveOn=" + mIsPowerSaveOn);
    ipw.println("mIsLowDataExpected=" + mIsLowDataExpected);
    ipw.println("mUnsolicitedResponseFilter=" + mUnsolicitedResponseFilter);
    ipw.println("Local logs:");
    ipw.increaseIndent();
    mLocalLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.decreaseIndent();
    ipw.flush();
}
#end_block

#method_before
@Test
@SmallTest
public void testScreenOff() throws Exception {
    Intent intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(0), any(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).sendLegacyScreenState(eq(false));
    intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(7), any(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).sendLegacyScreenState(eq(true));
}
#method_after
@Test
@SmallTest
public void testScreenOff() throws Exception {
    Intent intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(0), any(Message.class));
    intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(7), any(Message.class));
}
#end_block

#method_before
@Test
@SmallTest
public void testTethering() throws Exception {
    // Screen on
    Intent intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    // Turn tethering on
    intent = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    intent.putExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, new ArrayList<>(asList("abc")));
    mContext.sendBroadcast(intent);
    // Screen off
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(6), any(Message.class));
    // Make sure the legacy screen state is not turned off.
    verify(mSimulatedCommandsVerifier, times(0)).sendLegacyScreenState(eq(false));
    // Screen on
    intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(7), any(Message.class));
    verify(mSimulatedCommandsVerifier, times(0)).sendLegacyScreenState(eq(true));
    // Turn tethering off
    intent = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    intent.putExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, new ArrayList<>());
    mContext.sendBroadcast(intent);
    // Screen off
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(0), any(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).sendDeviceState(eq(LOW_DATA_EXPECTED), eq(true), any(Message.class));
}
#method_after
@Test
@SmallTest
public void testTethering() throws Exception {
    // Screen on
    Intent intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    // Turn tethering on
    intent = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    intent.putExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, new ArrayList<>(asList("abc")));
    mContext.sendBroadcast(intent);
    // Screen off
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(6), any(Message.class));
    // Screen on
    intent = new Intent(Intent.ACTION_SCREEN_ON);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(7), any(Message.class));
    // Turn tethering off
    intent = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    intent.putExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, new ArrayList<>());
    mContext.sendBroadcast(intent);
    // Screen off
    intent = new Intent(Intent.ACTION_SCREEN_OFF);
    mContext.sendBroadcast(intent);
    waitForMs(100);
    verify(mSimulatedCommandsVerifier, times(1)).setUnsolResponseFilter(eq(0), any(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).sendDeviceState(eq(LOW_DATA_EXPECTED), eq(true), any(Message.class));
}
#end_block

#method_before
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        firstApnSetting = mAllApnSettings.get(0);
        log("setInitialApn: firstApnSetting=" + firstApnSetting);
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
            if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) && apn.carrierEnabled) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstApnSetting");
        initialAttachApnSetting = firstApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn, initialAttachApnSetting.protocol, initialAttachApnSetting.authType, initialAttachApnSetting.user, initialAttachApnSetting.password, null);
    }
}
#method_after
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        firstApnSetting = mAllApnSettings.get(0);
        log("setInitialApn: firstApnSetting=" + firstApnSetting);
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
            if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) && apn.carrierEnabled) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstApnSetting");
        initialAttachApnSetting = firstApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mPhone.mCi.setInitialAttachApn(new DataProfile(initialAttachApnSetting), mPhone.getServiceState().getDataRoaming(), null);
    }
}
#end_block

#method_before
private void onRoamingOff() {
    if (DBG)
        log("onRoamingOff");
    if (!mDataEnabledSettings.isUserDataEnabled())
        return;
    if (getDataOnRoamingEnabled() == false) {
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
        setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
    } else {
        notifyDataConnection(Phone.REASON_ROAMING_OFF);
    }
}
#method_after
private void onRoamingOff() {
    if (DBG)
        log("onRoamingOff");
    // TODO: Remove this once all old vendor RILs are gone. We don't need to send the
    // data profile again as the modem should have both roaming and non-roaming protocol in
    // place. Modem should choose the right protocol based on roaming condition.
    setDataProfilesAsNeeded();
    if (!mDataEnabledSettings.isUserDataEnabled())
        return;
    if (getDataOnRoamingEnabled() == false) {
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
        setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
    } else {
        notifyDataConnection(Phone.REASON_ROAMING_OFF);
    }
}
#end_block

#method_before
private void onRoamingOn() {
    if (DBG)
        log("onRoamingOn");
    if (!mDataEnabledSettings.isUserDataEnabled()) {
        if (DBG)
            log("data not enabled by user");
        return;
    }
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    if (getDataOnRoamingEnabled()) {
        if (DBG)
            log("onRoamingOn: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        if (DBG)
            log("onRoamingOn: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#method_after
private void onRoamingOn() {
    if (DBG)
        log("onRoamingOn");
    // TODO: Remove this once all old vendor RILs are gone. We don't need to send the
    // data profile again as the modem should have both roaming and non-roaming protocol in
    // place. Modem should choose the right protocol based on roaming condition.
    setDataProfilesAsNeeded();
    if (!mDataEnabledSettings.isUserDataEnabled()) {
        if (DBG)
            log("data not enabled by user");
        return;
    }
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    if (getDataOnRoamingEnabled()) {
        if (DBG)
            log("onRoamingOn: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        if (DBG)
            log("onRoamingOn: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#end_block

#method_before
private void setDataProfilesAsNeeded() {
    if (DBG)
        log("setDataProfilesAsNeeded");
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.modemCognitive) {
                DataProfile dp = new DataProfile(apn, mPhone.getServiceState().getDataRoaming());
                boolean isDup = false;
                for (DataProfile dpIn : dps) {
                    if (dp.equals(dpIn)) {
                        isDup = true;
                        break;
                    }
                }
                if (!isDup) {
                    dps.add(dp);
                }
            }
        }
        if (dps.size() > 0) {
            mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), null);
        }
    }
}
#method_after
private void setDataProfilesAsNeeded() {
    if (DBG)
        log("setDataProfilesAsNeeded");
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.modemCognitive) {
                DataProfile dp = new DataProfile(apn);
                if (!dps.contains(dp)) {
                    dps.add(dp);
                }
            }
        }
        if (dps.size() > 0) {
            mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), mPhone.getServiceState().getDataRoaming(), null);
        }
    }
}
#end_block

#method_before
private void createAllApnList() {
    mMvnoMatched = false;
    mAllApnSettings = new ArrayList<ApnSetting>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = Telephony.Carriers.NUMERIC + " = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#method_after
private void createAllApnList() {
    mMvnoMatched = false;
    mAllApnSettings = new ArrayList<>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = Telephony.Carriers.NUMERIC + " = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void sendDeviceState(DeviceStateType stateType, boolean state, Message result) {
}
#method_after
@Override
public void sendDeviceState(int stateType, boolean state, Message result) {
}
#end_block

#method_before
public void getVoiceRegistrationStateResponse(RadioResponseInfo responseInfo, VoiceRegStateResult voiceRegResponse) {
    responseStrings(responseInfo, Integer.toString(voiceRegResponse.regState), Integer.toString(voiceRegResponse.lac), Integer.toString(voiceRegResponse.cid), Integer.toString(voiceRegResponse.rat), Integer.toString(voiceRegResponse.baseStationId), Integer.toString(voiceRegResponse.baseStationLatitude), Integer.toString(voiceRegResponse.baseStationLongitude), Integer.toString(voiceRegResponse.cssSupported ? 1 : 0), Integer.toString(voiceRegResponse.systemId), Integer.toString(voiceRegResponse.networkId), Integer.toString(voiceRegResponse.roamingIndicator), Integer.toString(voiceRegResponse.systemIsInPrl), Integer.toString(voiceRegResponse.defaultRoamingIndicator), Integer.toString(voiceRegResponse.reasonForDenial), Integer.toString(voiceRegResponse.psc));
}
#method_after
public void getVoiceRegistrationStateResponse(RadioResponseInfo responseInfo, VoiceRegStateResult voiceRegResponse) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, voiceRegResponse);
        }
        mRil.processResponseDone(rr, responseInfo, voiceRegResponse);
    }
}
#end_block

#method_before
public void getDataRegistrationStateResponse(RadioResponseInfo responseInfo, DataRegStateResult dataRegResponse) {
    responseStrings(responseInfo, Integer.toString(dataRegResponse.regState), Integer.toString(dataRegResponse.lac), Integer.toString(dataRegResponse.cid), Integer.toString(dataRegResponse.rat), Integer.toString(dataRegResponse.reasonDataDenied), Integer.toString(dataRegResponse.maxDataCalls), Integer.toString(dataRegResponse.tac), Integer.toString(dataRegResponse.phyCid), Integer.toString(dataRegResponse.eci), Integer.toString(dataRegResponse.csgid), Integer.toString(dataRegResponse.tadv));
}
#method_after
public void getDataRegistrationStateResponse(RadioResponseInfo responseInfo, DataRegStateResult dataRegResponse) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, dataRegResponse);
        }
        mRil.processResponseDone(rr, responseInfo, dataRegResponse);
    }
}
#end_block

#method_before
public void setupDataCallResponse(RadioResponseInfo responseInfo, SetupDataCallResult dcResponse) {
    responseSetupDataCall(responseInfo, dcResponse);
}
#method_after
public void setupDataCallResponse(RadioResponseInfo responseInfo, SetupDataCallResult setupDataCallResult) {
    responseSetupDataCall(responseInfo, setupDataCallResult);
}
#end_block

#method_before
public void getDataCallListResponse(RadioResponseInfo responseInfo, ArrayList<SetupDataCallResult> dcResponse) {
    responseDataCallList(responseInfo, dcResponse);
}
#method_after
public void getDataCallListResponse(RadioResponseInfo responseInfo, ArrayList<SetupDataCallResult> dataCallResultList) {
    responseDataCallList(responseInfo, dataCallResultList);
}
#end_block

#method_before
private void responseSetupDataCall(RadioResponseInfo responseInfo, SetupDataCallResult dcResponse) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        DataCallResponse ret = null;
        if (responseInfo.error == RadioError.NONE) {
            ret = RIL.convertHalDc(dcResponse);
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#method_after
private void responseSetupDataCall(RadioResponseInfo responseInfo, SetupDataCallResult setupDataCallResult) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        DataCallResponse ret = RIL.convertDataCallResult(setupDataCallResult);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#end_block

#method_before
private String convertOpertatorInfoToString(int status) {
    if (status == android.hardware.radio.V1_0.OperatorStatus.UNKNOWN) {
        return "unknown";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.AVAILABLE) {
        return "available";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.CURRENT) {
        return "current";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.FORBIDDEN) {
        return "forbidden";
    } else {
        return "";
    }
}
#method_after
private static String convertOpertatorInfoToString(int status) {
    if (status == android.hardware.radio.V1_0.OperatorStatus.UNKNOWN) {
        return "unknown";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.AVAILABLE) {
        return "available";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.CURRENT) {
        return "current";
    } else if (status == android.hardware.radio.V1_0.OperatorStatus.FORBIDDEN) {
        return "forbidden";
    } else {
        return "";
    }
}
#end_block

#method_before
private void responseDataCallList(RadioResponseInfo responseInfo, ArrayList<SetupDataCallResult> dcResponse) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<DataCallResponse> ret = null;
        if (responseInfo.error == RadioError.NONE) {
            ret = RIL.convertHalDcList(dcResponse);
            sendMessageResponse(rr.mResult, ret);
        }
        mRil.processResponseDone(rr, responseInfo, ret);
    }
}
#method_after
private void responseDataCallList(RadioResponseInfo responseInfo, ArrayList<SetupDataCallResult> dataCallResultList) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<DataCallResponse> dcResponseList = null;
        if (responseInfo.error == RadioError.NONE) {
            dcResponseList = new ArrayList<>();
            for (SetupDataCallResult dcResult : dataCallResultList) {
                dcResponseList.add(RIL.convertDataCallResult(dcResult));
            }
            sendMessageResponse(rr.mResult, dcResponseList);
        }
        mRil.processResponseDone(rr, responseInfo, dcResponseList);
    }
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, profile, apn, user, password, authType, protocol, result);
    if (mDcResponse == null) {
        mDcResponse = new DataCallResponse();
        mDcResponse.version = 11;
        mDcResponse.status = 0;
        mDcResponse.suggestedRetryTime = -1;
        mDcResponse.cid = 1;
        mDcResponse.active = 2;
        mDcResponse.type = "IP";
        mDcResponse.ifname = "rmnet_data7";
        mDcResponse.mtu = 1440;
        mDcResponse.addresses = new String[] { "12.34.56.78" };
        mDcResponse.dnses = new String[] { "98.76.54.32" };
        mDcResponse.gateways = new String[] { "11.22.33.44" };
        mDcResponse.pcscf = new String[] {};
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, dataProfile, isRoaming, allowRoaming, result);
    if (mDcResponse == null) {
        mDcResponse = new DataCallResponse(0, -1, 1, 2, "IP", "rmnet_data7", "12.34.56.78", "98.76.54.32", "11.22.33.44", "", 1440);
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void sendDeviceState(DeviceStateType stateType, boolean state, Message result) {
    SimulatedCommandsVerifier.getInstance().sendDeviceState(stateType, state, result);
    resultSuccess(result, null);
}
#method_after
@Override
public void sendDeviceState(int stateType, boolean state, Message result) {
    SimulatedCommandsVerifier.getInstance().sendDeviceState(stateType, state, result);
    resultSuccess(result, null);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    if (VDBG)
        pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mIsPhoneInEcmState=" + mIsPhoneInEcmState);
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        mIccCardProxy.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    mDeviceStateMonitor.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    if (VDBG)
        pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mIsPhoneInEcmState=" + mIsPhoneInEcmState);
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        mIccCardProxy.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("DeviceStateMonitor:");
    mDeviceStateMonitor.dump(fd, pw, args);
    pw.println("++++++++++++++++++++++++++++++++");
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void sendDeviceState(DeviceStateType stateType, boolean state, Message result) {
}
#method_after
@Override
public void sendDeviceState(int stateType, boolean state, Message result) {
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel((String) request.argument, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_INVOKE_OEM_RIL_REQUEST_RAW:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE, request);
            mPhone.invokeOemRilRequestRaw((byte[]) request.argument, onCompleted);
            break;
        case EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = ar;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = null;
                request.notifyAll();
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = null;
                request.notifyAll();
                return;
            } else {
                loge("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted, (WorkSource) request.argument);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel((String) request.argument, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_INVOKE_OEM_RIL_REQUEST_RAW:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE, request);
            mPhone.invokeOemRilRequestRaw((byte[]) request.argument, onCompleted);
            break;
        case EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = ar;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IllegalArgumentException("Failed to retrieve Forbidden Plmns");
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = new IllegalArgumentException("getForbiddenPlmns() UiccCard is null");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = new IllegalArgumentException("Failed to get UICC App");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            } else {
                if (DBG)
                    logv("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
            break;
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#end_block

#method_before
@Override
public Bundle getCellLocation(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getCellLocation");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        log("getCellLocation: returning null; mode != allowed");
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getCellLocation: is active user");
        Bundle data = new Bundle();
        Phone phone = getPhone(mSubscriptionController.getDefaultDataSubId());
        if (phone == null) {
            return null;
        }
        phone.getCellLocation().fillInNotifierBundle(data);
        return data;
    } else {
        log("getCellLocation: suppress non-active user");
        return null;
    }
}
#method_after
@Override
public Bundle getCellLocation(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getCellLocation");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        log("getCellLocation: returning null; mode != allowed");
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getCellLocation: is active user");
        Bundle data = new Bundle();
        Phone phone = getPhone(mSubscriptionController.getDefaultDataSubId());
        if (phone == null) {
            return null;
        }
        WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
        phone.getCellLocation(workSource).fillInNotifierBundle(data);
        return data;
    } else {
        log("getCellLocation: suppress non-active user");
        return null;
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public List<NeighboringCellInfo> getNeighboringCellInfo(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getNeighboringCellInfo");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_NEIGHBORING_CELLS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getNeighboringCellInfo: is active user");
        ArrayList<NeighboringCellInfo> cells = null;
        try {
            cells = (ArrayList<NeighboringCellInfo>) sendRequest(CMD_HANDLE_NEIGHBORING_CELL, null, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        } catch (RuntimeException e) {
            Log.e(LOG_TAG, "getNeighboringCellInfo " + e);
        }
        return cells;
    } else {
        if (DBG_LOC)
            log("getNeighboringCellInfo: suppress non-active user");
        return null;
    }
}
#method_after
@Override
@SuppressWarnings("unchecked")
public List<NeighboringCellInfo> getNeighboringCellInfo(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getNeighboringCellInfo");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_NEIGHBORING_CELLS, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getNeighboringCellInfo: is active user");
        ArrayList<NeighboringCellInfo> cells = null;
        WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
        try {
            cells = (ArrayList<NeighboringCellInfo>) sendRequest(CMD_HANDLE_NEIGHBORING_CELL, workSource, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        } catch (RuntimeException e) {
            Log.e(LOG_TAG, "getNeighboringCellInfo " + e);
        }
        return cells;
    } else {
        if (DBG_LOC)
            log("getNeighboringCellInfo: suppress non-active user");
        return null;
    }
}
#end_block

#method_before
@Override
public List<CellInfo> getAllCellInfo(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getAllCellInfo");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getAllCellInfo: is active user");
        List<CellInfo> cellInfos = new ArrayList<CellInfo>();
        for (Phone phone : PhoneFactory.getPhones()) {
            final List<CellInfo> info = phone.getAllCellInfo();
            if (info != null)
                cellInfos.addAll(phone.getAllCellInfo());
        }
        return cellInfos;
    } else {
        if (DBG_LOC)
            log("getAllCellInfo: suppress non-active user");
        return null;
    }
}
#method_after
@Override
public List<CellInfo> getAllCellInfo(String callingPackage) {
    enforceFineOrCoarseLocationPermission("getAllCellInfo");
    // OP_COARSE_LOCATION controls both fine and coarse location.
    if (mAppOps.noteOp(AppOpsManager.OP_COARSE_LOCATION, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    if (checkIfCallerIsSelfOrForegroundUser() || checkCallerInteractAcrossUsersFull()) {
        if (DBG_LOC)
            log("getAllCellInfo: is active user");
        WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
        List<CellInfo> cellInfos = new ArrayList<CellInfo>();
        for (Phone phone : PhoneFactory.getPhones()) {
            final List<CellInfo> info = phone.getAllCellInfo(workSource);
            if (info != null)
                cellInfos.addAll(info);
        }
        return cellInfos;
    } else {
        if (DBG_LOC)
            log("getAllCellInfo: suppress non-active user");
        return null;
    }
}
#end_block

#method_before
@Override
public void setCellInfoListRate(int rateInMillis) {
    mPhone.setCellInfoListRate(rateInMillis);
}
#method_after
@Override
public void setCellInfoListRate(int rateInMillis) {
    WorkSource workSource = getWorkSource(null, Binder.getCallingUid());
    mPhone.setCellInfoListRate(rateInMillis, workSource);
}
#end_block

#method_before
public String[] getForbiddenPlmns(int appType, int subId) {
    mApp.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    if (appType != TelephonyManager.APPTYPE_USIM && appType != TelephonyManager.APPTYPE_SIM) {
        loge("getForbiddenPlmnList(): App Type must be USIM or SIM");
        return null;
    }
    String[] response = (String[]) sendRequest(CMD_GET_FORBIDDEN_PLMNS, new Integer(appType), subId);
    return response;
}
#method_after
public String[] getForbiddenPlmns(int subId, int appType) {
    mApp.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    if (appType != TelephonyManager.APPTYPE_USIM && appType != TelephonyManager.APPTYPE_SIM) {
        loge("getForbiddenPlmnList(): App Type must be USIM or SIM");
        return null;
    }
    Object response = sendRequest(CMD_GET_FORBIDDEN_PLMNS, new Integer(appType), subId);
    if (response instanceof String[]) {
        return (String[]) response;
    }
    // Response is an Exception of some kind, which is signalled to the user as a NULL retval
    return null;
}
#end_block

#method_before
@Override
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    enforceModifyPermission();
    int returnValue = 0;
    try {
        AsyncResult result = (AsyncResult) sendRequest(CMD_INVOKE_OEM_RIL_REQUEST_RAW, oemReq);
        if (result.exception == null) {
            if (result.result != null) {
                byte[] responseData = (byte[]) (result.result);
                if (responseData.length > oemResp.length) {
                    Log.w(LOG_TAG, "Buffer to copy response too small: Response length is " + responseData.length + "bytes. Buffer Size is " + oemResp.length + "bytes.");
                }
                System.arraycopy(responseData, 0, oemResp, 0, responseData.length);
                returnValue = responseData.length;
            }
        } else {
            CommandException ex = (CommandException) result.exception;
            returnValue = ex.getCommandError().ordinal();
            if (returnValue > 0)
                returnValue *= -1;
        }
    } catch (RuntimeException e) {
        Log.w(LOG_TAG, "sendOemRilRequestRaw: Runtime Exception");
        returnValue = (CommandException.Error.GENERIC_FAILURE.ordinal());
        if (returnValue > 0)
            returnValue *= -1;
    }
    return returnValue;
}
#method_after
@Override
@Deprecated
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    enforceModifyPermission();
    int returnValue = 0;
    try {
        AsyncResult result = (AsyncResult) sendRequest(CMD_INVOKE_OEM_RIL_REQUEST_RAW, oemReq);
        if (result.exception == null) {
            if (result.result != null) {
                byte[] responseData = (byte[]) (result.result);
                if (responseData.length > oemResp.length) {
                    Log.w(LOG_TAG, "Buffer to copy response too small: Response length is " + responseData.length + "bytes. Buffer Size is " + oemResp.length + "bytes.");
                }
                System.arraycopy(responseData, 0, oemResp, 0, responseData.length);
                returnValue = responseData.length;
            }
        } else {
            CommandException ex = (CommandException) result.exception;
            returnValue = ex.getCommandError().ordinal();
            if (returnValue > 0)
                returnValue *= -1;
        }
    } catch (RuntimeException e) {
        Log.w(LOG_TAG, "sendOemRilRequestRaw: Runtime Exception");
        returnValue = (CommandException.Error.GENERIC_FAILURE.ordinal());
        if (returnValue > 0)
            returnValue *= -1;
    }
    return returnValue;
}
#end_block

#method_before
public int getVoiceMessageCount() {
    boolean voiceMailWaiting = false;
    int countVoiceMessages = 0;
    if (mEfMWIS != null) {
        // Use this data if the EF[MWIS] exists and
        // has been loaded
        // Refer TS 51.011 Section 10.3.45 for the content description
        voiceMailWaiting = ((mEfMWIS[0] & 0x01) != 0);
        countVoiceMessages = mEfMWIS[1] & 0xff;
        if (voiceMailWaiting && countVoiceMessages == 0) {
            // Unknown count = -1
            countVoiceMessages = -1;
        }
        if (DBG)
            log(" VoiceMessageCount from SIM MWIS = " + countVoiceMessages);
    } else if (mEfCPHS_MWI != null) {
        // use voice mail count from CPHS
        int indicator = (int) (mEfCPHS_MWI[0] & 0xf);
        // Refer CPHS4_2.WW6 B4.2.3
        if (indicator == 0xA) {
            // Unknown count = -1
            countVoiceMessages = -1;
        } else if (indicator == 0x5) {
            countVoiceMessages = 0;
        }
        if (DBG)
            log(" VoiceMessageCount from SIM CPHS = " + countVoiceMessages);
    }
    return countVoiceMessages;
}
#method_after
public int getVoiceMessageCount() {
    boolean voiceMailWaiting = false;
    int countVoiceMessages = 0;
    if (mEfMWIS != null) {
        // Use this data if the EF[MWIS] exists and
        // has been loaded
        // Refer TS 51.011 Section 10.3.45 for the content description
        voiceMailWaiting = ((mEfMWIS[0] & 0x01) != 0);
        countVoiceMessages = mEfMWIS[1] & 0xff;
        if (voiceMailWaiting && (countVoiceMessages == 0 || countVoiceMessages == 0xff)) {
            // Unknown count = -1
            countVoiceMessages = -1;
        }
        if (DBG)
            log(" VoiceMessageCount from SIM MWIS = " + countVoiceMessages);
    } else if (mEfCPHS_MWI != null) {
        // use voice mail count from CPHS
        int indicator = (int) (mEfCPHS_MWI[0] & 0xf);
        // Refer CPHS4_2.WW6 B4.2.3
        if (indicator == 0xA) {
            // Unknown count = -1
            countVoiceMessages = -1;
        } else if (indicator == 0x5) {
            countVoiceMessages = 0;
        }
        if (DBG)
            log(" VoiceMessageCount from SIM CPHS = " + countVoiceMessages);
    }
    return countVoiceMessages;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    log("setting4 mMncLength=" + mMncLength);
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                int[] index = (int[]) ar.result;
                if (ar.exception != null || index.length != 1) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " length " + index.length);
                } else {
                    log("READ EF_SMS RECORD index=" + index[0]);
                    mFh.loadEFLinearFixed(EF_SMS, index[0], obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = removePendingRequest(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                } else if (msg.arg1 == HANDLER_ACTION_NOTIFY_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send synchronous response");
                    isRecordLoadResponse = false;
                    Message syncResult = removePendingRequest(msg.arg2);
                    if (syncResult != null) {
                        synchronized (syncResult) {
                            AsyncResult.forMessage(syncResult, Arrays.copyOf(mFplmns, mFplmns.length), null);
                            syncResult.notifyAll();
                        }
                    } else {
                        loge("Synchronous result not found. Likely to cause binder watchdog");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            case EVENT_GET_TRANSPARENT_FILE_REQ:
                mFh.loadEFTransparent(msg.arg1, (Message) msg.obj);
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    log("setting4 mMncLength=" + mMncLength);
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_SIM_REFRESH:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("Sim REFRESH with exception: " + ar.exception);
                if (ar.exception == null) {
                    handleSimRefresh((IccRefreshResponse) ar.result);
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
public void getForbiddenPlmns(Message response) {
    int key = addPendingRequest(response);
    mFh.loadEFTransparent(EF_FPLMN, obtainMessage(EVENT_GET_FPLMN_DONE, HANDLER_ACTION_SEND_RESPONSE, key));
}
#method_after
public void getForbiddenPlmns(Message response) {
    int key = storePendingResponseMessage(response);
    mFh.loadEFTransparent(EF_FPLMN, obtainMessage(EVENT_GET_FPLMN_DONE, HANDLER_ACTION_SEND_RESPONSE, key));
}
#end_block

#method_before
public String[] getForbiddenPlmns(int subId, int appType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getForbiddenPlmns(subId, appType);
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone starts
        return null;
    }
}
#method_after
public String[] getForbiddenPlmns(int subId, int appType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getForbiddenPlmns(subId, appType);
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone starts
        return null;
    }
}
#end_block

#method_before
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#method_after
@Deprecated
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#end_block

#method_before
private void pollLatestScanData() {
    synchronized (mSettingsLock) {
        if (mLastScanSettings == null) {
            // got a scan before we started scanning or after scan was canceled
            return;
        }
        if (DBG)
            Log.d(TAG, "Polling scan data for scan: " + mLastScanSettings.scanId);
        ArrayList<ScanDetail> nativeResults = mWifiNative.getScanResults();
        List<ScanResult> singleScanResults = new ArrayList<>();
        List<ScanResult> backgroundScanResults = new ArrayList<>();
        List<ScanResult> hwPnoScanResults = new ArrayList<>();
        int numFilteredScanResults = 0;
        for (int i = 0; i < nativeResults.size(); ++i) {
            ScanResult result = nativeResults.get(i).getScanResult();
            // convert us -> ms
            long timestamp_ms = result.timestamp / 1000;
            if (timestamp_ms > mLastScanSettings.startTime) {
                if (mLastScanSettings.backgroundScanActive) {
                    backgroundScanResults.add(result);
                }
                if (mLastScanSettings.singleScanActive && mLastScanSettings.singleScanFreqs.containsChannel(result.frequency)) {
                    singleScanResults.add(result);
                }
                if (mLastScanSettings.hwPnoScanActive) {
                    hwPnoScanResults.add(result);
                }
            } else {
                numFilteredScanResults++;
            }
        }
        if (numFilteredScanResults != 0) {
            Log.d(TAG, "Filterting out " + numFilteredScanResults + " scan results.");
        }
        if (mLastScanSettings.backgroundScanActive) {
            if (mBackgroundScanEventHandler != null) {
                if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT) != 0) {
                    for (ScanResult scanResult : backgroundScanResults) {
                        // TODO(b/27506257): Fill in correct bucketsScanned value
                        mBackgroundScanEventHandler.onFullScanResult(scanResult, 0);
                    }
                }
            }
            Collections.sort(backgroundScanResults, SCAN_RESULT_SORT_COMPARATOR);
            ScanResult[] scanResultsArray = new ScanResult[Math.min(mLastScanSettings.maxAps, backgroundScanResults.size())];
            for (int i = 0; i < scanResultsArray.length; ++i) {
                scanResultsArray[i] = backgroundScanResults.get(i);
            }
            if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_NO_BATCH) == 0) {
                // TODO(b/27506257): Fill in correct bucketsScanned value
                mBackgroundScanBuffer.add(new WifiScanner.ScanData(mLastScanSettings.scanId, 0, scanResultsArray));
            }
            if (mBackgroundScanEventHandler != null) {
                if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT) != 0 || (mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN) != 0 || (mLastScanSettings.reportEvents == WifiScanner.REPORT_EVENT_AFTER_BUFFER_FULL && (mBackgroundScanBuffer.size() >= (mBackgroundScanBuffer.capacity() * mLastScanSettings.reportPercentThreshold / 100) || mBackgroundScanBuffer.size() >= mLastScanSettings.reportNumScansThreshold))) {
                    mBackgroundScanEventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
                }
            }
            if (mHotlistHandler != null) {
                int event = mHotlistChangeBuffer.processScan(backgroundScanResults);
                if ((event & ChangeBuffer.EVENT_FOUND) != 0) {
                    mHotlistHandler.onHotlistApFound(mHotlistChangeBuffer.getLastResults(ChangeBuffer.EVENT_FOUND));
                }
                if ((event & ChangeBuffer.EVENT_LOST) != 0) {
                    mHotlistHandler.onHotlistApLost(mHotlistChangeBuffer.getLastResults(ChangeBuffer.EVENT_LOST));
                }
            }
        }
        if (mLastScanSettings.singleScanActive && mLastScanSettings.singleScanEventHandler != null) {
            if (mLastScanSettings.reportSingleScanFullResults) {
                for (ScanResult scanResult : singleScanResults) {
                    // ignore buckets scanned since there is only one bucket for a single scan
                    mLastScanSettings.singleScanEventHandler.onFullScanResult(scanResult, /* bucketsScanned */
                    0);
                }
            }
            Collections.sort(singleScanResults, SCAN_RESULT_SORT_COMPARATOR);
            mLatestSingleScanResult = new WifiScanner.ScanData(mLastScanSettings.scanId, 0, 0, mLastScanSettings.singleScanFreqs.isAllChannels(), singleScanResults.toArray(new ScanResult[singleScanResults.size()]));
            mLastScanSettings.singleScanEventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
        }
        if (mLastScanSettings.hwPnoScanActive && mLastScanSettings.pnoScanEventHandler != null) {
            ScanResult[] pnoScanResultsArray = new ScanResult[hwPnoScanResults.size()];
            for (int i = 0; i < pnoScanResultsArray.length; ++i) {
                pnoScanResultsArray[i] = hwPnoScanResults.get(i);
            }
            mLastScanSettings.pnoScanEventHandler.onPnoNetworkFound(pnoScanResultsArray);
        }
        mLastScanSettings = null;
    }
}
#method_after
private void pollLatestScanData() {
    synchronized (mSettingsLock) {
        if (mLastScanSettings == null) {
            // got a scan before we started scanning or after scan was canceled
            return;
        }
        if (DBG)
            Log.d(TAG, "Polling scan data for scan: " + mLastScanSettings.scanId);
        ArrayList<ScanDetail> nativeResults = mWifiNative.getScanResults();
        List<ScanResult> singleScanResults = new ArrayList<>();
        List<ScanResult> backgroundScanResults = new ArrayList<>();
        List<ScanResult> hwPnoScanResults = new ArrayList<>();
        int numFilteredScanResults = 0;
        for (int i = 0; i < nativeResults.size(); ++i) {
            ScanResult result = nativeResults.get(i).getScanResult();
            // convert us -> ms
            long timestamp_ms = result.timestamp / 1000;
            if (timestamp_ms > mLastScanSettings.startTime) {
                if (mLastScanSettings.backgroundScanActive) {
                    backgroundScanResults.add(result);
                }
                if (mLastScanSettings.singleScanActive && mLastScanSettings.singleScanFreqs.containsChannel(result.frequency)) {
                    singleScanResults.add(result);
                }
                if (mLastScanSettings.hwPnoScanActive) {
                    hwPnoScanResults.add(result);
                }
            } else {
                numFilteredScanResults++;
            }
        }
        if (numFilteredScanResults != 0) {
            Log.d(TAG, "Filtering out " + numFilteredScanResults + " scan results.");
        }
        if (mLastScanSettings.backgroundScanActive) {
            if (mBackgroundScanEventHandler != null) {
                if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT) != 0) {
                    for (ScanResult scanResult : backgroundScanResults) {
                        // TODO(b/27506257): Fill in correct bucketsScanned value
                        mBackgroundScanEventHandler.onFullScanResult(scanResult, 0);
                    }
                }
            }
            Collections.sort(backgroundScanResults, SCAN_RESULT_SORT_COMPARATOR);
            ScanResult[] scanResultsArray = new ScanResult[Math.min(mLastScanSettings.maxAps, backgroundScanResults.size())];
            for (int i = 0; i < scanResultsArray.length; ++i) {
                scanResultsArray[i] = backgroundScanResults.get(i);
            }
            if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_NO_BATCH) == 0) {
                // TODO(b/27506257): Fill in correct bucketsScanned value
                mBackgroundScanBuffer.add(new WifiScanner.ScanData(mLastScanSettings.scanId, 0, scanResultsArray));
            }
            if (mBackgroundScanEventHandler != null) {
                if ((mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT) != 0 || (mLastScanSettings.reportEvents & WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN) != 0 || (mLastScanSettings.reportEvents == WifiScanner.REPORT_EVENT_AFTER_BUFFER_FULL && (mBackgroundScanBuffer.size() >= (mBackgroundScanBuffer.capacity() * mLastScanSettings.reportPercentThreshold / 100) || mBackgroundScanBuffer.size() >= mLastScanSettings.reportNumScansThreshold))) {
                    mBackgroundScanEventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
                }
            }
            if (mHotlistHandler != null) {
                int event = mHotlistChangeBuffer.processScan(backgroundScanResults);
                if ((event & ChangeBuffer.EVENT_FOUND) != 0) {
                    mHotlistHandler.onHotlistApFound(mHotlistChangeBuffer.getLastResults(ChangeBuffer.EVENT_FOUND));
                }
                if ((event & ChangeBuffer.EVENT_LOST) != 0) {
                    mHotlistHandler.onHotlistApLost(mHotlistChangeBuffer.getLastResults(ChangeBuffer.EVENT_LOST));
                }
            }
        }
        if (mLastScanSettings.singleScanActive && mLastScanSettings.singleScanEventHandler != null) {
            if (mLastScanSettings.reportSingleScanFullResults) {
                for (ScanResult scanResult : singleScanResults) {
                    // ignore buckets scanned since there is only one bucket for a single scan
                    mLastScanSettings.singleScanEventHandler.onFullScanResult(scanResult, /* bucketsScanned */
                    0);
                }
            }
            Collections.sort(singleScanResults, SCAN_RESULT_SORT_COMPARATOR);
            mLatestSingleScanResult = new WifiScanner.ScanData(mLastScanSettings.scanId, 0, 0, mLastScanSettings.singleScanFreqs.isAllChannels(), singleScanResults.toArray(new ScanResult[singleScanResults.size()]));
            mLastScanSettings.singleScanEventHandler.onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
        }
        if (mLastScanSettings.hwPnoScanActive && mLastScanSettings.pnoScanEventHandler != null) {
            ScanResult[] pnoScanResultsArray = new ScanResult[hwPnoScanResults.size()];
            for (int i = 0; i < pnoScanResultsArray.length; ++i) {
                pnoScanResultsArray[i] = hwPnoScanResults.get(i);
            }
            mLastScanSettings.pnoScanEventHandler.onPnoNetworkFound(pnoScanResultsArray);
        }
        mLastScanSettings = null;
    }
}
#end_block

#method_before
public void test_getDefault() {
    FileSystem fs = FileSystems.getDefault();
    assertTrue(fs.provider() instanceof LinuxFileSystemProvider);
}
#method_after
@Test
public void test_getDefault() {
    FileSystem fs = FileSystems.getDefault();
    assertNotNull(fs.provider());
}
#end_block

#method_before
public void test_getFileSystem() {
    Path testPath = Paths.get("/");
    FileSystem fs = FileSystems.getFileSystem(testPath.toUri());
    assertTrue(fs.provider() instanceof LinuxFileSystemProvider);
    try {
        FileSystems.getFileSystem(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_getFileSystem() {
    Path testPath = Paths.get("/");
    FileSystem fs = FileSystems.getFileSystem(testPath.toUri());
    assertNotNull(fs.provider());
    try {
        FileSystems.getFileSystem(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_newFileSystem$URI$Map$ClassLoader() throws IOException {
    Path testPath = Paths.get("/");
    Map<String, String> stubEnv = mock(Map.class);
    try {
        FileSystems.newFileSystem(testPath.toUri(), stubEnv, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
    try {
        FileSystems.newFileSystem(null, stubEnv, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath.toUri(), null, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath.toUri(), stubEnv, null);
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
}
#method_after
@Test
public void test_newFileSystem$URI$Map$ClassLoader() throws Exception {
    Path testPath = Paths.get("/");
    Map<String, String> stubEnv = new HashMap<>();
    try {
        FileSystems.newFileSystem(testPath.toUri(), stubEnv, getClass().getClassLoader());
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
    try {
        FileSystems.newFileSystem(null, stubEnv, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath.toUri(), null, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath.toUri(), stubEnv, null);
        fail();
    } catch (FileSystemAlreadyExistsException expected) {
    }
}
#end_block

#method_before
public void test_newFileSystem$Path$ClassLoader() throws IOException {
    Path testPath = Paths.get("/");
    try {
        FileSystems.newFileSystem(testPath, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (ProviderNotFoundException expected) {
    }
    try {
        FileSystems.newFileSystem(null, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath, null);
        fail();
    } catch (ProviderNotFoundException expected) {
    }
}
#method_after
@Test
public void test_newFileSystem$Path$ClassLoader() throws Exception {
    Path testPath = Paths.get("/");
    try {
        FileSystems.newFileSystem(testPath, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (ProviderNotFoundException expected) {
    }
    try {
        FileSystems.newFileSystem(null, Thread.currentThread().getContextClassLoader());
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        FileSystems.newFileSystem(testPath, null);
        fail();
    } catch (ProviderNotFoundException expected) {
    }
}
#end_block

#method_before
void setSupplicantLogLevel() {
    if (mVerboseLoggingEnabled) {
        mWifiNative.setSupplicantLogLevel("DEBUG");
    } else {
        mWifiNative.setSupplicantLogLevel("INFO");
    }
}
#method_after
void setSupplicantLogLevel() {
    mWifiNative.setSupplicantLogLevel(mVerboseLoggingEnabled);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
@Override
protected String getLogRecString(Message msg) {
    WifiConfiguration config;
    Long now;
    String report;
    String key;
    StringBuilder sb = new StringBuilder();
    if (mScreenOn) {
        sb.append("!");
    }
    if (messageHandlingStatus != MESSAGE_HANDLING_STATUS_UNKNOWN) {
        sb.append("(").append(messageHandlingStatus).append(")");
    }
    sb.append(smToString(msg));
    if (msg.sendingUid > 0 && msg.sendingUid != Process.WIFI_UID) {
        sb.append(" uid=" + msg.sendingUid);
    }
    sb.append(" ").append(printTime());
    switch(msg.what) {
        case CMD_START_SCAN:
            now = mClock.getWallClockMillis();
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ic=");
            sb.append(Integer.toString(sScanAlarmIntentCount));
            if (msg.obj != null) {
                Bundle bundle = (Bundle) msg.obj;
                Long request = bundle.getLong(SCAN_REQUEST_TIME, 0);
                if (request != 0) {
                    sb.append(" proc(ms):").append(now - request);
                }
            }
            if (mIsScanOngoing)
                sb.append(" onGoing");
            if (mIsFullScanOngoing)
                sb.append(" full");
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            if (lastScanFreqs != null) {
                sb.append(" list=");
                for (int freq : lastScanFreqs) {
                    sb.append(freq).append(",");
                }
            }
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            StateChangeResult stateChangeResult = (StateChangeResult) msg.obj;
            if (stateChangeResult != null) {
                sb.append(stateChangeResult.toString());
            }
            break;
        case WifiManager.SAVE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null && !config.preSharedKey.equals("*")) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
            }
            break;
        case WifiManager.FORGET_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
            }
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            String bssid = (String) msg.obj;
            if (bssid != null && bssid.length() > 0) {
                sb.append(" ");
                sb.append(bssid);
            }
            sb.append(" blacklist=" + Boolean.toString(didBlackListBSSID));
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mScanResults != null) {
                sb.append(" found=");
                sb.append(mScanResults.size());
            }
            sb.append(" known=").append(mNumScanResultsKnown);
            sb.append(" got=").append(mNumScanResultsReturned);
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            sb.append(String.format(" con=%d", mConnectionReqCount));
            sb.append(String.format(" untrustedcn=%d", mUntrustedReqCount));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case WifiMonitor.SCAN_FAILED_EVENT:
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ").append(mLastBssid);
            sb.append(" nid=").append(mLastNetworkId);
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(" ").append(config.configKey());
            }
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case CMD_TARGET_BSSID:
        case CMD_ASSOCIATED_BSSID:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                sb.append(" BSSID=").append((String) msg.obj);
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" Target=").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            sb.append(" nid=").append(msg.arg1);
            sb.append(" reason=").append(msg.arg2);
            if (mLastBssid != null) {
                sb.append(" lastbssid=").append(mLastBssid);
            }
            if (mWifiInfo.getFrequency() != -1) {
                sb.append(" freq=").append(mWifiInfo.getFrequency());
                sb.append(" rssi=").append(mWifiInfo.getRssi());
            }
            if (isLinkDebouncing()) {
                sb.append(" debounce");
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
        case WifiMonitor.SSID_REENABLED:
            sb.append(" nid=").append(msg.arg1);
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            config = getCurrentWifiConfiguration();
            if (config != null) {
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" cur=").append(config.configKey());
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                if (config.status != 0) {
                    sb.append(" st=").append(config.status);
                    sb.append(" rs=").append(netWorkSelectionStatus.getNetworkDisableReasonString());
                }
                if (config.lastConnected != 0) {
                    now = mClock.getWallClockMillis();
                    sb.append(" lastconn=").append(now - config.lastConnected).append("(ms)");
                }
                if (mLastBssid != null) {
                    sb.append(" lastbssid=").append(mLastBssid);
                }
                if (mWifiInfo.getFrequency() != -1) {
                    sb.append(" freq=").append(mWifiInfo.getFrequency());
                    sb.append(" rssi=").append(mWifiInfo.getRssi());
                    sb.append(" bssid=").append(mWifiInfo.getBSSID());
                }
            }
            break;
        case CMD_RSSI_POLL:
        case CMD_UNWANTED_NETWORK:
        case WifiManager.RSSI_PKTCNT_FETCH:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mWifiInfo.getSSID() != null)
                if (mWifiInfo.getSSID() != null)
                    sb.append(" ").append(mWifiInfo.getSSID());
            if (mWifiInfo.getBSSID() != null)
                sb.append(" ").append(mWifiInfo.getBSSID());
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            if (mWifiScoreReport.isLastReportValid()) {
                sb.append(mWifiScoreReport.getLastReport());
            }
            break;
        case CMD_START_CONNECT:
        case WifiManager.CONNECT_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null) {
                sb.append(" ").append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            break;
        case CMD_START_ROAM:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            ScanResult result = (ScanResult) msg.obj;
            if (result != null) {
                now = mClock.getWallClockMillis();
                sb.append(" bssid=").append(result.BSSID);
                sb.append(" rssi=").append(result.level);
                sb.append(" freq=").append(result.frequency);
                if (result.seen > 0 && result.seen < now) {
                    sb.append(" seen=").append(now - result.seen);
                } else {
                    // Somehow the timestamp for this scan result is inconsistent
                    sb.append(" !seen=").append(result.seen);
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            sb.append(" fail count=").append(Integer.toString(mRoamFailCount));
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                config = (WifiConfiguration) msg.obj;
                sb.append(" ").append(config.configKey());
                sb.append(" prio=").append(config.priority);
                sb.append(" status=").append(config.status);
                if (config.BSSID != null) {
                    sb.append(" ").append(config.BSSID);
                }
                WifiConfiguration curConfig = getCurrentWifiConfiguration();
                if (curConfig != null) {
                    if (curConfig.configKey().equals(config.configKey())) {
                        sb.append(" is current");
                    } else {
                        sb.append(" current=").append(curConfig.configKey());
                        sb.append(" prio=").append(curConfig.priority);
                        sb.append(" status=").append(curConfig.status);
                    }
                }
            }
            break;
        case WifiManager.DISABLE_NETWORK:
        case CMD_ENABLE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null && (key == null || !config.configKey().equals(key))) {
                sb.append(" target=").append(key);
            }
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" num=").append(mWifiConfigManager.getConfiguredNetworks().size());
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" txpkts=").append(mWifiInfo.txSuccess);
            sb.append(",").append(mWifiInfo.txBad);
            sb.append(",").append(mWifiInfo.txRetries);
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append(" OK ");
            } else if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append(" FAIL ");
            }
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                NetworkInfo info = (NetworkInfo) msg.obj;
                NetworkInfo.State state = info.getState();
                NetworkInfo.DetailedState detailedState = info.getDetailedState();
                if (state != null) {
                    sb.append(" st=").append(state);
                }
                if (detailedState != null) {
                    sb.append("/").append(detailedState);
                }
            }
            break;
        case CMD_IP_CONFIGURATION_LOST:
            int count = -1;
            WifiConfiguration c = getCurrentWifiConfiguration();
            if (c != null) {
                count = c.getNetworkSelectionStatus().getDisableReasonCounter(WifiConfiguration.NetworkSelectionStatus.DISABLED_DHCP_FAILURE);
            }
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" failures: ");
            sb.append(Integer.toString(count));
            sb.append("/");
            sb.append(Integer.toString(mFacade.getIntegerSetting(mContext, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, 0)));
            if (mWifiInfo.getBSSID() != null) {
                sb.append(" ").append(mWifiInfo.getBSSID());
            }
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            break;
        case CMD_UPDATE_LINKPROPERTIES:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            break;
        case CMD_INSTALL_PACKET_FILTER:
            sb.append(" len=" + ((byte[]) msg.obj).length);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            sb.append(" enabled=" + (boolean) msg.obj);
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(roamWatchdogCount);
            break;
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(disconnectingWatchdogCount);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            sb.append(" rssi=");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" thresholds=");
            sb.append(Arrays.toString(mRssiRanges));
            break;
        case CMD_USER_SWITCH:
            sb.append(" userId=");
            sb.append(Integer.toString(msg.arg1));
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append("DHCP_OK");
            } else if (msg.arg1 == CMD_STATIC_IP_SUCCESS) {
                sb.append("STATIC_OK");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        case CMD_IPV4_PROVISIONING_FAILURE:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append("DHCP_FAIL");
            } else if (msg.arg1 == CMD_STATIC_IP_FAILURE) {
                sb.append("STATIC_FAIL");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        default:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            break;
    }
    return sb.toString();
}
#method_after
@Override
protected String getLogRecString(Message msg) {
    WifiConfiguration config;
    Long now;
    String report;
    String key;
    StringBuilder sb = new StringBuilder();
    if (mScreenOn) {
        sb.append("!");
    }
    if (messageHandlingStatus != MESSAGE_HANDLING_STATUS_UNKNOWN) {
        sb.append("(").append(messageHandlingStatus).append(")");
    }
    sb.append(smToString(msg));
    if (msg.sendingUid > 0 && msg.sendingUid != Process.WIFI_UID) {
        sb.append(" uid=" + msg.sendingUid);
    }
    sb.append(" rt=").append(mClock.getUptimeSinceBootMillis());
    sb.append("/").append(mClock.getElapsedSinceBootMillis());
    switch(msg.what) {
        case CMD_START_SCAN:
            now = mClock.getWallClockMillis();
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ic=");
            sb.append(Integer.toString(sScanAlarmIntentCount));
            if (msg.obj != null) {
                Bundle bundle = (Bundle) msg.obj;
                Long request = bundle.getLong(SCAN_REQUEST_TIME, 0);
                if (request != 0) {
                    sb.append(" proc(ms):").append(now - request);
                }
            }
            if (mIsScanOngoing)
                sb.append(" onGoing");
            if (mIsFullScanOngoing)
                sb.append(" full");
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            if (lastScanFreqs != null) {
                sb.append(" list=");
                for (int freq : lastScanFreqs) {
                    sb.append(freq).append(",");
                }
            }
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            StateChangeResult stateChangeResult = (StateChangeResult) msg.obj;
            if (stateChangeResult != null) {
                sb.append(stateChangeResult.toString());
            }
            break;
        case WifiManager.SAVE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null && !config.preSharedKey.equals("*")) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
            }
            break;
        case WifiManager.FORGET_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
            }
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            String bssid = (String) msg.obj;
            if (bssid != null && bssid.length() > 0) {
                sb.append(" ");
                sb.append(bssid);
            }
            sb.append(" blacklist=" + Boolean.toString(didBlackListBSSID));
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mScanResults != null) {
                sb.append(" found=");
                sb.append(mScanResults.size());
            }
            sb.append(" known=").append(mNumScanResultsKnown);
            sb.append(" got=").append(mNumScanResultsReturned);
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            sb.append(String.format(" con=%d", mConnectionReqCount));
            sb.append(String.format(" untrustedcn=%d", mUntrustedReqCount));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case WifiMonitor.SCAN_FAILED_EVENT:
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ").append(mLastBssid);
            sb.append(" nid=").append(mLastNetworkId);
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(" ").append(config.configKey());
            }
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case CMD_TARGET_BSSID:
        case CMD_ASSOCIATED_BSSID:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                sb.append(" BSSID=").append((String) msg.obj);
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" Target=").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            sb.append(" nid=").append(msg.arg1);
            sb.append(" reason=").append(msg.arg2);
            if (mLastBssid != null) {
                sb.append(" lastbssid=").append(mLastBssid);
            }
            if (mWifiInfo.getFrequency() != -1) {
                sb.append(" freq=").append(mWifiInfo.getFrequency());
                sb.append(" rssi=").append(mWifiInfo.getRssi());
            }
            if (isLinkDebouncing()) {
                sb.append(" debounce");
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
        case WifiMonitor.SSID_REENABLED:
            sb.append(" nid=").append(msg.arg1);
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            config = getCurrentWifiConfiguration();
            if (config != null) {
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" cur=").append(config.configKey());
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                if (config.status != 0) {
                    sb.append(" st=").append(config.status);
                    sb.append(" rs=").append(netWorkSelectionStatus.getNetworkDisableReasonString());
                }
                if (config.lastConnected != 0) {
                    now = mClock.getWallClockMillis();
                    sb.append(" lastconn=").append(now - config.lastConnected).append("(ms)");
                }
                if (mLastBssid != null) {
                    sb.append(" lastbssid=").append(mLastBssid);
                }
                if (mWifiInfo.getFrequency() != -1) {
                    sb.append(" freq=").append(mWifiInfo.getFrequency());
                    sb.append(" rssi=").append(mWifiInfo.getRssi());
                    sb.append(" bssid=").append(mWifiInfo.getBSSID());
                }
            }
            break;
        case CMD_RSSI_POLL:
        case CMD_UNWANTED_NETWORK:
        case WifiManager.RSSI_PKTCNT_FETCH:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mWifiInfo.getSSID() != null)
                if (mWifiInfo.getSSID() != null)
                    sb.append(" ").append(mWifiInfo.getSSID());
            if (mWifiInfo.getBSSID() != null)
                sb.append(" ").append(mWifiInfo.getBSSID());
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            if (mWifiScoreReport.isLastReportValid()) {
                sb.append(mWifiScoreReport.getLastReport());
            }
            break;
        case CMD_START_CONNECT:
        case WifiManager.CONNECT_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null) {
                sb.append(" ").append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            break;
        case CMD_START_ROAM:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            ScanResult result = (ScanResult) msg.obj;
            if (result != null) {
                now = mClock.getWallClockMillis();
                sb.append(" bssid=").append(result.BSSID);
                sb.append(" rssi=").append(result.level);
                sb.append(" freq=").append(result.frequency);
                if (result.seen > 0 && result.seen < now) {
                    sb.append(" seen=").append(now - result.seen);
                } else {
                    // Somehow the timestamp for this scan result is inconsistent
                    sb.append(" !seen=").append(result.seen);
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            sb.append(" fail count=").append(Integer.toString(mRoamFailCount));
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                config = (WifiConfiguration) msg.obj;
                sb.append(" ").append(config.configKey());
                sb.append(" prio=").append(config.priority);
                sb.append(" status=").append(config.status);
                if (config.BSSID != null) {
                    sb.append(" ").append(config.BSSID);
                }
                WifiConfiguration curConfig = getCurrentWifiConfiguration();
                if (curConfig != null) {
                    if (curConfig.configKey().equals(config.configKey())) {
                        sb.append(" is current");
                    } else {
                        sb.append(" current=").append(curConfig.configKey());
                        sb.append(" prio=").append(curConfig.priority);
                        sb.append(" status=").append(curConfig.status);
                    }
                }
            }
            break;
        case WifiManager.DISABLE_NETWORK:
        case CMD_ENABLE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null && (key == null || !config.configKey().equals(key))) {
                sb.append(" target=").append(key);
            }
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" num=").append(mWifiConfigManager.getConfiguredNetworks().size());
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" txpkts=").append(mWifiInfo.txSuccess);
            sb.append(",").append(mWifiInfo.txBad);
            sb.append(",").append(mWifiInfo.txRetries);
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append(" OK ");
            } else if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append(" FAIL ");
            }
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                NetworkInfo info = (NetworkInfo) msg.obj;
                NetworkInfo.State state = info.getState();
                NetworkInfo.DetailedState detailedState = info.getDetailedState();
                if (state != null) {
                    sb.append(" st=").append(state);
                }
                if (detailedState != null) {
                    sb.append("/").append(detailedState);
                }
            }
            break;
        case CMD_IP_CONFIGURATION_LOST:
            int count = -1;
            WifiConfiguration c = getCurrentWifiConfiguration();
            if (c != null) {
                count = c.getNetworkSelectionStatus().getDisableReasonCounter(WifiConfiguration.NetworkSelectionStatus.DISABLED_DHCP_FAILURE);
            }
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" failures: ");
            sb.append(Integer.toString(count));
            sb.append("/");
            sb.append(Integer.toString(mFacade.getIntegerSetting(mContext, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, 0)));
            if (mWifiInfo.getBSSID() != null) {
                sb.append(" ").append(mWifiInfo.getBSSID());
            }
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            break;
        case CMD_UPDATE_LINKPROPERTIES:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            break;
        case CMD_INSTALL_PACKET_FILTER:
            sb.append(" len=" + ((byte[]) msg.obj).length);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            sb.append(" enabled=" + (boolean) msg.obj);
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(roamWatchdogCount);
            break;
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(disconnectingWatchdogCount);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            sb.append(" rssi=");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" thresholds=");
            sb.append(Arrays.toString(mRssiRanges));
            break;
        case CMD_USER_SWITCH:
            sb.append(" userId=");
            sb.append(Integer.toString(msg.arg1));
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append("DHCP_OK");
            } else if (msg.arg1 == CMD_STATIC_IP_SUCCESS) {
                sb.append("STATIC_OK");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        case CMD_IPV4_PROVISIONING_FAILURE:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append("DHCP_FAIL");
            } else if (msg.arg1 == CMD_STATIC_IP_FAILURE) {
                sb.append("STATIC_FAIL");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        default:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            break;
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public void enter() {
    cleanup();
}
#method_after
@Override
public void enter() {
    mWifiStateTracker.updateState(WifiStateTracker.INVALID);
    cleanup();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupDriverForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupDriverForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        setWifiState(WIFI_STATE_DISABLED);
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            mPasspointManager.notifyIconDone((IconEvent) message.obj);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            // TODO (b/35620640): Remove this command since the API is deprecated.
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            mPasspointManager.notifyIconDone((IconEvent) message.obj);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    mLastOperationMode = mOperationalMode;
}
#method_after
@Override
public void enter() {
    mLastOperationMode = mOperationalMode;
    mWifiStateTracker.updateState(WifiStateTracker.SCAN_MODE);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 == CONNECT_MODE) {
                setWifiState(WIFI_STATE_ENABLED);
                // Load and re-enable networks when going back to enabled state
                // This is essential for networks to show up after restore
                mWifiConfigManager.loadFromStore();
                p2pSendMessage(CMD_ENABLE_P2P);
                mOperationalMode = CONNECT_MODE;
                transitionTo(mDisconnectedState);
            } else if (message.arg1 == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            // Nothing to do
            break;
        // handled only in ConnectModeState
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            if (mVerboseLoggingEnabled)
                log("SupplicantState= " + state);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 == CONNECT_MODE) {
                mOperationalMode = CONNECT_MODE;
                transitionTo(mDisconnectedState);
            } else if (message.arg1 == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            // Nothing to do
            break;
        // handled only in ConnectModeState
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            if (mVerboseLoggingEnabled)
                log("SupplicantState= " + state);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && TelephonyUtil.isSimConfig(targetWificonfiguration)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), targetWificonfiguration);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                } else {
                    Log.e(TAG, "Unable to retrieve identity from Telephony");
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    updateDefaultRouteMacAddress(1000);
    if (mVerboseLoggingEnabled) {
        log("Enter ConnectedState " + " mScreenOn=" + mScreenOn);
    }
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED);
    registerConnected();
    lastConnectAttemptTimestamp = 0;
    targetWificonfiguration = null;
    // Paranoia
    mIsLinkDebouncing = false;
    // Not roaming anymore
    mAutoRoaming = false;
    if (testNetworkDisconnect) {
        testNetworkDisconnectCounter++;
        logd("ConnectedState Enter start disconnect test " + testNetworkDisconnectCounter);
        sendMessageDelayed(obtainMessage(CMD_TEST_NETWORK_DISCONNECT, testNetworkDisconnectCounter, 0), 15000);
    }
    mLastDriverRoamAttempt = 0;
    mTargetNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(true);
}
#method_after
@Override
public void enter() {
    updateDefaultRouteMacAddress(1000);
    if (mVerboseLoggingEnabled) {
        log("Enter ConnectedState " + " mScreenOn=" + mScreenOn);
    }
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED);
    registerConnected();
    lastConnectAttemptTimestamp = 0;
    targetWificonfiguration = null;
    // Paranoia
    mIsLinkDebouncing = false;
    // Not roaming anymore
    mAutoRoaming = false;
    if (testNetworkDisconnect) {
        testNetworkDisconnectCounter++;
        logd("ConnectedState Enter start disconnect test " + testNetworkDisconnectCounter);
        sendMessageDelayed(obtainMessage(CMD_TEST_NETWORK_DISCONNECT, testNetworkDisconnectCounter, 0), 15000);
    }
    mLastDriverRoamAttempt = 0;
    mTargetNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(true);
    mWifiStateTracker.updateState(WifiStateTracker.CONNECTED);
}
#end_block

#method_before
@Override
public void enter() {
    // due to p2p
    if (mTemporarilyDisconnectWifi) {
        p2pSendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
        return;
    }
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectedState screenOn=" + mScreenOn);
    }
    /**
     * clear the roaming state, if we were roaming, we failed
     */
    mAutoRoaming = false;
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
    /**
     * If we have no networks saved, the supplicant stops doing the periodic scan.
     * The scans are useful to notify the user of the presence of an open network.
     * Note that these are not wake up scans.
     */
    if (mNoNetworksPeriodicScan != 0 && !mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
    }
    mDisconnectedTimeStamp = mClock.getWallClockMillis();
}
#method_after
@Override
public void enter() {
    // due to p2p
    if (mTemporarilyDisconnectWifi) {
        p2pSendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
        return;
    }
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectedState screenOn=" + mScreenOn);
    }
    /**
     * clear the roaming state, if we were roaming, we failed
     */
    mAutoRoaming = false;
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
    /**
     * If we have no networks saved, the supplicant stops doing the periodic scan.
     * The scans are useful to notify the user of the presence of an open network.
     * Note that these are not wake up scans.
     */
    if (mNoNetworksPeriodicScan != 0 && !mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
    }
    mDisconnectedTimeStamp = mClock.getWallClockMillis();
    mWifiStateTracker.updateState(WifiStateTracker.DISCONNECTED);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (mP2pConnected.get()) {
                int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_scan_interval_p2p_connected);
                long scanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS, defaultInterval);
                mWifiNative.setScanInterval((int) scanIntervalMs / 1000);
            } else if (mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (!mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#end_block

#method_before
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = mWifiNative.setupDriverForSoftApMode();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
}
#method_after
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = mWifiNative.setupDriverForSoftApMode();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
    mWifiStateTracker.updateState(WifiStateTracker.SOFT_AP);
}
#end_block

#method_before
void updateWifiMetrics() {
    int numSavedNetworks = mWifiConfigManager.getConfiguredNetworks().size();
    int numOpenNetworks = 0;
    int numPersonalNetworks = 0;
    int numEnterpriseNetworks = 0;
    int numNetworksAddedByUser = 0;
    int numNetworksAddedByApps = 0;
    int numHiddenNetworks = 0;
    int numPasspoint = 0;
    for (WifiConfiguration config : mWifiConfigManager.getSavedNetworks()) {
        if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            numOpenNetworks++;
        } else if (config.isEnterprise()) {
            numEnterpriseNetworks++;
        } else {
            numPersonalNetworks++;
        }
        if (config.selfAdded) {
            numNetworksAddedByUser++;
        } else {
            numNetworksAddedByApps++;
        }
        if (config.hiddenSSID) {
            numHiddenNetworks++;
        }
        if (config.isPasspoint()) {
            numPasspoint++;
        }
    }
    mWifiMetrics.setNumSavedNetworks(numSavedNetworks);
    mWifiMetrics.setNumOpenNetworks(numOpenNetworks);
    mWifiMetrics.setNumPersonalNetworks(numPersonalNetworks);
    mWifiMetrics.setNumEnterpriseNetworks(numEnterpriseNetworks);
    mWifiMetrics.setNumNetworksAddedByUser(numNetworksAddedByUser);
    mWifiMetrics.setNumNetworksAddedByApps(numNetworksAddedByApps);
    mWifiMetrics.setNumHiddenNetworks(numHiddenNetworks);
    mWifiMetrics.setNumPasspointNetworks(numPasspoint);
}
#method_after
public void updateWifiMetrics() {
    mWifiMetrics.updateSavedNetworks(mWifiConfigManager.getSavedNetworks());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(mock(Clock.class));
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiNative.setupDriverForClientMode()).thenReturn(mClientInterface);
    when(mWifiNative.setupDriverForSoftApMode()).thenReturn(mApInterface);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiNative.enableSupplicant()).thenReturn(true);
    when(mWifiNative.disableSupplicant()).thenReturn(true);
    when(mWifiNative.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#method_after
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(new Clock());
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiNative.setupDriverForClientMode()).thenReturn(mClientInterface);
    when(mWifiNative.setupDriverForSoftApMode()).thenReturn(mApInterface);
    when(mWifiInjector.getWifiStateTracker()).thenReturn(mWifiStateTracker);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiNative.enableSupplicant()).thenReturn(true);
    when(mWifiNative.disableSupplicant()).thenReturn(true);
    when(mWifiNative.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#end_block

#method_before
@Test
public void normalLogRecSizeIsUsedByDefault() {
    for (int i = 0; i < WifiStateMachine.NUM_LOG_RECS_NORMAL * 2; i++) {
        mWsm.sendMessage(WifiStateMachine.CMD_DISCONNECT);
    }
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.NUM_LOG_RECS_NORMAL, mWsm.getLogRecSize());
}
#method_after
@Test
public void normalLogRecSizeIsUsedByDefault() {
    assertEquals(WifiStateMachine.NUM_LOG_RECS_NORMAL, mWsm.getLogRecMaxSize());
}
#end_block

#method_before
private void enforceCarrierOrCarrierImsPrivilege() {
    int callingUid = Binder.getCallingUid();
    String carrierImsPackage = CarrierSmsUtils.getCarrierImsPackageForIntent(mContext, mPhone, new Intent(CarrierMessagingService.SERVICE_INTERFACE));
    try {
        if (carrierImsPackage == null || callingUid != mContext.getPackageManager().getPackageUid(carrierImsPackage, 0)) {
            enforceCarrierPrivilege();
        }
    } catch (PackageManager.NameNotFoundException e) {
        if (Rlog.isLoggable("SMS", Log.DEBUG)) {
            log("Cannot find configured carrier ims package");
        }
        enforceCarrierPrivilege();
    }
}
#method_after
private void enforceCarrierOrCarrierImsPrivilege() {
    int callingUid = Binder.getCallingUid();
    String carrierImsPackage = CarrierSmsUtils.getCarrierImsPackageForIntent(mContext, mPhone, new Intent(CarrierMessagingService.SERVICE_INTERFACE));
    try {
        if (carrierImsPackage != null && callingUid == mContext.getPackageManager().getPackageUid(carrierImsPackage, 0)) {
            return;
        }
    } catch (PackageManager.NameNotFoundException e) {
        if (Rlog.isLoggable("SMS", Log.DEBUG)) {
            log("Cannot find configured carrier ims package");
        }
    }
    enforceCarrierPrivilege();
}
#end_block

#method_before
/* Parcelable Implementation */
public int describeContents() {
    return 0;
}
#method_after
public int describeContents() {
    return 0;
}
#end_block

#method_before
public void writeToParcel(Parcel out, int flags) {
/* TODO: stuff */
}
#method_after
public void writeToParcel(Parcel out, int flags) {
    out.writeString(mName);
    out.writeByteArray(mKey);
    out.writeInt(mTruncLenBits);
}
#end_block

#method_before
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent mockAgent, int timeoutMs) {
    final Network expectedNetwork = (mockAgent != null) ? mockAgent.getNetwork() : null;
    CallbackInfo expected = new CallbackInfo(state, expectedNetwork, 0);
    CallbackInfo actual = nextCallback(timeoutMs);
    assertEquals("Unexpected callback:", expected, actual);
    if (state == CallbackState.LOSING) {
        String msg = String.format("Invalid linger time value %d, must be between %d and %d", actual.arg, 0, TEST_LINGER_DELAY_MS);
        int maxMsToLive = (Integer) actual.arg;
        assertTrue(msg, 0 <= maxMsToLive && maxMsToLive <= TEST_LINGER_DELAY_MS);
    }
    return actual;
}
#method_after
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent agent, int timeoutMs) {
    final Network expectedNetwork = (agent != null) ? agent.getNetwork() : null;
    CallbackInfo expected = new CallbackInfo(state, expectedNetwork, 0);
    CallbackInfo actual = nextCallback(timeoutMs);
    assertEquals("Unexpected callback:", expected, actual);
    if (state == CallbackState.LOSING) {
        String msg = String.format("Invalid linger time value %d, must be between %d and %d", actual.arg, 0, TEST_LINGER_DELAY_MS);
        int maxMsToLive = (Integer) actual.arg;
        assertTrue(msg, 0 <= maxMsToLive && maxMsToLive <= TEST_LINGER_DELAY_MS);
    }
    return actual;
}
#end_block

#method_before
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent mockAgent) {
    return expectCallback(state, mockAgent, TIMEOUT_MS);
}
#method_after
CallbackInfo expectCallback(CallbackState state, MockNetworkAgent agent) {
    return expectCallback(state, agent, TIMEOUT_MS);
}
#end_block

#method_before
void expectAvailableCallbacks(MockNetworkAgent mockAgent, boolean expectSuspended, int timeoutMs) {
    expectCallback(CallbackState.AVAILABLE, mockAgent, timeoutMs);
    final boolean HAS_DATASYNC_ON_AVAILABLE = false;
    if (HAS_DATASYNC_ON_AVAILABLE) {
        if (expectSuspended) {
            expectCallback(CallbackState.SUSPENDED, mockAgent, timeoutMs);
        }
        expectCallback(CallbackState.NETWORK_CAPABILITIES, mockAgent, timeoutMs);
        expectCallback(CallbackState.LINK_PROPERTIES, mockAgent, timeoutMs);
    }
}
#method_after
void expectAvailableCallbacks(MockNetworkAgent agent, boolean expectSuspended, int timeoutMs) {
    expectCallback(CallbackState.AVAILABLE, agent, timeoutMs);
    final boolean HAS_DATASYNC_ON_AVAILABLE = false;
    if (HAS_DATASYNC_ON_AVAILABLE) {
        if (expectSuspended) {
            expectCallback(CallbackState.SUSPENDED, agent, timeoutMs);
        }
        expectCallback(CallbackState.NETWORK_CAPABILITIES, agent, timeoutMs);
        expectCallback(CallbackState.LINK_PROPERTIES, agent, timeoutMs);
    }
}
#end_block

#method_before
void expectAvailableCallbacks(MockNetworkAgent mockAgent) {
    expectAvailableCallbacks(mockAgent, false, TIMEOUT_MS);
}
#method_after
void expectAvailableCallbacks(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, false, TIMEOUT_MS);
}
#end_block

#method_before
void expectAvailableAndSuspendedCallbacks(MockNetworkAgent mockAgent) {
    expectAvailableCallbacks(mockAgent, true, TIMEOUT_MS);
}
#method_after
void expectAvailableAndSuspendedCallbacks(MockNetworkAgent agent) {
    expectAvailableCallbacks(agent, true, TIMEOUT_MS);
}
#end_block

#method_before
void expectCapabilitiesWith(int capability, MockNetworkAgent mockAgent) {
    CallbackInfo cbi = expectCallback(CallbackState.NETWORK_CAPABILITIES, mockAgent);
    NetworkCapabilities nc = (NetworkCapabilities) cbi.arg;
    assertTrue(nc.hasCapability(capability));
}
#method_after
void expectCapabilitiesWith(int capability, MockNetworkAgent agent) {
    CallbackInfo cbi = expectCallback(CallbackState.NETWORK_CAPABILITIES, agent);
    NetworkCapabilities nc = (NetworkCapabilities) cbi.arg;
    assertTrue(nc.hasCapability(capability));
}
#end_block

#method_before
void expectCapabilitiesWithout(int capability, MockNetworkAgent mockAgent) {
    CallbackInfo cbi = expectCallback(CallbackState.NETWORK_CAPABILITIES, mockAgent);
    NetworkCapabilities nc = (NetworkCapabilities) cbi.arg;
    assertFalse(nc.hasCapability(capability));
}
#method_after
void expectCapabilitiesWithout(int capability, MockNetworkAgent agent) {
    CallbackInfo cbi = expectCallback(CallbackState.NETWORK_CAPABILITIES, agent);
    NetworkCapabilities nc = (NetworkCapabilities) cbi.arg;
    assertFalse(nc.hasCapability(capability));
}
#end_block

#method_before
@SmallTest
public void testStateChangeNetworkCallbacks() throws Exception {
    final TestNetworkCallback genericNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback wifiNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest genericRequest = new NetworkRequest.Builder().clearCapabilities().build();
    final NetworkRequest wifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(genericRequest, genericNetworkCallback);
    mCm.registerNetworkCallback(wifiRequest, wifiNetworkCallback);
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    // Test unvalidated networks
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // Test validated networks
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    genericNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    genericNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    genericNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    wifiNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
}
#method_after
@SmallTest
public void testStateChangeNetworkCallbacks() throws Exception {
    final TestNetworkCallback genericNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback wifiNetworkCallback = new TestNetworkCallback();
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest genericRequest = new NetworkRequest.Builder().clearCapabilities().build();
    final NetworkRequest wifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(genericRequest, genericNetworkCallback);
    mCm.registerNetworkCallback(wifiRequest, wifiNetworkCallback);
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    // Test unvalidated networks
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(2);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    cv = waitForConnectivityBroadcasts(1);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    waitFor(cv);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // Test validated networks
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    // This should not trigger spurious onAvailable() callbacks, b/21762680.
    mCellNetworkAgent.adjustScore(-1);
    mService.waitForIdle();
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    genericNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    genericNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    genericNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetworkCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mWiFiNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    wifiNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
    mCellNetworkAgent.disconnect();
    genericNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
}
#end_block

#method_before
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mEthernetNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mEthernetNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mEthernetNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectAvailableCallbacks(newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    // We expect a notification about the capabilities change, and nothing else.
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_NOT_METERED, mWiFiNetworkAgent);
    defaultCallback.assertNoCallback();
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#method_after
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mEthernetNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mEthernetNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectAvailableCallbacks(newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    // We expect a notification about the capabilities change, and nothing else.
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_NOT_METERED, mWiFiNetworkAgent);
    defaultCallback.assertNoCallback();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate sending validated before losing.
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#end_block

#method_before
@SmallTest
public void testCaptivePortal() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), firstRedirectUrl);
    // Take down network.
    // Expect onLost callback.
    mWiFiNetworkAgent.disconnect();
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), secondRedirectUrl);
    // Make captive portal disappear then revalidate.
    // Expect onLost callback because network no longer provides NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 204;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // Break network connectivity.
    // Expect NET_CAPABILITY_VALIDATED onLost callback.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 500;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), false);
    validatedCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
}
#method_after
@SmallTest
public void testCaptivePortal() {
    final TestNetworkCallback captivePortalCallback = new TestNetworkCallback();
    final NetworkRequest captivePortalRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    mCm.registerNetworkCallback(captivePortalRequest, captivePortalCallback);
    final TestNetworkCallback validatedCallback = new TestNetworkCallback();
    final NetworkRequest validatedRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    mCm.registerNetworkCallback(validatedRequest, validatedCallback);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String firstRedirectUrl = "http://example.com/firstPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(firstRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), firstRedirectUrl);
    // Take down network.
    // Expect onLost callback.
    mWiFiNetworkAgent.disconnect();
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Bring up a network with a captive portal.
    // Expect onAvailable callback of listen for NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    String secondRedirectUrl = "http://example.com/secondPath";
    mWiFiNetworkAgent.connectWithCaptivePortal(secondRedirectUrl);
    captivePortalCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.waitForRedirectUrl(), secondRedirectUrl);
    // Make captive portal disappear then revalidate.
    // Expect onLost callback because network no longer provides NET_CAPABILITY_CAPTIVE_PORTAL.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 204;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    captivePortalCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Expect NET_CAPABILITY_VALIDATED onAvailable callback.
    validatedCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    // TODO: Investigate only sending available callbacks.
    validatedCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // Break network connectivity.
    // Expect NET_CAPABILITY_VALIDATED onLost callback.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 500;
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), false);
    validatedCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
}
#end_block

#method_before
@SmallTest
public void testRegisterDefaultNetworkCallback() throws Exception {
    final TestNetworkCallback defaultNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultNetworkCallback);
    defaultNetworkCallback.assertNoCallback();
    // Create a TRANSPORT_CELLULAR request to keep the mobile interface up
    // whenever Wi-Fi is up. Without this, the mobile network agent is
    // reaped before any other activity can take place.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    cellNetworkCallback.assertNoCallback();
    // Bring up cell and expect CALLBACK_AVAILABLE.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    defaultNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    // Bring up wifi and expect CALLBACK_AVAILABLE.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // Bring down cell. Expect no default network callback, since it wasn't the default.
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring up cell. Expect no default network callback, since it won't be the default.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring down wifi. Expect the default network callback to notified of LOST wifi
    // followed by AVAILABLE cell.
    mWiFiNetworkAgent.disconnect();
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
}
#method_after
@SmallTest
public void testRegisterDefaultNetworkCallback() throws Exception {
    final TestNetworkCallback defaultNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultNetworkCallback);
    defaultNetworkCallback.assertNoCallback();
    // Create a TRANSPORT_CELLULAR request to keep the mobile interface up
    // whenever Wi-Fi is up. Without this, the mobile network agent is
    // reaped before any other activity can take place.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    cellNetworkCallback.assertNoCallback();
    // Bring up cell and expect CALLBACK_AVAILABLE.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    // Bring up wifi and expect CALLBACK_AVAILABLE.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    // Bring down cell. Expect no default network callback, since it wasn't the default.
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring up cell. Expect no default network callback, since it won't be the default.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultNetworkCallback.assertNoCallback();
    // Bring down wifi. Expect the default network callback to notified of LOST wifi
    // followed by AVAILABLE cell.
    mWiFiNetworkAgent.disconnect();
    cellNetworkCallback.assertNoCallback();
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
}
#end_block

#method_before
@SmallTest
public void testAdditionalStateCallbacks() throws Exception {
    // File a network request for mobile.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    // Bring up the mobile network.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    // We should get onAvailable(), onCapabilitiesChanged(), and
    // onLinkPropertiesChanged() in rapid succession.
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // We should get onCapabilitiesChanged(), when the mobile network successfully validates.
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Update LinkProperties.
    final LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("foonet_data0");
    mCellNetworkAgent.sendLinkProperties(lp);
    // We should get onLinkPropertiesChanged().
    cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Suspend the network.
    mCellNetworkAgent.suspend();
    cellNetworkCallback.expectCallback(CallbackState.SUSPENDED, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Register a garden variety default network request.
    final TestNetworkCallback dfltNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(dfltNetworkCallback);
    // We should get onAvailable(), onCapabilitiesChanged(), onLinkPropertiesChanged(),
    // as well as onNetworkSuspended() in rapid succession.
    dfltNetworkCallback.expectAvailableAndSuspendedCallbacks(mCellNetworkAgent);
    dfltNetworkCallback.assertNoCallback();
    // Request a NetworkCapabilities update; only the requesting callback is notified.
    // TODO: Delete this together with Connectivity{Manager,Service} code.
    mCm.requestNetworkCapabilities(dfltNetworkCallback);
    dfltNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    dfltNetworkCallback.assertNoCallback();
    // Request a LinkProperties update; only the requesting callback is notified.
    // TODO: Delete this together with Connectivity{Manager,Service} code.
    mCm.requestLinkProperties(dfltNetworkCallback);
    dfltNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    dfltNetworkCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(dfltNetworkCallback);
    mCm.unregisterNetworkCallback(cellNetworkCallback);
}
#method_after
@SmallTest
public void testAdditionalStateCallbacks() throws Exception {
    // File a network request for mobile.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    // Bring up the mobile network.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    // We should get onAvailable(), onCapabilitiesChanged(), and
    // onLinkPropertiesChanged() in rapid succession. Additionally, we
    // should get onCapabilitiesChanged() when the mobile network validates.
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Update LinkProperties.
    final LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("foonet_data0");
    mCellNetworkAgent.sendLinkProperties(lp);
    // We should get onLinkPropertiesChanged().
    cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Suspend the network.
    mCellNetworkAgent.suspend();
    cellNetworkCallback.expectCallback(CallbackState.SUSPENDED, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    // Register a garden variety default network request.
    final TestNetworkCallback dfltNetworkCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(dfltNetworkCallback);
    // We should get onAvailable(), onCapabilitiesChanged(), onLinkPropertiesChanged(),
    // as well as onNetworkSuspended() in rapid succession.
    dfltNetworkCallback.expectAvailableAndSuspendedCallbacks(mCellNetworkAgent);
    dfltNetworkCallback.assertNoCallback();
    // Request a NetworkCapabilities update; only the requesting callback is notified.
    // TODO: Delete this together with Connectivity{Manager,Service} code.
    mCm.requestNetworkCapabilities(dfltNetworkCallback);
    dfltNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    dfltNetworkCallback.assertNoCallback();
    // Request a LinkProperties update; only the requesting callback is notified.
    // TODO: Delete this together with Connectivity{Manager,Service} code.
    mCm.requestLinkProperties(dfltNetworkCallback);
    dfltNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    dfltNetworkCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(dfltNetworkCallback);
    mCm.unregisterNetworkCallback(cellNetworkCallback);
}
#end_block

#method_before
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableCallbacks(mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    mService.waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    // NOTE: This request causes the network's capabilities to change. This
    // is currently delivered before the onAvailable() callbacks.
    cellCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    cellCallback.expectAvailableCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Expect a network capabilities update with FOREGROUND, because the most recent
    // request causes its state to change.
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#method_after
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectAvailableCallbacks(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    mService.waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    // NOTE: This request causes the network's capabilities to change. This
    // is currently delivered before the onAvailable() callbacks.
    // TODO: Fix this.
    cellCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    cellCallback.expectAvailableCallbacks(mCellNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    // Expect a network capabilities update with FOREGROUND, because the most recent
    // request causes its state to change.
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // Expect a network capabilities update sans FOREGROUND.
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#end_block

#method_before
@SmallTest
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setMobileDataAlwaysOn(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertEquals(1, mCm.getAllNetworks().length);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    mService.waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertEquals(2, mCm.getAllNetworks().length);
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setMobileDataAlwaysOn(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertEquals(1, mCm.getAllNetworks().length);
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#method_after
@SmallTest
public void testMobileDataAlwaysOn() throws Exception {
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.registerNetworkCallback(cellRequest, cellNetworkCallback);
    final HandlerThread handlerThread = new HandlerThread("MobileDataAlwaysOnFactory");
    handlerThread.start();
    NetworkCapabilities filter = new NetworkCapabilities().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET);
    final MockNetworkFactory testFactory = new MockNetworkFactory(handlerThread.getLooper(), mServiceContext, "testFactory", filter);
    testFactory.setScoreFilter(40);
    // Register the factory and expect it to start looking for a network.
    testFactory.expectAddRequests(1);
    testFactory.register();
    testFactory.waitForNetworkRequests(1);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up wifi. The factory stops looking for a network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Because the default request changes score twice.
    testFactory.expectAddRequests(2);
    mWiFiNetworkAgent.connect(true);
    testFactory.waitForNetworkRequests(1);
    assertFalse(testFactory.getMyStartRequested());
    ContentResolver cr = mServiceContext.getContentResolver();
    // Turn on mobile data always on. The factory starts looking again.
    testFactory.expectAddRequests(1);
    setMobileDataAlwaysOn(true);
    testFactory.waitForNetworkRequests(2);
    assertTrue(testFactory.getMyStartRequested());
    // Bring up cell data and check that the factory stops looking.
    assertEquals(1, mCm.getAllNetworks().length);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Because the cell request changes score twice.
    testFactory.expectAddRequests(2);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    testFactory.waitForNetworkRequests(2);
    // Because the cell network outscores us.
    assertFalse(testFactory.getMyStartRequested());
    // Check that cell data stays up.
    mService.waitForIdle();
    verifyActiveNetwork(TRANSPORT_WIFI);
    assertEquals(2, mCm.getAllNetworks().length);
    // Turn off mobile data always on and expect the request to disappear...
    testFactory.expectRemoveRequests(1);
    setMobileDataAlwaysOn(false);
    testFactory.waitForNetworkRequests(1);
    // ...  and cell data to be torn down.
    cellNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    assertEquals(1, mCm.getAllNetworks().length);
    testFactory.unregister();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    handlerThread.quit();
}
#end_block

#method_before
@SmallTest
public void testAvoidBadWifi() throws Exception {
    final ContentResolver cr = mServiceContext.getContentResolver();
    final WrappedMultinetworkPolicyTracker tracker = mService.getMultinetworkPolicyTracker();
    // Pretend we're on a carrier that restricts switching away from bad wifi.
    tracker.configRestrictsAvoidBadWifi = true;
    // File a request for cell to ensure it doesn't go down.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    NetworkRequest validatedWifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).addCapability(NET_CAPABILITY_VALIDATED).build();
    TestNetworkCallback validatedWifiCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(validatedWifiRequest, validatedWifiCallback);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 0);
    tracker.reevaluate();
    // Bring up validated cell.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableCallbacks(mCellNetworkAgent);
    cellNetworkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mCellNetworkAgent);
    Network cellNetwork = mCellNetworkAgent.getNetwork();
    // Bring up validated wifi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    Network wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Because avoid bad wifi is off, we don't switch to cellular.
    defaultCallback.assertNoCallback();
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate switching to a carrier that does not restrict avoiding bad wifi, and expect
    // that we switch back to cell.
    tracker.configRestrictsAvoidBadWifi = false;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Switch back to a restrictive carrier.
    tracker.configRestrictsAvoidBadWifi = true;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate the user selecting "switch" on the dialog, and check that we switch to cell.
    mCm.setAvoidUnvalidated(wifiNetwork);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Disconnect and reconnect wifi to clear the one-time switch above.
    mWiFiNetworkAgent.disconnect();
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi and expect the dialog to appear.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Simulate the user selecting "switch" and checking the don't ask again checkbox.
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    // We now switch to cell.
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Simulate the user turning the cellular fallback setting off and then on.
    // We switch to wifi and then to cell.
    Settings.Global.putString(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // If cell goes down, we switch to wifi.
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    mCm.unregisterNetworkCallback(validatedWifiCallback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#method_after
@SmallTest
public void testAvoidBadWifi() throws Exception {
    final ContentResolver cr = mServiceContext.getContentResolver();
    final WrappedMultinetworkPolicyTracker tracker = mService.getMultinetworkPolicyTracker();
    // Pretend we're on a carrier that restricts switching away from bad wifi.
    tracker.configRestrictsAvoidBadWifi = true;
    // File a request for cell to ensure it doesn't go down.
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    NetworkRequest validatedWifiRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).addCapability(NET_CAPABILITY_VALIDATED).build();
    TestNetworkCallback validatedWifiCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(validatedWifiRequest, validatedWifiCallback);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 0);
    tracker.reevaluate();
    // Bring up validated cell.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    cellNetworkCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableAndValidatedCallbacks(mCellNetworkAgent);
    Network cellNetwork = mCellNetworkAgent.getNetwork();
    // Bring up validated wifi.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    Network wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Because avoid bad wifi is off, we don't switch to cellular.
    defaultCallback.assertNoCallback();
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate switching to a carrier that does not restrict avoiding bad wifi, and expect
    // that we switch back to cell.
    tracker.configRestrictsAvoidBadWifi = false;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Switch back to a restrictive carrier.
    tracker.configRestrictsAvoidBadWifi = true;
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    // Simulate the user selecting "switch" on the dialog, and check that we switch to cell.
    mCm.setAvoidUnvalidated(wifiNetwork);
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Disconnect and reconnect wifi to clear the one-time switch above.
    mWiFiNetworkAgent.disconnect();
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableAndValidatedCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    wifiNetwork = mWiFiNetworkAgent.getNetwork();
    // Fail validation on wifi and expect the dialog to appear.
    mWiFiNetworkAgent.getWrappedNetworkMonitor().gen204ProbeResult = 599;
    mCm.reportNetworkConnectivity(wifiNetwork, false);
    defaultCallback.expectCapabilitiesWithout(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    validatedWifiCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Simulate the user selecting "switch" and checking the don't ask again checkbox.
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    // We now switch to cell.
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertFalse(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertTrue(mCm.getNetworkCapabilities(cellNetwork).hasCapability(NET_CAPABILITY_VALIDATED));
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // Simulate the user turning the cellular fallback setting off and then on.
    // We switch to wifi and then to cell.
    Settings.Global.putString(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), wifiNetwork);
    Settings.Global.putInt(cr, Settings.Global.NETWORK_AVOID_BAD_WIFI, 1);
    tracker.reevaluate();
    defaultCallback.expectAvailableCallbacks(mCellNetworkAgent);
    assertEquals(mCm.getActiveNetwork(), cellNetwork);
    // If cell goes down, we switch to wifi.
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacks(mWiFiNetworkAgent);
    validatedWifiCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(cellNetworkCallback);
    mCm.unregisterNetworkCallback(validatedWifiCallback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#end_block

#method_before
public void onDeviceFound(byte[] srcAddress, byte[] p2pDeviceAddress, byte[] primaryDeviceType, String deviceName, short configMethods, byte deviceCapabilities, int groupCapabilities, byte[] wfdDeviceInfo) {
    WifiP2pDevice device = new WifiP2pDevice();
    device.deviceName = deviceName;
    device.deviceAddress = bytesToString(p2pDeviceAddress, ":");
    device.primaryDeviceType = bytesToString(primaryDeviceType, null);
    device.deviceCapability = deviceCapabilities;
    device.groupCapability = groupCapabilities;
    device.wpsConfigMethodsSupported = configMethods;
    device.status = WifiP2pDevice.AVAILABLE;
    if (wfdDeviceInfo.length >= 6) {
        device.wfdInfo = new WifiP2pWfdInfo((wfdDeviceInfo[0] << 8) + wfdDeviceInfo[1], (wfdDeviceInfo[2] << 8) + wfdDeviceInfo[3], (wfdDeviceInfo[4] << 8) + wfdDeviceInfo[5]);
    }
    Log.i(TAG, "Device discovered on " + mInterface + ": " + device);
    mMonitor.handleDeviceFound(mInterface, device);
}
#method_after
public void onDeviceFound(byte[] srcAddress, byte[] p2pDeviceAddress, byte[] primaryDeviceType, String deviceName, short configMethods, byte deviceCapabilities, int groupCapabilities, byte[] wfdDeviceInfo) {
    WifiP2pDevice device = new WifiP2pDevice();
    device.deviceName = deviceName;
    if (deviceName == null) {
        Log.e(TAG, "Missing device name.");
        return;
    }
    try {
        device.deviceAddress = NativeUtil.macAddressFromByteArray(p2pDeviceAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode device address.", e);
        return;
    }
    try {
        device.primaryDeviceType = new String(HexEncoding.encode(primaryDeviceType, 0, primaryDeviceType.length));
    } catch (Exception e) {
        Log.e(TAG, "Could not encode device primary type.", e);
        return;
    }
    device.deviceCapability = deviceCapabilities;
    device.groupCapability = groupCapabilities;
    device.wpsConfigMethodsSupported = configMethods;
    device.status = WifiP2pDevice.AVAILABLE;
    if (wfdDeviceInfo != null && wfdDeviceInfo.length >= 6) {
        device.wfdInfo = new WifiP2pWfdInfo((wfdDeviceInfo[0] << 8) + wfdDeviceInfo[1], (wfdDeviceInfo[2] << 8) + wfdDeviceInfo[3], (wfdDeviceInfo[4] << 8) + wfdDeviceInfo[5]);
    }
    logd("Device discovered on " + mInterface + ": " + device);
    mMonitor.broadcastP2pDeviceFound(mInterface, device);
}
#end_block

#method_before
public void onDeviceLost(byte[] p2pDeviceAddress) {
    WifiP2pDevice device = new WifiP2pDevice();
    device.deviceAddress = bytesToString(p2pDeviceAddress, ":");
    device.status = WifiP2pDevice.UNAVAILABLE;
    Log.i(TAG, "Device lost on " + mInterface + ": " + device);
    mMonitor.handleDeviceLost(mInterface, device);
}
#method_after
public void onDeviceLost(byte[] p2pDeviceAddress) {
    WifiP2pDevice device = new WifiP2pDevice();
    try {
        device.deviceAddress = NativeUtil.macAddressFromByteArray(p2pDeviceAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode device address.", e);
        return;
    }
    device.status = WifiP2pDevice.UNAVAILABLE;
    logd("Device lost on " + mInterface + ": " + device);
    mMonitor.broadcastP2pDeviceLost(mInterface, device);
}
#end_block

#method_before
public void onFindStopped() {
    Log.i(TAG, "Search stopped on " + mInterface);
    mMonitor.handleFindStopped(mInterface);
}
#method_after
public void onFindStopped() {
    logd("Search stopped on " + mInterface);
    mMonitor.broadcastP2pFindStopped(mInterface);
}
#end_block

#method_before
public void onGoNegotiationRequest(byte[] srcAddress, short passwordId) {
    WifiP2pConfig config = new WifiP2pConfig();
    config.deviceAddress = bytesToString(srcAddress, ":");
    config.wps = new WpsInfo();
    switch(passwordId) {
        case WpsDevPasswordId.USER_SPECIFIED:
            config.wps.setup = WpsInfo.DISPLAY;
            break;
        case WpsDevPasswordId.PUSHBUTTON:
            config.wps.setup = WpsInfo.PBC;
            break;
        case WpsDevPasswordId.REGISTRAR_SPECIFIED:
            config.wps.setup = WpsInfo.KEYPAD;
            break;
        default:
            config.wps.setup = WpsInfo.PBC;
            break;
    }
    Log.i(TAG, "Group Owner negotiation initiated on " + mInterface + ": " + config);
    mMonitor.handleGoNegotiationRequest(mInterface, config);
}
#method_after
public void onGoNegotiationRequest(byte[] srcAddress, short passwordId) {
    WifiP2pConfig config = new WifiP2pConfig();
    try {
        config.deviceAddress = NativeUtil.macAddressFromByteArray(srcAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode device address.", e);
        return;
    }
    config.wps = new WpsInfo();
    switch(passwordId) {
        case WpsDevPasswordId.USER_SPECIFIED:
            config.wps.setup = WpsInfo.DISPLAY;
            break;
        case WpsDevPasswordId.PUSHBUTTON:
            config.wps.setup = WpsInfo.PBC;
            break;
        case WpsDevPasswordId.REGISTRAR_SPECIFIED:
            config.wps.setup = WpsInfo.KEYPAD;
            break;
        default:
            config.wps.setup = WpsInfo.PBC;
            break;
    }
    logd("Group Owner negotiation initiated on " + mInterface + ": " + config);
    mMonitor.broadcastP2pGoNegotiationRequest(mInterface, config);
}
#end_block

#method_before
public void onGoNegotiationCompleted(int status) {
    Log.i(TAG, "Group Owner negotiation completed with status: " + status);
    P2pStatus result = halStatusToP2pStatus(status);
    if (result == P2pStatus.SUCCESS) {
        mMonitor.handleGoNegotiationSuccess(mInterface);
    } else {
        mMonitor.handleGoNegotiationFailure(mInterface, result);
    }
}
#method_after
public void onGoNegotiationCompleted(int status) {
    logd("Group Owner negotiation completed with status: " + status);
    P2pStatus result = halStatusToP2pStatus(status);
    if (result == P2pStatus.SUCCESS) {
        mMonitor.broadcastP2pGoNegotiationSuccess(mInterface);
    } else {
        mMonitor.broadcastP2pGoNegotiationFailure(mInterface, result);
    }
}
#end_block

#method_before
public void onGroupFormationSuccess() {
    Log.i(TAG, "Group formation successful on " + mInterface);
    mMonitor.handleGroupFormationSuccess(mInterface);
}
#method_after
public void onGroupFormationSuccess() {
    logd("Group formation successful on " + mInterface);
    mMonitor.broadcastP2pGroupFormationSuccess(mInterface);
}
#end_block

#method_before
public void onGroupFormationFailure(String failureReason) {
    // TODO(ender): failureReason should probably be an int (P2pStatusCode).
    Log.i(TAG, "Group formation failed on " + mInterface + ": " + failureReason);
    mMonitor.handleGroupFormationFailure(mInterface, failureReason);
}
#method_after
public void onGroupFormationFailure(String failureReason) {
    // TODO(ender): failureReason should probably be an int (P2pStatusCode).
    logd("Group formation failed on " + mInterface + ": " + failureReason);
    mMonitor.broadcastP2pGroupFormationFailure(mInterface, failureReason);
}
#end_block

#method_before
public void onGroupStarted(String groupIfName, boolean isGo, ArrayList<Byte> ssid, int frequency, byte[] psk, String passphrase, byte[] goDeviceAddress, boolean isPersistent) {
    Log.i(TAG, "Group " + groupIfName + " started on " + mInterface);
    WifiP2pGroup group = new WifiP2pGroup();
    group.setInterface(groupIfName);
    group.setNetworkName(byteListToString(ssid));
    group.setIsGroupOwner(isGo);
    group.setPassphrase(passphrase);
    if (isPersistent) {
        group.setNetworkId(WifiP2pGroup.PERSISTENT_NET_ID);
    } else {
        group.setNetworkId(WifiP2pGroup.TEMPORARY_NET_ID);
    }
    WifiP2pDevice owner = new WifiP2pDevice();
    owner.deviceAddress = bytesToString(goDeviceAddress, ":");
    group.setOwner(owner);
    mMonitor.handleGroupStarted(mInterface, group);
}
#method_after
public void onGroupStarted(String groupIfName, boolean isGo, ArrayList<Byte> ssid, int frequency, byte[] psk, String passphrase, byte[] goDeviceAddress, boolean isPersistent) {
    if (groupIfName == null) {
        Log.e(TAG, "Missing group interface name.");
        return;
    }
    logd("Group " + groupIfName + " started on " + mInterface);
    WifiP2pGroup group = new WifiP2pGroup();
    group.setInterface(groupIfName);
    try {
        group.setNetworkName(NativeUtil.encodeSsid(ssid));
    } catch (Exception e) {
        Log.e(TAG, "Could not encode SSID.", e);
        return;
    }
    group.setIsGroupOwner(isGo);
    group.setPassphrase(passphrase);
    if (isPersistent) {
        group.setNetworkId(WifiP2pGroup.PERSISTENT_NET_ID);
    } else {
        group.setNetworkId(WifiP2pGroup.TEMPORARY_NET_ID);
    }
    WifiP2pDevice owner = new WifiP2pDevice();
    try {
        owner.deviceAddress = NativeUtil.macAddressFromByteArray(goDeviceAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode Group Owner address.", e);
        return;
    }
    group.setOwner(owner);
    mMonitor.broadcastP2pGroupStarted(mInterface, group);
}
#end_block

#method_before
public void onGroupRemoved(String groupIfName, boolean isGo) {
    Log.i(TAG, "Group " + groupIfName + " removed from " + mInterface);
    WifiP2pGroup group = new WifiP2pGroup();
    group.setInterface(groupIfName);
    group.setIsGroupOwner(isGo);
    mMonitor.handleGroupRemoved(mInterface, group);
}
#method_after
public void onGroupRemoved(String groupIfName, boolean isGo) {
    if (groupIfName == null) {
        Log.e(TAG, "Missing group name.");
        return;
    }
    logd("Group " + groupIfName + " removed from " + mInterface);
    WifiP2pGroup group = new WifiP2pGroup();
    group.setInterface(groupIfName);
    group.setIsGroupOwner(isGo);
    mMonitor.broadcastP2pGroupRemoved(mInterface, group);
}
#end_block

#method_before
public void onInvitationReceived(byte[] srcAddress, byte[] goDeviceAddress, byte[] bssid, int persistentNetworkId, int operatingFrequency) {
    WifiP2pGroup group = new WifiP2pGroup();
    group.setNetworkId(persistentNetworkId);
    WifiP2pDevice client = new WifiP2pDevice();
    client.deviceAddress = bytesToString(srcAddress, ":");
    group.addClient(client);
    WifiP2pDevice owner = new WifiP2pDevice();
    owner.deviceAddress = bytesToString(goDeviceAddress, ":");
    group.setOwner(owner);
    Log.i(TAG, "Invitation received on " + mInterface + ": " + group);
    mMonitor.handleInvitationReceived(mInterface, group);
}
#method_after
public void onInvitationReceived(byte[] srcAddress, byte[] goDeviceAddress, byte[] bssid, int persistentNetworkId, int operatingFrequency) {
    WifiP2pGroup group = new WifiP2pGroup();
    group.setNetworkId(persistentNetworkId);
    WifiP2pDevice client = new WifiP2pDevice();
    try {
        client.deviceAddress = NativeUtil.macAddressFromByteArray(srcAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode MAC address.", e);
        return;
    }
    group.addClient(client);
    WifiP2pDevice owner = new WifiP2pDevice();
    try {
        owner.deviceAddress = NativeUtil.macAddressFromByteArray(goDeviceAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode Group Owner MAC address.", e);
        return;
    }
    group.setOwner(owner);
    logd("Invitation received on " + mInterface + ": " + group);
    mMonitor.broadcastP2pInvitationReceived(mInterface, group);
}
#end_block

#method_before
public void onInvitationResult(byte[] bssid, int status) {
    Log.i(TAG, "Invitation completed with status: " + status);
    mMonitor.handleInvitationResult(mInterface, halStatusToP2pStatus(status));
}
#method_after
public void onInvitationResult(byte[] bssid, int status) {
    logd("Invitation completed with status: " + status);
    mMonitor.broadcastP2pInvitationResult(mInterface, halStatusToP2pStatus(status));
}
#end_block

#method_before
public void onProvisionDiscoveryCompleted(byte[] p2pDeviceAddress, boolean isRequest, byte status, short configMethods, String generatedPin) {
    Log.i(TAG, "Provision discovery completed on " + mInterface);
// TODO(ender): there seems to be no need for this event in WifiMonitor.
}
#method_after
public void onProvisionDiscoveryCompleted(byte[] p2pDeviceAddress, boolean isRequest, byte status, short configMethods, String generatedPin) {
    if (status != 0) {
        Log.e(TAG, "Provision discovery failed: " + status);
        mMonitor.broadcastP2pProvisionDiscoveryFailure(mInterface);
        return;
    }
    logd("Provision discovery " + (isRequest ? "request" : "response") + " for WPS Config method: " + configMethods);
    WifiP2pProvDiscEvent event = new WifiP2pProvDiscEvent();
    event.device = new WifiP2pDevice();
    try {
        event.device.deviceAddress = NativeUtil.macAddressFromByteArray(p2pDeviceAddress);
    } catch (Exception e) {
        Log.e(TAG, "Could not decode MAC address.", e);
        return;
    }
    if ((configMethods & ISupplicantP2pIface.WpsProvisionMethod.PBC) != 0) {
        if (isRequest) {
            event.event = WifiP2pProvDiscEvent.PBC_REQ;
            mMonitor.broadcastP2pProvisionDiscoveryPbcRequest(mInterface, event);
        } else {
            event.event = WifiP2pProvDiscEvent.PBC_RSP;
            mMonitor.broadcastP2pProvisionDiscoveryPbcResponse(mInterface, event);
        }
    } else if ((configMethods & ISupplicantP2pIface.WpsProvisionMethod.DISPLAY) != 0) {
        event.event = WifiP2pProvDiscEvent.SHOW_PIN;
        event.pin = generatedPin;
        mMonitor.broadcastP2pProvisionDiscoveryShowPin(mInterface, event);
    } else if ((configMethods & ISupplicantP2pIface.WpsProvisionMethod.KEYPAD) != 0) {
        event.event = WifiP2pProvDiscEvent.ENTER_PIN;
        mMonitor.broadcastP2pProvisionDiscoveryEnterPin(mInterface, event);
    } else {
        Log.e(TAG, "Unsupported config methods: " + configMethods);
    }
}
#end_block

#method_before
public void onServiceDiscoveryResponse(byte[] srcAddress, short updateIndicator, ArrayList<Byte> tlvs) {
}
#method_after
public void onServiceDiscoveryResponse(byte[] srcAddress, short updateIndicator, ArrayList<Byte> tlvs) {
    List<WifiP2pServiceResponse> response = null;
    logd("Service discovery response received on " + mInterface);
    try {
        StringBuilder event = new StringBuilder();
        event.append(NativeUtil.macAddressFromByteArray(srcAddress));
        event.append(" ");
        event.append(updateIndicator);
        event.append(" ");
        event.append(NativeUtil.stringFromByteArrayList(tlvs));
        response = WifiP2pServiceResponse.newInstance(event.toString());
    } catch (Exception e) {
        Log.e(TAG, "Could not process service discovery response.", e);
        return;
    }
    mMonitor.broadcastP2pServiceDiscoveryResponse(mInterface, response);
}
#end_block

#method_before
public void onStaAuthorized(byte[] srcAddress, byte[] p2pDeviceAddress) {
}
#method_after
public void onStaAuthorized(byte[] srcAddress, byte[] p2pDeviceAddress) {
    logd("STA authorized on " + mInterface);
}
#end_block

#method_before
public void onStaDeauthorized(byte[] srcAddress, byte[] p2pDeviceAddress) {
}
#method_after
public void onStaDeauthorized(byte[] srcAddress, byte[] p2pDeviceAddress) {
    logd("STA deauthorized on " + mInterface);
}
#end_block

#method_before
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        if (mIServiceManager != null) {
            Log.i(TAG, "Supplicant HAL already initialized.");
            // don't register another.
            return true;
        }
        mISupplicant = null;
        mISupplicantP2pIface = null;
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantP2pIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#method_after
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        if (mIServiceManager != null) {
            Log.i(TAG, "Supplicant HAL already initialized.");
            // don't register another.
            return true;
        }
        mISupplicant = null;
        mISupplicantP2pIface = null;
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", mServiceNotificationCallback)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            // proper initialization after exception is caught.
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return false;
    }
}
#end_block

#method_before
private boolean initSupplicantP2pIface() {
    synchronized (mLock) {
        /**
         * List all supplicant Ifaces
         */
        final ArrayList<ISupplicant.IfaceInfo> supplicantIfaces = new ArrayList();
        try {
            mISupplicant.listInterfaces((SupplicantStatus status, ArrayList<ISupplicant.IfaceInfo> ifaces) -> {
                if (status.code != SupplicantStatusCode.SUCCESS) {
                    Log.e(TAG, "Getting Supplicant Interfaces failed: " + status.code);
                    return;
                }
                supplicantIfaces.addAll(ifaces);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicant.listInterfaces exception: " + e);
            return false;
        }
        if (supplicantIfaces.size() == 0) {
            Log.e(TAG, "Got zero HIDL supplicant ifaces. Stopping supplicant HIDL startup.");
            return false;
        }
        SupplicantResult<ISupplicantIface> supplicantIface = new SupplicantResult("getInterface()");
        for (ISupplicant.IfaceInfo ifaceInfo : supplicantIfaces) {
            if (ifaceInfo.type == IfaceType.P2P) {
                try {
                    mISupplicant.getInterface(ifaceInfo, (SupplicantStatus status, ISupplicantIface iface) -> {
                        if (status.code != SupplicantStatusCode.SUCCESS) {
                            Log.e(TAG, "Failed to get ISupplicantIface " + status.code);
                            return;
                        }
                        supplicantIface.setResult(status, iface);
                    });
                } catch (RemoteException e) {
                    Log.e(TAG, "ISupplicant.getInterface exception: " + e);
                    return false;
                }
                break;
            }
        }
        if (supplicantIface.getResult() == null) {
            Log.e(TAG, "initSupplicantP2pIface got null iface");
            return false;
        }
        mISupplicantP2pIface = getP2pIfaceMockable(supplicantIface.getResult());
        return true;
    }
}
#method_after
private boolean initSupplicantP2pIface() {
    synchronized (mLock) {
        /**
         * List all supplicant Ifaces
         */
        final ArrayList<ISupplicant.IfaceInfo> supplicantIfaces = new ArrayList();
        try {
            mISupplicant.listInterfaces((SupplicantStatus status, ArrayList<ISupplicant.IfaceInfo> ifaces) -> {
                if (status.code != SupplicantStatusCode.SUCCESS) {
                    Log.e(TAG, "Getting Supplicant Interfaces failed: " + status.code);
                    return;
                }
                supplicantIfaces.addAll(ifaces);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicant.listInterfaces exception: " + e);
            return false;
        }
        if (supplicantIfaces.size() == 0) {
            Log.e(TAG, "Got zero HIDL supplicant ifaces. Stopping supplicant HIDL startup.");
            return false;
        }
        SupplicantResult<ISupplicantIface> supplicantIface = new SupplicantResult("getInterface()");
        for (ISupplicant.IfaceInfo ifaceInfo : supplicantIfaces) {
            if (ifaceInfo.type == IfaceType.P2P) {
                try {
                    mISupplicant.getInterface(ifaceInfo, (SupplicantStatus status, ISupplicantIface iface) -> {
                        if (status.code != SupplicantStatusCode.SUCCESS) {
                            Log.e(TAG, "Failed to get ISupplicantIface " + status.code);
                            return;
                        }
                        supplicantIface.setResult(status, iface);
                    });
                } catch (RemoteException e) {
                    Log.e(TAG, "ISupplicant.getInterface exception: " + e);
                    return false;
                }
                break;
            }
        }
        if (supplicantIface.getResult() == null) {
            Log.e(TAG, "initSupplicantP2pIface got null iface");
            return false;
        }
        mISupplicantP2pIface = getP2pIfaceMockable(supplicantIface.getResult());
    }
    if (mISupplicantP2pIface != null && mMonitor != null) {
        // TODO(ender): Get rid of hard-coded interface name, which is
        // assumed to be the group interface name in several other classes
        // ("p2p0" should probably become getName()).
        mCallback = new SupplicantP2pIfaceCallback("p2p0", mMonitor);
        if (!registerCallback(mCallback)) {
            Log.e(TAG, "Callback registration failed. Initialization incomplete.");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected static void logCompletion(String operation, SupplicantStatus status) {
    if (status.code == SupplicantStatusCode.SUCCESS) {
        logd(operation + " completed successfully.");
    } else {
        Log.w(TAG, operation + " failed: " + status.code + " (" + status.debugMessage + ")");
    }
}
#method_after
protected static void logCompletion(String operation, SupplicantStatus status) {
    if (status == null) {
        Log.w(TAG, operation + " failed: no status code returned.");
    } else if (status.code == SupplicantStatusCode.SUCCESS) {
        logd(operation + " completed successfully.");
    } else {
        Log.w(TAG, operation + " failed: " + status.code + " (" + status.debugMessage + ")");
    }
}
#end_block

#method_before
private int wpsInfoToConfigMethod(int info) {
    switch(info) {
        case WpsInfo.PBC:
            return ISupplicantP2pIface.WpsProvisionMethod.PBC;
        case WpsInfo.DISPLAY:
            return ISupplicantP2pIface.WpsProvisionMethod.DISPLAY;
        case WpsInfo.KEYPAD:
            return ISupplicantP2pIface.WpsProvisionMethod.KEYPAD;
        case WpsInfo.LABEL:
        default:
            Log.e(TAG, "Unsupported WPS provision method: " + info);
            return RESULT_NOT_VALID;
    }
}
#method_after
private int wpsInfoToConfigMethod(int info) {
    switch(info) {
        case WpsInfo.PBC:
            return ISupplicantP2pIface.WpsProvisionMethod.PBC;
        case WpsInfo.DISPLAY:
            return ISupplicantP2pIface.WpsProvisionMethod.DISPLAY;
        case WpsInfo.KEYPAD:
        case WpsInfo.LABEL:
            return ISupplicantP2pIface.WpsProvisionMethod.KEYPAD;
        default:
            Log.e(TAG, "Unsupported WPS provision method: " + info);
            return RESULT_NOT_VALID;
    }
}
#end_block

#method_before
public boolean find(int timeout) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("find"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("find(" + timeout + ")");
        try {
            result.setResult(mISupplicantP2pIface.find(timeout));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean find(int timeout) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("find"))
            return false;
        if (timeout < 0) {
            Log.e(TAG, "Invalid timeout value: " + timeout);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("find(" + timeout + ")");
        try {
            result.setResult(mISupplicantP2pIface.find(timeout));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null) {
            Log.e(TAG, "Invalid SSID postfix value (null).");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(NativeUtil.decodeSsid(postfix)));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null) {
            Log.e(TAG, "Invalid SSID postfix value (null).");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(NativeUtil.decodeSsid("\"" + postfix + "\"")));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        } catch (Exception e) {
            Log.e(TAG, "Could not decode SSID.", e);
            return false;
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
    synchronized (mLock) {
        if (config == null) {
            Log.e(TAG, "Could not connect: null config.");
            return null;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Could not parse null mac address.");
            return null;
        }
        byte[] peerAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        int provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (provisionMethod == RESULT_NOT_VALID) {
            Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
            return null;
        }
        // NOTE: preSelectedPin cannot be null, otherwise hal would crash.
        String preSelectedPin = "";
        if (provisionMethod == ISupplicantP2pIface.WpsProvisionMethod.DISPLAY) {
            preSelectedPin = config.wps.pin;
        }
        boolean persistent = (config.netId == WifiP2pGroup.PERSISTENT_NET_ID);
        int goIntent = 0;
        if (!joinExistingGroup) {
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("connect(" + config.deviceAddress + ")");
        try {
            mISupplicantP2pIface.connect(peerAddress, provisionMethod, preSelectedPin, joinExistingGroup, persistent, goIntent, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#method_after
public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return null;
        if (config == null) {
            Log.e(TAG, "Could not connect: null config.");
            return null;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Could not parse null mac address.");
            return null;
        }
        byte[] peerAddress = null;
        try {
            peerAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return null;
        }
        int provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (provisionMethod == RESULT_NOT_VALID) {
            Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
            return null;
        }
        // NOTE: preSelectedPin cannot be null, otherwise hal would crash.
        String preSelectedPin = "";
        if (provisionMethod == ISupplicantP2pIface.WpsProvisionMethod.DISPLAY) {
            preSelectedPin = config.wps.pin;
            if (preSelectedPin == null) {
                Log.e(TAG, "PIN must be supplied when provision method is DISPLAY.");
                return null;
            }
        }
        boolean persistent = (config.netId == WifiP2pGroup.PERSISTENT_NET_ID);
        int goIntent = 0;
        if (!joinExistingGroup) {
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("connect(" + config.deviceAddress + ")");
        try {
            mISupplicantP2pIface.connect(peerAddress, provisionMethod, preSelectedPin, joinExistingGroup, persistent, goIntent, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean provisionDiscovery(WifiP2pConfig config) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("provisionDiscovery"))
            return false;
        int targetMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (targetMethod == -1) {
            Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
            return false;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Cannot parse null mac address.");
            return false;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        SupplicantResult<Void> result = new SupplicantResult("provisionDiscovery(" + config.deviceAddress + ", " + config.wps.setup + ")");
        try {
            result.setResult(mISupplicantP2pIface.provisionDiscovery(macAddress, targetMethod));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean provisionDiscovery(WifiP2pConfig config) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("provisionDiscovery"))
            return false;
        int targetMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (targetMethod == -1) {
            Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
            return false;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Cannot parse null mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("provisionDiscovery(" + config.deviceAddress + ", " + config.wps.setup + ")");
        try {
            result.setResult(mISupplicantP2pIface.provisionDiscovery(macAddress, targetMethod));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean invite(WifiP2pGroup group, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("invite"))
            return false;
        if (group.getOwner().deviceAddress == null) {
            Log.e(TAG, "Cannot parse owner mac address.");
            return false;
        }
        byte[] ownerMacAddress = NativeUtil.macAddressToByteArray(group.getOwner().deviceAddress);
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] peerMacAddress = NativeUtil.macAddressToByteArray(peerAddress);
        SupplicantResult<Void> result = new SupplicantResult("invite(" + group.getInterface() + ", " + group.getOwner().deviceAddress + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.invite(group.getInterface(), ownerMacAddress, peerMacAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean invite(WifiP2pGroup group, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("invite"))
            return false;
        if (group == null) {
            Log.e(TAG, "Cannot invite to null group.");
            return false;
        }
        if (group.getOwner() == null) {
            Log.e(TAG, "Cannot invite to group with null owner.");
            return false;
        }
        if (group.getOwner().deviceAddress == null) {
            Log.e(TAG, "Group owner has no mac address.");
            return false;
        }
        byte[] ownerMacAddress = null;
        try {
            ownerMacAddress = NativeUtil.macAddressToByteArray(group.getOwner().deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Group owner mac address parse error.", e);
            return false;
        }
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] peerMacAddress;
        try {
            peerMacAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Peer mac address parse error.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("invite(" + group.getInterface() + ", " + group.getOwner().deviceAddress + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.invite(group.getInterface(), ownerMacAddress, peerMacAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean reject(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reject"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse rejected peer's mac address.");
            return false;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        SupplicantResult<Void> result = new SupplicantResult("reject(" + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reject(macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean reject(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reject"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse rejected peer's mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reject(" + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reject(macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String getDeviceAddress() {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getDeviceAddress"))
            return null;
        SupplicantResult<String> result = new SupplicantResult("getDeviceAddress()");
        try {
            mISupplicantP2pIface.getDeviceAddress((SupplicantStatus status, byte[] address) -> {
                String parsedAddress = null;
                if (address != null) {
                    parsedAddress = NativeUtil.macAddressFromByteArray(address);
                }
                result.setResult(status, parsedAddress);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#method_after
public String getDeviceAddress() {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getDeviceAddress"))
            return null;
        SupplicantResult<String> result = new SupplicantResult("getDeviceAddress()");
        try {
            mISupplicantP2pIface.getDeviceAddress((SupplicantStatus status, byte[] address) -> {
                String parsedAddress = null;
                try {
                    parsedAddress = NativeUtil.macAddressFromByteArray(address);
                } catch (Exception e) {
                    Log.e(TAG, "Could not process reported address.", e);
                }
                result.setResult(status, parsedAddress);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#end_block

#method_before
public String getSsid(String address) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getSsid"))
            return null;
        if (address == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(address);
        SupplicantResult<String> result = new SupplicantResult("getSsid(" + address + ")");
        try {
            mISupplicantP2pIface.getSsid(macAddress, (SupplicantStatus status, ArrayList<Byte> ssid) -> {
                String ssidString = null;
                if (ssid != null) {
                    ssidString = NativeUtil.encodeSsid(ssid);
                }
                result.setResult(status, ssidString);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#method_after
public String getSsid(String address) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getSsid"))
            return null;
        if (address == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(address);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse mac address.", e);
            return null;
        }
        SupplicantResult<String> result = new SupplicantResult("getSsid(" + address + ")");
        try {
            mISupplicantP2pIface.getSsid(macAddress, (SupplicantStatus status, ArrayList<Byte> ssid) -> {
                String ssidString = null;
                if (ssid != null) {
                    try {
                        ssidString = NativeUtil.encodeSsid(ssid);
                    } catch (Exception e) {
                        Log.e(TAG, "Could not encode SSID.", e);
                    }
                }
                result.setResult(status, ssidString);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean reinvoke(int networkId, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reinvoke"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        SupplicantResult<Void> result = new SupplicantResult("reinvoke(" + networkId + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reinvoke(networkId, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean reinvoke(int networkId, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reinvoke"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reinvoke(" + networkId + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reinvoke(networkId, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public int getGroupCapability(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getGroupCapability")) {
            return RESULT_NOT_VALID;
        }
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return RESULT_NOT_VALID;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        SupplicantResult<Integer> capability = new SupplicantResult("getGroupCapability(" + peerAddress + ")");
        try {
            mISupplicantP2pIface.getGroupCapability(macAddress, (SupplicantStatus status, int cap) -> {
                capability.setResult(status, cap);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        if (!capability.isSuccess()) {
            return RESULT_NOT_VALID;
        }
        return capability.getResult();
    }
}
#method_after
public int getGroupCapability(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getGroupCapability")) {
            return RESULT_NOT_VALID;
        }
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return RESULT_NOT_VALID;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse group address.", e);
            return RESULT_NOT_VALID;
        }
        SupplicantResult<Integer> capability = new SupplicantResult("getGroupCapability(" + peerAddress + ")");
        try {
            mISupplicantP2pIface.getGroupCapability(macAddress, (SupplicantStatus status, int cap) -> {
                capability.setResult(status, cap);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        if (!capability.isSuccess()) {
            return RESULT_NOT_VALID;
        }
        return capability.getResult();
    }
}
#end_block

#method_before
public boolean serviceAdd(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceAdd"))
            return false;
        for (String s : servInfo.getSupplicantQueryList()) {
            String[] data = s.split(" ");
            if (data.length < 2) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("addUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.addUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null && data[2] != null) {
                        ArrayList<Byte> request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                        ArrayList<Byte> response = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[2]));
                        result = new SupplicantResult("addBonjourService(" + data[1] + ", " + data[2] + ")");
                        result.setResult(mISupplicantP2pIface.addBonjourService(request, response));
                    }
                } else {
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#method_after
public boolean serviceAdd(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceAdd"))
            return false;
        if (servInfo == null) {
            Log.e(TAG, "Null service info passed.");
            return false;
        }
        for (String s : servInfo.getSupplicantQueryList()) {
            if (s == null) {
                Log.e(TAG, "Invalid service description (null).");
                return false;
            }
            String[] data = s.split(" ");
            if (data.length < 3) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("addUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.addUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null && data[2] != null) {
                        ArrayList<Byte> request = null;
                        ArrayList<Byte> response = null;
                        try {
                            request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                            response = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[2]));
                        } catch (Exception e) {
                            Log.e(TAG, "Invalid bonjour service description.");
                            return false;
                        }
                        result = new SupplicantResult("addBonjourService(" + data[1] + ", " + data[2] + ")");
                        result.setResult(mISupplicantP2pIface.addBonjourService(request, response));
                    }
                } else {
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#end_block

#method_before
public boolean serviceRemove(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceRemove"))
            return false;
        for (String s : servInfo.getSupplicantQueryList()) {
            String[] data = s.split(" ");
            if (data.length < 2) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("removeUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.removeUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null) {
                        ArrayList<Byte> request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                        result = new SupplicantResult("removeBonjourService(" + data[1] + ")");
                        result.setResult(mISupplicantP2pIface.removeBonjourService(request));
                    }
                } else {
                    Log.e(TAG, "Unknown / unsupported P2P service requested: " + data[0]);
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#method_after
public boolean serviceRemove(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceRemove"))
            return false;
        if (servInfo == null) {
            Log.e(TAG, "Null service info passed.");
            return false;
        }
        for (String s : servInfo.getSupplicantQueryList()) {
            if (s == null) {
                Log.e(TAG, "Invalid service description (null).");
                return false;
            }
            String[] data = s.split(" ");
            if (data.length < 3) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("removeUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.removeUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null) {
                        ArrayList<Byte> request = null;
                        try {
                            request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                        } catch (Exception e) {
                            Log.e(TAG, "Invalid bonjour service description.");
                            return false;
                        }
                        result = new SupplicantResult("removeBonjourService(" + data[1] + ")");
                        result.setResult(mISupplicantP2pIface.removeBonjourService(request));
                    }
                } else {
                    Log.e(TAG, "Unknown / unsupported P2P service requested: " + data[0]);
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#end_block

#method_before
public String requestServiceDiscovery(String peerAddress, String query) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("requestServiceDiscovery"))
            return null;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        if (query == null) {
            Log.e(TAG, "Cannot parse service discovery query: " + query);
            return null;
        }
        ArrayList<Byte> binQuery = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(query));
        SupplicantResult<Long> result = new SupplicantResult("requestServiceDiscovery(" + peerAddress + ", " + query + ")");
        try {
            mISupplicantP2pIface.requestServiceDiscovery(macAddress, binQuery, (SupplicantStatus status, long identifier) -> {
                result.setResult(status, new Long(identifier));
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        Long value = result.getResult();
        if (value == null)
            return null;
        return value.toString();
    }
}
#method_after
public String requestServiceDiscovery(String peerAddress, String query) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("requestServiceDiscovery"))
            return null;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not process peer MAC address.", e);
            return null;
        }
        if (query == null) {
            Log.e(TAG, "Cannot parse service discovery query: " + query);
            return null;
        }
        ArrayList<Byte> binQuery = null;
        try {
            binQuery = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(query));
        } catch (Exception e) {
            Log.e(TAG, "Could not parse service query.", e);
            return null;
        }
        SupplicantResult<Long> result = new SupplicantResult("requestServiceDiscovery(" + peerAddress + ", " + query + ")");
        try {
            mISupplicantP2pIface.requestServiceDiscovery(macAddress, binQuery, (SupplicantStatus status, long identifier) -> {
                result.setResult(status, new Long(identifier));
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        Long value = result.getResult();
        if (value == null)
            return null;
        return value.toString();
    }
}
#end_block

#method_before
public boolean cancelServiceDiscovery(String identifier) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelServiceDiscovery"))
            return false;
        int id = 0;
        try {
            id = Integer.parseInt(identifier);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Service discovery identifier invalid: " + identifier, e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelServiceDiscovery(" + identifier + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelServiceDiscovery(id));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean cancelServiceDiscovery(String identifier) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelServiceDiscovery"))
            return false;
        if (identifier == null) {
            Log.e(TAG, "cancelServiceDiscovery requires a valid tag.");
            return false;
        }
        int id = 0;
        try {
            id = Integer.parseInt(identifier);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Service discovery identifier invalid: " + identifier, e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelServiceDiscovery(" + identifier + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelServiceDiscovery(id));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setMiracastMode(int mode) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setMiracastMode"))
            return false;
        byte targetMode = ISupplicantP2pIface.MiracastMode.DISABLED;
        switch(mode) {
            case 1:
                targetMode = ISupplicantP2pIface.MiracastMode.SOURCE;
                break;
            case 2:
                targetMode = ISupplicantP2pIface.MiracastMode.SINK;
                break;
        }
        SupplicantResult<Void> result = new SupplicantResult("setMiracastMode(" + mode + ")");
        try {
            result.setResult(mISupplicantP2pIface.setMiracastMode(targetMode));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setMiracastMode(int mode) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setMiracastMode"))
            return false;
        byte targetMode = ISupplicantP2pIface.MiracastMode.DISABLED;
        switch(mode) {
            case WifiP2pManager.MIRACAST_SOURCE:
                targetMode = ISupplicantP2pIface.MiracastMode.SOURCE;
                break;
            case WifiP2pManager.MIRACAST_SINK:
                targetMode = ISupplicantP2pIface.MiracastMode.SINK;
                break;
        }
        SupplicantResult<Void> result = new SupplicantResult("setMiracastMode(" + mode + ")");
        try {
            result.setResult(mISupplicantP2pIface.setMiracastMode(targetMode));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean startWpsPbc(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPbc"))
            return false;
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            macAddress = NativeUtil.macAddressToByteArray(bssid);
        }
        SupplicantResult<Void> result = new SupplicantResult("startWpsPbc(" + groupIfName + ", " + bssid + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPbc(groupIfName, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean startWpsPbc(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPbc"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS PBC.");
            return false;
        }
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            try {
                macAddress = NativeUtil.macAddressToByteArray(bssid);
            } catch (Exception e) {
                Log.e(TAG, "Could not parse BSSID.", e);
                return false;
            }
        }
        SupplicantResult<Void> result = new SupplicantResult("startWpsPbc(" + groupIfName + ", " + bssid + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPbc(groupIfName, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean startWpsPinKeypad(String groupIfName, String pin) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("startWpsPinKeypad(" + groupIfName + ", " + pin + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean startWpsPinKeypad(String groupIfName, String pin) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return false;
        }
        if (pin == null) {
            Log.e(TAG, "PIN required when requesting WPS KEYPAD.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("startWpsPinKeypad(" + groupIfName + ", " + pin + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay"))
            return null;
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            NativeUtil.macAddressToByteArray(bssid);
        }
        SupplicantResult<String> result = new SupplicantResult("startWpsPinDisplay(" + groupIfName + ", " + bssid + ")");
        try {
            mISupplicantP2pIface.startWpsPinDisplay(groupIfName, macAddress, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#method_after
public String startWpsPinDisplay(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay"))
            return null;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return null;
        }
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            try {
                macAddress = NativeUtil.macAddressToByteArray(bssid);
            } catch (Exception e) {
                Log.e(TAG, "Could not parse BSSID.", e);
                return null;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("startWpsPinDisplay(" + groupIfName + ", " + bssid + ")");
        try {
            mISupplicantP2pIface.startWpsPinDisplay(groupIfName, macAddress, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean cancelWps(String groupIfName) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelWps"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("cancelWps(" + groupIfName + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelWps(groupIfName));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean cancelWps(String groupIfName) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelWps"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelWps(" + groupIfName + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelWps(groupIfName));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setWfdDeviceInfo(String info) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setWfdDeviceInfo"))
            return false;
        if (info == null) {
            Log.e(TAG, "Cannot parse null WFD info string.");
            return false;
        }
        byte[] wfdInfo = NativeUtil.hexStringToByteArray(info);
        SupplicantResult<Void> result = new SupplicantResult("setWfdDeviceInfo(" + info + ")");
        try {
            result.setResult(mISupplicantP2pIface.setWfdDeviceInfo(wfdInfo));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setWfdDeviceInfo(String info) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setWfdDeviceInfo"))
            return false;
        if (info == null) {
            Log.e(TAG, "Cannot parse null WFD info string.");
            return false;
        }
        byte[] wfdInfo = null;
        try {
            wfdInfo = NativeUtil.hexStringToByteArray(info);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse WFD Device Info string.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setWfdDeviceInfo(" + info + ")");
        try {
            result.setResult(mISupplicantP2pIface.setWfdDeviceInfo(wfdInfo));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
private void setMonitoring(String iface, boolean enabled) {
    mMonitoringMap.put(iface, enabled);
}
#method_after
@VisibleForTesting
public void setMonitoring(String iface, boolean enabled) {
    mMonitoringMap.put(iface, enabled);
}
#end_block

#method_before
private boolean ensureConnectedLocked() {
    if (mConnected) {
        return true;
    }
    if (mVerboseLoggingEnabled)
        Log.d(TAG, "connecting to supplicant");
    int connectTries = 0;
    while (true) {
        if (mWifiNative.connectToSupplicant()) {
            mConnected = true;
            new MonitorThread(mWifiNative.getLocalLog()).start();
            return true;
        }
        if (connectTries++ < 5) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ignore) {
            }
        } else {
            return false;
        }
    }
}
#method_after
private boolean ensureConnectedLocked() {
    if (mConnected) {
        return true;
    }
    if (mVerboseLoggingEnabled)
        Log.d(TAG, "connecting to supplicant");
    int connectTries = 0;
    while (true) {
        if (mWifiNative.connectToSupplicant()) {
            mConnected = true;
            if (!WifiNative.HIDL_SUP_ENABLE) {
                new MonitorThread(mWifiNative.getLocalLog()).start();
            }
            return true;
        }
        if (connectTries++ < 5) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ignore) {
            }
        } else {
            return false;
        }
    }
}
#end_block

#method_before
public synchronized void startMonitoring(String iface) {
    Log.d(TAG, "startMonitoring(" + iface + ") with mConnected = " + mConnected);
    if (ensureConnectedLocked()) {
        setMonitoring(iface, true);
        sendMessage(iface, SUP_CONNECTION_EVENT);
    } else {
        boolean originalMonitoring = isMonitoring(iface);
        setMonitoring(iface, true);
        sendMessage(iface, SUP_DISCONNECTION_EVENT);
        setMonitoring(iface, originalMonitoring);
        Log.e(TAG, "startMonitoring(" + iface + ") failed!");
    }
}
#method_after
public synchronized void startMonitoring(String iface) {
    Log.d(TAG, "startMonitoring(" + iface + ") with mConnected = " + mConnected);
    if (ensureConnectedLocked()) {
        setMonitoring(iface, true);
        broadcastSupplicantConnectionEvent(iface);
    } else {
        boolean originalMonitoring = isMonitoring(iface);
        setMonitoring(iface, true);
        broadcastSupplicantDisconnectionEvent(iface);
        setMonitoring(iface, originalMonitoring);
        Log.e(TAG, "startMonitoring(" + iface + ") failed!");
    }
}
#end_block

#method_before
public synchronized void stopMonitoring(String iface) {
    if (mVerboseLoggingEnabled)
        Log.d(TAG, "stopMonitoring(" + iface + ")");
    setMonitoring(iface, true);
    sendMessage(iface, SUP_DISCONNECTION_EVENT);
    setMonitoring(iface, false);
}
#method_after
public synchronized void stopMonitoring(String iface) {
    if (mVerboseLoggingEnabled)
        Log.d(TAG, "stopMonitoring(" + iface + ")");
    setMonitoring(iface, true);
    broadcastSupplicantDisconnectionEvent(iface);
    setMonitoring(iface, false);
}
#end_block

#method_before
private boolean dispatchEvent(String eventStr, String iface) {
    if (mVerboseLoggingEnabled) {
        // Dont log CTRL-EVENT-BSS-ADDED which are too verbose and not handled
        if (eventStr != null && !eventStr.contains("CTRL-EVENT-BSS-ADDED")) {
            Log.d(TAG, iface + " cnt=" + Integer.toString(eventLogCounter) + " dispatchEvent: " + eventStr);
        }
    }
    if (!eventStr.startsWith(EVENT_PREFIX_STR)) {
        if (eventStr.startsWith(WPS_SUCCESS_STR)) {
            sendMessage(iface, WPS_SUCCESS_EVENT);
        } else if (eventStr.startsWith(WPS_FAIL_STR)) {
            handleWpsFailEvent(eventStr, iface);
        } else if (eventStr.startsWith(WPS_OVERLAP_STR)) {
            sendMessage(iface, WPS_OVERLAP_EVENT);
        } else if (eventStr.startsWith(WPS_TIMEOUT_STR)) {
            sendMessage(iface, WPS_TIMEOUT_EVENT);
        } else if (eventStr.startsWith(P2P_EVENT_PREFIX_STR)) {
            handleP2pEvents(eventStr, iface);
        } else if (eventStr.startsWith(HOST_AP_EVENT_PREFIX_STR)) {
            handleHostApEvents(eventStr, iface);
        } else if (eventStr.startsWith(ANQP_DONE_STR)) {
            try {
                handleAnqpResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad ANQP event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_ICON_STR)) {
            try {
                handleIconResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad Icon event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_SUB_REM_STR)) {
            // Tack on the last connected BSSID so we have some idea what AP the WNM pertains to
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(HS20_DEAUTH_STR)) {
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(REQUEST_PREFIX_STR)) {
            handleRequests(eventStr, iface);
        } else if (eventStr.startsWith(TARGET_BSSID_STR)) {
            handleTargetBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(ASSOCIATED_WITH_STR)) {
            handleAssociatedBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(AUTH_EVENT_PREFIX_STR) && eventStr.endsWith(AUTH_TIMEOUT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_TIMEOUT);
        } else if (eventStr.startsWith(WPA_EVENT_PREFIX_STR) && eventStr.endsWith(PASSWORD_MAY_BE_INCORRECT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        } else {
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "couldn't identify event type - " + eventStr);
            }
        }
        eventLogCounter++;
        return false;
    }
    String eventName = eventStr.substring(EVENT_PREFIX_LEN_STR);
    int nameEnd = eventName.indexOf(' ');
    if (nameEnd != -1)
        eventName = eventName.substring(0, nameEnd);
    if (eventName.length() == 0) {
        if (mVerboseLoggingEnabled) {
            Log.i(TAG, "Received wpa_supplicant event with empty event name");
        }
        eventLogCounter++;
        return false;
    }
    /*
        * Map event name into event enum
        */
    int event;
    if (eventName.equals(CONNECTED_STR)) {
        event = CONNECTED;
        long bssid = -1L;
        int prefix = eventStr.indexOf(ConnectPrefix);
        if (prefix >= 0) {
            int suffix = eventStr.indexOf(ConnectSuffix);
            if (suffix > prefix) {
                try {
                    bssid = Utils.parseMac(eventStr.substring(prefix + ConnectPrefix.length(), suffix));
                } catch (IllegalArgumentException iae) {
                    bssid = -1L;
                }
            }
        }
        mLastConnectBSSIDs.put(iface, bssid);
        if (bssid == -1L) {
            Log.w(TAG, "Failed to parse out BSSID from '" + eventStr + "'");
        }
    } else if (eventName.equals(DISCONNECTED_STR))
        event = DISCONNECTED;
    else if (eventName.equals(STATE_CHANGE_STR))
        event = STATE_CHANGE;
    else if (eventName.equals(SCAN_RESULTS_STR))
        event = SCAN_RESULTS;
    else if (eventName.equals(SCAN_FAILED_STR))
        event = SCAN_FAILED;
    else if (eventName.equals(LINK_SPEED_STR))
        event = LINK_SPEED;
    else if (eventName.equals(TERMINATING_STR))
        event = TERMINATING;
    else if (eventName.equals(DRIVER_STATE_STR))
        event = DRIVER_STATE;
    else if (eventName.equals(EAP_FAILURE_STR))
        event = EAP_FAILURE;
    else if (eventName.equals(ASSOC_REJECT_STR))
        event = ASSOC_REJECT;
    else if (eventName.equals(TEMP_DISABLED_STR)) {
        event = SSID_TEMP_DISABLE;
    } else if (eventName.equals(REENABLED_STR)) {
        event = SSID_REENABLE;
    } else if (eventName.equals(BSS_ADDED_STR)) {
        event = BSS_ADDED;
    } else if (eventName.equals(BSS_REMOVED_STR)) {
        event = BSS_REMOVED;
    } else
        event = UNKNOWN;
    String eventData = eventStr;
    if (event == DRIVER_STATE || event == LINK_SPEED)
        eventData = eventData.split(" ")[1];
    else if (event == STATE_CHANGE || event == EAP_FAILURE) {
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 1);
        }
    } else {
        int ind = eventStr.indexOf(" - ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 3);
        }
    }
    if ((event == SSID_TEMP_DISABLE) || (event == SSID_REENABLE)) {
        String substr = null;
        int netId = -1;
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            substr = eventStr.substring(ind + 1);
        }
        if (substr != null) {
            String[] status = substr.split(" ");
            for (String key : status) {
                if (key.regionMatches(0, "id=", 0, 3)) {
                    int idx = 3;
                    netId = 0;
                    while (idx < key.length()) {
                        char c = key.charAt(idx);
                        if ((c >= 0x30) && (c <= 0x39)) {
                            netId *= 10;
                            netId += c - 0x30;
                            idx++;
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        sendMessage(iface, (event == SSID_TEMP_DISABLE) ? SSID_TEMP_DISABLED : SSID_REENABLED, netId, 0, substr);
    } else if (event == STATE_CHANGE) {
        handleSupplicantStateChange(eventData, iface);
    } else if (event == DRIVER_STATE) {
        handleDriverEvent(eventData, iface);
    } else if (event == TERMINATING) {
        /**
         * Close the supplicant connection if we see
         * too many recv errors
         */
        if (eventData.startsWith(WPA_RECV_ERROR_STR)) {
            if (++mRecvErrors > MAX_RECV_ERRORS) {
                if (mVerboseLoggingEnabled) {
                    Log.d(TAG, "too many recv errors, closing connection");
                }
            } else {
                eventLogCounter++;
                return false;
            }
        }
        // Notify and exit
        sendMessage(null, SUP_DISCONNECTION_EVENT, eventLogCounter);
        return true;
    } else if (event == EAP_FAILURE) {
        if (eventData.startsWith(EAP_AUTH_FAILURE_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_EAP_FAILURE);
        }
    } else if (event == ASSOC_REJECT) {
        Matcher match = mAssocRejectEventPattern.matcher(eventData);
        String BSSID = "";
        int status = -1;
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "Assoc Reject: Could not parse assoc reject string");
            }
        } else {
            int groupNumber = match.groupCount();
            int statusGroupNumber = -1;
            if (groupNumber == 2) {
                BSSID = match.group(1);
                statusGroupNumber = 2;
            } else {
                // Under such case Supplicant does not report BSSID
                BSSID = null;
                statusGroupNumber = 1;
            }
            try {
                status = Integer.parseInt(match.group(statusGroupNumber));
            } catch (NumberFormatException e) {
                status = -1;
            }
        }
        sendMessage(iface, ASSOCIATION_REJECTION_EVENT, eventLogCounter, status, BSSID);
    } else if (event == BSS_ADDED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else if (event == BSS_REMOVED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else {
        handleEvent(event, eventData, iface);
    }
    mRecvErrors = 0;
    eventLogCounter++;
    return false;
}
#method_after
private boolean dispatchEvent(String eventStr, String iface) {
    if (mVerboseLoggingEnabled) {
        // Dont log CTRL-EVENT-BSS-ADDED which are too verbose and not handled
        if (eventStr != null && !eventStr.contains("CTRL-EVENT-BSS-ADDED")) {
            Log.d(TAG, iface + " cnt=" + Integer.toString(eventLogCounter) + " dispatchEvent: " + eventStr);
        }
    }
    if (!eventStr.startsWith(EVENT_PREFIX_STR)) {
        if (eventStr.startsWith(WPS_SUCCESS_STR)) {
            broadcastWpsSuccessEvent(iface);
        } else if (eventStr.startsWith(WPS_FAIL_STR)) {
            handleWpsFailEvent(eventStr, iface);
        } else if (eventStr.startsWith(WPS_OVERLAP_STR)) {
            broadcastWpsOverlapEvent(iface);
        } else if (eventStr.startsWith(WPS_TIMEOUT_STR)) {
            broadcastWpsTimeoutEvent(iface);
        } else if (eventStr.startsWith(P2P_EVENT_PREFIX_STR)) {
            handleP2pEvents(eventStr, iface);
        } else if (eventStr.startsWith(HOST_AP_EVENT_PREFIX_STR)) {
            handleHostApEvents(eventStr, iface);
        } else if (eventStr.startsWith(ANQP_DONE_STR)) {
            try {
                handleAnqpResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad ANQP event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_ICON_STR)) {
            try {
                handleIconResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad Icon event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_SUB_REM_STR)) {
            // Tack on the last connected BSSID so we have some idea what AP the WNM pertains to
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(HS20_DEAUTH_STR)) {
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(REQUEST_PREFIX_STR)) {
            handleRequests(eventStr, iface);
        } else if (eventStr.startsWith(TARGET_BSSID_STR)) {
            handleTargetBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(ASSOCIATED_WITH_STR)) {
            handleAssociatedBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(AUTH_EVENT_PREFIX_STR) && eventStr.endsWith(AUTH_TIMEOUT_STR)) {
            broadcastAuthenticationFailureEvent(iface, AUTHENTICATION_FAILURE_REASON_TIMEOUT);
        } else if (eventStr.startsWith(WPA_EVENT_PREFIX_STR) && eventStr.endsWith(PASSWORD_MAY_BE_INCORRECT_STR)) {
            broadcastAuthenticationFailureEvent(iface, AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        } else {
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "couldn't identify event type - " + eventStr);
            }
        }
        eventLogCounter++;
        return false;
    }
    String eventName = eventStr.substring(EVENT_PREFIX_LEN_STR);
    int nameEnd = eventName.indexOf(' ');
    if (nameEnd != -1)
        eventName = eventName.substring(0, nameEnd);
    if (eventName.length() == 0) {
        if (mVerboseLoggingEnabled) {
            Log.i(TAG, "Received wpa_supplicant event with empty event name");
        }
        eventLogCounter++;
        return false;
    }
    /*
        * Map event name into event enum
        */
    int event;
    if (eventName.equals(CONNECTED_STR)) {
        event = CONNECTED;
        long bssid = -1L;
        int prefix = eventStr.indexOf(ConnectPrefix);
        if (prefix >= 0) {
            int suffix = eventStr.indexOf(ConnectSuffix);
            if (suffix > prefix) {
                try {
                    bssid = Utils.parseMac(eventStr.substring(prefix + ConnectPrefix.length(), suffix));
                } catch (IllegalArgumentException iae) {
                    bssid = -1L;
                }
            }
        }
        mLastConnectBSSIDs.put(iface, bssid);
        if (bssid == -1L) {
            Log.w(TAG, "Failed to parse out BSSID from '" + eventStr + "'");
        }
    } else if (eventName.equals(DISCONNECTED_STR))
        event = DISCONNECTED;
    else if (eventName.equals(STATE_CHANGE_STR))
        event = STATE_CHANGE;
    else if (eventName.equals(LINK_SPEED_STR))
        event = LINK_SPEED;
    else if (eventName.equals(TERMINATING_STR))
        event = TERMINATING;
    else if (eventName.equals(DRIVER_STATE_STR))
        event = DRIVER_STATE;
    else if (eventName.equals(EAP_FAILURE_STR))
        event = EAP_FAILURE;
    else if (eventName.equals(ASSOC_REJECT_STR))
        event = ASSOC_REJECT;
    else if (eventName.equals(TEMP_DISABLED_STR)) {
        event = SSID_TEMP_DISABLE;
    } else if (eventName.equals(REENABLED_STR)) {
        event = SSID_REENABLE;
    } else if (eventName.equals(BSS_ADDED_STR)) {
        event = BSS_ADDED;
    } else if (eventName.equals(BSS_REMOVED_STR)) {
        event = BSS_REMOVED;
    } else
        event = UNKNOWN;
    String eventData = eventStr;
    if (event == DRIVER_STATE || event == LINK_SPEED)
        eventData = eventData.split(" ")[1];
    else if (event == STATE_CHANGE || event == EAP_FAILURE) {
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 1);
        }
    } else {
        int ind = eventStr.indexOf(" - ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 3);
        }
    }
    if ((event == SSID_TEMP_DISABLE) || (event == SSID_REENABLE)) {
        String substr = null;
        int netId = -1;
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            substr = eventStr.substring(ind + 1);
        }
        if (substr != null) {
            String[] status = substr.split(" ");
            for (String key : status) {
                if (key.regionMatches(0, "id=", 0, 3)) {
                    int idx = 3;
                    netId = 0;
                    while (idx < key.length()) {
                        char c = key.charAt(idx);
                        if ((c >= 0x30) && (c <= 0x39)) {
                            netId *= 10;
                            netId += c - 0x30;
                            idx++;
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        sendMessage(iface, (event == SSID_TEMP_DISABLE) ? SSID_TEMP_DISABLED : SSID_REENABLED, netId, 0, substr);
    } else if (event == STATE_CHANGE) {
        handleSupplicantStateChange(eventData, iface);
    } else if (event == DRIVER_STATE) {
        handleDriverEvent(eventData, iface);
    } else if (event == TERMINATING) {
        /**
         * Close the supplicant connection if we see
         * too many recv errors
         */
        if (eventData.startsWith(WPA_RECV_ERROR_STR)) {
            if (++mRecvErrors > MAX_RECV_ERRORS) {
                if (mVerboseLoggingEnabled) {
                    Log.d(TAG, "too many recv errors, closing connection");
                }
            } else {
                eventLogCounter++;
                return false;
            }
        }
        // Notify and exit
        broadcastSupplicantDisconnectionEvent(null);
        return true;
    } else if (event == EAP_FAILURE) {
        if (eventData.startsWith(EAP_AUTH_FAILURE_STR)) {
            broadcastAuthenticationFailureEvent(iface, AUTHENTICATION_FAILURE_REASON_EAP_FAILURE);
        }
    } else if (event == ASSOC_REJECT) {
        Matcher match = mAssocRejectEventPattern.matcher(eventData);
        String BSSID = "";
        int status = -1;
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "Assoc Reject: Could not parse assoc reject string");
            }
        } else {
            int groupNumber = match.groupCount();
            int statusGroupNumber = -1;
            if (groupNumber == 2) {
                BSSID = match.group(1);
                statusGroupNumber = 2;
            } else {
                // Under such case Supplicant does not report BSSID
                BSSID = null;
                statusGroupNumber = 1;
            }
            try {
                status = Integer.parseInt(match.group(statusGroupNumber));
            } catch (NumberFormatException e) {
                status = -1;
            }
        }
        broadcastAssociationRejectionEvent(iface, status, BSSID);
    } else if (event == BSS_ADDED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else if (event == BSS_REMOVED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else {
        handleEvent(event, eventData, iface);
    }
    mRecvErrors = 0;
    eventLogCounter++;
    return false;
}
#end_block

#method_before
private void handleEvent(int event, String remainder, String iface) {
    if (mVerboseLoggingEnabled) {
        Log.d(TAG, "handleEvent " + Integer.toString(event) + " " + remainder);
    }
    switch(event) {
        case DISCONNECTED:
            handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED, remainder, iface);
            break;
        case CONNECTED:
            handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED, remainder, iface);
            break;
        case SCAN_RESULTS:
            sendMessage(iface, SCAN_RESULTS_EVENT);
            break;
        case SCAN_FAILED:
            sendMessage(iface, SCAN_FAILED_EVENT);
            break;
        case UNKNOWN:
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "handleEvent unknown: " + Integer.toString(event) + " " + remainder);
            }
            break;
        default:
            break;
    }
}
#method_after
private void handleEvent(int event, String remainder, String iface) {
    if (mVerboseLoggingEnabled) {
        Log.d(TAG, "handleEvent " + Integer.toString(event) + " " + remainder);
    }
    switch(event) {
        case DISCONNECTED:
            handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED, remainder, iface);
            break;
        case CONNECTED:
            handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED, remainder, iface);
            break;
        case UNKNOWN:
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "handleEvent unknown: " + Integer.toString(event) + " " + remainder);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void handleAssociatedBSSIDEvent(String eventStr, String iface) {
    String BSSID = null;
    Matcher match = mAssociatedPattern.matcher(eventStr);
    if (match.find()) {
        BSSID = match.group(1);
    }
    sendMessage(iface, WifiStateMachine.CMD_ASSOCIATED_BSSID, eventLogCounter, 0, BSSID);
}
#method_after
private void handleAssociatedBSSIDEvent(String eventStr, String iface) {
    String BSSID = null;
    Matcher match = mAssociatedPattern.matcher(eventStr);
    if (match.find()) {
        BSSID = match.group(1);
    }
    broadcastAssociationSuccesfulEvent(iface, BSSID);
}
#end_block

#method_before
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int reason = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String reasonStr = match.group(2);
        if (reasonStr != null) {
            int reasonInt = Integer.parseInt(reasonStr);
            switch(reasonInt) {
                case REASON_TKIP_ONLY_PROHIBITED:
                    sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_TKIP_ONLY_PROHIBITED);
                    return;
                case REASON_WEP_PROHIBITED:
                    sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_WEP_PROHIBITED);
                    return;
                default:
                    reason = reasonInt;
                    break;
            }
        }
        if (cfgErrStr != null) {
            int cfgErrInt = Integer.parseInt(cfgErrStr);
            switch(cfgErrInt) {
                case CONFIG_AUTH_FAILURE:
                    sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_AUTH_FAILURE);
                    return;
                case CONFIG_MULTIPLE_PBC_DETECTED:
                    sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_OVERLAP_ERROR);
                    return;
                default:
                    if (reason == 0)
                        reason = cfgErrInt;
                    break;
            }
        }
    }
    // For all other errors, return a generic internal error
    sendMessage(iface, WPS_FAIL_EVENT, WifiManager.ERROR, reason);
}
#method_after
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int vendorErrorCodeInt = 0;
    int cfgErrInt = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String vendorErrorCodeStr = match.group(2);
        if (vendorErrorCodeStr != null) {
            vendorErrorCodeInt = Integer.parseInt(vendorErrorCodeStr);
        }
        if (cfgErrStr != null) {
            cfgErrInt = Integer.parseInt(cfgErrStr);
        }
    }
    broadcastWpsFailEvent(iface, cfgErrInt, vendorErrorCodeInt);
}
#end_block

#method_before
private void handleP2pEvents(String dataString, String iface) {
    if (dataString.startsWith(P2P_DEVICE_FOUND_STR)) {
        WifiP2pDevice device = getWifiP2pDevice(dataString);
        if (device != null)
            sendMessage(iface, P2P_DEVICE_FOUND_EVENT, device);
    } else if (dataString.startsWith(P2P_DEVICE_LOST_STR)) {
        WifiP2pDevice device = getWifiP2pDevice(dataString);
        if (device != null)
            sendMessage(iface, P2P_DEVICE_LOST_EVENT, device);
    } else if (dataString.startsWith(P2P_FIND_STOPPED_STR)) {
        sendMessage(iface, P2P_FIND_STOPPED_EVENT);
    } else if (dataString.startsWith(P2P_GO_NEG_REQUEST_STR)) {
        sendMessage(iface, P2P_GO_NEGOTIATION_REQUEST_EVENT, new WifiP2pConfig(dataString));
    } else if (dataString.startsWith(P2P_GO_NEG_SUCCESS_STR)) {
        sendMessage(iface, P2P_GO_NEGOTIATION_SUCCESS_EVENT);
    } else if (dataString.startsWith(P2P_GO_NEG_FAILURE_STR)) {
        sendMessage(iface, P2P_GO_NEGOTIATION_FAILURE_EVENT, p2pError(dataString));
    } else if (dataString.startsWith(P2P_GROUP_FORMATION_SUCCESS_STR)) {
        sendMessage(iface, P2P_GROUP_FORMATION_SUCCESS_EVENT);
    } else if (dataString.startsWith(P2P_GROUP_FORMATION_FAILURE_STR)) {
        sendMessage(iface, P2P_GROUP_FORMATION_FAILURE_EVENT, p2pError(dataString));
    } else if (dataString.startsWith(P2P_GROUP_STARTED_STR)) {
        WifiP2pGroup group = getWifiP2pGroup(dataString);
        if (group != null)
            sendMessage(iface, P2P_GROUP_STARTED_EVENT, group);
    } else if (dataString.startsWith(P2P_GROUP_REMOVED_STR)) {
        WifiP2pGroup group = getWifiP2pGroup(dataString);
        if (group != null)
            sendMessage(iface, P2P_GROUP_REMOVED_EVENT, group);
    } else if (dataString.startsWith(P2P_INVITATION_RECEIVED_STR)) {
        sendMessage(iface, P2P_INVITATION_RECEIVED_EVENT, new WifiP2pGroup(dataString));
    } else if (dataString.startsWith(P2P_INVITATION_RESULT_STR)) {
        sendMessage(iface, P2P_INVITATION_RESULT_EVENT, p2pError(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_PBC_REQ_STR)) {
        sendMessage(iface, P2P_PROV_DISC_PBC_REQ_EVENT, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_PBC_RSP_STR)) {
        sendMessage(iface, P2P_PROV_DISC_PBC_RSP_EVENT, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_ENTER_PIN_STR)) {
        sendMessage(iface, P2P_PROV_DISC_ENTER_PIN_EVENT, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_SHOW_PIN_STR)) {
        sendMessage(iface, P2P_PROV_DISC_SHOW_PIN_EVENT, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_FAILURE_STR)) {
        sendMessage(iface, P2P_PROV_DISC_FAILURE_EVENT);
    } else if (dataString.startsWith(P2P_SERV_DISC_RESP_STR)) {
        List<WifiP2pServiceResponse> list = WifiP2pServiceResponse.newInstance(dataString);
        if (list != null) {
            sendMessage(iface, P2P_SERV_DISC_RESP_EVENT, list);
        } else {
            Log.e(TAG, "Null service resp " + dataString);
        }
    }
}
#method_after
private void handleP2pEvents(String dataString, String iface) {
    if (dataString.startsWith(P2P_DEVICE_FOUND_STR)) {
        broadcastP2pDeviceFound(iface, getWifiP2pDevice(dataString));
    } else if (dataString.startsWith(P2P_DEVICE_LOST_STR)) {
        broadcastP2pDeviceLost(iface, getWifiP2pDevice(dataString));
    } else if (dataString.startsWith(P2P_FIND_STOPPED_STR)) {
        broadcastP2pFindStopped(iface);
    } else if (dataString.startsWith(P2P_GO_NEG_REQUEST_STR)) {
        broadcastP2pGoNegotiationRequest(iface, new WifiP2pConfig(dataString));
    } else if (dataString.startsWith(P2P_GO_NEG_SUCCESS_STR)) {
        broadcastP2pGoNegotiationSuccess(iface);
    } else if (dataString.startsWith(P2P_GO_NEG_FAILURE_STR)) {
        broadcastP2pGoNegotiationFailure(iface, p2pError(dataString));
    } else if (dataString.startsWith(P2P_GROUP_FORMATION_SUCCESS_STR)) {
        broadcastP2pGroupFormationSuccess(iface);
    } else if (dataString.startsWith(P2P_GROUP_FORMATION_FAILURE_STR)) {
        broadcastP2pGroupFormationFailure(iface, dataString);
    } else if (dataString.startsWith(P2P_GROUP_STARTED_STR)) {
        broadcastP2pGroupStarted(iface, getWifiP2pGroup(dataString));
    } else if (dataString.startsWith(P2P_GROUP_REMOVED_STR)) {
        broadcastP2pGroupRemoved(iface, getWifiP2pGroup(dataString));
    } else if (dataString.startsWith(P2P_INVITATION_RECEIVED_STR)) {
        broadcastP2pInvitationReceived(iface, new WifiP2pGroup(dataString));
    } else if (dataString.startsWith(P2P_INVITATION_RESULT_STR)) {
        broadcastP2pInvitationResult(iface, p2pError(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_PBC_REQ_STR)) {
        broadcastP2pProvisionDiscoveryPbcRequest(iface, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_PBC_RSP_STR)) {
        broadcastP2pProvisionDiscoveryPbcResponse(iface, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_ENTER_PIN_STR)) {
        broadcastP2pProvisionDiscoveryEnterPin(iface, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_SHOW_PIN_STR)) {
        broadcastP2pProvisionDiscoveryShowPin(iface, new WifiP2pProvDiscEvent(dataString));
    } else if (dataString.startsWith(P2P_PROV_DISC_FAILURE_STR)) {
        broadcastP2pProvisionDiscoveryFailure(iface);
    } else if (dataString.startsWith(P2P_SERV_DISC_RESP_STR)) {
        List<WifiP2pServiceResponse> list = WifiP2pServiceResponse.newInstance(dataString);
        if (list != null) {
            broadcastP2pServiceDiscoveryResponse(iface, list);
        } else {
            Log.e(TAG, "Null service resp " + dataString);
        }
    }
}
#end_block

#method_before
// ANQP-QUERY-DONE addr=18:cf:5e:26:a4:88 result=SUCCESS
private void handleAnqpResult(String eventStr, String iface) {
    int addrPos = eventStr.indexOf(ADDR_STRING);
    int resPos = eventStr.indexOf(RESULT_STRING);
    if (addrPos < 0 || resPos < 0) {
        throw new IllegalArgumentException("Unexpected ANQP result notification");
    }
    int eoaddr = eventStr.indexOf(' ', addrPos + ADDR_STRING.length());
    if (eoaddr < 0) {
        eoaddr = eventStr.length();
    }
    int eoresult = eventStr.indexOf(' ', resPos + RESULT_STRING.length());
    if (eoresult < 0) {
        eoresult = eventStr.length();
    }
    try {
        long bssid = Utils.parseMac(eventStr.substring(addrPos + ADDR_STRING.length(), eoaddr));
        int result = eventStr.substring(resPos + RESULT_STRING.length(), eoresult).equalsIgnoreCase("success") ? 1 : 0;
        sendMessage(iface, ANQP_DONE_EVENT, result, 0, bssid);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, "Bad MAC address in ANQP response: " + iae.getMessage());
    }
}
#method_after
// ANQP-QUERY-DONE addr=18:cf:5e:26:a4:88 result=SUCCESS
private void handleAnqpResult(String eventStr, String iface) {
    int addrPos = eventStr.indexOf(ADDR_STRING);
    int resPos = eventStr.indexOf(RESULT_STRING);
    if (addrPos < 0 || resPos < 0) {
        throw new IllegalArgumentException("Unexpected ANQP result notification");
    }
    int eoaddr = eventStr.indexOf(' ', addrPos + ADDR_STRING.length());
    if (eoaddr < 0) {
        eoaddr = eventStr.length();
    }
    int eoresult = eventStr.indexOf(' ', resPos + RESULT_STRING.length());
    if (eoresult < 0) {
        eoresult = eventStr.length();
    }
    long bssid = 0;
    int result = 0;
    try {
        bssid = Utils.parseMac(eventStr.substring(addrPos + ADDR_STRING.length(), eoaddr));
        result = eventStr.substring(resPos + RESULT_STRING.length(), eoresult).equalsIgnoreCase("success") ? 1 : 0;
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, "Bad MAC address in ANQP response: " + iae.getMessage());
        return;
    }
    AnqpEvent anqpEvent = null;
    // empty ANQP elements.
    if (bssid != 0 && result != 0) {
        String bssData = mWifiNative.scanResult(Utils.macToString(bssid));
        anqpEvent = AnqpEvent.buildAnqpEvent(bssid, bssData);
    } else {
        anqpEvent = AnqpEvent.buildAnqpEvent(bssid, null);
    }
    broadcastAnqpDoneEvent(iface, anqpEvent);
}
#end_block

#method_before
private void handleIconResult(String eventStr, String iface) {
    // RX-HS20-ICON c0:c5:20:27:d1:e8 <file> <size>
    String[] segments = eventStr.split(" ");
    if (segments.length != 4) {
        throw new IllegalArgumentException("Incorrect number of segments");
    }
    try {
        String bssid = segments[1];
        String fileName = segments[2];
        int size = Integer.parseInt(segments[3]);
        sendMessage(iface, RX_HS20_ANQP_ICON_EVENT, new IconEvent(Utils.parseMac(bssid), fileName, size));
    } catch (NumberFormatException nfe) {
        throw new IllegalArgumentException("Bad numeral");
    }
}
#method_after
private void handleIconResult(String eventStr, String iface) {
    // RX-HS20-ICON c0:c5:20:27:d1:e8 <file> <size>
    String[] segments = eventStr.split(" ");
    if (segments.length != 4) {
        throw new IllegalArgumentException("Incorrect number of segments");
    }
    try {
        String bssid = segments[1];
        String fileName = segments[2];
        int size = Integer.parseInt(segments[3]);
        byte[] iconData = null;
        if (!TextUtils.isEmpty(bssid) && !TextUtils.isEmpty(fileName) && size > 0) {
            try {
                iconData = retrieveIcon(Utils.parseMac(bssid), fileName, size);
            } catch (IOException ioe) {
                Log.e(TAG, "Failed to retrieve icon: " + ioe.toString() + ": " + fileName);
            }
        }
        broadcastIconDoneEvent(iface, new IconEvent(Utils.parseMac(bssid), fileName, size, iconData));
    } catch (NumberFormatException nfe) {
        throw new IllegalArgumentException("Bad numeral");
    }
}
#end_block

#method_before
private void handleWnmFrame(String eventStr, String iface) {
    try {
        WnmData wnmData = WnmData.buildWnmData(eventStr);
        sendMessage(iface, HS20_REMEDIATION_EVENT, wnmData);
    } catch (IOException | NumberFormatException e) {
        Log.w(TAG, "Bad WNM event: '" + eventStr + "'");
    }
}
#method_after
private void handleWnmFrame(String eventStr, String iface) {
    try {
        WnmData wnmData = WnmData.buildWnmData(eventStr);
        broadcastWnmEvent(iface, wnmData);
    } catch (IOException | NumberFormatException e) {
        Log.w(TAG, "Bad WNM event: '" + eventStr + "'");
    }
}
#end_block

#method_before
private void handleRequests(String dataString, String iface) {
    String SSID = null;
    int reason = -2;
    String requestName = dataString.substring(REQUEST_PREFIX_LEN_STR);
    if (TextUtils.isEmpty(requestName)) {
        return;
    }
    if (requestName.startsWith(IDENTITY_STR)) {
        Matcher match = mRequestIdentityPattern.matcher(requestName);
        if (match.find()) {
            SSID = match.group(2);
            try {
                reason = Integer.parseInt(match.group(1));
            } catch (NumberFormatException e) {
                reason = -1;
            }
        } else {
            Log.e(TAG, "didn't find SSID " + requestName);
        }
        sendMessage(iface, SUP_REQUEST_IDENTITY, eventLogCounter, reason, SSID);
    } else if (requestName.startsWith(SIM_STR)) {
        Matcher matchGsm = mRequestGsmAuthPattern.matcher(requestName);
        Matcher matchUmts = mRequestUmtsAuthPattern.matcher(requestName);
        SimAuthRequestData data = new SimAuthRequestData();
        if (matchGsm.find()) {
            data.networkId = Integer.parseInt(matchGsm.group(1));
            data.protocol = WifiEnterpriseConfig.Eap.SIM;
            data.ssid = matchGsm.group(4);
            data.data = matchGsm.group(2).split(":");
            sendMessage(iface, SUP_REQUEST_SIM_AUTH, data);
        } else if (matchUmts.find()) {
            data.networkId = Integer.parseInt(matchUmts.group(1));
            data.protocol = WifiEnterpriseConfig.Eap.AKA;
            data.ssid = matchUmts.group(4);
            data.data = new String[2];
            data.data[0] = matchUmts.group(2);
            data.data[1] = matchUmts.group(3);
            sendMessage(iface, SUP_REQUEST_SIM_AUTH, data);
        } else {
            Log.e(TAG, "couldn't parse SIM auth request - " + requestName);
        }
    } else {
        if (mVerboseLoggingEnabled) {
            Log.w(TAG, "couldn't identify request type - " + dataString);
        }
    }
}
#method_after
private void handleRequests(String dataString, String iface) {
    String SSID = null;
    int networkId = -2;
    String requestName = dataString.substring(REQUEST_PREFIX_LEN_STR);
    if (TextUtils.isEmpty(requestName)) {
        return;
    }
    if (requestName.startsWith(IDENTITY_STR)) {
        Matcher match = mRequestIdentityPattern.matcher(requestName);
        if (match.find()) {
            SSID = match.group(2);
            try {
                networkId = Integer.parseInt(match.group(1));
            } catch (NumberFormatException e) {
                networkId = -1;
            }
        } else {
            Log.e(TAG, "didn't find SSID " + requestName);
        }
        broadcastNetworkIdentityRequestEvent(iface, networkId, SSID);
    } else if (requestName.startsWith(SIM_STR)) {
        Matcher matchGsm = mRequestGsmAuthPattern.matcher(requestName);
        Matcher matchUmts = mRequestUmtsAuthPattern.matcher(requestName);
        if (matchGsm.find()) {
            String[] data = matchGsm.group(2).split(":");
            broadcastNetworkGsmAuthRequestEvent(iface, Integer.parseInt(matchGsm.group(1)), matchGsm.group(4), data);
        } else if (matchUmts.find()) {
            String[] data = { matchUmts.group(2), matchUmts.group(3) };
            broadcastNetworkUmtsAuthRequestEvent(iface, Integer.parseInt(matchUmts.group(1)), matchUmts.group(4), data);
        } else {
            Log.e(TAG, "couldn't parse SIM auth request - " + requestName);
        }
    } else {
        if (mVerboseLoggingEnabled) {
            Log.w(TAG, "couldn't identify request type - " + dataString);
        }
    }
}
#end_block

#method_before
private void handleSupplicantStateChange(String dataString, String iface) {
    WifiSsid wifiSsid = null;
    int index = dataString.lastIndexOf("SSID=");
    if (index != -1) {
        wifiSsid = WifiSsid.createFromAsciiEncoded(dataString.substring(index + 5));
    }
    String[] dataTokens = dataString.split(" ");
    String BSSID = null;
    int networkId = -1;
    int newState = -1;
    for (String token : dataTokens) {
        String[] nameValue = token.split("=");
        if (nameValue.length != 2) {
            continue;
        }
        if (nameValue[0].equals("BSSID")) {
            BSSID = nameValue[1];
            continue;
        }
        int value;
        try {
            value = Integer.parseInt(nameValue[1]);
        } catch (NumberFormatException e) {
            continue;
        }
        if (nameValue[0].equals("id")) {
            networkId = value;
        } else if (nameValue[0].equals("state")) {
            newState = value;
        }
    }
    if (newState == -1)
        return;
    SupplicantState newSupplicantState = SupplicantState.INVALID;
    for (SupplicantState state : SupplicantState.values()) {
        if (state.ordinal() == newState) {
            newSupplicantState = state;
            break;
        }
    }
    if (newSupplicantState == SupplicantState.INVALID) {
        Log.w(TAG, "Invalid supplicant state: " + newState);
    }
    sendMessage(iface, SUPPLICANT_STATE_CHANGE_EVENT, eventLogCounter, 0, new StateChangeResult(networkId, wifiSsid, BSSID, newSupplicantState));
}
#method_after
private void handleSupplicantStateChange(String dataString, String iface) {
    WifiSsid wifiSsid = null;
    int index = dataString.lastIndexOf("SSID=");
    if (index != -1) {
        wifiSsid = WifiSsid.createFromAsciiEncoded(dataString.substring(index + 5));
    }
    String[] dataTokens = dataString.split(" ");
    String BSSID = null;
    int networkId = -1;
    int newState = -1;
    for (String token : dataTokens) {
        String[] nameValue = token.split("=");
        if (nameValue.length != 2) {
            continue;
        }
        if (nameValue[0].equals("BSSID")) {
            BSSID = nameValue[1];
            continue;
        }
        int value;
        try {
            value = Integer.parseInt(nameValue[1]);
        } catch (NumberFormatException e) {
            continue;
        }
        if (nameValue[0].equals("id")) {
            networkId = value;
        } else if (nameValue[0].equals("state")) {
            newState = value;
        }
    }
    if (newState == -1)
        return;
    SupplicantState newSupplicantState = SupplicantState.INVALID;
    for (SupplicantState state : SupplicantState.values()) {
        if (state.ordinal() == newState) {
            newSupplicantState = state;
            break;
        }
    }
    if (newSupplicantState == SupplicantState.INVALID) {
        Log.w(TAG, "Invalid supplicant state: " + newState);
    }
    broadcastSupplicantStateChangeEvent(iface, networkId, wifiSsid, BSSID, newSupplicantState);
}
#end_block

#method_before
private void handleNetworkStateChange(NetworkInfo.DetailedState newState, String data, String iface) {
    String BSSID = null;
    int networkId = -1;
    int reason = 0;
    int ind = -1;
    int local = 0;
    Matcher match;
    if (newState == NetworkInfo.DetailedState.CONNECTED) {
        match = mConnectedEventPattern.matcher(data);
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "handleNetworkStateChange: Couldnt find BSSID in event string");
            }
        } else {
            BSSID = match.group(1);
            try {
                networkId = Integer.parseInt(match.group(2));
            } catch (NumberFormatException e) {
                networkId = -1;
            }
        }
        sendMessage(iface, NETWORK_CONNECTION_EVENT, networkId, reason, BSSID);
    } else if (newState == NetworkInfo.DetailedState.DISCONNECTED) {
        match = mDisconnectedEventPattern.matcher(data);
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "handleNetworkStateChange: Could not parse disconnect string");
            }
        } else {
            BSSID = match.group(1);
            try {
                reason = Integer.parseInt(match.group(2));
            } catch (NumberFormatException e) {
                reason = -1;
            }
            try {
                local = Integer.parseInt(match.group(3));
            } catch (NumberFormatException e) {
                local = -1;
            }
        }
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, "WifiMonitor notify network disconnect: " + BSSID + " reason=" + Integer.toString(reason));
        }
        sendMessage(iface, NETWORK_DISCONNECTION_EVENT, local, reason, BSSID);
    }
}
#method_after
private void handleNetworkStateChange(NetworkInfo.DetailedState newState, String data, String iface) {
    String BSSID = null;
    int networkId = -1;
    int reason = 0;
    int ind = -1;
    int local = 0;
    Matcher match;
    if (newState == NetworkInfo.DetailedState.CONNECTED) {
        match = mConnectedEventPattern.matcher(data);
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "handleNetworkStateChange: Couldnt find BSSID in event string");
            }
        } else {
            BSSID = match.group(1);
            try {
                networkId = Integer.parseInt(match.group(2));
            } catch (NumberFormatException e) {
                networkId = -1;
            }
        }
        broadcastNetworkConnectionEvent(iface, networkId, BSSID);
    } else if (newState == NetworkInfo.DetailedState.DISCONNECTED) {
        match = mDisconnectedEventPattern.matcher(data);
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "handleNetworkStateChange: Could not parse disconnect string");
            }
        } else {
            BSSID = match.group(1);
            try {
                reason = Integer.parseInt(match.group(2));
            } catch (NumberFormatException e) {
                reason = -1;
            }
            try {
                local = Integer.parseInt(match.group(3));
            } catch (NumberFormatException e) {
                local = -1;
            }
        }
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, "WifiMonitor notify network disconnect: " + BSSID + " reason=" + Integer.toString(reason));
        }
        broadcastNetworkDisconnectionEvent(iface, local, reason, BSSID);
    }
}
#end_block

#method_before
public void setWifiLinkLayerStats(String iface, int enable) {
    if (HIDL_VENDOR_ENABLE) {
        mWifiVendorHal.enableLinkLayerStats();
    } else {
        if (iface == null)
            return;
        synchronized (sLock) {
            if (isHalStarted()) {
                setWifiLinkLayerStatsNative(sWlan0Index, enable);
            }
        }
    }
}
#method_after
public void setWifiLinkLayerStats(String iface, int enable) {
    if (HIDL_VENDOR_ENABLE) {
    // Nothing to do here. Link layer stats is enabled when the HAL is started.
    } else {
        if (iface == null)
            return;
        synchronized (sLock) {
            if (isHalStarted()) {
                setWifiLinkLayerStatsNative(sWlan0Index, enable);
            }
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiStatusSuccess = new WifiStatus();
    mWifiStatusSuccess.code = WifiStatusCode.SUCCESS;
    mWifiStatusFailure = new WifiStatus();
    mWifiStatusFailure.code = WifiStatusCode.ERROR_UNKNOWN;
    mWifiStatusFailure.description = "I don't even know what a Mock Turtle is.";
    when(mIWifiStaIface.enableLinkLayerStatsCollection(false)).thenReturn(mWifiStatusSuccess);
    // Setup the HalDeviceManager mock's start/stop behaviour. This can be overridden in
    // individual tests, if needed.
    doAnswer(new AnswerWithArguments() {

        public boolean answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(true);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
            return true;
        }
    }).when(mHalDeviceManager).start();
    doAnswer(new AnswerWithArguments() {

        public void answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(false);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
        }
    }).when(mHalDeviceManager).stop();
    when(mHalDeviceManager.createStaIface(eq(null), eq(null))).thenReturn(mIWifiStaIface);
    when(mHalDeviceManager.createApIface(eq(null), eq(null))).thenReturn(mIWifiApIface);
    when(mHalDeviceManager.getChip(any(IWifiIface.class))).thenReturn(mIWifiChip);
    when(mHalDeviceManager.createRttController(any(IWifiIface.class))).thenReturn(mIWifiRttController);
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenReturn(mWifiStatusSuccess);
    when(mIWifiStaIface.registerEventCallback(any(IWifiStaIfaceEventCallback.class))).thenReturn(mWifiStatusSuccess);
    // Create the vendor HAL object under test.
    mWifiVendorHal = new WifiVendorHal(mHalDeviceManager, mWifiStateMachineHandlerThread);
    // Initialize the vendor HAL to capture the registered callback.
    mWifiVendorHal.initialize();
    ArgumentCaptor<WifiVendorHal.HalDeviceManagerStatusListener> hdmCallbackCaptor = ArgumentCaptor.forClass(WifiVendorHal.HalDeviceManagerStatusListener.class);
    verify(mHalDeviceManager).registerStatusListener(hdmCallbackCaptor.capture(), any(Looper.class));
    mHalDeviceManagerStatusCallbacks = hdmCallbackCaptor.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiStatusSuccess = new WifiStatus();
    mWifiStatusSuccess.code = WifiStatusCode.SUCCESS;
    mWifiStatusFailure = new WifiStatus();
    mWifiStatusFailure.code = WifiStatusCode.ERROR_UNKNOWN;
    mWifiStatusFailure.description = "I don't even know what a Mock Turtle is.";
    when(mIWifiStaIface.enableLinkLayerStatsCollection(false)).thenReturn(mWifiStatusSuccess);
    // Setup the HalDeviceManager mock's start/stop behaviour. This can be overridden in
    // individual tests, if needed.
    doAnswer(new AnswerWithArguments() {

        public boolean answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(true);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
            return true;
        }
    }).when(mHalDeviceManager).start();
    doAnswer(new AnswerWithArguments() {

        public void answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(false);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
        }
    }).when(mHalDeviceManager).stop();
    when(mHalDeviceManager.createStaIface(eq(null), eq(null))).thenReturn(mIWifiStaIface);
    when(mHalDeviceManager.createApIface(eq(null), eq(null))).thenReturn(mIWifiApIface);
    when(mHalDeviceManager.getChip(any(IWifiIface.class))).thenReturn(mIWifiChip);
    when(mHalDeviceManager.createRttController(any(IWifiIface.class))).thenReturn(mIWifiRttController);
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenReturn(mWifiStatusSuccess);
    mIWifiStaIfaceEventCallback = null;
    when(mIWifiStaIface.registerEventCallback(any(IWifiStaIfaceEventCallback.class))).thenAnswer(answerWifiStatus((invocation) -> {
        Object[] args = invocation.getArguments();
        mIWifiStaIfaceEventCallback = (IWifiStaIfaceEventCallback) args[0];
        return (mWifiStatusSuccess);
    }));
    mIWifiChipEventCallback = null;
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenAnswer(answerWifiStatus((invocation) -> {
        Object[] args = invocation.getArguments();
        mIWifiChipEventCallback = (IWifiChipEventCallback) args[0];
        return (mWifiStatusSuccess);
    }));
    // Create the vendor HAL object under test.
    mWifiVendorHal = new WifiVendorHal(mHalDeviceManager, mWifiStateMachineHandlerThread);
    // Initialize the vendor HAL to capture the registered callback.
    mWifiVendorHal.initialize();
    ArgumentCaptor<WifiVendorHal.HalDeviceManagerStatusListener> hdmCallbackCaptor = ArgumentCaptor.forClass(WifiVendorHal.HalDeviceManagerStatusListener.class);
    verify(mHalDeviceManager).registerStatusListener(hdmCallbackCaptor.capture(), any(Looper.class));
    mHalDeviceManagerStatusCallbacks = hdmCallbackCaptor.getValue();
}
#end_block

#method_before
@Test
public void testSetScanningMacOui() throws Exception {
    byte[] oui = NativeUtil.macAddressOuiToByteArray("DA:A1:19");
    byte[] zzz = NativeUtil.macAddressOuiToByteArray("00:00:00");
    when(mIWifiStaIface.setScanningMacOui(any())).thenReturn(mWifiStatusSuccess);
    // expect fail - STA not started
    assertFalse(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // expect fail - null
    assertFalse(mWifiVendorHal.setScanningMacOui(null));
    // expect fail - len
    assertFalse(mWifiVendorHal.setScanningMacOui(new byte[] { (byte) 1 }));
    assertTrue(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.setScanningMacOui(zzz));
    verify(mIWifiStaIface).setScanningMacOui(eq(oui));
    verify(mIWifiStaIface).setScanningMacOui(eq(zzz));
}
#method_after
// TODO(b/34901744) negative RTT test cases as well.
// e.g. invoke RTT without putting the HAL in the correct mode.
@Test
public void testSetScanningMacOui() throws Exception {
    byte[] oui = NativeUtil.macAddressOuiToByteArray("DA:A1:19");
    byte[] zzz = NativeUtil.macAddressOuiToByteArray("00:00:00");
    when(mIWifiStaIface.setScanningMacOui(any())).thenReturn(mWifiStatusSuccess);
    // expect fail - STA not started
    assertFalse(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // expect fail - null
    assertFalse(mWifiVendorHal.setScanningMacOui(null));
    // expect fail - len
    assertFalse(mWifiVendorHal.setScanningMacOui(new byte[] { (byte) 1 }));
    assertTrue(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.setScanningMacOui(zzz));
    verify(mIWifiStaIface).setScanningMacOui(eq(oui));
    verify(mIWifiStaIface).setScanningMacOui(eq(zzz));
}
#end_block

#method_before
@Test
public void testBgScanFailureCallback() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#method_after
@Test
public void testBgScanFailureCallback() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#end_block

#method_before
@Test
public void testBgScanFailureCallbackWithInvalidCmdId() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId + 1);
    verify(eventHandler, never()).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#method_after
@Test
public void testBgScanFailureCallbackWithInvalidCmdId() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId + 1);
    verify(eventHandler, never()).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#end_block

#method_before
@Test
public void testBgScanFullScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    mIWifiStaIfaceEventCallback.onBackgroundFullScanResult(mWifiVendorHal.mScan.cmdId, (short) 5, result.first);
    ArgumentCaptor<ScanResult> scanResultCaptor = ArgumentCaptor.forClass(ScanResult.class);
    verify(eventHandler).onFullScanResult(scanResultCaptor.capture(), eq(5));
    assertScanResultEqual(result.second, scanResultCaptor.getValue());
}
#method_after
@Test
public void testBgScanFullScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    mIWifiStaIfaceEventCallback.onBackgroundFullScanResult(mWifiVendorHal.mScan.cmdId, result.first);
    ArgumentCaptor<ScanResult> scanResultCaptor = ArgumentCaptor.forClass(ScanResult.class);
    verify(eventHandler).onFullScanResult(scanResultCaptor.capture(), eq(0));
    assertScanResultEqual(result.second, scanResultCaptor.getValue());
}
#end_block

#method_before
@Test
public void testBgScanScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> data = createHidlAndFrameworkBgScanDatas();
    mIWifiStaIfaceEventCallback.onBackgroundScanResults(mWifiVendorHal.mScan.cmdId, data.first);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
    assertScanDatasEqual(data.second, Arrays.asList(mWifiVendorHal.mScan.latestScanResults));
}
#method_after
@Test
public void testBgScanScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> data = createHidlAndFrameworkBgScanDatas();
    mIWifiStaIfaceEventCallback.onBackgroundScanResults(mWifiVendorHal.mScan.cmdId, data.first);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
    assertScanDatasEqual(data.second, Arrays.asList(mWifiVendorHal.mScan.latestScanResults));
}
#end_block

#method_before
@Test
public void testResetLogHandler() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    when(mIWifiChip.stopLoggingToDebugRingBuffer()).thenReturn(mWifiStatusSuccess);
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
    verify(mIWifiChip, never()).stopLoggingToDebugRingBuffer();
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // Not set, so this should fail.
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
    verify(mIWifiChip, never()).stopLoggingToDebugRingBuffer();
    // Now set and then reset.
    assertTrue(mWifiVendorHal.setLoggingEventHandler(mock(WifiNative.WifiLoggerEventHandler.class)));
    assertTrue(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip).enableDebugErrorAlerts(eq(false));
    verify(mIWifiChip).stopLoggingToDebugRingBuffer();
    reset(mIWifiChip);
    // Second reset should fail.
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
    verify(mIWifiChip, never()).stopLoggingToDebugRingBuffer();
}
#method_after
@Test
public void testResetLogHandler() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // Not set, so this should fail.
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
    // Now set and then reset.
    assertTrue(mWifiVendorHal.setLoggingEventHandler(mock(WifiNative.WifiLoggerEventHandler.class)));
    assertTrue(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip).enableDebugErrorAlerts(eq(false));
    reset(mIWifiChip);
    // Second reset should fail.
    assertFalse(mWifiVendorHal.resetLogHandler());
    verify(mIWifiChip, never()).enableDebugErrorAlerts(anyBoolean());
}
#end_block

#method_before
@Test
public void testAlertCallback() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    when(mIWifiChip.stopLoggingToDebugRingBuffer()).thenReturn(mWifiStatusSuccess);
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureChipEventCallback();
    assertNotNull(mIWifiChipEventCallback);
    int errorCode = 5;
    byte[] errorData = new byte[45];
    new Random().nextBytes(errorData);
    // Randomly raise the HIDL callback before we register for the log callback.
    // This should be ignored.
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
    WifiNative.WifiLoggerEventHandler eventHandler = mock(WifiNative.WifiLoggerEventHandler.class);
    assertTrue(mWifiVendorHal.setLoggingEventHandler(eventHandler));
    verify(mIWifiChip).enableDebugErrorAlerts(eq(true));
    // Now raise the HIDL callback, this should be properly handled.
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
    verify(eventHandler).onWifiAlert(eq(errorCode), eq(errorData));
    // Now stop the logging and invoke the callback. This should be ignored.
    assertTrue(mWifiVendorHal.resetLogHandler());
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
}
#method_after
@Test
public void testAlertCallback() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiChipEventCallback);
    int errorCode = 5;
    byte[] errorData = new byte[45];
    new Random().nextBytes(errorData);
    // Randomly raise the HIDL callback before we register for the log callback.
    // This should be ignored.
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
    WifiNative.WifiLoggerEventHandler eventHandler = mock(WifiNative.WifiLoggerEventHandler.class);
    assertTrue(mWifiVendorHal.setLoggingEventHandler(eventHandler));
    verify(mIWifiChip).enableDebugErrorAlerts(eq(true));
    // Now raise the HIDL callback, this should be properly handled.
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
    verify(eventHandler).onWifiAlert(eq(errorCode), eq(errorData));
    // Now stop the logging and invoke the callback. This should be ignored.
    assertTrue(mWifiVendorHal.resetLogHandler());
    mIWifiChipEventCallback.onDebugErrorAlert(errorCode, NativeUtil.byteArrayToArrayList(errorData));
}
#end_block

#method_before
@Test
public void testRingBufferDataCallback() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    when(mIWifiChip.stopLoggingToDebugRingBuffer()).thenReturn(mWifiStatusSuccess);
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureChipEventCallback();
    assertNotNull(mIWifiChipEventCallback);
    byte[] errorData = new byte[45];
    new Random().nextBytes(errorData);
    // Randomly raise the HIDL callback before we register for the log callback.
    // This should be ignored.
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
    WifiNative.WifiLoggerEventHandler eventHandler = mock(WifiNative.WifiLoggerEventHandler.class);
    assertTrue(mWifiVendorHal.setLoggingEventHandler(eventHandler));
    verify(mIWifiChip).enableDebugErrorAlerts(eq(true));
    // Now raise the HIDL callback, this should be properly handled.
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
    verify(eventHandler).onRingBufferData(any(WifiNative.RingBufferStatus.class), eq(errorData));
    // Now stop the logging and invoke the callback. This should be ignored.
    assertTrue(mWifiVendorHal.resetLogHandler());
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
}
#method_after
@Test
public void testRingBufferDataCallback() throws Exception {
    when(mIWifiChip.enableDebugErrorAlerts(anyBoolean())).thenReturn(mWifiStatusSuccess);
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiChipEventCallback);
    byte[] errorData = new byte[45];
    new Random().nextBytes(errorData);
    // Randomly raise the HIDL callback before we register for the log callback.
    // This should be ignored.
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
    WifiNative.WifiLoggerEventHandler eventHandler = mock(WifiNative.WifiLoggerEventHandler.class);
    assertTrue(mWifiVendorHal.setLoggingEventHandler(eventHandler));
    verify(mIWifiChip).enableDebugErrorAlerts(eq(true));
    // Now raise the HIDL callback, this should be properly handled.
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
    verify(eventHandler).onRingBufferData(any(WifiNative.RingBufferStatus.class), eq(errorData));
    // Now stop the logging and invoke the callback. This should be ignored.
    assertTrue(mWifiVendorHal.resetLogHandler());
    mIWifiChipEventCallback.onDebugRingBufferDataAvailable(new WifiDebugRingBufferStatus(), NativeUtil.byteArrayToArrayList(errorData));
}
#end_block

#method_before
// Create a pair of HIDL scan result and it's corresponding framework scan result for
private Pair<StaScanResult, ScanResult> createHidlAndFrameworkBgScanResult() {
    StaScanResult staScanResult = new StaScanResult();
    Random random = new Random();
    byte[] ssid = new byte[8];
    random.nextBytes(ssid);
    staScanResult.ssid.addAll(NativeUtil.byteArrayToArrayList(ssid));
    random.nextBytes(staScanResult.bssid);
    staScanResult.frequency = 2432;
    staScanResult.rssi = -45;
    staScanResult.timeStampInUs = 5;
    WifiInformationElement ie1 = new WifiInformationElement();
    byte[] ie1_data = new byte[56];
    random.nextBytes(ie1_data);
    ie1.id = 1;
    ie1.data.addAll(NativeUtil.byteArrayToArrayList(ie1_data));
    staScanResult.informationElements.add(ie1);
    // Now create the corresponding Scan result structure.
    ScanResult scanResult = new ScanResult();
    scanResult.SSID = NativeUtil.encodeSsid(staScanResult.ssid);
    scanResult.BSSID = NativeUtil.macAddressFromByteArray(staScanResult.bssid);
    scanResult.wifiSsid = WifiSsid.createFromByteArray(ssid);
    scanResult.frequency = staScanResult.frequency;
    scanResult.level = staScanResult.rssi;
    scanResult.timestamp = staScanResult.timeStampInUs;
    scanResult.bytes = new byte[57];
    scanResult.bytes[0] = ie1.id;
    System.arraycopy(ie1_data, 0, scanResult.bytes, 1, ie1_data.length);
    return Pair.create(staScanResult, scanResult);
}
#method_after
// Create a pair of HIDL scan result and its corresponding framework scan result for
private Pair<StaScanResult, ScanResult> createHidlAndFrameworkBgScanResult() {
    StaScanResult staScanResult = new StaScanResult();
    Random random = new Random();
    byte[] ssid = new byte[8];
    random.nextBytes(ssid);
    staScanResult.ssid.addAll(NativeUtil.byteArrayToArrayList(ssid));
    random.nextBytes(staScanResult.bssid);
    staScanResult.frequency = 2432;
    staScanResult.rssi = -45;
    staScanResult.timeStampInUs = 5;
    WifiInformationElement ie1 = new WifiInformationElement();
    byte[] ie1_data = new byte[56];
    random.nextBytes(ie1_data);
    ie1.id = 1;
    ie1.data.addAll(NativeUtil.byteArrayToArrayList(ie1_data));
    staScanResult.informationElements.add(ie1);
    // Now create the corresponding Scan result structure.
    ScanResult scanResult = new ScanResult();
    scanResult.SSID = NativeUtil.encodeSsid(staScanResult.ssid);
    scanResult.BSSID = NativeUtil.macAddressFromByteArray(staScanResult.bssid);
    scanResult.wifiSsid = WifiSsid.createFromByteArray(ssid);
    scanResult.frequency = staScanResult.frequency;
    scanResult.level = staScanResult.rssi;
    scanResult.timestamp = staScanResult.timeStampInUs;
    scanResult.bytes = new byte[57];
    scanResult.bytes[0] = ie1.id;
    System.arraycopy(ie1_data, 0, scanResult.bytes, 1, ie1_data.length);
    return Pair.create(staScanResult, scanResult);
}
#end_block

#method_before
// Create a pair of HIDL scan datas and it's corresponding framework scan datas for
private Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> createHidlAndFrameworkBgScanDatas() {
    ArrayList<StaScanData> staScanDatas = new ArrayList<>();
    StaScanData staScanData = new StaScanData();
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    staScanData.results.add(result.first);
    staScanData.bucketsScanned = 5;
    staScanData.flags = StaScanDataFlagMask.INTERRUPTED;
    staScanDatas.add(staScanData);
    ArrayList<WifiScanner.ScanData> scanDatas = new ArrayList<>();
    ScanResult[] scanResults = new ScanResult[1];
    scanResults[0] = result.second;
    WifiScanner.ScanData scanData = new WifiScanner.ScanData(mWifiVendorHal.mScan.cmdId, 1, staScanData.bucketsScanned, false, scanResults);
    scanDatas.add(scanData);
    return Pair.create(staScanDatas, scanDatas);
}
#method_after
// Create a pair of HIDL scan datas and its corresponding framework scan datas for
private Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> createHidlAndFrameworkBgScanDatas() {
    ArrayList<StaScanData> staScanDatas = new ArrayList<>();
    StaScanData staScanData = new StaScanData();
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    staScanData.results.add(result.first);
    staScanData.bucketsScanned = 5;
    staScanData.flags = StaScanDataFlagMask.INTERRUPTED;
    staScanDatas.add(staScanData);
    ArrayList<WifiScanner.ScanData> scanDatas = new ArrayList<>();
    ScanResult[] scanResults = new ScanResult[1];
    scanResults[0] = result.second;
    WifiScanner.ScanData scanData = new WifiScanner.ScanData(mWifiVendorHal.mScan.cmdId, 1, staScanData.bucketsScanned, false, scanResults);
    scanDatas.add(scanData);
    return Pair.create(staScanDatas, scanDatas);
}
#end_block

#method_before
public RttManager.RttCapabilities getRttCapabilities() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
/* RTT related commands/events */
public RttManager.RttCapabilities getRttCapabilities() {
    kilroy();
    class AnswerBox {

        public RttManager.RttCapabilities value = null;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            mIWifiRttController.getCapabilities((status, capabilities) -> {
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                RttManager.RttCapabilities ans = new RttManager.RttCapabilities();
                ans.oneSidedRttSupported = capabilities.rttOneSidedSupported;
                ans.twoSided11McRttSupported = capabilities.rttFtmSupported;
                ans.lciSupported = capabilities.lciSupported;
                ans.lcrSupported = capabilities.lcrSupported;
                ans.preambleSupported = frameworkPreambleFromHalPreamble(capabilities.preambleSupport);
                ans.bwSupported = frameworkBwFromHalBw(capabilities.bwSupport);
                ans.responderSupported = capabilities.responderSupported;
                ans.secureRttSupported = false;
                ans.mcVersion = ((int) capabilities.mcVersion) & 0xff;
                kilroy();
                box.value = ans;
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
/* RTT related commands/events */
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    kilroy();
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttCmdId != 0)
            return false;
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (status.code == WifiStatusCode.SUCCESS) {
                kilroy();
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (status.code == WifiStatusCode.SUCCESS) {
                kilroy();
                return true;
            }
            noteHidlError(status, "requestRtt");
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean cancelRtt(RttManager.RttParams[] params) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean cancelRtt(RttManager.RttParams[] params) {
    kilroy();
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttCmdId == 0)
            return false;
        ArrayList<byte[]> /* 6 */
        addrs = new ArrayList<byte[]>(rttConfigs.size());
        for (RttConfig x : rttConfigs) addrs.add(x.addr);
        try {
            WifiStatus status = mIWifiRttController.rangeCancel(mRttCmdId, addrs);
            mRttCmdId = 0;
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
@Nullable
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    kilroy();
    RttResponder info = getRttResponder();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        if (mRttResponderCmdId != 0) {
            Log.e(TAG, "responder mode already enabled - this shouldn't happen");
            return null;
        }
        ResponderConfig config = null;
        int id = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            WifiStatus status = mIWifiRttController.enableResponder(/* cmdId */
            id, /* WifiChannelInfo channelHint */
            null, timeoutSeconds, info);
            if (status.code == WifiStatusCode.SUCCESS) {
                mRttResponderCmdId = id;
                config = frameworkResponderConfigFromHalRttResponder(info);
                Log.d(TAG, "enabling rtt " + mRttResponderCmdId);
            } else {
                noteHidlError(status, "enableRttResponder");
            }
            return config;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public boolean disableRttResponder() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean disableRttResponder() {
    kilroy();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttResponderCmdId == 0)
            return false;
        try {
            WifiStatus status = mIWifiRttController.disableResponder(mRttResponderCmdId);
            mRttResponderCmdId = 0;
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public int[] getChannelsForBand(int band) {
    kilroy();
    class AnswerBox {

        public int[] value = null;
    }
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            int hb = makeWifiBandFromFrameworkBand(band);
            mIWifiStaIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                    kilroy();
                    mChannelsForBandSupport = false;
                }
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                mChannelsForBandSupport = true;
                kilroy();
                box.value = intArrayFromArrayList(frequencies);
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#method_after
public int[] getChannelsForBand(int band) {
    kilroy();
    class AnswerBox {

        public int[] value = null;
    }
    synchronized (sLock) {
        try {
            AnswerBox box = new AnswerBox();
            int hb = makeWifiBandFromFrameworkBand(band);
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                    if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                        kilroy();
                        mChannelsForBandSupport = false;
                    }
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    mChannelsForBandSupport = true;
                    kilroy();
                    box.value = intArrayFromArrayList(frequencies);
                });
            } else if (mIWifiApIface != null) {
                mIWifiApIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                    if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                        kilroy();
                        mChannelsForBandSupport = false;
                    }
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    mChannelsForBandSupport = true;
                    kilroy();
                    box.value = intArrayFromArrayList(frequencies);
                });
            }
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    kilroy();
    synchronized (sLock) {
        if (mIWifiChip == null)
            return false;
        if (mLogEventHandler != null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            mLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    kilroy();
    if (handler == null)
        return false;
    synchronized (sLock) {
        if (mIWifiChip == null)
            return false;
        if (mLogEventHandler != null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            mLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean resetLogHandler() {
    kilroy();
    synchronized (sLock) {
        if (mIWifiChip == null)
            return false;
        if (mLogEventHandler == null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            status = mIWifiChip.stopLoggingToDebugRingBuffer();
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            mLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean resetLogHandler() {
    kilroy();
    synchronized (sLock) {
        if (mIWifiChip == null)
            return false;
        if (mLogEventHandler == null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            mLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    if (maxRssi <= minRssi)
        return -1;
    if (rssiEventHandler == null)
        return -1;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status;
            status = mIWifiStaIface.startRssiMonitoring(sRssiMonCmdId, maxRssi, minRssi);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            mWifiRssiEventHandler = rssiEventHandler;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#end_block

#method_before
public int stopRssiMonitoring() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public int stopRssiMonitoring() {
    kilroy();
    synchronized (sLock) {
        mWifiRssiEventHandler = null;
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status = mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#end_block

#method_before
@Override
public void onBackgroundFullScanResult(int cmdId, short bucketsScanned, StaScanResult result) {
    kilroy();
    Log.d(TAG, "onBackgroundFullScanResult " + cmdId);
    synchronized (sLock) {
        if (mScan != null && cmdId == mScan.cmdId) {
            mScan.eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), bucketsScanned);
        }
    }
}
#method_after
@Override
public void onBackgroundFullScanResult(int cmdId, StaScanResult result) {
    kilroy();
    Log.d(TAG, "onBackgroundFullScanResult " + cmdId);
    synchronized (sLock) {
        if (mScan != null && cmdId == mScan.cmdId) {
            mScan.eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), 0);
        }
    }
}
#end_block

#method_before
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    kilroy();
    Log.d(TAG, "onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
}
#method_after
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    Log.d(TAG, "onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
    WifiNative.WifiRssiEventHandler handler;
    synchronized (sLock) {
        handler = mWifiRssiEventHandler;
        if (mWifiRssiEventHandler == null)
            return;
        if (cmdId != sRssiMonCmdId)
            return;
        kilroy();
    }
    handler.onRssiThresholdBreached((byte) currRssi);
}
#end_block

#method_before
@Test
public void test_ofInstant() {
    // ofInstant behaves as if it calculated an Instant from the LocalDateTime/ZoneOffset
    // calculation and then calling ofInstant(Instant, ZoneId). That's why "invalid" zone
    // offsets are tolerated and basically just change how the LocalDateTime is interpreted.
    // Correct offset in winter.
    checkOfInstant(LDT_SUMMER, OFFSET_P2, ZONE_VIENNA, LDT_SUMMER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P2);
    // Correct offset in summer.
    checkOfInstant(LDT_WINTER, OFFSET_P1, ZONE_VIENNA, LDT_WINTER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P1);
    // "Wrong" offset in summer.
    checkOfInstant(LDT_SUMMER, OFFSET_P1, ZONE_VIENNA, LDT_SUMMER.toLocalDate(), LocalTime.of(1, 0), OFFSET_P2);
    // "Wrong" offset in winter.
    checkOfInstant(LDT_WINTER, OFFSET_P2, ZONE_VIENNA, LDT_WINTER.toLocalDate().minusDays(1), LocalTime.of(23, 0), OFFSET_P1);
    // Very wrong offset in winter.
    checkOfInstant(LDT_WINTER, ZoneOffset.ofHours(-10), ZONE_VIENNA, LDT_WINTER.toLocalDate(), LocalTime.of(11, 0), OFFSET_P1);
    // Neither of those combinations exist, so they are interpreted as either before or after
    // the gap, depending on the offset.
    checkOfInstant(LDT_IN_GAP, OFFSET_P1, ZONE_VIENNA, LDT_IN_GAP.toLocalDate(), LDT_IN_GAP.toLocalTime().plusHours(1), OFFSET_P2);
    checkOfInstant(LDT_IN_GAP, OFFSET_P2, ZONE_VIENNA, LDT_IN_GAP.toLocalDate(), LDT_IN_GAP.toLocalTime().minusHours(1), OFFSET_P1);
    // Both combinations exist and are valid, so they produce exactly the input.
    checkOfInstant(LDT_IN_OVERLAP, OFFSET_P1, ZONE_VIENNA, LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P1);
    checkOfInstant(LDT_IN_OVERLAP, OFFSET_P2, ZONE_VIENNA, LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P2);
}
#method_after
@Test
public void test_ofInstant() {
    // ofInstant behaves as if it calculated an Instant from the LocalDateTime/ZoneOffset
    // and then calling ofInstant(Instant, ZoneId). That's why "invalid" zone offsets are
    // tolerated and basically just change how the LocalDateTime is interpreted.
    // checkOfInstant(localDateTime, offset, zone, expectedDateTime, expectedOffset)
    // Correct offset in summer.
    checkOfInstant(LDT_P1, OFFSET_P1, ZONE_VIENNA, LDT_P1, OFFSET_P1);
    // Correct offset in winter.
    checkOfInstant(LDT_P2, OFFSET_P2, ZONE_VIENNA, LDT_P2, OFFSET_P2);
    // "Wrong" offset in winter.
    checkOfInstant(LDT_P1, OFFSET_P2, ZONE_VIENNA, LDT_P1.minusDays(1).withHour(23), OFFSET_P1);
    // "Wrong" offset in summer.
    checkOfInstant(LDT_P2, OFFSET_P1, ZONE_VIENNA, LDT_P2.withHour(1), OFFSET_P2);
    // Very wrong offset in winter.
    checkOfInstant(LDT_P1, ZoneOffset.ofHours(-10), ZONE_VIENNA, LDT_P1.withHour(11), OFFSET_P1);
    // Neither of those combinations exist, so they are interpreted as either before or after
    // the gap, depending on the offset.
    checkOfInstant(LDT_IN_GAP, OFFSET_P1, ZONE_VIENNA, LDT_IN_GAP.plusHours(1), OFFSET_P2);
    checkOfInstant(LDT_IN_GAP, OFFSET_P2, ZONE_VIENNA, LDT_IN_GAP.minusHours(1), OFFSET_P1);
    // Both combinations exist and are valid, so they produce exactly the input.
    checkOfInstant(LDT_IN_OVERLAP, OFFSET_P1, ZONE_VIENNA, LDT_IN_OVERLAP, OFFSET_P1);
    checkOfInstant(LDT_IN_OVERLAP, OFFSET_P2, ZONE_VIENNA, LDT_IN_OVERLAP, OFFSET_P2);
}
#end_block

#method_before
private static void checkOfInstant(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone, LocalDate expectedDate, LocalTime expectedTime, ZoneOffset expectedOffset) {
    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(localDateTime, offset, zone);
    String message = String.format(" for ofInstant(%s, %s, %s) = %s, ", localDateTime, offset, zone, zonedDateTime);
    // Note that localDateTime doesn't necessarily equal zoneDateTime.toLocalDateTime(),
    // specifically when offset is not a valid offset for zone at localDateTime (or ever).
    assertEquals("zone" + message, zone, zonedDateTime.getZone());
    assertEquals("offset" + message, expectedOffset, zonedDateTime.getOffset());
    assertEquals("time" + message, expectedTime, zonedDateTime.toLocalTime());
    assertEquals("date" + message, expectedDate, zonedDateTime.toLocalDate());
    if (offset.equals(expectedOffset)) {
        // When we get same offset, the localDateTime must be the same as the input.
        assertEquals("localDateTime" + message, localDateTime, zonedDateTime.toLocalDateTime());
    }
}
#method_after
private static void checkOfInstant(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone, LocalDateTime expectedDateTime, ZoneOffset expectedOffset) {
    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(localDateTime, offset, zone);
    String message = String.format(" for ofInstant(%s, %s, %s) = %s, ", localDateTime, offset, zone, zonedDateTime);
    // Note that localDateTime doesn't necessarily equal zoneDateTime.toLocalDateTime(),
    // specifically when offset is not a valid offset for zone at localDateTime (or ever).
    assertEquals("zone" + message, zone, zonedDateTime.getZone());
    assertEquals("offset" + message, expectedOffset, zonedDateTime.getOffset());
    assertEquals("localDateTime" + message, expectedDateTime, zonedDateTime.toLocalDateTime());
    if (offset.equals(expectedOffset)) {
        // When we get same offset, the localDateTime must be the same as the input. This
        // assert basically just verifies that the test is written correctly.
        assertEquals("expected localDateTime" + message, expectedDateTime, zonedDateTime.toLocalDateTime());
    }
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_ofInstant_offset_null() {
    ZonedDateTime.ofInstant(LDT_SUMMER, null, ZONE_VIENNA);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_ofInstant_offset_null() {
    ZonedDateTime.ofInstant(LDT_P1, null, ZONE_VIENNA);
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_ofInstant_zone_null() {
    ZonedDateTime.ofInstant(LDT_SUMMER, OFFSET_P1, null);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_ofInstant_zone_null() {
    ZonedDateTime.ofInstant(LDT_P1, OFFSET_P1, null);
}
#end_block

#method_before
@Test
public void test_ofLocal() {
    // Correct offset in winter.
    checkOfLocal(LDT_SUMMER, ZONE_VIENNA, OFFSET_P2, LDT_SUMMER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P2);
    // Correct offset in summer.
    checkOfLocal(LDT_WINTER, ZONE_VIENNA, OFFSET_P1, LDT_WINTER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P1);
    // "Wrong" offset in summer.
    checkOfLocal(LDT_SUMMER, ZONE_VIENNA, OFFSET_P1, LDT_SUMMER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P2);
    // "Wrong" offset in winter.
    checkOfLocal(LDT_WINTER, ZONE_VIENNA, OFFSET_P2, LDT_WINTER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P1);
    // Very wrong offset in winter.
    checkOfLocal(LDT_WINTER, ZONE_VIENNA, ZoneOffset.ofHours(-10), LDT_WINTER.toLocalDate(), LocalTime.MIDNIGHT, OFFSET_P1);
    // Neither of those combinations exist, so they are interpreted as either before or after
    // the gap, depending on the offset.
    checkOfLocal(LDT_IN_GAP, ZONE_VIENNA, OFFSET_P1, LDT_IN_GAP.toLocalDate(), LDT_IN_GAP.toLocalTime().plusHours(1), OFFSET_P2);
    checkOfLocal(LDT_IN_GAP, ZONE_VIENNA, OFFSET_P2, LDT_IN_GAP.toLocalDate(), LDT_IN_GAP.toLocalTime().plusHours(1), OFFSET_P2);
    // Both combinations exist and are valid, so they produce exactly the input.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, OFFSET_P1, LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P1);
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, OFFSET_P2, LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P2);
    // Passing in null for preferredOffset will be biased to the offset before the transition.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, null, LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P2);
    // Passing in an invalid offset will be biased to the offset before the transition.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, ZoneOffset.ofHours(10), LDT_IN_OVERLAP.toLocalDate(), LDT_IN_OVERLAP.toLocalTime(), OFFSET_P2);
}
#method_after
@Test
public void test_ofLocal() {
    // checkOfLocal(localDateTime, zone, preferredOffset, expectedDateTime, expectedOffset)
    // Correct offset in summer.
    checkOfLocal(LDT_P1, ZONE_VIENNA, OFFSET_P1, LDT_P1, OFFSET_P1);
    // Correct offset in winter.
    checkOfLocal(LDT_P2, ZONE_VIENNA, OFFSET_P2, LDT_P2, OFFSET_P2);
    // "Wrong" offset in winter.
    checkOfLocal(LDT_P1, ZONE_VIENNA, OFFSET_P2, LDT_P1, OFFSET_P1);
    // "Wrong" offset in summer.
    checkOfLocal(LDT_P2, ZONE_VIENNA, OFFSET_P1, LDT_P2, OFFSET_P2);
    // Very wrong offset in winter.
    checkOfLocal(LDT_P1, ZONE_VIENNA, ZoneOffset.ofHours(-10), LDT_P1, OFFSET_P1);
    // Neither of those combinations exist, so they are interpreted as after the gap.
    checkOfLocal(LDT_IN_GAP, ZONE_VIENNA, OFFSET_P1, LDT_IN_GAP.plusHours(1), OFFSET_P2);
    checkOfLocal(LDT_IN_GAP, ZONE_VIENNA, OFFSET_P2, LDT_IN_GAP.plusHours(1), OFFSET_P2);
    // Both combinations exist and are valid, so they produce exactly the input.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, OFFSET_P1, LDT_IN_OVERLAP, OFFSET_P1);
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, OFFSET_P2, LDT_IN_OVERLAP, OFFSET_P2);
    // Passing in null for preferredOffset will be biased to the offset before the transition.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, /* preferredOffset */
    null, LDT_IN_OVERLAP, OFFSET_P2);
    // Passing in an invalid offset will be biased to the offset before the transition.
    checkOfLocal(LDT_IN_OVERLAP, ZONE_VIENNA, ZoneOffset.ofHours(10), LDT_IN_OVERLAP, OFFSET_P2);
}
#end_block

#method_before
private static void checkOfLocal(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset, LocalDate expectedDate, LocalTime expectedTime, ZoneOffset expectedOffset) {
    ZonedDateTime zonedDateTime = ZonedDateTime.ofLocal(localDateTime, zone, preferredOffset);
    String message = String.format(" for ofLocal(%s, %s, %s) = %s, ", localDateTime, zone, preferredOffset, zonedDateTime);
    // Note that localDateTime doesn't necessarily equal zoneDateTime.toLocalDateTime(),
    // specifically when offset is not a valid offset for zone at localDateTime (or ever).
    assertEquals("zone" + message, zone, zonedDateTime.getZone());
    assertEquals("offset" + message, expectedOffset, zonedDateTime.getOffset());
    assertEquals("time" + message, expectedTime, zonedDateTime.toLocalTime());
    assertEquals("date" + message, expectedDate, zonedDateTime.toLocalDate());
}
#method_after
private static void checkOfLocal(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset, LocalDateTime expectedDateTime, ZoneOffset expectedOffset) {
    ZonedDateTime zonedDateTime = ZonedDateTime.ofLocal(localDateTime, zone, preferredOffset);
    String message = String.format(" for ofLocal(%s, %s, %s) = %s, ", localDateTime, zone, preferredOffset, zonedDateTime);
    // Note that localDateTime doesn't necessarily equal zoneDateTime.toLocalDateTime(),
    // specifically when offset is not a valid offset for zone at localDateTime (or ever).
    assertEquals("zone" + message, zone, zonedDateTime.getZone());
    assertEquals("offset" + message, expectedOffset, zonedDateTime.getOffset());
    assertEquals("localDateTime" + message, expectedDateTime, zonedDateTime.toLocalDateTime());
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_ofLocal_zone_null() {
    ZonedDateTime.ofLocal(LDT_SUMMER, null, OFFSET_P1);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_ofLocal_zone_null() {
    ZonedDateTime.ofLocal(LDT_P1, null, OFFSET_P1);
}
#end_block

#method_before
@Test
public void test_plus() {
    // Most of the logic is in LocalDateTime, to which OffsetDateTime#plus() delegates, verify
    // only some simple cases here. In-depth tests for LocalDateTime#plus() can be found in
    // TCKLocalDateTime.
    assertEquals(OffsetDateTime.of(2000, 1, 2, 4, 4, 5, 6, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.HOURS));
    assertEquals(OffsetDateTime.of(2000, 1, 3, 2, 4, 5, 6, ZoneOffset.UTC), ODT.plus(23, ChronoUnit.HOURS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 5, 5, 6, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.MINUTES));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 5, 5, 6, ZoneOffset.UTC), ODT.plus(60, ChronoUnit.SECONDS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 4, 5, 1_000_006, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.MILLIS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 4, 5, 7, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.NANOS));
}
#method_after
// 2000-01-02T03:04:05.000000006 UTC
@Test
public void test_plus() {
    // Most of the logic is in LocalDateTime, to which OffsetDateTime#plus() delegates, verify
    // only some simple cases here. In-depth tests for LocalDateTime#plus() can be found in
    // TCKLocalDateTime.
    assertEquals(OffsetDateTime.of(2000, 1, 2, 4, 4, 5, 6, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.HOURS));
    assertEquals(OffsetDateTime.of(2000, 1, 3, 2, 4, 5, 6, ZoneOffset.UTC), ODT.plus(23, ChronoUnit.HOURS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 5, 5, 6, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.MINUTES));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 5, 5, 6, ZoneOffset.UTC), ODT.plus(60, ChronoUnit.SECONDS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 4, 5, 1_000_006, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.MILLIS));
    assertEquals(OffsetDateTime.of(2000, 1, 2, 3, 4, 5, 7, ZoneOffset.UTC), ODT.plus(1, ChronoUnit.NANOS));
}
#end_block

#method_before
@Test
public void test_getDecimalStyle() {
    Locale arLocale = Locale.forLanguageTag("ar");
    DateTimeFormatter[] formatters = new DateTimeFormatter[] { DateTimeFormatter.ISO_DATE, DateTimeFormatter.RFC_1123_DATE_TIME, new DateTimeFormatterBuilder().toFormatter(), new DateTimeFormatterBuilder().toFormatter(Locale.ROOT), new DateTimeFormatterBuilder().toFormatter(Locale.ENGLISH), new DateTimeFormatterBuilder().toFormatter(arLocale) };
    DecimalStyle arDecimalStyle = DecimalStyle.of(arLocale);
    // Verify that the Locale ar returns a DecimalStyle other than STANDARD.
    assertNotEquals(DecimalStyle.STANDARD, arDecimalStyle);
    for (DateTimeFormatter formatter : formatters) {
        // All DateTimeFormatters should use the standard style, unless explicitly changed.
        assertEquals(DecimalStyle.STANDARD, formatter.getDecimalStyle());
        DateTimeFormatter arStyleFormatter = formatter.withDecimalStyle(arDecimalStyle);
        assertEquals(arDecimalStyle, arStyleFormatter.getDecimalStyle());
        // Verify that calling withDecimalStyle() doesn't modify the original formatter.
        assertEquals(DecimalStyle.STANDARD, formatter.getDecimalStyle());
    }
}
#method_after
@Test
public void test_getDecimalStyle() {
    Locale arLocale = Locale.forLanguageTag("ar");
    DateTimeFormatter[] formatters = new DateTimeFormatter[] { DateTimeFormatter.ISO_DATE, DateTimeFormatter.RFC_1123_DATE_TIME, new DateTimeFormatterBuilder().toFormatter(), new DateTimeFormatterBuilder().toFormatter(Locale.ROOT), new DateTimeFormatterBuilder().toFormatter(Locale.ENGLISH), new DateTimeFormatterBuilder().toFormatter(arLocale) };
    DecimalStyle arDecimalStyle = DecimalStyle.of(arLocale);
    // Verify that the Locale ar returns a DecimalStyle other than STANDARD.
    assertNotEquals(DecimalStyle.STANDARD, arDecimalStyle);
    for (DateTimeFormatter formatter : formatters) {
        // All DateTimeFormatters should use the standard style, unless explicitly changed.
        assertEquals(formatter.toString(), DecimalStyle.STANDARD, formatter.getDecimalStyle());
        DateTimeFormatter arStyleFormatter = formatter.withDecimalStyle(arDecimalStyle);
        assertEquals(arStyleFormatter.toString(), arDecimalStyle, arStyleFormatter.getDecimalStyle());
        // Verify that calling withDecimalStyle() doesn't modify the original formatter.
        assertEquals(formatter.toString(), DecimalStyle.STANDARD, formatter.getDecimalStyle());
    }
}
#end_block

#method_before
@Test
public void test_isSupported() {
    for (ChronoField field : ChronoField.values()) {
        // Only OFFSET_SECONDS is supported
        assertEquals("isSupported(" + field + ")", field == ChronoField.OFFSET_SECONDS, OFFSET_P1.isSupported(field));
    }
}
#method_after
@Test
public void test_isSupported() {
    for (ChronoField field : ChronoField.values()) {
        // Only OFFSET_SECONDS is supported.
        assertEquals("isSupported(" + field + ")", field == ChronoField.OFFSET_SECONDS, OFFSET_P1.isSupported(field));
    }
}
#end_block

#method_before
@Test
public void test_range_unsupported() {
    for (ChronoField field : ChronoField.values()) {
        if (field == ChronoField.OFFSET_SECONDS) {
            continue;
        }
        try {
            OFFSET_P1.range(field);
            fail("ZoneOffset.range(" + field + ") should have failed.");
        } catch (UnsupportedTemporalTypeException expected) {
        }
    }
}
#method_after
@Test
public void test_range_unsupported() {
    for (ChronoField field : ChronoField.values()) {
        // Only OFFSET_SECONDS is supported.
        if (field == ChronoField.OFFSET_SECONDS) {
            continue;
        }
        try {
            OFFSET_P1.range(field);
            fail("ZoneOffset.range(" + field + ") should have failed.");
        } catch (UnsupportedTemporalTypeException expected) {
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiStatusSuccess = new WifiStatus();
    mWifiStatusSuccess.code = WifiStatusCode.SUCCESS;
    mWifiStatusFailure = new WifiStatus();
    mWifiStatusFailure.code = WifiStatusCode.ERROR_UNKNOWN;
    mWifiStatusFailure.description = "I don't even know what a Mock Turtle is.";
    when(mIWifiStaIface.enableLinkLayerStatsCollection(false)).thenReturn(mWifiStatusSuccess);
    // Setup the HalDeviceManager mock's start/stop behaviour. This can be overridden in
    // individual tests, if needed.
    doAnswer(new AnswerWithArguments() {

        public boolean answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(true);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
            return true;
        }
    }).when(mHalDeviceManager).start();
    doAnswer(new AnswerWithArguments() {

        public void answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(false);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
        }
    }).when(mHalDeviceManager).stop();
    when(mHalDeviceManager.createStaIface(eq(null), eq(null))).thenReturn(mIWifiStaIface);
    when(mHalDeviceManager.createApIface(eq(null), eq(null))).thenReturn(mIWifiApIface);
    when(mHalDeviceManager.getChip(any(IWifiIface.class))).thenReturn(mIWifiChip);
    when(mHalDeviceManager.createRttController(any(IWifiIface.class))).thenReturn(mIWifiRttController);
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenReturn(mWifiStatusSuccess);
    when(mIWifiStaIface.registerEventCallback(any(IWifiStaIfaceEventCallback.class))).thenReturn(mWifiStatusSuccess);
    // Create the vendor HAL object under test.
    mWifiVendorHal = new WifiVendorHal(mHalDeviceManager, mWifiStateMachineHandlerThread);
    // Initialize the vendor HAL to capture the registered callback.
    mWifiVendorHal.initialize();
    ArgumentCaptor<WifiVendorHal.HalDeviceManagerStatusListener> hdmCallbackCaptor = ArgumentCaptor.forClass(WifiVendorHal.HalDeviceManagerStatusListener.class);
    verify(mHalDeviceManager).registerStatusListener(hdmCallbackCaptor.capture(), any(Looper.class));
    mHalDeviceManagerStatusCallbacks = hdmCallbackCaptor.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiStatusSuccess = new WifiStatus();
    mWifiStatusSuccess.code = WifiStatusCode.SUCCESS;
    mWifiStatusFailure = new WifiStatus();
    mWifiStatusFailure.code = WifiStatusCode.ERROR_UNKNOWN;
    mWifiStatusFailure.description = "I don't even know what a Mock Turtle is.";
    when(mIWifiStaIface.enableLinkLayerStatsCollection(false)).thenReturn(mWifiStatusSuccess);
    // Setup the HalDeviceManager mock's start/stop behaviour. This can be overridden in
    // individual tests, if needed.
    doAnswer(new AnswerWithArguments() {

        public boolean answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(true);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
            return true;
        }
    }).when(mHalDeviceManager).start();
    doAnswer(new AnswerWithArguments() {

        public void answer() {
            when(mHalDeviceManager.isReady()).thenReturn(true);
            when(mHalDeviceManager.isStarted()).thenReturn(false);
            mHalDeviceManagerStatusCallbacks.onStatusChanged();
        }
    }).when(mHalDeviceManager).stop();
    when(mHalDeviceManager.createStaIface(eq(null), eq(null))).thenReturn(mIWifiStaIface);
    when(mHalDeviceManager.createApIface(eq(null), eq(null))).thenReturn(mIWifiApIface);
    when(mHalDeviceManager.getChip(any(IWifiIface.class))).thenReturn(mIWifiChip);
    when(mHalDeviceManager.createRttController(any(IWifiIface.class))).thenReturn(mIWifiRttController);
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenReturn(mWifiStatusSuccess);
    mIWifiStaIfaceEventCallback = null;
    when(mIWifiStaIface.registerEventCallback(any(IWifiStaIfaceEventCallback.class))).thenAnswer(answerWifiStatus((invocation) -> {
        Object[] args = invocation.getArguments();
        mIWifiStaIfaceEventCallback = (IWifiStaIfaceEventCallback) args[0];
        return (mWifiStatusSuccess);
    }));
    mIWifiChipEventCallback = null;
    when(mIWifiChip.registerEventCallback(any(IWifiChipEventCallback.class))).thenAnswer(answerWifiStatus((invocation) -> {
        Object[] args = invocation.getArguments();
        mIWifiChipEventCallback = (IWifiChipEventCallback) args[0];
        return (mWifiStatusSuccess);
    }));
    // Create the vendor HAL object under test.
    mWifiVendorHal = new WifiVendorHal(mHalDeviceManager, mWifiStateMachineHandlerThread);
    // Initialize the vendor HAL to capture the registered callback.
    mWifiVendorHal.initialize();
    ArgumentCaptor<WifiVendorHal.HalDeviceManagerStatusListener> hdmCallbackCaptor = ArgumentCaptor.forClass(WifiVendorHal.HalDeviceManagerStatusListener.class);
    verify(mHalDeviceManager).registerStatusListener(hdmCallbackCaptor.capture(), any(Looper.class));
    mHalDeviceManagerStatusCallbacks = hdmCallbackCaptor.getValue();
}
#end_block

#method_before
@Test
public void testSetScanningMacOui() throws Exception {
    byte[] oui = NativeUtil.macAddressOuiToByteArray("DA:A1:19");
    byte[] zzz = NativeUtil.macAddressOuiToByteArray("00:00:00");
    when(mIWifiStaIface.setScanningMacOui(any())).thenReturn(mWifiStatusSuccess);
    // expect fail - STA not started
    assertFalse(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // expect fail - null
    assertFalse(mWifiVendorHal.setScanningMacOui(null));
    // expect fail - len
    assertFalse(mWifiVendorHal.setScanningMacOui(new byte[] { (byte) 1 }));
    assertTrue(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.setScanningMacOui(zzz));
    verify(mIWifiStaIface).setScanningMacOui(eq(oui));
    verify(mIWifiStaIface).setScanningMacOui(eq(zzz));
}
#method_after
// TODO(b/34901744) negative RTT test cases as well.
// e.g. invoke RTT without putting the HAL in the correct mode.
@Test
public void testSetScanningMacOui() throws Exception {
    byte[] oui = NativeUtil.macAddressOuiToByteArray("DA:A1:19");
    byte[] zzz = NativeUtil.macAddressOuiToByteArray("00:00:00");
    when(mIWifiStaIface.setScanningMacOui(any())).thenReturn(mWifiStatusSuccess);
    // expect fail - STA not started
    assertFalse(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.startVendorHalSta());
    // expect fail - null
    assertFalse(mWifiVendorHal.setScanningMacOui(null));
    // expect fail - len
    assertFalse(mWifiVendorHal.setScanningMacOui(new byte[] { (byte) 1 }));
    assertTrue(mWifiVendorHal.setScanningMacOui(oui));
    assertTrue(mWifiVendorHal.setScanningMacOui(zzz));
    verify(mIWifiStaIface).setScanningMacOui(eq(oui));
    verify(mIWifiStaIface).setScanningMacOui(eq(zzz));
}
#end_block

#method_before
@Test
public void testBgScanFailureCallback() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#method_after
@Test
public void testBgScanFailureCallback() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#end_block

#method_before
@Test
public void testBgScanFailureCallbackWithInvalidCmdId() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId + 1);
    verify(eventHandler, never()).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#method_after
@Test
public void testBgScanFailureCallbackWithInvalidCmdId() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    mIWifiStaIfaceEventCallback.onBackgroundScanFailure(mWifiVendorHal.mScan.cmdId + 1);
    verify(eventHandler, never()).onScanStatus(WifiNative.WIFI_SCAN_FAILED);
}
#end_block

#method_before
@Test
public void testBgScanFullScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    mIWifiStaIfaceEventCallback.onBackgroundFullScanResult(mWifiVendorHal.mScan.cmdId, (short) 5, result.first);
    ArgumentCaptor<ScanResult> scanResultCaptor = ArgumentCaptor.forClass(ScanResult.class);
    verify(eventHandler).onFullScanResult(scanResultCaptor.capture(), eq(5));
    assertScanResultEqual(result.second, scanResultCaptor.getValue());
}
#method_after
@Test
public void testBgScanFullScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    mIWifiStaIfaceEventCallback.onBackgroundFullScanResult(mWifiVendorHal.mScan.cmdId, result.first);
    ArgumentCaptor<ScanResult> scanResultCaptor = ArgumentCaptor.forClass(ScanResult.class);
    verify(eventHandler).onFullScanResult(scanResultCaptor.capture(), eq(0));
    assertScanResultEqual(result.second, scanResultCaptor.getValue());
}
#end_block

#method_before
@Test
public void testBgScanScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    captureStaIfaceEventCallback();
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> data = createHidlAndFrameworkBgScanDatas();
    mIWifiStaIfaceEventCallback.onBackgroundScanResults(mWifiVendorHal.mScan.cmdId, data.first);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
    assertScanDatasEqual(data.second, Arrays.asList(mWifiVendorHal.mScan.latestScanResults));
}
#method_after
@Test
public void testBgScanScanResults() throws Exception {
    assertTrue(mWifiVendorHal.startVendorHalSta());
    assertNotNull(mIWifiStaIfaceEventCallback);
    WifiNative.ScanEventHandler eventHandler = mock(WifiNative.ScanEventHandler.class);
    startBgScan(eventHandler);
    Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> data = createHidlAndFrameworkBgScanDatas();
    mIWifiStaIfaceEventCallback.onBackgroundScanResults(mWifiVendorHal.mScan.cmdId, data.first);
    verify(eventHandler).onScanStatus(WifiNative.WIFI_SCAN_RESULTS_AVAILABLE);
    assertScanDatasEqual(data.second, Arrays.asList(mWifiVendorHal.mScan.latestScanResults));
}
#end_block

#method_before
// Create a pair of HIDL scan result and it's corresponding framework scan result for
private Pair<StaScanResult, ScanResult> createHidlAndFrameworkBgScanResult() {
    StaScanResult staScanResult = new StaScanResult();
    Random random = new Random();
    byte[] ssid = new byte[8];
    random.nextBytes(ssid);
    staScanResult.ssid.addAll(NativeUtil.byteArrayToArrayList(ssid));
    random.nextBytes(staScanResult.bssid);
    staScanResult.frequency = 2432;
    staScanResult.rssi = -45;
    staScanResult.timeStampInUs = 5;
    WifiInformationElement ie1 = new WifiInformationElement();
    byte[] ie1_data = new byte[56];
    random.nextBytes(ie1_data);
    ie1.id = 1;
    ie1.data.addAll(NativeUtil.byteArrayToArrayList(ie1_data));
    staScanResult.informationElements.add(ie1);
    // Now create the corresponding Scan result structure.
    ScanResult scanResult = new ScanResult();
    scanResult.SSID = NativeUtil.encodeSsid(staScanResult.ssid);
    scanResult.BSSID = NativeUtil.macAddressFromByteArray(staScanResult.bssid);
    scanResult.wifiSsid = WifiSsid.createFromByteArray(ssid);
    scanResult.frequency = staScanResult.frequency;
    scanResult.level = staScanResult.rssi;
    scanResult.timestamp = staScanResult.timeStampInUs;
    scanResult.bytes = new byte[57];
    scanResult.bytes[0] = ie1.id;
    System.arraycopy(ie1_data, 0, scanResult.bytes, 1, ie1_data.length);
    return Pair.create(staScanResult, scanResult);
}
#method_after
// Create a pair of HIDL scan result and its corresponding framework scan result for
private Pair<StaScanResult, ScanResult> createHidlAndFrameworkBgScanResult() {
    StaScanResult staScanResult = new StaScanResult();
    Random random = new Random();
    byte[] ssid = new byte[8];
    random.nextBytes(ssid);
    staScanResult.ssid.addAll(NativeUtil.byteArrayToArrayList(ssid));
    random.nextBytes(staScanResult.bssid);
    staScanResult.frequency = 2432;
    staScanResult.rssi = -45;
    staScanResult.timeStampInUs = 5;
    WifiInformationElement ie1 = new WifiInformationElement();
    byte[] ie1_data = new byte[56];
    random.nextBytes(ie1_data);
    ie1.id = 1;
    ie1.data.addAll(NativeUtil.byteArrayToArrayList(ie1_data));
    staScanResult.informationElements.add(ie1);
    // Now create the corresponding Scan result structure.
    ScanResult scanResult = new ScanResult();
    scanResult.SSID = NativeUtil.encodeSsid(staScanResult.ssid);
    scanResult.BSSID = NativeUtil.macAddressFromByteArray(staScanResult.bssid);
    scanResult.wifiSsid = WifiSsid.createFromByteArray(ssid);
    scanResult.frequency = staScanResult.frequency;
    scanResult.level = staScanResult.rssi;
    scanResult.timestamp = staScanResult.timeStampInUs;
    scanResult.bytes = new byte[57];
    scanResult.bytes[0] = ie1.id;
    System.arraycopy(ie1_data, 0, scanResult.bytes, 1, ie1_data.length);
    return Pair.create(staScanResult, scanResult);
}
#end_block

#method_before
// Create a pair of HIDL scan datas and it's corresponding framework scan datas for
private Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> createHidlAndFrameworkBgScanDatas() {
    ArrayList<StaScanData> staScanDatas = new ArrayList<>();
    StaScanData staScanData = new StaScanData();
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    staScanData.results.add(result.first);
    staScanData.bucketsScanned = 5;
    staScanData.flags = StaScanDataFlagMask.INTERRUPTED;
    staScanDatas.add(staScanData);
    ArrayList<WifiScanner.ScanData> scanDatas = new ArrayList<>();
    ScanResult[] scanResults = new ScanResult[1];
    scanResults[0] = result.second;
    WifiScanner.ScanData scanData = new WifiScanner.ScanData(mWifiVendorHal.mScan.cmdId, 1, staScanData.bucketsScanned, false, scanResults);
    scanDatas.add(scanData);
    return Pair.create(staScanDatas, scanDatas);
}
#method_after
// Create a pair of HIDL scan datas and its corresponding framework scan datas for
private Pair<ArrayList<StaScanData>, ArrayList<WifiScanner.ScanData>> createHidlAndFrameworkBgScanDatas() {
    ArrayList<StaScanData> staScanDatas = new ArrayList<>();
    StaScanData staScanData = new StaScanData();
    Pair<StaScanResult, ScanResult> result = createHidlAndFrameworkBgScanResult();
    staScanData.results.add(result.first);
    staScanData.bucketsScanned = 5;
    staScanData.flags = StaScanDataFlagMask.INTERRUPTED;
    staScanDatas.add(staScanData);
    ArrayList<WifiScanner.ScanData> scanDatas = new ArrayList<>();
    ScanResult[] scanResults = new ScanResult[1];
    scanResults[0] = result.second;
    WifiScanner.ScanData scanData = new WifiScanner.ScanData(mWifiVendorHal.mScan.cmdId, 1, staScanData.bucketsScanned, false, scanResults);
    scanDatas.add(scanData);
    return Pair.create(staScanDatas, scanDatas);
}
#end_block

#method_before
public RttManager.RttCapabilities getRttCapabilities() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
/* RTT related commands/events */
public RttManager.RttCapabilities getRttCapabilities() {
    kilroy();
    class AnswerBox {

        public RttManager.RttCapabilities value = null;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            mIWifiRttController.getCapabilities((status, capabilities) -> {
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                RttManager.RttCapabilities ans = new RttManager.RttCapabilities();
                ans.oneSidedRttSupported = capabilities.rttOneSidedSupported;
                ans.twoSided11McRttSupported = capabilities.rttFtmSupported;
                ans.lciSupported = capabilities.lciSupported;
                ans.lcrSupported = capabilities.lcrSupported;
                ans.preambleSupported = frameworkPreambleFromHalPreamble(capabilities.preambleSupport);
                ans.bwSupported = frameworkBwFromHalBw(capabilities.bwSupport);
                ans.responderSupported = capabilities.responderSupported;
                ans.secureRttSupported = false;
                ans.mcVersion = ((int) capabilities.mcVersion) & 0xff;
                kilroy();
                box.value = ans;
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
/* RTT related commands/events */
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    kilroy();
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttCmdId != 0)
            return false;
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (status.code == WifiStatusCode.SUCCESS) {
                kilroy();
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (status.code == WifiStatusCode.SUCCESS) {
                kilroy();
                return true;
            }
            noteHidlError(status, "requestRtt");
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean cancelRtt(RttManager.RttParams[] params) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean cancelRtt(RttManager.RttParams[] params) {
    kilroy();
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttCmdId == 0)
            return false;
        ArrayList<byte[]> /* 6 */
        addrs = new ArrayList<byte[]>(rttConfigs.size());
        for (RttConfig x : rttConfigs) addrs.add(x.addr);
        try {
            WifiStatus status = mIWifiRttController.rangeCancel(mRttCmdId, addrs);
            mRttCmdId = 0;
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
@Nullable
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public ResponderConfig enableRttResponder(int timeoutSeconds) {
    kilroy();
    RttResponder info = getRttResponder();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return null;
        if (mRttResponderCmdId != 0) {
            Log.e(TAG, "responder mode already enabled - this shouldn't happen");
            return null;
        }
        ResponderConfig config = null;
        int id = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            WifiStatus status = mIWifiRttController.enableResponder(/* cmdId */
            id, /* WifiChannelInfo channelHint */
            null, timeoutSeconds, info);
            if (status.code == WifiStatusCode.SUCCESS) {
                mRttResponderCmdId = id;
                config = frameworkResponderConfigFromHalRttResponder(info);
                Log.d(TAG, "enabling rtt " + mRttResponderCmdId);
            } else {
                noteHidlError(status, "enableRttResponder");
            }
            return config;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public boolean disableRttResponder() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean disableRttResponder() {
    kilroy();
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return false;
        if (mRttResponderCmdId == 0)
            return false;
        try {
            WifiStatus status = mIWifiRttController.disableResponder(mRttResponderCmdId);
            mRttResponderCmdId = 0;
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public int[] getChannelsForBand(int band) {
    kilroy();
    class AnswerBox {

        public int[] value = null;
    }
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return null;
        try {
            AnswerBox box = new AnswerBox();
            int hb = makeWifiBandFromFrameworkBand(band);
            mIWifiStaIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                    kilroy();
                    mChannelsForBandSupport = false;
                }
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                mChannelsForBandSupport = true;
                kilroy();
                box.value = intArrayFromArrayList(frequencies);
            });
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#method_after
public int[] getChannelsForBand(int band) {
    kilroy();
    class AnswerBox {

        public int[] value = null;
    }
    synchronized (sLock) {
        try {
            AnswerBox box = new AnswerBox();
            int hb = makeWifiBandFromFrameworkBand(band);
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                    if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                        kilroy();
                        mChannelsForBandSupport = false;
                    }
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    mChannelsForBandSupport = true;
                    kilroy();
                    box.value = intArrayFromArrayList(frequencies);
                });
            } else if (mIWifiApIface != null) {
                mIWifiApIface.getValidFrequenciesForBand(hb, (status, frequencies) -> {
                    if (status.code == WifiStatusCode.ERROR_NOT_SUPPORTED) {
                        kilroy();
                        mChannelsForBandSupport = false;
                    }
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    mChannelsForBandSupport = true;
                    kilroy();
                    box.value = intArrayFromArrayList(frequencies);
                });
            }
            return box.value;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    if (maxRssi <= minRssi)
        return -1;
    if (rssiEventHandler == null)
        return -1;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status;
            status = mIWifiStaIface.startRssiMonitoring(sRssiMonCmdId, maxRssi, minRssi);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            mWifiRssiEventHandler = rssiEventHandler;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#end_block

#method_before
public int stopRssiMonitoring() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public int stopRssiMonitoring() {
    kilroy();
    synchronized (sLock) {
        mWifiRssiEventHandler = null;
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status = mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#end_block

#method_before
@Override
public void onBackgroundFullScanResult(int cmdId, short bucketsScanned, StaScanResult result) {
    kilroy();
    Log.d(TAG, "onBackgroundFullScanResult " + cmdId);
    synchronized (sLock) {
        if (mScan != null && cmdId == mScan.cmdId) {
            mScan.eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), bucketsScanned);
        }
    }
}
#method_after
@Override
public void onBackgroundFullScanResult(int cmdId, StaScanResult result) {
    kilroy();
    Log.d(TAG, "onBackgroundFullScanResult " + cmdId);
    synchronized (sLock) {
        if (mScan != null && cmdId == mScan.cmdId) {
            mScan.eventHandler.onFullScanResult(hidlToFrameworkScanResult(result), 0);
        }
    }
}
#end_block

#method_before
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    kilroy();
    Log.d(TAG, "onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
}
#method_after
@Override
public void onRssiThresholdBreached(int cmdId, byte[] currBssid, int currRssi) {
    Log.d(TAG, "onRssiThresholdBreached " + cmdId + "currRssi " + currRssi);
    WifiNative.WifiRssiEventHandler handler;
    synchronized (sLock) {
        handler = mWifiRssiEventHandler;
        if (mWifiRssiEventHandler == null)
            return;
        if (cmdId != sRssiMonCmdId)
            return;
        kilroy();
    }
    handler.onRssiThresholdBreached((byte) currRssi);
}
#end_block

#method_before
public void testInputStreamAsynchronousByteChannel() throws Exception {
    AsynchronousByteChannel abc = mock(AsynchronousByteChannel.class);
    InputStream is = Channels.newInputStream(abc);
    Future<Integer> result = mock(Future.class);
    ArgumentCaptor<ByteBuffer> bbCaptor = ArgumentCaptor.forClass(ByteBuffer.class);
    final byte[] data = new byte[10];
    final int readCount = 5;
    when(abc.read(bbCaptor.capture())).thenReturn(result);
    when(result.get()).thenAnswer(new Answer<Integer>() {

        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer bb = bbCaptor.getValue();
            assertEquals(data.length, bb.remaining());
            // Write 'readCount' bytes
            for (int i = 0; i < readCount; ++i) {
                bb.put((byte) 1);
            }
            return readCount;
        }
    });
    assertEquals(readCount, is.read(data));
    // Expect to find 'readCount' bytes of value 1
    for (int i = 0; i < data.length; ++i) {
        assertEquals((i < readCount) ? (byte) 1 : (byte) 0, data[i]);
    }
}
#method_after
public void testInputStreamAsynchronousByteChannel() throws Exception {
    AsynchronousByteChannel abc = mock(AsynchronousByteChannel.class);
    InputStream is = Channels.newInputStream(abc);
    Future<Integer> result = mock(Future.class);
    ArgumentCaptor<ByteBuffer> bbCaptor = ArgumentCaptor.forClass(ByteBuffer.class);
    final byte[] bytesRead = new byte[10];
    when(abc.read(bbCaptor.capture())).thenReturn(result);
    when(result.get()).thenAnswer(new Answer<Integer>() {

        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer bb = bbCaptor.getValue();
            assertEquals(bytesRead.length, bb.remaining());
            // Write '7' bytes
            bb.put(new byte[] { 0, 1, 2, 3, 4, 5, 6 });
            return 7;
        }
    });
    assertEquals(7, is.read(bytesRead));
    // Only 7 bytes of data should be written into the buffer
    byte[] bytesExpected = new byte[] { 0, 1, 2, 3, 4, 5, 6, 0, 0, 0 };
    assertTrue(Arrays.equals(bytesExpected, bytesRead));
    Mockito.verify(abc).read(isA(ByteBuffer.class));
    Mockito.verify(result).get();
}
#end_block

#method_before
public void testOutputStreamAsynchronousByteChannel() throws Exception {
    AsynchronousByteChannel abc = mock(AsynchronousByteChannel.class);
    OutputStream os = Channels.newOutputStream(abc);
    Future<Integer> result = mock(Future.class);
    ArgumentCaptor<ByteBuffer> bbCaptor = ArgumentCaptor.forClass(ByteBuffer.class);
    final byte[] data = new byte[] { 'a', 'a', 'a' };
    when(abc.write(bbCaptor.capture())).thenReturn(result);
    when(result.get()).thenAnswer(new Answer<Integer>() {

        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer bb = bbCaptor.getValue();
            assertEquals(data.length, bb.remaining());
            byte[] readData = new byte[data.length];
            // Read the whole thing
            bb.get(readData, 0, data.length);
            for (int i = 0; i < readData.length; ++i) {
                assertEquals(data[i], readData[i]);
            }
            return data.length;
        }
    });
    os.write(data);
}
#method_after
public void testOutputStreamAsynchronousByteChannel() throws Exception {
    AsynchronousByteChannel abc = mock(AsynchronousByteChannel.class);
    OutputStream os = Channels.newOutputStream(abc);
    Future<Integer> result = mock(Future.class);
    ArgumentCaptor<ByteBuffer> bbCaptor = ArgumentCaptor.forClass(ByteBuffer.class);
    final byte[] data = "world".getBytes();
    when(abc.write(bbCaptor.capture())).thenReturn(result);
    when(result.get()).thenAnswer(new Answer<Integer>() {

        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer bb = bbCaptor.getValue();
            assertEquals(data.length, bb.remaining());
            byte[] readData = new byte[data.length];
            // Read the whole thing
            bb.get(readData);
            assertTrue(Arrays.equals(data, readData));
            return data.length;
        }
    });
    os.write(data);
    Mockito.verify(abc).write(isA(ByteBuffer.class));
    Mockito.verify(result).get();
}
#end_block

#method_before
@Override
public void onNetworkEapSimUmtsAuthRequest(ISupplicantStaNetworkCallback.NetworkRequestEapSimUmtsAuthParams params) {
    logCallback("onNetworkEapSimUmtsAuthRequest");
    synchronized (mLock) {
        String autnHex = NativeUtil.hexStringFromByteArray(params.autn);
        String randHex = NativeUtil.hexStringFromByteArray(params.rand);
        String[] data = { randHex, randHex };
        mWifiMonitor.broadcastNetworkUmtsAuthRequestEvent(mIfaceName, mFramewokNetworkId, mSsid, data);
    }
}
#method_after
@Override
public void onNetworkEapSimUmtsAuthRequest(ISupplicantStaNetworkCallback.NetworkRequestEapSimUmtsAuthParams params) {
    logCallback("onNetworkEapSimUmtsAuthRequest");
    synchronized (mLock) {
        String randHex = NativeUtil.hexStringFromByteArray(params.rand);
        String autnHex = NativeUtil.hexStringFromByteArray(params.autn);
        String[] data = { randHex, autnHex };
        mWifiMonitor.broadcastNetworkUmtsAuthRequestEvent(mIfaceName, mFramewokNetworkId, mSsid, data);
    }
}
#end_block

#method_before
public String[][] validNumericAddressesAndStringRepresentation() {
    return new String[][] { // Regular IPv4.
    { "1.2.3.4", "/1.2.3.4" }, // Regular IPv6.
    { "2001:4860:800d::68", "/2001:4860:800d::68" }, // Mapped IPv4
    { "::ffff:127.0.0.1", "/127.0.0.1" }, // Optional square brackets around IPv6 addresses, including mapped IPv4.
    { "[2001:4860:800d::68]", "/2001:4860:800d::68" }, { "[::ffff:127.0.0.1]", "/127.0.0.1" }, // Android does not recognize Octal (leading 0) cases: they are treated as decimal.
    { "0177.00.00.01", "/177.0.0.1" } };
}
#method_after
public static String[][] validNumericAddressesAndStringRepresentation() {
    return new String[][] { // Regular IPv4.
    { "1.2.3.4", "/1.2.3.4" }, // Regular IPv6.
    { "2001:4860:800d::68", "/2001:4860:800d::68" }, // Mapped IPv4
    { "::ffff:127.0.0.1", "/127.0.0.1" }, // Optional square brackets around IPv6 addresses, including mapped IPv4.
    { "[2001:4860:800d::68]", "/2001:4860:800d::68" }, { "[::ffff:127.0.0.1]", "/127.0.0.1" }, // Android does not recognize Octal (leading 0) cases: they are treated as decimal.
    { "0177.00.00.01", "/177.0.0.1" } };
}
#end_block

#method_before
public String[] validNumericAddresses() {
    return new String[] { // IPv4
    "1.2.3.4", "127.0.0.1", // IPv6
    "::1", "2001:4860:800d::68", // Mapped IPv4
    "::ffff:127.0.0.1", // Optional square brackets around IPv6 addresses, including mapped IPv4.
    "[2001:4860:800d::68]", "[::ffff:127.0.0.1]", // Android does not handle Octal (leading 0) cases: they are treated as decimal.
    "0177.00.00.01" };
}
#method_after
public static String[] validNumericAddresses() {
    return new String[] { // IPv4
    "1.2.3.4", "127.0.0.1", // IPv6
    "::1", "2001:4860:800d::68", // Mapped IPv4
    "::ffff:127.0.0.1", // Optional square brackets around IPv6 addresses, including mapped IPv4.
    "[2001:4860:800d::68]", "[::ffff:127.0.0.1]", // Android does not handle Octal (leading 0) cases: they are treated as decimal.
    "0177.00.00.01" };
}
#end_block

#method_before
public String[] invalidNumericAddresses() {
    return INVALID_IPv4_AND_6_NUMERIC_ADDRESSES;
}
#method_after
public static String[] invalidNumericAddresses() {
    return INVALID_IPv4_AND_6_NUMERIC_ADDRESSES;
}
#end_block

#method_before
public String[] validIPv6Addresses() {
    return VALID_IPv6_ADDRESSES;
}
#method_after
public static String[] validIPv6Addresses() {
    return VALID_IPv6_ADDRESSES;
}
#end_block

#method_before
public String[][] validAddressesAndStringRepresentation() {
    return new String[][] { { "::1.2.3.4", "/::1.2.3.4" }, { "::", "/::" }, { "1::0", "/1::" }, { "1::", "/1::" }, { "::1", "/::1" }, { "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF", "/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff" }, { "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:255.255.255.255", "/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff" }, { "0:0:0:0:0:0:0:0", "/::" }, { "0:0:0:0:0:0:0.0.0.0", "/::" } };
}
#method_after
public static String[][] validAddressesAndStringRepresentation() {
    return new String[][] { { "::1.2.3.4", "/::1.2.3.4" }, { "::", "/::" }, { "1::0", "/1::" }, { "1::", "/1::" }, { "::1", "/::1" }, { "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF", "/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff" }, { "FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:255.255.255.255", "/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff" }, { "0:0:0:0:0:0:0:0", "/::" }, { "0:0:0:0:0:0:0.0.0.0", "/::" } };
}
#end_block

#method_before
// Package-private to be used by j.l.System. We do the implementation here
// to avoid Object.hashCode doing a clinit check on j.l.System, and also
// to avoid leaking shadow$_monitor_ outside of this class.
static int identityHashCode(Object obj) {
    int lockWord = obj.shadow$_monitor_;
    // Top 2 bits.
    final int lockWordStateMask = 0xC0000000;
    // Top 2 bits are value 2 (kStateHash).
    final int lockWordStateHash = 0x80000000;
    // Low 28 bits.
    final int lockWordHashMask = 0x0FFFFFFF;
    if ((lockWord & lockWordStateMask) == lockWordStateHash) {
        return lockWord & lockWordHashMask;
    }
    return identityHashCodeNative(obj);
}
#method_after
// Android-changed: add a local helper for identityHashCode.
// Package-private to be used by j.l.System. We do the implementation here
// to avoid Object.hashCode doing a clinit check on j.l.System, and also
// to avoid leaking shadow$_monitor_ outside of this class.
static int identityHashCode(Object obj) {
    int lockWord = obj.shadow$_monitor_;
    // Top 2 bits.
    final int lockWordStateMask = 0xC0000000;
    // Top 2 bits are value 2 (kStateHash).
    final int lockWordStateHash = 0x80000000;
    // Low 28 bits.
    final int lockWordHashMask = 0x0FFFFFFF;
    if ((lockWord & lockWordStateMask) == lockWordStateHash) {
        return lockWord & lockWordHashMask;
    }
    return identityHashCodeNative(obj);
}
#end_block

#method_before
LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create) {
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new SimpleArrayMap<String, LoaderManager>();
    }
    LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
    if (lm == null) {
        if (create) {
            lm = new LoaderManagerImpl(who, this, started);
            mAllLoaderManagers.put(who, lm);
        }
    } else {
        lm.updateHostController(this);
    }
    return lm;
}
#method_after
LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create) {
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new SimpleArrayMap<String, LoaderManager>();
    }
    LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
    if (lm == null && create) {
        lm = new LoaderManagerImpl(who, this, started);
        mAllLoaderManagers.put(who, lm);
    }
    return lm;
}
#end_block

#method_before
protected void handleBroadcastSms(SmsCbMessage message) {
    String receiverPermission;
    int appOp;
    Intent intent;
    if (message.isEmergencyMessage()) {
        log("Dispatching emergency SMS CB, SmsCbMessage is: " + message);
        intent = new Intent(Telephony.Sms.Intents.SMS_EMERGENCY_CB_RECEIVED_ACTION);
        receiverPermission = Manifest.permission.RECEIVE_EMERGENCY_BROADCAST;
        appOp = AppOpsManager.OP_RECEIVE_EMERGECY_SMS;
    } else {
        log("Dispatching SMS CB, SmsCbMessage is: " + message);
        intent = new Intent(Telephony.Sms.Intents.SMS_CB_RECEIVED_ACTION);
        receiverPermission = Manifest.permission.RECEIVE_SMS;
        appOp = AppOpsManager.OP_RECEIVE_SMS;
    }
    // explicitly send it to the default cell broadcast receiver only.
    intent.setComponent(getDefaultCellBroadcastReceiverApp(mContext));
    intent.putExtra("message", message);
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, receiverPermission, appOp, mReceiver, getHandler(), Activity.RESULT_OK, null, null);
    String additionalPackage = Settings.Secure.getString(mContext.getContentResolver(), CMAS_ADDITIONAL_BROADCAST_PKG);
    if (additionalPackage != null) {
        intent.setComponent(additionalPackage);
        mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, receiverPermission, appOp, mReceiver, getHandler(), Activity.RESULT_OK, null, null);
    }
}
#method_after
protected void handleBroadcastSms(SmsCbMessage message) {
    String receiverPermission;
    int appOp;
    Intent intent;
    if (message.isEmergencyMessage()) {
        log("Dispatching emergency SMS CB, SmsCbMessage is: " + message);
        intent = new Intent(Telephony.Sms.Intents.SMS_EMERGENCY_CB_RECEIVED_ACTION);
        receiverPermission = Manifest.permission.RECEIVE_EMERGENCY_BROADCAST;
        appOp = AppOpsManager.OP_RECEIVE_EMERGECY_SMS;
    } else {
        log("Dispatching SMS CB, SmsCbMessage is: " + message);
        intent = new Intent(Telephony.Sms.Intents.SMS_CB_RECEIVED_ACTION);
        receiverPermission = Manifest.permission.RECEIVE_SMS;
        appOp = AppOpsManager.OP_RECEIVE_SMS;
    }
    // explicitly send it to the default cell broadcast receiver only.
    intent.setPackage(mContext.getResources().getString(com.android.internal.R.string.config_defaultCellBroadcastReceiverPkg));
    intent.putExtra("message", message);
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, receiverPermission, appOp, mReceiver, getHandler(), Activity.RESULT_OK, null, null);
    if (Build.IS_DEBUGGABLE) {
        String additionalPackage = Settings.Secure.getString(mContext.getContentResolver(), CMAS_ADDITIONAL_BROADCAST_PKG);
        if (additionalPackage != null) {
            intent.setPackage(additionalPackage);
            mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, receiverPermission, appOp, mReceiver, getHandler(), Activity.RESULT_OK, null, null);
        }
    }
}
#end_block

#method_before
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    if (maxRssi <= minRssi)
        return -1;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status;
            status = mIWifiStaIface.startRssiMonitoring(sRssiMonCmdId, maxRssi, minRssi);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            mWifiRssiEventHandler = rssiEventHandler;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#method_after
public int startRssiMonitoring(byte maxRssi, byte minRssi, WifiNative.WifiRssiEventHandler rssiEventHandler) {
    kilroy();
    if (maxRssi <= minRssi)
        return -1;
    if (rssiEventHandler == null)
        return -1;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return -1;
        try {
            mIWifiStaIface.stopRssiMonitoring(sRssiMonCmdId);
            WifiStatus status;
            status = mIWifiStaIface.startRssiMonitoring(sRssiMonCmdId, maxRssi, minRssi);
            if (status.code != WifiStatusCode.SUCCESS)
                return -1;
            mWifiRssiEventHandler = rssiEventHandler;
            kilroy();
            return 0;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return -1;
        }
    }
}
#end_block

#method_before
private void populateMaskedFieldFromWpaSupplicantFile(String fieldName, Map<String, WifiConfiguration> configurationMap, MaskedWpaSupplicantFieldSetter setter) {
    Map<String, String> configKeyToValueMap = mWifiSupplicantControl.readNetworkVariablesFromSupplicantFile(fieldName);
    if (configKeyToValueMap == null || configKeyToValueMap.isEmpty()) {
        Log.w(TAG, "Cannot retrieve field: " + fieldName + " values");
        return;
    }
    for (Map.Entry<String, WifiConfiguration> entry : configurationMap.entrySet()) {
        if (configKeyToValueMap.containsKey(entry.getKey())) {
            WifiConfiguration config = entry.getValue();
            setter.setValue(config, configKeyToValueMap.get(entry.getKey()));
        }
    }
}
#method_after
private void populateMaskedFieldFromWpaSupplicantFile(String fieldName, Map<String, WifiConfiguration> configurationMap, MaskedWpaSupplicantFieldSetter setter) {
    Map<String, String> configKeyToValueMap = mWifiNative.readNetworkVariablesFromSupplicantFile(fieldName);
    if (configKeyToValueMap == null || configKeyToValueMap.isEmpty()) {
        Log.w(TAG, "Cannot retrieve field: " + fieldName + " values");
        return;
    }
    for (Map.Entry<String, WifiConfiguration> entry : configurationMap.entrySet()) {
        if (configKeyToValueMap.containsKey(entry.getKey())) {
            WifiConfiguration config = entry.getValue();
            setter.setValue(config, configKeyToValueMap.get(entry.getKey()));
        }
    }
}
#end_block

#method_before
private void loadFromWpaSupplicant(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    mWifiSupplicantControl.loadNetworks(configurationMap, networkExtras);
    if (configurationMap.isEmpty()) {
        Log.w(TAG, "No wifi configurations found in wpa_supplicant");
        return;
    }
    // Now parse wpa_supplicant.conf for the masked fields.
    populateMaskedFieldsFromWpaSupplicantFile(configurationMap);
}
#method_after
private void loadFromWpaSupplicant(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    if (!mWifiNative.migrateNetworksFromSupplicant(configurationMap, networkExtras)) {
        Log.wtf(TAG, "Failed to load wifi configurations from wpa_supplicant");
        return;
    }
    if (configurationMap.isEmpty()) {
        Log.w(TAG, "No wifi configurations found in wpa_supplicant");
        return;
    }
    if (!WifiNative.HIDL_SUP_ENABLE) {
        // Now parse wpa_supplicant.conf for the masked fields.
        populateMaskedFieldsFromWpaSupplicantFile(configurationMap);
    }
}
#end_block

#method_before
private void loadFromPasspointConfigStore(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    Map<String, LegacyPasspointConfig> passpointConfigMap = null;
    try {
        passpointConfigMap = mPasspointConfigParser.parseConfig(PPS_FILE.getAbsolutePath());
    } catch (IOException e) {
        Log.w(TAG, "Failed to read/parse Passpoint config file: " + e.getMessage());
    }
    List<String> entriesToBeRemoved = new ArrayList<>();
    for (Map.Entry<String, WifiConfiguration> entry : configurationMap.entrySet()) {
        WifiConfiguration wifiConfig = entry.getValue();
        // Passpoint.
        if (wifiConfig.enterpriseConfig == null) {
            continue;
        }
        // Ignore configuration without FQDN.
        Map<String, String> extras = networkExtras.get(wifiConfig.networkId);
        if (extras == null || !extras.containsKey(WifiSupplicantControl.ID_STRING_KEY_FQDN)) {
            continue;
        }
        String fqdn = networkExtras.get(wifiConfig.networkId).get(WifiSupplicantControl.ID_STRING_KEY_FQDN);
        // Passpoint configuration file.
        if (passpointConfigMap == null || !passpointConfigMap.containsKey(fqdn)) {
            entriesToBeRemoved.add(entry.getKey());
            continue;
        }
        // Update the missing Passpoint configuration fields to this WifiConfiguration.
        LegacyPasspointConfig passpointConfig = passpointConfigMap.get(fqdn);
        wifiConfig.providerFriendlyName = passpointConfig.mFriendlyName;
        wifiConfig.roamingConsortiumIds = Arrays.copyOf(passpointConfig.mRoamingConsortiumOis, passpointConfig.mRoamingConsortiumOis.length);
        if (passpointConfig.mImsi != null) {
            wifiConfig.enterpriseConfig.setPlmn(passpointConfig.mImsi);
        }
        if (passpointConfig.mRealm != null) {
            wifiConfig.enterpriseConfig.setRealm(passpointConfig.mRealm);
        }
    }
    // remove them to avoid maintaining any invalid Passpoint configurations.
    for (String key : entriesToBeRemoved) {
        Log.w(TAG, "Remove incomplete Passpoint configuration: " + key);
        configurationMap.remove(key);
    }
}
#method_after
private void loadFromPasspointConfigStore(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    Map<String, LegacyPasspointConfig> passpointConfigMap = null;
    try {
        passpointConfigMap = mPasspointConfigParser.parseConfig(PPS_FILE.getAbsolutePath());
    } catch (IOException e) {
        Log.w(TAG, "Failed to read/parse Passpoint config file: " + e.getMessage());
    }
    List<String> entriesToBeRemoved = new ArrayList<>();
    for (Map.Entry<String, WifiConfiguration> entry : configurationMap.entrySet()) {
        WifiConfiguration wifiConfig = entry.getValue();
        // Passpoint.
        if (wifiConfig.enterpriseConfig == null || wifiConfig.enterpriseConfig.getEapMethod() == WifiEnterpriseConfig.Eap.NONE) {
            continue;
        }
        // Ignore configuration without FQDN.
        Map<String, String> extras = networkExtras.get(wifiConfig.networkId);
        if (extras == null || !extras.containsKey(WifiSupplicantControl.ID_STRING_KEY_FQDN)) {
            continue;
        }
        String fqdn = networkExtras.get(wifiConfig.networkId).get(WifiSupplicantControl.ID_STRING_KEY_FQDN);
        // Passpoint configuration file.
        if (passpointConfigMap == null || !passpointConfigMap.containsKey(fqdn)) {
            entriesToBeRemoved.add(entry.getKey());
            continue;
        }
        // Update the missing Passpoint configuration fields to this WifiConfiguration.
        LegacyPasspointConfig passpointConfig = passpointConfigMap.get(fqdn);
        wifiConfig.FQDN = fqdn;
        wifiConfig.providerFriendlyName = passpointConfig.mFriendlyName;
        if (passpointConfig.mRoamingConsortiumOis != null) {
            wifiConfig.roamingConsortiumIds = Arrays.copyOf(passpointConfig.mRoamingConsortiumOis, passpointConfig.mRoamingConsortiumOis.length);
        }
        if (passpointConfig.mImsi != null) {
            wifiConfig.enterpriseConfig.setPlmn(passpointConfig.mImsi);
        }
        if (passpointConfig.mRealm != null) {
            wifiConfig.enterpriseConfig.setRealm(passpointConfig.mRealm);
        }
    }
    // remove them to avoid maintaining any invalid Passpoint configurations.
    for (String key : entriesToBeRemoved) {
        Log.w(TAG, "Remove incomplete Passpoint configuration: " + key);
        configurationMap.remove(key);
    }
}
#end_block

#method_before
public boolean removeStores() {
    // First remove all networks from wpa_supplicant and save configuration.
    if (!mWifiSupplicantControl.removeAllNetworks()) {
        Log.e(TAG, "Removing networks from wpa_supplicant failed");
        return false;
    }
    mWifiSupplicantControl.saveConfig();
    // Now remove the ipconfig.txt file.
    if (!IP_CONFIG_FILE.delete()) {
        Log.e(TAG, "Removing ipconfig.txt failed");
        return false;
    }
    // Now finally remove network history.txt
    if (!NETWORK_HISTORY_FILE.delete()) {
        Log.e(TAG, "Removing networkHistory.txt failed");
        return false;
    }
    if (!PPS_FILE.delete()) {
        Log.e(TAG, "Removing PerProviderSubscription.conf failed");
        return false;
    }
    Log.i(TAG, "All legacy stores removed!");
    return true;
}
#method_after
public boolean removeStores() {
    // First remove all networks from wpa_supplicant and save configuration.
    if (!mWifiNative.removeAllNetworks()) {
        Log.e(TAG, "Removing networks from wpa_supplicant failed");
        return false;
    }
    mWifiNative.saveConfig();
    // Now remove the ipconfig.txt file.
    if (!IP_CONFIG_FILE.delete()) {
        Log.e(TAG, "Removing ipconfig.txt failed");
        return false;
    }
    // Now finally remove network history.txt
    if (!NETWORK_HISTORY_FILE.delete()) {
        Log.e(TAG, "Removing networkHistory.txt failed");
        return false;
    }
    if (!PPS_FILE.delete()) {
        Log.e(TAG, "Removing PerProviderSubscription.conf failed");
        return false;
    }
    Log.i(TAG, "All legacy stores removed!");
    return true;
}
#end_block

#method_before
public SoftApManager makeSoftApManager(INetworkManagementService nmService, SoftApManager.Listener listener, IApInterface apInterface, WifiConfiguration config) {
    return new SoftApManager(mWifiServiceHandlerThread.getLooper(), mWifiNative, mCountryCode.getCountryCode(), listener, apInterface, nmService, mWifiApConfigStore, config);
}
#method_after
public SoftApManager makeSoftApManager(INetworkManagementService nmService, SoftApManager.Listener listener, IApInterface apInterface, WifiConfiguration config) {
    return new SoftApManager(mWifiServiceHandlerThread.getLooper(), mWifiNative, mCountryCode.getCountryCode(), listener, apInterface, nmService, mWifiApConfigStore, config, mWifiMetrics);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiConfigStore = new WifiConfigStoreLegacy(mWifiNetworkHistory, mWifiSupplicantControl, mIpconfigStore, mPasspointConfigParser);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiConfigStore = new WifiConfigStoreLegacy(mWifiNetworkHistory, mWifiNative, mIpconfigStore, mPasspointConfigParser);
}
#end_block

#method_before
@Test
public void testLoadFromStores() throws Exception {
    WifiConfiguration pskNetwork = WifiConfigurationTestUtil.createPskNetwork();
    WifiConfiguration wepNetwork = WifiConfigurationTestUtil.createWepNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    WifiConfiguration passpointNetwork = WifiConfigurationTestUtil.createPasspointNetwork();
    eapNetwork.enterpriseConfig.setPassword("EapPassword");
    // Setup additional configuration for Passpoint.
    passpointNetwork.networkId = 1234;
    passpointNetwork.enterpriseConfig.setPassword("PaspointPassword");
    passpointNetwork.roamingConsortiumIds = new long[] { 0x1234, 0x5678 };
    passpointNetwork.enterpriseConfig.setRealm("test.com");
    passpointNetwork.enterpriseConfig.setPlmn("214321");
    final List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(pskNetwork);
    networks.add(wepNetwork);
    networks.add(eapNetwork);
    networks.add(passpointNetwork);
    // Setup legacy Passpoint configuration data.
    Map<String, LegacyPasspointConfig> passpointConfigs = new HashMap<>();
    LegacyPasspointConfig passpointConfig = new LegacyPasspointConfig();
    passpointConfig.mFqdn = passpointNetwork.FQDN;
    passpointConfig.mFriendlyName = passpointNetwork.providerFriendlyName;
    passpointConfig.mRoamingConsortiumOis = passpointNetwork.roamingConsortiumIds;
    passpointConfig.mRealm = passpointNetwork.enterpriseConfig.getRealm();
    passpointConfig.mImsi = passpointNetwork.enterpriseConfig.getPlmn();
    passpointConfigs.put(passpointNetwork.FQDN, passpointConfig);
    // Return the config data with passwords masked from wpa_supplicant control interface.
    doAnswer(new AnswerWithArguments() {

        public int answer(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
            for (Map.Entry<String, WifiConfiguration> entry : createWpaSupplicantLoadData(networks).entrySet()) {
                configs.put(entry.getKey(), entry.getValue());
                // Setup networkExtras for Passpoint configuration.
                if (entry.getValue().FQDN != null) {
                    networkExtras.put(entry.getValue().networkId, createNetworkExtrasForPasspointConfig(entry.getValue()));
                }
            }
            return 0;
        }
    }).when(mWifiSupplicantControl).loadNetworks(any(Map.class), any(SparseArray.class));
    // Return the unmasked values during file parsing.
    doAnswer(new AnswerWithArguments() {

        public Map<String, String> answer(String fieldName) {
            if (fieldName.equals(WifiConfiguration.pskVarName)) {
                return createPskMap(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[0])) {
                return createWepKey0Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[1])) {
                return createWepKey1Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[2])) {
                return createWepKey2Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[3])) {
                return createWepKey3Map(networks);
            } else if (fieldName.equals(WifiEnterpriseConfig.PASSWORD_KEY)) {
                return createEapPasswordMap(networks);
            }
            return new HashMap<>();
        }
    }).when(mWifiSupplicantControl).readNetworkVariablesFromSupplicantFile(anyString());
    when(mPasspointConfigParser.parseConfig(anyString())).thenReturn(passpointConfigs);
    WifiConfigStoreLegacy.WifiConfigStoreDataLegacy storeData = mWifiConfigStore.read();
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(networks, storeData.getConfigurations());
}
#method_after
@Test
public void testLoadFromStores() throws Exception {
    WifiConfiguration pskNetwork = WifiConfigurationTestUtil.createPskNetwork();
    WifiConfiguration wepNetwork = WifiConfigurationTestUtil.createWepNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    WifiConfiguration passpointNetwork = WifiConfigurationTestUtil.createPasspointNetwork();
    eapNetwork.enterpriseConfig.setPassword("EapPassword");
    // Initialize Passpoint configuration data.
    int passpointNetworkId = 1234;
    String fqdn = passpointNetwork.FQDN;
    String providerFriendlyName = passpointNetwork.providerFriendlyName;
    long[] roamingConsortiumIds = new long[] { 0x1234, 0x5678 };
    String realm = "test.com";
    String imsi = "214321";
    // Update Passpoint network.
    // Network ID is used for lookup network extras, so use an unique ID for passpoint network.
    passpointNetwork.networkId = passpointNetworkId;
    passpointNetwork.enterpriseConfig.setPassword("PaspointPassword");
    // Reset FQDN and provider friendly name so that the derived network from #read will
    // obtained these information from networkExtras and {@link LegacyPasspointConfigParser}.
    passpointNetwork.FQDN = null;
    passpointNetwork.providerFriendlyName = null;
    final List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(pskNetwork);
    networks.add(wepNetwork);
    networks.add(eapNetwork);
    networks.add(passpointNetwork);
    // Setup legacy Passpoint configuration data.
    Map<String, LegacyPasspointConfig> passpointConfigs = new HashMap<>();
    LegacyPasspointConfig passpointConfig = new LegacyPasspointConfig();
    passpointConfig.mFqdn = fqdn;
    passpointConfig.mFriendlyName = providerFriendlyName;
    passpointConfig.mRoamingConsortiumOis = roamingConsortiumIds;
    passpointConfig.mRealm = realm;
    passpointConfig.mImsi = imsi;
    passpointConfigs.put(fqdn, passpointConfig);
    // Return the config data with passwords masked from wpa_supplicant control interface.
    doAnswer(new AnswerWithArguments() {

        public boolean answer(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
            for (Map.Entry<String, WifiConfiguration> entry : createWpaSupplicantLoadData(networks).entrySet()) {
                configs.put(entry.getKey(), entry.getValue());
            }
            // Setup networkExtras for Passpoint configuration.
            networkExtras.put(passpointNetworkId, createNetworkExtrasForPasspointConfig(fqdn));
            return true;
        }
    }).when(mWifiNative).migrateNetworksFromSupplicant(any(Map.class), any(SparseArray.class));
    // Return the unmasked values during file parsing.
    doAnswer(new AnswerWithArguments() {

        public Map<String, String> answer(String fieldName) {
            if (fieldName.equals(WifiConfiguration.pskVarName)) {
                return createPskMap(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[0])) {
                return createWepKey0Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[1])) {
                return createWepKey1Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[2])) {
                return createWepKey2Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[3])) {
                return createWepKey3Map(networks);
            } else if (fieldName.equals(WifiEnterpriseConfig.PASSWORD_KEY)) {
                return createEapPasswordMap(networks);
            }
            return new HashMap<>();
        }
    }).when(mWifiNative).readNetworkVariablesFromSupplicantFile(anyString());
    when(mPasspointConfigParser.parseConfig(anyString())).thenReturn(passpointConfigs);
    WifiConfigStoreLegacy.WifiConfigStoreDataLegacy storeData = mWifiConfigStore.read();
    // Update the expected configuration for Passpoint network.
    passpointNetwork.FQDN = fqdn;
    passpointNetwork.providerFriendlyName = providerFriendlyName;
    passpointNetwork.roamingConsortiumIds = roamingConsortiumIds;
    passpointNetwork.enterpriseConfig.setRealm(realm);
    passpointNetwork.enterpriseConfig.setPlmn(imsi);
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(networks, storeData.getConfigurations());
}
#end_block

#method_before
private Map<String, WifiConfiguration> createWpaSupplicantLoadData(List<WifiConfiguration> configurations) {
    List<WifiConfiguration> newConfigurations = createMaskedWifiConfigurations(configurations);
    Map<String, WifiConfiguration> configurationMap = new HashMap<>();
    for (WifiConfiguration config : newConfigurations) {
        configurationMap.put(config.configKey(true), config);
    }
    return configurationMap;
}
#method_after
private Map<String, WifiConfiguration> createWpaSupplicantLoadData(List<WifiConfiguration> configurations) {
    List<WifiConfiguration> newConfigurations;
    // no need to read masked variables from wpa_supplicant.conf file.
    if (WifiNative.HIDL_SUP_ENABLE) {
        newConfigurations = configurations;
    } else {
        newConfigurations = createMaskedWifiConfigurations(configurations);
    }
    Map<String, WifiConfiguration> configurationMap = new HashMap<>();
    for (WifiConfiguration config : newConfigurations) {
        configurationMap.put(config.configKey(true), config);
    }
    return configurationMap;
}
#end_block

#method_before
private Map<String, String> createNetworkExtrasForPasspointConfig(WifiConfiguration config) {
    Map<String, String> extras = new HashMap<>();
    extras.put(WifiSupplicantControl.ID_STRING_KEY_FQDN, config.FQDN);
    return extras;
}
#method_after
private Map<String, String> createNetworkExtrasForPasspointConfig(String fqdn) {
    Map<String, String> extras = new HashMap<>();
    extras.put(WifiSupplicantControl.ID_STRING_KEY_FQDN, fqdn);
    return extras;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.ca_certificate_wifi);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.sec_wifi_ca_cert_test, R.string.sec_wifi_ca_cert_test_info, -1);
    mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
    getPassButton().setEnabled(false);
    final Button goToSettingsButton = (Button) findViewById(R.id.gotosettings);
    goToSettingsButton.setEnabled(false);
    final Button goToWifiSettingsButton = (Button) findViewById(R.id.gotowifisettings);
    goToWifiSettingsButton.setEnabled(false);
    final Button certificateTrustCheckButton = (Button) findViewById(R.id.check_cert_trust);
    certificateTrustCheckButton.setEnabled(false);
    final TextView finalStepTextView = (TextView) findViewById(R.id.clear_creds_textView);
    final Button transferCertificateButton = (Button) findViewById(R.id.transfer_ca_certificate);
    if (!isWifiCertificateSupported()) {
        transferCertificateButton.setEnabled(false);
        getPassButton().setEnabled(true);
        finalStepTextView.setText(getResources().getString(R.string.sec_autopass_test_instruction));
    }
    goToSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            // Launch settings of the device
            startActivityForResult(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS), 0);
            if (testResult) {
                getPassButton().setEnabled(true);
                finalStepTextView.setText(getResources().getString(R.string.sec_pass_test_instruction));
            } else {
                finalStepTextView.setText(getResources().getString(R.string.sec_fail_test_instruction));
            }
        }
    });
    goToWifiSettingsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            // Launch WiFi settings of the device
            startActivity(new Intent(android.provider.Settings.ACTION_WIFI_SETTINGS));
        }
    });
    transferCertificateButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (transferCertificateToDevice()) {
                openDialog(getResources().getString(R.string.sec_file_transferred_text));
                goToSettingsButton.setEnabled(true);
                goToWifiSettingsButton.setEnabled(true);
                certificateTrustCheckButton.setEnabled(true);
            } else {
                openDialog(getResources().getString(R.string.sec_file_transfer_failed));
            }
        }
    });
    certificateTrustCheckButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            Certificate caCert = readCertificate(convertFileToByteArray(certStagingFile));
            if (caCert != null) {
                if (isCaCertificateTrusted(caCert)) {
                    testResult = false;
                    openDialog(getResources().getString(R.string.sec_cert_trusted_text));
                } else {
                    testResult = true;
                    openDialog(getResources().getString(R.string.sec_cert_nottrusted_text));
                }
            } else {
                openDialog(getResources().getString(R.string.sec_read_cert_exception));
            }
        }
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.ca_certificate_wifi);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.sec_wifi_ca_cert_test, R.string.sec_wifi_ca_cert_test_info, -1);
    mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
    final Button goToSettingsButton = (Button) findViewById(R.id.gotosettings);
    goToSettingsButton.setEnabled(false);
    final Button goToWifiSettingsButton = (Button) findViewById(R.id.gotowifisettings);
    goToWifiSettingsButton.setEnabled(false);
    final Button certificateTrustCheckButton = (Button) findViewById(R.id.check_cert_trust);
    certificateTrustCheckButton.setEnabled(false);
    final TextView finalStepTextView = (TextView) findViewById(R.id.clear_creds_textView);
    final Button transferCertificateButton = (Button) findViewById(R.id.transfer_ca_certificate);
    if (!isWifiCertificateSupported()) {
        transferCertificateButton.setEnabled(false);
        getPassButton().setEnabled(true);
        finalStepTextView.setText(R.string.sec_autopass_test_instruction);
    } else {
        getPassButton().setEnabled(false);
        goToSettingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // Launch settings of the device
                startActivityForResult(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS), 0);
                if (testResult) {
                    getPassButton().setEnabled(true);
                    finalStepTextView.setText(getResources().getString(R.string.sec_pass_test_instruction));
                } else {
                    finalStepTextView.setText(getResources().getString(R.string.sec_fail_test_instruction));
                }
            }
        });
        goToWifiSettingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // Launch Internal Storage.
                startActivity(KeyChain.createInstallIntent());
            }
        });
        transferCertificateButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (transferCertificateToDevice()) {
                    openDialog(getResources().getString(R.string.sec_file_transferred_text));
                    goToSettingsButton.setEnabled(true);
                    goToWifiSettingsButton.setEnabled(true);
                    certificateTrustCheckButton.setEnabled(true);
                } else {
                    openDialog(getResources().getString(R.string.sec_file_transfer_failed));
                }
            }
        });
        certificateTrustCheckButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                Certificate caCert = readCertificate(convertFileToByteArray(certStagingFile));
                if (caCert != null) {
                    if (isCaCertificateTrusted(caCert)) {
                        testResult = false;
                        openDialog(getResources().getString(R.string.sec_cert_trusted_text));
                    } else {
                        testResult = true;
                        openDialog(getResources().getString(R.string.sec_cert_nottrusted_text));
                    }
                } else {
                    openDialog(getResources().getString(R.string.sec_read_cert_exception));
                }
            }
        });
    }
}
#end_block

#method_before
private boolean isWifiCertificateSupported() {
    ComponentName componentName = new ComponentName("com.android.settings", "com.android.settings.Settings$AdvancedWifiSettingsActivity");
    switch(getPackageManager().getComponentEnabledSetting(componentName)) {
        case PackageManager.COMPONENT_ENABLED_STATE_ENABLED:
            return true;
        case PackageManager.COMPONENT_ENABLED_STATE_DEFAULT:
            try {
                PackageInfo packageInfo = getPackageManager().getPackageInfo(componentName.getPackageName(), PackageManager.GET_ACTIVITIES);
                if (packageInfo == null || packageInfo.activities == null) {
                    return false;
                }
                for (ComponentInfo componentInfo : packageInfo.activities) {
                    if (componentInfo != null && componentInfo.name.equals(componentName.getClassName())) {
                        return componentInfo.isEnabled();
                    }
                }
            } catch (PackageManager.NameNotFoundException e) {
            // The package is not found, there is no way to install Wi-Fi certificates.
            }
            return false;
        default:
            return false;
    }
}
#method_after
private boolean isWifiCertificateSupported() {
    return KeyChain.createInstallIntent() != null;
}
#end_block

#method_before
private void pollStateDoneGsm() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDoneGsm() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
protected void pollStateDoneCdma() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
protected void pollStateDoneCdma() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
protected void pollStateDoneCdmaLte() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
protected void pollStateDoneCdmaLte() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        mISupplicant = null;
        mISupplicantP2pIface = null;
        if (mIServiceManager != null) {
            // don't register another.
            return true;
        }
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantP2pIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#method_after
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        if (mIServiceManager != null) {
            Log.i(TAG, "Supplicant HAL already initialized.");
            // don't register another.
            return true;
        }
        mISupplicant = null;
        mISupplicantP2pIface = null;
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantP2pIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#end_block

#method_before
protected static void logCompletion(String operation, SupplicantStatus status) {
    if (status.code == SupplicantStatusCode.SUCCESS) {
        logd(operation + " completed successfully.");
    } else {
        Log.w(TAG, operation + " failed: " + status.code + " (" + status.debugMessage + ")");
    }
}
#method_after
protected static void logCompletion(String operation, SupplicantStatus status) {
    if (status == null) {
        Log.w(TAG, operation + " failed: no status code returned.");
    } else if (status.code == SupplicantStatusCode.SUCCESS) {
        logd(operation + " completed successfully.");
    } else {
        Log.w(TAG, operation + " failed: " + status.code + " (" + status.debugMessage + ")");
    }
}
#end_block

#method_before
private int wpsInfoToConfigMethod(int info) {
    switch(info) {
        case WpsInfo.PBC:
            return ISupplicantP2pIface.WpsProvisionMethod.PBC;
        case WpsInfo.DISPLAY:
            return ISupplicantP2pIface.WpsProvisionMethod.DISPLAY;
        case WpsInfo.KEYPAD:
            return ISupplicantP2pIface.WpsProvisionMethod.KEYPAD;
        case WpsInfo.LABEL:
        default:
            Log.e(TAG, "Unsupported WPS provision method: " + info);
            return RESULT_NOT_VALID;
    }
}
#method_after
private int wpsInfoToConfigMethod(int info) {
    switch(info) {
        case WpsInfo.PBC:
            return ISupplicantP2pIface.WpsProvisionMethod.PBC;
        case WpsInfo.DISPLAY:
            return ISupplicantP2pIface.WpsProvisionMethod.DISPLAY;
        case WpsInfo.KEYPAD:
        case WpsInfo.LABEL:
            return ISupplicantP2pIface.WpsProvisionMethod.KEYPAD;
        default:
            Log.e(TAG, "Unsupported WPS provision method: " + info);
            return RESULT_NOT_VALID;
    }
}
#end_block

#method_before
public boolean find(int timeout) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("find"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("find(" + timeout + ")");
        try {
            result.setResult(mISupplicantP2pIface.find(timeout));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean find(int timeout) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("find"))
            return false;
        if (timeout < 0) {
            Log.e(TAG, "Invalid timeout value: " + timeout);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("find(" + timeout + ")");
        try {
            result.setResult(mISupplicantP2pIface.find(timeout));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setGroupIdle(String groupIfName, int timeoutInSec) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setGroupIdle"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (timeoutInSec < 0)
            return false;
        SupplicantResult<Void> result = new SupplicantResult("setGroupIdle(" + groupIfName + ", " + timeoutInSec + ")");
        try {
            result.setResult(mISupplicantP2pIface.setGroupIdle(groupIfName, timeoutInSec));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setGroupIdle(String groupIfName, int timeoutInSec) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setGroupIdle"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (timeoutInSec < 0) {
            Log.e(TAG, "Invalid group timeout value " + timeoutInSec);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setGroupIdle(" + groupIfName + ", " + timeoutInSec + ")");
        try {
            result.setResult(mISupplicantP2pIface.setGroupIdle(groupIfName, timeoutInSec));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null)
            return false;
        ArrayList<Byte> ssid = new ArrayList<Byte>();
        for (byte b : postfix.getBytes()) {
            ssid.add(new Byte(b));
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(ssid));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null) {
            Log.e(TAG, "Invalid SSID postfix value (null).");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(NativeUtil.decodeSsid("\"" + postfix + "\"")));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        } catch (Exception e) {
            Log.e(TAG, "Could not decode SSID.", e);
            return false;
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
    synchronized (mLock) {
        if (config == null)
            return null;
        byte[] peerAddress = stringToAddress(config.deviceAddress);
        if (peerAddress == null) {
            Log.e(TAG, "Could not parse mac address: " + config.deviceAddress);
            return null;
        }
        int provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (provisionMethod == RESULT_NOT_VALID) {
            Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
            return null;
        }
        String preSelectedPin = null;
        if (provisionMethod == ISupplicantP2pIface.WpsProvisionMethod.DISPLAY) {
            preSelectedPin = config.wps.pin;
        }
        boolean persistent = (config.netId == WifiP2pGroup.PERSISTENT_NET_ID);
        int goIntent = 0;
        if (!joinExistingGroup) {
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("connect(" + config.deviceAddress + ")");
        try {
            mISupplicantP2pIface.connect(peerAddress, provisionMethod, preSelectedPin, joinExistingGroup, persistent, goIntent, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#method_after
public String connect(WifiP2pConfig config, boolean joinExistingGroup) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return null;
        if (config == null) {
            Log.e(TAG, "Could not connect: null config.");
            return null;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Could not parse null mac address.");
            return null;
        }
        byte[] peerAddress = null;
        try {
            peerAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return null;
        }
        int provisionMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (provisionMethod == RESULT_NOT_VALID) {
            Log.e(TAG, "Invalid WPS config method: " + config.wps.setup);
            return null;
        }
        // NOTE: preSelectedPin cannot be null, otherwise hal would crash.
        String preSelectedPin = "";
        if (provisionMethod == ISupplicantP2pIface.WpsProvisionMethod.DISPLAY) {
            preSelectedPin = config.wps.pin;
            if (preSelectedPin == null) {
                Log.e(TAG, "PIN must be supplied when provision method is DISPLAY.");
                return null;
            }
        }
        boolean persistent = (config.netId == WifiP2pGroup.PERSISTENT_NET_ID);
        int goIntent = 0;
        if (!joinExistingGroup) {
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("connect(" + config.deviceAddress + ")");
        try {
            mISupplicantP2pIface.connect(peerAddress, provisionMethod, preSelectedPin, joinExistingGroup, persistent, goIntent, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean provisionDiscovery(WifiP2pConfig config) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("provisionDiscovery"))
            return false;
        int targetMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (targetMethod == -1) {
            Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
            return false;
        }
        byte[] macAddress = stringToAddress(config.deviceAddress);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse null mac address.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("provisionDiscovery(" + config.deviceAddress + ", " + config.wps.setup + ")");
        try {
            result.setResult(mISupplicantP2pIface.provisionDiscovery(macAddress, targetMethod));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean provisionDiscovery(WifiP2pConfig config) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("provisionDiscovery"))
            return false;
        int targetMethod = wpsInfoToConfigMethod(config.wps.setup);
        if (targetMethod == -1) {
            Log.e(TAG, "Unrecognized WPS configuration method: " + config.wps.setup);
            return false;
        }
        if (config.deviceAddress == null) {
            Log.e(TAG, "Cannot parse null mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(config.deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("provisionDiscovery(" + config.deviceAddress + ", " + config.wps.setup + ")");
        try {
            result.setResult(mISupplicantP2pIface.provisionDiscovery(macAddress, targetMethod));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean invite(WifiP2pGroup group, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("invite"))
            return false;
        byte[] ownerMacAddress = stringToAddress(group.getOwner().deviceAddress);
        if (ownerMacAddress == null) {
            Log.e(TAG, "Cannot parse owner mac address.");
            return false;
        }
        byte[] peerMacAddress = stringToAddress(peerAddress);
        if (peerMacAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("invite(" + group.getInterface() + ", " + group.getOwner().deviceAddress + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.invite(group.getInterface(), ownerMacAddress, peerMacAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean invite(WifiP2pGroup group, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("invite"))
            return false;
        if (group == null) {
            Log.e(TAG, "Cannot invite to null group.");
            return false;
        }
        if (group.getOwner() == null) {
            Log.e(TAG, "Cannot invite to group with null owner.");
            return false;
        }
        if (group.getOwner().deviceAddress == null) {
            Log.e(TAG, "Group owner has no mac address.");
            return false;
        }
        byte[] ownerMacAddress = null;
        try {
            ownerMacAddress = NativeUtil.macAddressToByteArray(group.getOwner().deviceAddress);
        } catch (Exception e) {
            Log.e(TAG, "Group owner mac address parse error.", e);
            return false;
        }
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] peerMacAddress;
        try {
            peerMacAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Peer mac address parse error.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("invite(" + group.getInterface() + ", " + group.getOwner().deviceAddress + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.invite(group.getInterface(), ownerMacAddress, peerMacAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean reject(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reject"))
            return false;
        byte[] macAddress = stringToAddress(peerAddress);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse rejected peer's mac address.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reject(" + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reject(macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean reject(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reject"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse rejected peer's mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse peer mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reject(" + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reject(macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String getDeviceAddress() {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getDeviceAddress"))
            return null;
        SupplicantResult<byte[]> result = new SupplicantResult("getDeviceAddress()");
        try {
            mISupplicantP2pIface.getDeviceAddress((SupplicantStatus status, byte[] address) -> {
                result.setResult(status, address);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return addressToString(result.getResult());
    }
}
#method_after
public String getDeviceAddress() {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getDeviceAddress"))
            return null;
        SupplicantResult<String> result = new SupplicantResult("getDeviceAddress()");
        try {
            mISupplicantP2pIface.getDeviceAddress((SupplicantStatus status, byte[] address) -> {
                String parsedAddress = null;
                try {
                    parsedAddress = NativeUtil.macAddressFromByteArray(address);
                } catch (Exception e) {
                    Log.e(TAG, "Could not process reported address.", e);
                }
                result.setResult(status, parsedAddress);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#end_block

#method_before
public String getSsid(String address) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getSsid"))
            return null;
        byte[] macAddress = stringToAddress(address);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        SupplicantResult<ArrayList<Byte>> result = new SupplicantResult("getSsid(" + address + ")");
        try {
            mISupplicantP2pIface.getSsid(macAddress, (SupplicantStatus status, ArrayList<Byte> ssid) -> {
                result.setResult(status, ssid);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return byteListToString(result.getResult());
    }
}
#method_after
public String getSsid(String address) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getSsid"))
            return null;
        if (address == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(address);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse mac address.", e);
            return null;
        }
        SupplicantResult<String> result = new SupplicantResult("getSsid(" + address + ")");
        try {
            mISupplicantP2pIface.getSsid(macAddress, (SupplicantStatus status, ArrayList<Byte> ssid) -> {
                String ssidString = null;
                if (ssid != null) {
                    try {
                        ssidString = NativeUtil.encodeSsid(ssid);
                    } catch (Exception e) {
                        Log.e(TAG, "Could not encode SSID.", e);
                    }
                }
                result.setResult(status, ssidString);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
            return null;
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean reinvoke(int networkId, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reinvoke"))
            return false;
        byte[] macAddress = stringToAddress(peerAddress);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reinvoke(" + networkId + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reinvoke(networkId, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean reinvoke(int networkId, String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("reinvoke"))
            return false;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return false;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse mac address.", e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("reinvoke(" + networkId + ", " + peerAddress + ")");
        try {
            result.setResult(mISupplicantP2pIface.reinvoke(networkId, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public int getGroupCapability(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getGroupCapability"))
            return 0;
        byte[] macAddress = stringToAddress(peerAddress);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return -1;
        }
        SupplicantResult<Integer> capability = new SupplicantResult("getGroupCapability(" + peerAddress + ")");
        try {
            mISupplicantP2pIface.getGroupCapability(macAddress, (SupplicantStatus status, int cap) -> {
                capability.setResult(status, cap);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        if (!capability.isSuccess()) {
            return RESULT_NOT_VALID;
        }
        return capability.getResult();
    }
}
#method_after
public int getGroupCapability(String peerAddress) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("getGroupCapability")) {
            return RESULT_NOT_VALID;
        }
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return RESULT_NOT_VALID;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse group address.", e);
            return RESULT_NOT_VALID;
        }
        SupplicantResult<Integer> capability = new SupplicantResult("getGroupCapability(" + peerAddress + ")");
        try {
            mISupplicantP2pIface.getGroupCapability(macAddress, (SupplicantStatus status, int cap) -> {
                capability.setResult(status, cap);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        if (!capability.isSuccess()) {
            return RESULT_NOT_VALID;
        }
        return capability.getResult();
    }
}
#end_block

#method_before
public boolean configureExtListen(boolean enable, int periodInMillis, int intervalInMillis) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("configureExtListen"))
            return false;
        // If listening is disabled, wpa supplicant expects zeroes.
        if (!enable) {
            periodInMillis = 0;
            intervalInMillis = 0;
        }
        // supplicant.
        if (periodInMillis < 0 || intervalInMillis < 0)
            return false;
        SupplicantResult<Void> result = new SupplicantResult("configureExtListen(" + periodInMillis + ", " + intervalInMillis + ")");
        try {
            result.setResult(mISupplicantP2pIface.configureExtListen(periodInMillis, intervalInMillis));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean configureExtListen(boolean enable, int periodInMillis, int intervalInMillis) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("configureExtListen"))
            return false;
        // If listening is disabled, wpa supplicant expects zeroes.
        if (!enable) {
            periodInMillis = 0;
            intervalInMillis = 0;
        }
        // supplicant.
        if (periodInMillis < 0 || intervalInMillis < 0) {
            Log.e(TAG, "Invalid parameters supplied to configureExtListen: " + periodInMillis + ", " + intervalInMillis);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("configureExtListen(" + periodInMillis + ", " + intervalInMillis + ")");
        try {
            result.setResult(mISupplicantP2pIface.configureExtListen(periodInMillis, intervalInMillis));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setListenChannel(int channel, int operatingClass) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setListenChannel"))
            return false;
        // supplicant.
        if (channel < 0 || operatingClass < 0)
            return false;
        SupplicantResult<Void> result = new SupplicantResult("setListenChannel(" + channel + ", " + operatingClass + ")");
        try {
            result.setResult(mISupplicantP2pIface.setListenChannel(channel, operatingClass));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setListenChannel(int channel, int operatingClass) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setListenChannel"))
            return false;
        // supplicant.
        if (channel < 0 || operatingClass < 0) {
            Log.e(TAG, "Invalid values supplied to setListenChannel: " + channel + ", " + operatingClass);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setListenChannel(" + channel + ", " + operatingClass + ")");
        try {
            result.setResult(mISupplicantP2pIface.setListenChannel(channel, operatingClass));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean serviceAdd(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceAdd"))
            return false;
        for (String s : servInfo.getSupplicantQueryList()) {
            String[] data = s.split(" ");
            if (data.length < 2) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("addUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.addUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    ArrayList<Byte> request = hexStringToByteArrayList(data[1]);
                    ArrayList<Byte> response = hexStringToByteArrayList(data[2]);
                    result = new SupplicantResult("addBonjourService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.addBonjourService(request, response));
                } else {
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#method_after
public boolean serviceAdd(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceAdd"))
            return false;
        if (servInfo == null) {
            Log.e(TAG, "Null service info passed.");
            return false;
        }
        for (String s : servInfo.getSupplicantQueryList()) {
            if (s == null) {
                Log.e(TAG, "Invalid service description (null).");
                return false;
            }
            String[] data = s.split(" ");
            if (data.length < 3) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("addUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.addUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null && data[2] != null) {
                        ArrayList<Byte> request = null;
                        ArrayList<Byte> response = null;
                        try {
                            request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                            response = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[2]));
                        } catch (Exception e) {
                            Log.e(TAG, "Invalid bonjour service description.");
                            return false;
                        }
                        result = new SupplicantResult("addBonjourService(" + data[1] + ", " + data[2] + ")");
                        result.setResult(mISupplicantP2pIface.addBonjourService(request, response));
                    }
                } else {
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#end_block

#method_before
public boolean serviceRemove(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceRemove"))
            return false;
        for (String s : servInfo.getSupplicantQueryList()) {
            String[] data = s.split(" ");
            if (data.length < 2) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("removeUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.removeUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    ArrayList<Byte> request = hexStringToByteArrayList(data[1]);
                    result = new SupplicantResult("removeBonjourService(" + data[1] + ")");
                    result.setResult(mISupplicantP2pIface.removeBonjourService(request));
                } else {
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#method_after
public boolean serviceRemove(WifiP2pServiceInfo servInfo) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("serviceRemove"))
            return false;
        if (servInfo == null) {
            Log.e(TAG, "Null service info passed.");
            return false;
        }
        for (String s : servInfo.getSupplicantQueryList()) {
            if (s == null) {
                Log.e(TAG, "Invalid service description (null).");
                return false;
            }
            String[] data = s.split(" ");
            if (data.length < 3) {
                Log.e(TAG, "Service specification invalid: " + s);
                return false;
            }
            SupplicantResult<Void> result = null;
            try {
                if ("upnp".equals(data[0])) {
                    int version = 0;
                    try {
                        version = Integer.parseInt(data[1]);
                    } catch (NumberFormatException e) {
                        Log.e(TAG, "UPnP Service specification invalid: " + s, e);
                        return false;
                    }
                    result = new SupplicantResult("removeUpnpService(" + data[1] + ", " + data[2] + ")");
                    result.setResult(mISupplicantP2pIface.removeUpnpService(version, data[2]));
                } else if ("bonjour".equals(data[0])) {
                    if (data[1] != null) {
                        ArrayList<Byte> request = null;
                        try {
                            request = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(data[1]));
                        } catch (Exception e) {
                            Log.e(TAG, "Invalid bonjour service description.");
                            return false;
                        }
                        result = new SupplicantResult("removeBonjourService(" + data[1] + ")");
                        result.setResult(mISupplicantP2pIface.removeBonjourService(request));
                    }
                } else {
                    Log.e(TAG, "Unknown / unsupported P2P service requested: " + data[0]);
                    return false;
                }
            } catch (RemoteException e) {
                Log.e(TAG, "ISupplicantP2pIface exception: " + e);
                supplicantServiceDiedHandler();
            }
            if (result == null || !result.isSuccess())
                return false;
        }
        return true;
    }
}
#end_block

#method_before
public String requestServiceDiscovery(String peerAddress, String query) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("requestServiceDiscovery"))
            return null;
        byte[] macAddress = stringToAddress(peerAddress);
        if (macAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        ArrayList<Byte> binQuery = hexStringToByteArrayList(query);
        if (binQuery == null) {
            Log.e(TAG, "Cannot parse service discovery query: " + query);
            return null;
        }
        SupplicantResult<Long> result = new SupplicantResult("requestServiceDiscovery(" + peerAddress + ", " + query + ")");
        try {
            mISupplicantP2pIface.requestServiceDiscovery(macAddress, binQuery, (SupplicantStatus status, long identifier) -> {
                result.setResult(status, new Long(identifier));
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        Long value = result.getResult();
        if (value == null)
            return null;
        return value.toString();
    }
}
#method_after
public String requestServiceDiscovery(String peerAddress, String query) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("requestServiceDiscovery"))
            return null;
        if (peerAddress == null) {
            Log.e(TAG, "Cannot parse peer mac address.");
            return null;
        }
        byte[] macAddress = null;
        try {
            macAddress = NativeUtil.macAddressToByteArray(peerAddress);
        } catch (Exception e) {
            Log.e(TAG, "Could not process peer MAC address.", e);
            return null;
        }
        if (query == null) {
            Log.e(TAG, "Cannot parse service discovery query: " + query);
            return null;
        }
        ArrayList<Byte> binQuery = null;
        try {
            binQuery = NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(query));
        } catch (Exception e) {
            Log.e(TAG, "Could not parse service query.", e);
            return null;
        }
        SupplicantResult<Long> result = new SupplicantResult("requestServiceDiscovery(" + peerAddress + ", " + query + ")");
        try {
            mISupplicantP2pIface.requestServiceDiscovery(macAddress, binQuery, (SupplicantStatus status, long identifier) -> {
                result.setResult(status, new Long(identifier));
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        Long value = result.getResult();
        if (value == null)
            return null;
        return value.toString();
    }
}
#end_block

#method_before
public boolean cancelServiceDiscovery(String identifier) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelServiceDiscovery"))
            return false;
        int id = 0;
        try {
            id = Integer.parseInt(identifier);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Service discovery identifier invalid: " + identifier, e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelServiceDiscovery(" + identifier + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelServiceDiscovery(id));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean cancelServiceDiscovery(String identifier) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelServiceDiscovery"))
            return false;
        if (identifier == null) {
            Log.e(TAG, "cancelServiceDiscovery requires a valid tag.");
            return false;
        }
        int id = 0;
        try {
            id = Integer.parseInt(identifier);
        } catch (NumberFormatException e) {
            Log.e(TAG, "Service discovery identifier invalid: " + identifier, e);
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelServiceDiscovery(" + identifier + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelServiceDiscovery(id));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setMiracastMode(int mode) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setMiracastMode"))
            return false;
        byte targetMode = ISupplicantP2pIface.MiracastMode.DISABLED;
        switch(mode) {
            case 1:
                targetMode = ISupplicantP2pIface.MiracastMode.SOURCE;
                break;
            case 2:
                targetMode = ISupplicantP2pIface.MiracastMode.SINK;
                break;
        }
        SupplicantResult<Void> result = new SupplicantResult("setMiracastMode(" + mode + ")");
        try {
            result.setResult(mISupplicantP2pIface.setMiracastMode(targetMode));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setMiracastMode(int mode) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setMiracastMode"))
            return false;
        byte targetMode = ISupplicantP2pIface.MiracastMode.DISABLED;
        switch(mode) {
            case WifiP2pManager.MIRACAST_SOURCE:
                targetMode = ISupplicantP2pIface.MiracastMode.SOURCE;
                break;
            case WifiP2pManager.MIRACAST_SINK:
                targetMode = ISupplicantP2pIface.MiracastMode.SINK;
                break;
        }
        SupplicantResult<Void> result = new SupplicantResult("setMiracastMode(" + mode + ")");
        try {
            result.setResult(mISupplicantP2pIface.setMiracastMode(targetMode));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean startWpsPbc(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPbc"))
            return false;
        byte[] macAddress = stringToAddress(bssid);
        // Null values should be fine, since bssid can be empty.
        SupplicantResult<Void> result = new SupplicantResult("startWpsPbc(" + groupIfName + ", " + bssid + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPbc(groupIfName, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean startWpsPbc(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPbc"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS PBC.");
            return false;
        }
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            try {
                macAddress = NativeUtil.macAddressToByteArray(bssid);
            } catch (Exception e) {
                Log.e(TAG, "Could not parse BSSID.", e);
                return false;
            }
        }
        SupplicantResult<Void> result = new SupplicantResult("startWpsPbc(" + groupIfName + ", " + bssid + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPbc(groupIfName, macAddress));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean startWpsPinKeypad(String groupIfName, String pin) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("startWpsPinKeypad(" + groupIfName + ", " + pin + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean startWpsPinKeypad(String groupIfName, String pin) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinKeypad"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return false;
        }
        if (pin == null) {
            Log.e(TAG, "PIN required when requesting WPS KEYPAD.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("startWpsPinKeypad(" + groupIfName + ", " + pin + ")");
        try {
            result.setResult(mISupplicantP2pIface.startWpsPinKeypad(groupIfName, pin));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay"))
            return null;
        byte[] macAddress = stringToAddress(bssid);
        // Null values should be fine, since bssid can be empty.
        SupplicantResult<String> result = new SupplicantResult("startWpsPinDisplay(" + groupIfName + ", " + bssid + ")");
        try {
            mISupplicantP2pIface.startWpsPinDisplay(groupIfName, macAddress, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#method_after
public String startWpsPinDisplay(String groupIfName, String bssid) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("startWpsPinDisplay"))
            return null;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return null;
        }
        // Null values should be fine, since bssid can be empty.
        byte[] macAddress = null;
        if (bssid != null) {
            try {
                macAddress = NativeUtil.macAddressToByteArray(bssid);
            } catch (Exception e) {
                Log.e(TAG, "Could not parse BSSID.", e);
                return null;
            }
        }
        SupplicantResult<String> result = new SupplicantResult("startWpsPinDisplay(" + groupIfName + ", " + bssid + ")");
        try {
            mISupplicantP2pIface.startWpsPinDisplay(groupIfName, macAddress, (SupplicantStatus status, String generatedPin) -> {
                result.setResult(status, generatedPin);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.getResult();
    }
}
#end_block

#method_before
public boolean cancelWps(String groupIfName) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelWps"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("cancelWps(" + groupIfName + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelWps(groupIfName));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean cancelWps(String groupIfName) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("cancelWps"))
            return false;
        if (groupIfName == null) {
            Log.e(TAG, "Group name required when requesting WPS KEYPAD.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("cancelWps(" + groupIfName + ")");
        try {
            result.setResult(mISupplicantP2pIface.cancelWps(groupIfName));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean setWfdDeviceInfo(String info) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setWfdDeviceInfo"))
            return false;
        byte[] wfdInfo = hexStringToByteArray(info);
        SupplicantResult<Void> result = new SupplicantResult("setWfdDeviceInfo(" + info + ")");
        try {
            result.setResult(mISupplicantP2pIface.setWfdDeviceInfo(wfdInfo));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setWfdDeviceInfo(String info) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setWfdDeviceInfo"))
            return false;
        if (info == null) {
            Log.e(TAG, "Cannot parse null WFD info string.");
            return false;
        }
        byte[] wfdInfo = null;
        try {
            wfdInfo = NativeUtil.hexStringToByteArray(info);
        } catch (Exception e) {
            Log.e(TAG, "Could not parse WFD Device Info string.");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setWfdDeviceInfo(" + info + ")");
        try {
            result.setResult(mISupplicantP2pIface.setWfdDeviceInfo(wfdInfo));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public void setResult(SupplicantStatus status, E value) {
    logCompletion(mMethodName, status);
    logd("leaving " + mMethodName);
    mStatus = status;
    mValue = value;
}
#method_after
public void setResult(SupplicantStatus status, E value) {
    logCompletion(mMethodName, status);
    logd("leaving " + mMethodName + " with result = " + value);
    mStatus = status;
    mValue = value;
}
#end_block

#method_before
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        DBG = true;
    } else {
        DBG = false;
    }
}
#method_after
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        DBG = true;
    } else {
        DBG = false;
    }
    if (mWificondControl != null) {
        mWificondControl.enableVerboseLogging(verbose > 0 ? true : false);
    }
    if (mSupplicantStaIfaceHal != null) {
        mSupplicantStaIfaceHal.enableVerboseLogging(verbose > 0);
    }
}
#end_block

#method_before
public boolean connectToSupplicant() {
    synchronized (sLock) {
        localLog(mInterfacePrefix + "connectToSupplicant");
        return connectToSupplicantNative();
    }
}
#method_after
public boolean connectToSupplicant() {
    if (HIDL_SUP_ENABLE) {
        // Start initialization if not already started.
        if (!mSupplicantP2pIfaceHal.isInitializationStarted() && !mSupplicantP2pIfaceHal.initialize()) {
            return false;
        }
        if (!mSupplicantStaIfaceHal.isInitializationStarted() && !mSupplicantStaIfaceHal.initialize()) {
            return false;
        }
        // Check if the initialization is complete.
        return (mSupplicantP2pIfaceHal.isInitializationComplete() && mSupplicantStaIfaceHal.isInitializationComplete());
    } else {
        synchronized (sLock) {
            localLog(mInterfacePrefix + "connectToSupplicant");
            return connectToSupplicantNative();
        }
    }
}
#end_block

#method_before
public void closeSupplicantConnection() {
    synchronized (sLock) {
        localLog(mInterfacePrefix + "closeSupplicantConnection");
        closeSupplicantConnectionNative();
    }
}
#method_after
public void closeSupplicantConnection() {
    if (HIDL_SUP_ENABLE) {
    // Nothing to do for HIDL.
    } else {
        synchronized (sLock) {
            localLog(mInterfacePrefix + "closeSupplicantConnection");
            closeSupplicantConnectionNative();
        }
    }
}
#end_block

#method_before
public void setSupplicantLogLevel(String level) {
    doStringCommand("LOG_LEVEL " + level);
}
#method_after
/*
     * Wrappers for supplicant commands
     */
public void setSupplicantLogLevel(boolean turnOnVerbose) {
    if (HIDL_SUP_ENABLE) {
        int logLevel = turnOnVerbose ? SupplicantStaIfaceHal.LOG_LEVEL_DEBUG : SupplicantStaIfaceHal.LOG_LEVEL_INFO;
        mSupplicantStaIfaceHal.setLogLevel(logLevel);
    } else {
        doStringCommand("LOG_LEVEL " + (turnOnVerbose ? "DEBUG" : "INFO"));
    }
}
#end_block

#method_before
public boolean scan(Set<Integer> freqs, Set<String> hiddenNetworkSSIDs) {
    String freqList = null;
    String hiddenNetworkSSIDList = null;
    if (freqs != null && freqs.size() != 0) {
        freqList = TextUtils.join(",", freqs);
    }
    if (hiddenNetworkSSIDs != null && hiddenNetworkSSIDs.size() != 0) {
        StringBuilder ssidList = new StringBuilder();
        for (String ssid : hiddenNetworkSSIDs) {
            ssidList.append(encodeSSID(ssid)).append(" ");
        }
        hiddenNetworkSSIDList = ssidList.toString();
    }
    return scanWithParams(freqList, hiddenNetworkSSIDList);
}
#method_after
public boolean scan(Set<Integer> freqs, Set<String> hiddenNetworkSSIDs) {
    return mWificondControl.scan(freqs, hiddenNetworkSSIDs);
}
#end_block

#method_before
public Map<String, String> getNetworkExtra(int netId, String name) {
    final String extraString = getNetworkVariable(netId, name);
    return parseNetworkExtra(extraString);
}
#method_after
public Map<String, String> getNetworkExtra(int netId, String name) {
    final String extraString = getNetworkVariable(netId, name);
    if (extraString == null || !extraString.startsWith("\"") || !extraString.endsWith("\"")) {
        return null;
    }
    return parseNetworkExtra(NativeUtil.removeEnclosingQuotes(extraString));
}
#end_block

#method_before
public static Map<String, String> parseNetworkExtra(String extraSting) {
    if (extraSting == null || !extraSting.startsWith("\"") || !extraSting.endsWith("\"")) {
        return null;
    }
    try {
        final String encoded = extraSting.substring(1, extraSting.length() - 1);
        // This method reads a JSON dictionary that was written by setNetworkExtra(). However,
        // on devices that upgraded from Marshmallow, it may encounter a legacy value instead -
        // an FQDN stored as a plain string. If such a value is encountered, the JSONObject
        // constructor will thrown a JSONException and the method will return null.
        final JSONObject json = new JSONObject(URLDecoder.decode(encoded, "UTF-8"));
        final Map<String, String> values = new HashMap<>();
        final Iterator<?> it = json.keys();
        while (it.hasNext()) {
            final String key = (String) it.next();
            final Object value = json.get(key);
            if (value instanceof String) {
                values.put(key, (String) value);
            }
        }
        return values;
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, "Unable to deserialize networkExtra: " + e.toString());
        return null;
    } catch (JSONException e) {
        // dictionary of extras was found.
        return null;
    }
}
#method_after
public static Map<String, String> parseNetworkExtra(String encoded) {
    if (TextUtils.isEmpty(encoded)) {
        return null;
    }
    try {
        // This method reads a JSON dictionary that was written by setNetworkExtra(). However,
        // on devices that upgraded from Marshmallow, it may encounter a legacy value instead -
        // an FQDN stored as a plain string. If such a value is encountered, the JSONObject
        // constructor will thrown a JSONException and the method will return null.
        final JSONObject json = new JSONObject(URLDecoder.decode(encoded, "UTF-8"));
        final Map<String, String> values = new HashMap<>();
        final Iterator<?> it = json.keys();
        while (it.hasNext()) {
            final String key = (String) it.next();
            final Object value = json.get(key);
            if (value instanceof String) {
                values.put(key, (String) value);
            }
        }
        return values;
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, "Unable to deserialize networkExtra: " + e.toString());
        return null;
    } catch (JSONException e) {
        // dictionary of extras was found.
        return null;
    }
}
#end_block

#method_before
public boolean reconnect() {
    if (DBG)
        logDbg("RECONNECT ");
    return doBooleanCommand("RECONNECT");
}
#method_after
public boolean reconnect() {
    if (DBG)
        logDbg("RECONNECT ");
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.reconnect();
    } else {
        return doBooleanCommand("RECONNECT");
    }
}
#end_block

#method_before
public boolean reassociate() {
    if (DBG)
        logDbg("REASSOCIATE ");
    return doBooleanCommand("REASSOCIATE");
}
#method_after
public boolean reassociate() {
    if (DBG)
        logDbg("REASSOCIATE ");
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.reassociate();
    } else {
        return doBooleanCommand("REASSOCIATE");
    }
}
#end_block

#method_before
public boolean disconnect() {
    if (DBG)
        logDbg("DISCONNECT ");
    return doBooleanCommand("DISCONNECT");
}
#method_after
public boolean disconnect() {
    if (DBG)
        logDbg("DISCONNECT ");
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.disconnect();
    } else {
        return doBooleanCommand("DISCONNECT");
    }
}
#end_block

#method_before
public String getMacAddress() {
    // Macaddr = XX.XX.XX.XX.XX.XX
    String ret = doStringCommand("DRIVER MACADDR");
    if (!TextUtils.isEmpty(ret)) {
        String[] tokens = ret.split(" = ");
        if (tokens.length == 2)
            return tokens[1];
    }
    return null;
}
#method_after
public String getMacAddress() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.getMacAddress();
    } else {
        // Macaddr = XX.XX.XX.XX.XX.XX
        String ret = doStringCommand("DRIVER MACADDR");
        if (!TextUtils.isEmpty(ret)) {
            String[] tokens = ret.split(" = ");
            if (tokens.length == 2)
                return tokens[1];
        }
        return null;
    }
}
#end_block

#method_before
public ArrayList<ScanDetail> getScanResults() {
    int next_sid = 0;
    ArrayList<ScanDetail> results = new ArrayList<>();
    while (next_sid >= 0) {
        String rawResult = getRawScanResults(next_sid + "-");
        next_sid = -1;
        if (TextUtils.isEmpty(rawResult))
            break;
        String[] lines = rawResult.split("\n");
        // note that all these splits and substrings keep references to the original
        // huge string buffer while the amount we really want is generally pretty small
        // so make copies instead (one example b/11087956 wasted 400k of heap here).
        final int bssidStrLen = BSS_BSSID_STR.length();
        String bssid = "";
        int level = 0;
        int freq = 0;
        long tsf = 0;
        int cap = 0;
        String flags = "";
        WifiSsid wifiSsid = null;
        String infoElementsStr = null;
        List<String> anqpLines = null;
        for (String line : lines) {
            if (line.startsWith(BSS_ID_STR)) {
                // Will find the last id line
                try {
                    next_sid = Integer.parseInt(line.substring(BSS_ID_STR.length())) + 1;
                } catch (NumberFormatException e) {
                // Nothing to do
                }
            } else if (line.startsWith(BSS_BSSID_STR)) {
                bssid = new String(line.getBytes(), bssidStrLen, line.length() - bssidStrLen);
            } else if (line.startsWith(BSS_FREQ_STR)) {
                try {
                    freq = Integer.parseInt(line.substring(BSS_FREQ_STR.length()));
                } catch (NumberFormatException e) {
                    freq = 0;
                }
            } else if (line.startsWith(BSS_LEVEL_STR)) {
                try {
                    level = Integer.parseInt(line.substring(BSS_LEVEL_STR.length()));
                    /* some implementations avoid negative values by adding 256
                         * so we need to adjust for that here.
                         */
                    if (level > 0)
                        level -= 256;
                } catch (NumberFormatException e) {
                    level = 0;
                }
            } else if (line.startsWith(BSS_TSF_STR)) {
                try {
                    tsf = Long.parseLong(line.substring(BSS_TSF_STR.length()));
                } catch (NumberFormatException e) {
                    tsf = 0;
                }
            } else if (line.startsWith(BSS_CAPABILITIES_STR)) {
                try {
                    cap = Integer.decode(line.substring(BSS_CAPABILITIES_STR.length()));
                } catch (NumberFormatException e) {
                    cap = 0;
                }
            } else if (line.startsWith(BSS_SSID_STR)) {
                wifiSsid = WifiSsid.createFromAsciiEncoded(line.substring(BSS_SSID_STR.length()));
            } else if (line.startsWith(BSS_IE_STR)) {
                infoElementsStr = line;
            } else if (PasspointEventHandler.isAnqpAttribute(line)) {
                if (anqpLines == null) {
                    anqpLines = new ArrayList<>();
                }
                anqpLines.add(line);
            } else if (line.startsWith(BSS_DELIMITER_STR) || line.startsWith(BSS_END_STR)) {
                if (bssid != null) {
                    try {
                        if (infoElementsStr == null) {
                            throw new IllegalArgumentException("Null information element data");
                        }
                        int seperator = infoElementsStr.indexOf('=');
                        if (seperator < 0) {
                            throw new IllegalArgumentException("No element separator");
                        }
                        ScanResult.InformationElement[] infoElements = InformationElementUtil.parseInformationElements(Utils.hexToBytes(infoElementsStr.substring(seperator + 1)));
                        NetworkDetail networkDetail = new NetworkDetail(bssid, infoElements, anqpLines, freq);
                        String xssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
                        if (!xssid.equals(networkDetail.getTrimmedSSID())) {
                            Log.d(TAG, String.format("Inconsistent SSID on BSSID '%s': '%s' vs '%s': %s", bssid, xssid, networkDetail.getSSID(), infoElementsStr));
                        }
                        if (networkDetail.hasInterworking()) {
                            if (DBG)
                                Log.d(TAG, "HSNwk: '" + networkDetail);
                        }
                        BitSet beaconCapBits = new BitSet(16);
                        for (int i = 0; i < 16; i++) {
                            if ((cap & (1 << i)) != 0) {
                                beaconCapBits.set(i);
                            }
                        }
                        InformationElementUtil.Capabilities capabilities = new InformationElementUtil.Capabilities();
                        capabilities.from(infoElements, beaconCapBits);
                        flags = capabilities.generateCapabilitiesString();
                        ScanDetail scan = new ScanDetail(networkDetail, wifiSsid, bssid, flags, level, freq, tsf, infoElements, anqpLines);
                        results.add(scan);
                    } catch (IllegalArgumentException iae) {
                        Log.d(TAG, "Failed to parse information elements: " + iae);
                    }
                }
                bssid = null;
                level = 0;
                freq = 0;
                tsf = 0;
                cap = 0;
                flags = "";
                wifiSsid = null;
                infoElementsStr = null;
                anqpLines = null;
            }
        }
    }
    return results;
}
#method_after
public ArrayList<ScanDetail> getScanResults() {
    return mWificondControl.getScanResults();
}
#end_block

#method_before
public boolean startFilteringMulticastV4Packets() {
    return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-REMOVE 2") && doBooleanCommand("DRIVER RXFILTER-START");
}
#method_after
public boolean startFilteringMulticastV4Packets() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter();
    } else {
        return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-REMOVE 2") && doBooleanCommand("DRIVER RXFILTER-START");
    }
}
#end_block

#method_before
public boolean stopFilteringMulticastV4Packets() {
    return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-ADD 2") && doBooleanCommand("DRIVER RXFILTER-START");
}
#method_after
public boolean stopFilteringMulticastV4Packets() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter();
    } else {
        return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-ADD 2") && doBooleanCommand("DRIVER RXFILTER-START");
    }
}
#end_block

#method_before
public boolean startFilteringMulticastV6Packets() {
    return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-REMOVE 3") && doBooleanCommand("DRIVER RXFILTER-START");
}
#method_after
public boolean startFilteringMulticastV6Packets() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter();
    } else {
        return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-REMOVE 3") && doBooleanCommand("DRIVER RXFILTER-START");
    }
}
#end_block

#method_before
public boolean stopFilteringMulticastV6Packets() {
    return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-ADD 3") && doBooleanCommand("DRIVER RXFILTER-START");
}
#method_after
public boolean stopFilteringMulticastV6Packets() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.stopRxFilter();
    } else {
        return doBooleanCommand("DRIVER RXFILTER-STOP") && doBooleanCommand("DRIVER RXFILTER-ADD 3") && doBooleanCommand("DRIVER RXFILTER-START");
    }
}
#end_block

#method_before
public boolean setBluetoothCoexistenceMode(int mode) {
    return doBooleanCommand("DRIVER BTCOEXMODE " + mode);
}
#method_after
public boolean setBluetoothCoexistenceMode(int mode) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setBtCoexistenceMode((byte) mode);
    } else {
        return doBooleanCommand("DRIVER BTCOEXMODE " + mode);
    }
}
#end_block

#method_before
public boolean setBluetoothCoexistenceScanMode(boolean setCoexScanMode) {
    if (setCoexScanMode) {
        return doBooleanCommand("DRIVER BTCOEXSCAN-START");
    } else {
        return doBooleanCommand("DRIVER BTCOEXSCAN-STOP");
    }
}
#method_after
public boolean setBluetoothCoexistenceScanMode(boolean setCoexScanMode) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setBtCoexistenceScanModeEnabled(setCoexScanMode);
    } else {
        if (setCoexScanMode) {
            return doBooleanCommand("DRIVER BTCOEXSCAN-START");
        } else {
            return doBooleanCommand("DRIVER BTCOEXSCAN-STOP");
        }
    }
}
#end_block

#method_before
public boolean setSuspendOptimizations(boolean enabled) {
    if (enabled) {
        return doBooleanCommand("DRIVER SETSUSPENDMODE 1");
    } else {
        return doBooleanCommand("DRIVER SETSUSPENDMODE 0");
    }
}
#method_after
public boolean setSuspendOptimizations(boolean enabled) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setSuspendModeEnabled(enabled);
    } else {
        if (enabled) {
            return doBooleanCommand("DRIVER SETSUSPENDMODE 1");
        } else {
            return doBooleanCommand("DRIVER SETSUSPENDMODE 0");
        }
    }
}
#end_block

#method_before
public boolean setCountryCode(String countryCode) {
    if (countryCode != null)
        return doBooleanCommand("DRIVER COUNTRY " + countryCode.toUpperCase(Locale.ROOT));
    else
        return doBooleanCommand("DRIVER COUNTRY");
}
#method_after
public boolean setCountryCode(String countryCode) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setCountryCode(countryCode);
    } else {
        if (countryCode != null) {
            return doBooleanCommand("DRIVER COUNTRY " + countryCode.toUpperCase(Locale.ROOT));
        } else {
            return doBooleanCommand("DRIVER COUNTRY");
        }
    }
}
#end_block

#method_before
public void startTdls(String macAddr, boolean enable) {
    if (enable) {
        synchronized (sLock) {
            doBooleanCommand("TDLS_DISCOVER " + macAddr);
            doBooleanCommand("TDLS_SETUP " + macAddr);
        }
    } else {
        doBooleanCommand("TDLS_TEARDOWN " + macAddr);
    }
}
#method_after
public void startTdls(String macAddr, boolean enable) {
    if (HIDL_SUP_ENABLE) {
        if (enable) {
            mSupplicantStaIfaceHal.initiateTdlsDiscover(macAddr);
            mSupplicantStaIfaceHal.initiateTdlsSetup(macAddr);
        } else {
            mSupplicantStaIfaceHal.initiateTdlsTeardown(macAddr);
        }
    } else {
        if (enable) {
            synchronized (sLock) {
                doBooleanCommand("TDLS_DISCOVER " + macAddr);
                doBooleanCommand("TDLS_SETUP " + macAddr);
            }
        } else {
            doBooleanCommand("TDLS_TEARDOWN " + macAddr);
        }
    }
}
#end_block

#method_before
public boolean startWpsPbc(String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPbc(null, bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doBooleanCommand("WPS_PBC");
        } else {
            return doBooleanCommand("WPS_PBC " + bssid);
        }
    }
}
#method_after
public boolean startWpsPbc(String bssid) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.startWpsPbc(bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doBooleanCommand("WPS_PBC");
        } else {
            return doBooleanCommand("WPS_PBC " + bssid);
        }
    }
}
#end_block

#method_before
public boolean startWpsPbc(String iface, String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPbc(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC " + bssid);
            }
        }
    }
}
#method_after
public boolean startWpsPbc(String iface, String bssid) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPbc(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC " + bssid);
            }
        }
    }
}
#end_block

#method_before
public boolean startWpsPinKeypad(String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinKeypad(null, pin);
    } else {
        return doBooleanCommand("WPS_PIN any " + pin);
    }
}
#method_after
public boolean startWpsPinKeypad(String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.startWpsPinKeypad(pin);
    } else {
        return doBooleanCommand("WPS_PIN any " + pin);
    }
}
#end_block

#method_before
public boolean startWpsPinKeypad(String iface, String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinKeypad(iface, pin);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PIN any " + pin);
        }
    }
}
#method_after
public boolean startWpsPinKeypad(String iface, String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinKeypad(iface, pin);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PIN any " + pin);
        }
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinDisplay(null, bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doStringCommand("WPS_PIN any");
        } else {
            return doStringCommand("WPS_PIN " + bssid);
        }
    }
}
#method_after
public String startWpsPinDisplay(String bssid) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.startWpsPinDisplay(bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doStringCommand("WPS_PIN any");
        } else {
            return doStringCommand("WPS_PIN " + bssid);
        }
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String iface, String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinDisplay(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN any");
            } else {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN " + bssid);
            }
        }
    }
}
#method_after
public String startWpsPinDisplay(String iface, String bssid) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinDisplay(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN any");
            } else {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN " + bssid);
            }
        }
    }
}
#end_block

#method_before
public boolean setExternalSim(boolean external) {
    String value = external ? "1" : "0";
    Log.d(TAG, "Setting external_sim to " + value);
    return doBooleanCommand("SET external_sim " + value);
}
#method_after
public boolean setExternalSim(boolean external) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setExternalSim(external);
    } else {
        String value = external ? "1" : "0";
        Log.d(TAG, "Setting external_sim to " + value);
        return doBooleanCommand("SET external_sim " + value);
    }
}
#end_block

#method_before
public boolean simAuthResponse(int id, String type, String response) {
    // with type = GSM-AUTH, UMTS-AUTH or UMTS-AUTS
    return doBooleanCommand("CTRL-RSP-SIM-" + id + ":" + type + response);
}
#method_after
public boolean simAuthResponse(int id, String type, String response) {
    if (HIDL_SUP_ENABLE) {
        if ("GSM-AUTH".equals(type)) {
            return mSupplicantStaIfaceHal.sendCurrentNetworkEapSimGsmAuthResponse(response);
        } else if ("UMTS-AUTH".equals(type)) {
            return mSupplicantStaIfaceHal.sendCurrentNetworkEapSimUmtsAuthResponse(response);
        } else if ("UMTS-AUTS".equals(type)) {
            return mSupplicantStaIfaceHal.sendCurrentNetworkEapSimUmtsAuthResponse(response);
        } else {
            return false;
        }
    } else {
        // with type = GSM-AUTH, UMTS-AUTH or UMTS-AUTS
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":" + type + response);
    }
}
#end_block

#method_before
public boolean simAuthFailedResponse(int id) {
    // should be used with type GSM-AUTH
    return doBooleanCommand("CTRL-RSP-SIM-" + id + ":GSM-FAIL");
}
#method_after
public boolean simAuthFailedResponse(int id) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.sendCurrentNetworkEapSimGsmAuthFailure();
    } else {
        // should be used with type GSM-AUTH
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":GSM-FAIL");
    }
}
#end_block

#method_before
public boolean umtsAuthFailedResponse(int id) {
    // should be used with type UMTS-AUTH
    return doBooleanCommand("CTRL-RSP-SIM-" + id + ":UMTS-FAIL");
}
#method_after
public boolean umtsAuthFailedResponse(int id) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.sendCurrentNetworkEapSimUmtsAuthFailure();
    } else {
        // should be used with type UMTS-AUTH
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":UMTS-FAIL");
    }
}
#end_block

#method_before
public boolean simIdentityResponse(int id, String response) {
    return doBooleanCommand("CTRL-RSP-IDENTITY-" + id + ":" + response);
}
#method_after
public boolean simIdentityResponse(int id, String response) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.sendCurrentNetworkEapIdentityResponse(response);
    } else {
        return doBooleanCommand("CTRL-RSP-IDENTITY-" + id + ":" + response);
    }
}
#end_block

#method_before
public boolean startWpsRegistrar(String bssid, String pin) {
    if (TextUtils.isEmpty(bssid) || TextUtils.isEmpty(pin))
        return false;
    return doBooleanCommand("WPS_REG " + bssid + " " + pin);
}
#method_after
public boolean startWpsRegistrar(String bssid, String pin) {
    if (TextUtils.isEmpty(bssid) || TextUtils.isEmpty(pin))
        return false;
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.startWpsRegistrar(bssid, pin);
    } else {
        return doBooleanCommand("WPS_REG " + bssid + " " + pin);
    }
}
#end_block

#method_before
public boolean cancelWps() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelWps(null);
    } else {
        return doBooleanCommand("WPS_CANCEL");
    }
}
#method_after
public boolean cancelWps() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.cancelWps();
    } else {
        return doBooleanCommand("WPS_CANCEL");
    }
}
#end_block

#method_before
public boolean setDeviceName(String name) {
    return doBooleanCommand("SET device_name " + name);
}
#method_after
public boolean setDeviceName(String name) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsDeviceName(name);
    } else {
        return doBooleanCommand("SET device_name " + name);
    }
}
#end_block

#method_before
public boolean setDeviceType(String type) {
    return doBooleanCommand("SET device_type " + type);
}
#method_after
public boolean setDeviceType(String type) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsDeviceType(type);
    } else {
        return doBooleanCommand("SET device_type " + type);
    }
}
#end_block

#method_before
public boolean setConfigMethods(String cfg) {
    return doBooleanCommand("SET config_methods " + cfg);
}
#method_after
public boolean setConfigMethods(String cfg) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsConfigMethods(cfg);
    } else {
        return doBooleanCommand("SET config_methods " + cfg);
    }
}
#end_block

#method_before
public boolean setManufacturer(String value) {
    return doBooleanCommand("SET manufacturer " + value);
}
#method_after
public boolean setManufacturer(String value) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsManufacturer(value);
    } else {
        return doBooleanCommand("SET manufacturer " + value);
    }
}
#end_block

#method_before
public boolean setModelName(String value) {
    return doBooleanCommand("SET model_name " + value);
}
#method_after
public boolean setModelName(String value) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsModelName(value);
    } else {
        return doBooleanCommand("SET model_name " + value);
    }
}
#end_block

#method_before
public boolean setModelNumber(String value) {
    return doBooleanCommand("SET model_number " + value);
}
#method_after
public boolean setModelNumber(String value) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsModelNumber(value);
    } else {
        return doBooleanCommand("SET model_number " + value);
    }
}
#end_block

#method_before
public boolean setSerialNumber(String value) {
    return doBooleanCommand("SET serial_number " + value);
}
#method_after
public boolean setSerialNumber(String value) {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.setWpsSerialNumber(value);
    } else {
        return doBooleanCommand("SET serial_number " + value);
    }
}
#end_block

#method_before
public boolean setP2pSsidPostfix(String postfix) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setSsidPostfix(postfix);
    } else {
        return doBooleanCommand("SET p2p_ssid_postfix " + postfix);
    }
}
#method_after
public boolean setP2pSsidPostfix(String postfix) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setSsidPostfix(postfix);
    } else {
        return doBooleanCommand("SET p2p_ssid_postfix " + postfix);
    }
}
#end_block

#method_before
public boolean setP2pGroupIdle(String iface, int time) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setGroupIdle(iface, time);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " SET p2p_group_idle " + time);
        }
    }
}
#method_after
public boolean setP2pGroupIdle(String iface, int time) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setGroupIdle(iface, time);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " SET p2p_group_idle " + time);
        }
    }
}
#end_block

#method_before
public void setPowerSave(boolean enabled) {
    if (enabled) {
        doBooleanCommand("SET ps 1");
    } else {
        doBooleanCommand("SET ps 0");
    }
}
#method_after
public void setPowerSave(boolean enabled) {
    if (HIDL_SUP_ENABLE) {
        mSupplicantStaIfaceHal.setPowerSave(enabled);
    } else {
        if (enabled) {
            doBooleanCommand("SET ps 1");
        } else {
            doBooleanCommand("SET ps 0");
        }
    }
}
#end_block

#method_before
public boolean setP2pPowerSave(String iface, boolean enabled) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setPowerSave(iface, enabled);
    } else {
        synchronized (sLock) {
            if (enabled) {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 1");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 0");
            }
        }
    }
}
#method_after
public boolean setP2pPowerSave(String iface, boolean enabled) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setPowerSave(iface, enabled);
    } else {
        synchronized (sLock) {
            if (enabled) {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 1");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 0");
            }
        }
    }
}
#end_block

#method_before
public boolean setWfdEnable(boolean enable) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.enableWfd(enable);
    } else {
        return doBooleanCommand("SET wifi_display " + (enable ? "1" : "0"));
    }
}
#method_after
public boolean setWfdEnable(boolean enable) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.enableWfd(enable);
    } else {
        return doBooleanCommand("SET wifi_display " + (enable ? "1" : "0"));
    }
}
#end_block

#method_before
public boolean setWfdDeviceInfo(String hex) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex);
    } else {
        return doBooleanCommand("WFD_SUBELEM_SET 0 " + hex);
    }
}
#method_after
public boolean setWfdDeviceInfo(String hex) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex);
    } else {
        return doBooleanCommand("WFD_SUBELEM_SET 0 " + hex);
    }
}
#end_block

#method_before
public boolean p2pFind() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find();
    } else {
        return doBooleanCommand("P2P_FIND");
    }
}
#method_after
public boolean p2pFind() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find();
    } else {
        return doBooleanCommand("P2P_FIND");
    }
}
#end_block

#method_before
public boolean p2pFind(int timeout) {
    if (timeout <= 0) {
        return p2pFind();
    }
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find(timeout);
    } else {
        return doBooleanCommand("P2P_FIND " + timeout);
    }
}
#method_after
public boolean p2pFind(int timeout) {
    if (timeout <= 0) {
        return p2pFind();
    }
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find(timeout);
    } else {
        return doBooleanCommand("P2P_FIND " + timeout);
    }
}
#end_block

#method_before
public boolean p2pStopFind() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.stopFind();
    } else {
        return doBooleanCommand("P2P_STOP_FIND");
    }
}
#method_after
public boolean p2pStopFind() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.stopFind();
    } else {
        return doBooleanCommand("P2P_STOP_FIND");
    }
}
#end_block

#method_before
public boolean p2pExtListen(boolean enable, int period, int interval) {
    if (enable && interval < period) {
        return false;
    }
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.configureExtListen(enable, period, interval);
    } else {
        return doBooleanCommand("P2P_EXT_LISTEN" + (enable ? (" " + period + " " + interval) : ""));
    }
}
#method_after
public boolean p2pExtListen(boolean enable, int period, int interval) {
    if (enable && interval < period) {
        return false;
    }
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.configureExtListen(enable, period, interval);
    } else {
        return doBooleanCommand("P2P_EXT_LISTEN" + (enable ? (" " + period + " " + interval) : ""));
    }
}
#end_block

#method_before
public boolean p2pSetChannel(int lc, int oc) {
    if (DBG)
        Log.d(mTAG, "p2pSetChannel: lc=" + lc + ", oc=" + oc);
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setListenChannel(lc, oc);
    } else {
        synchronized (sLock) {
            if (lc >= 1 && lc <= 11) {
                if (!doBooleanCommand("P2P_SET listen_channel " + lc)) {
                    return false;
                }
            } else if (lc != 0) {
                return false;
            }
            if (oc >= 1 && oc <= 165) {
                int freq = (oc <= 14 ? 2407 : 5000) + oc * 5;
                return doBooleanCommand("P2P_SET disallow_freq 1000-" + (freq - 5) + "," + (freq + 5) + "-6000");
            } else if (oc == 0) {
                /* oc==0 disables "P2P_SET disallow_freq" (enables all freqs) */
                return doBooleanCommand("P2P_SET disallow_freq \"\"");
            }
        }
        return false;
    }
}
#method_after
public boolean p2pSetChannel(int lc, int oc) {
    if (DBG)
        Log.d(mTAG, "p2pSetChannel: lc=" + lc + ", oc=" + oc);
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setListenChannel(lc, oc);
    } else {
        synchronized (sLock) {
            if (lc >= 1 && lc <= 11) {
                if (!doBooleanCommand("P2P_SET listen_channel " + lc)) {
                    return false;
                }
            } else if (lc != 0) {
                return false;
            }
            if (oc >= 1 && oc <= 165) {
                int freq = (oc <= 14 ? 2407 : 5000) + oc * 5;
                return doBooleanCommand("P2P_SET disallow_freq 1000-" + (freq - 5) + "," + (freq + 5) + "-6000");
            } else if (oc == 0) {
                /* oc==0 disables "P2P_SET disallow_freq" (enables all freqs) */
                return doBooleanCommand("P2P_SET disallow_freq \"\"");
            }
        }
        return false;
    }
}
#end_block

#method_before
public boolean p2pFlush() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.flush();
    } else {
        return doBooleanCommand("P2P_FLUSH");
    }
}
#method_after
public boolean p2pFlush() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.flush();
    } else {
        return doBooleanCommand("P2P_FLUSH");
    }
}
#end_block

#method_before
public String p2pConnect(WifiP2pConfig config, boolean joinExistingGroup) {
    if (config == null)
        return null;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.connect(config, joinExistingGroup);
    } else {
        List<String> args = new ArrayList<>();
        WpsInfo wps = config.wps;
        args.add(config.deviceAddress);
        switch(wps.setup) {
            case WpsInfo.PBC:
                args.add("pbc");
                break;
            case WpsInfo.DISPLAY:
                if (TextUtils.isEmpty(wps.pin)) {
                    args.add("pin");
                } else {
                    args.add(wps.pin);
                }
                args.add("display");
                break;
            case WpsInfo.KEYPAD:
                args.add(wps.pin);
                args.add("keypad");
                break;
            case WpsInfo.LABEL:
                args.add(wps.pin);
                args.add("label");
            default:
                break;
        }
        if (config.netId == WifiP2pGroup.PERSISTENT_NET_ID) {
            args.add("persistent");
        }
        if (joinExistingGroup) {
            args.add("join");
        } else {
            // TODO: This can be adapted based on device plugged in state and
            // device battery state
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
            args.add("go_intent=" + groupOwnerIntent);
        }
        String command = "P2P_CONNECT ";
        for (String s : args) command += s + " ";
        return doStringCommand(command);
    }
}
#method_after
public String p2pConnect(WifiP2pConfig config, boolean joinExistingGroup) {
    if (config == null)
        return null;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.connect(config, joinExistingGroup);
    } else {
        List<String> args = new ArrayList<>();
        WpsInfo wps = config.wps;
        args.add(config.deviceAddress);
        switch(wps.setup) {
            case WpsInfo.PBC:
                args.add("pbc");
                break;
            case WpsInfo.DISPLAY:
                if (TextUtils.isEmpty(wps.pin)) {
                    args.add("pin");
                } else {
                    args.add(wps.pin);
                }
                args.add("display");
                break;
            case WpsInfo.KEYPAD:
                args.add(wps.pin);
                args.add("keypad");
                break;
            case WpsInfo.LABEL:
                args.add(wps.pin);
                args.add("label");
            default:
                break;
        }
        if (config.netId == WifiP2pGroup.PERSISTENT_NET_ID) {
            args.add("persistent");
        }
        if (joinExistingGroup) {
            args.add("join");
        } else {
            // TODO: This can be adapted based on device plugged in state and
            // device battery state
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
            args.add("go_intent=" + groupOwnerIntent);
        }
        String command = "P2P_CONNECT ";
        for (String s : args) command += s + " ";
        return doStringCommand(command);
    }
}
#end_block

#method_before
public boolean p2pCancelConnect() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelConnect();
    } else {
        return doBooleanCommand("P2P_CANCEL");
    }
}
#method_after
public boolean p2pCancelConnect() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelConnect();
    } else {
        return doBooleanCommand("P2P_CANCEL");
    }
}
#end_block

#method_before
public boolean p2pProvisionDiscovery(WifiP2pConfig config) {
    if (config == null)
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.provisionDiscovery(config);
    } else {
        switch(config.wps.setup) {
            case WpsInfo.PBC:
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " pbc");
            case WpsInfo.DISPLAY:
                // We are doing display, so provision discovery is keypad
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " keypad");
            case WpsInfo.KEYPAD:
                // We are doing keypad, so provision discovery is display
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " display");
            default:
                break;
        }
        return false;
    }
}
#method_after
public boolean p2pProvisionDiscovery(WifiP2pConfig config) {
    if (config == null)
        return false;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.provisionDiscovery(config);
    } else {
        switch(config.wps.setup) {
            case WpsInfo.PBC:
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " pbc");
            case WpsInfo.DISPLAY:
                // We are doing display, so provision discovery is keypad
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " keypad");
            case WpsInfo.KEYPAD:
                // We are doing keypad, so provision discovery is display
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " display");
            default:
                break;
        }
        return false;
    }
}
#end_block

#method_before
public boolean p2pGroupAdd(boolean persistent) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(persistent);
    } else {
        if (persistent) {
            return doBooleanCommand("P2P_GROUP_ADD persistent");
        }
        return doBooleanCommand("P2P_GROUP_ADD");
    }
}
#method_after
public boolean p2pGroupAdd(boolean persistent) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(persistent);
    } else {
        if (persistent) {
            return doBooleanCommand("P2P_GROUP_ADD persistent");
        }
        return doBooleanCommand("P2P_GROUP_ADD");
    }
}
#end_block

#method_before
public boolean p2pGroupAdd(int netId) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(netId, true);
    } else {
        return doBooleanCommand("P2P_GROUP_ADD persistent=" + netId);
    }
}
#method_after
public boolean p2pGroupAdd(int netId) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(netId, true);
    } else {
        return doBooleanCommand("P2P_GROUP_ADD persistent=" + netId);
    }
}
#end_block

#method_before
public boolean p2pGroupRemove(String iface) {
    if (TextUtils.isEmpty(iface))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupRemove(iface);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_GROUP_REMOVE " + iface);
        }
    }
}
#method_after
public boolean p2pGroupRemove(String iface) {
    if (TextUtils.isEmpty(iface))
        return false;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupRemove(iface);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_GROUP_REMOVE " + iface);
        }
    }
}
#end_block

#method_before
public boolean p2pReject(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reject(deviceAddress);
    } else {
        return doBooleanCommand("P2P_REJECT " + deviceAddress);
    }
}
#method_after
public boolean p2pReject(String deviceAddress) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reject(deviceAddress);
    } else {
        return doBooleanCommand("P2P_REJECT " + deviceAddress);
    }
}
#end_block

#method_before
public boolean p2pInvite(WifiP2pGroup group, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.invite(group, deviceAddress);
    } else {
        if (group == null) {
            return doBooleanCommand("P2P_INVITE peer=" + deviceAddress);
        } else {
            return doBooleanCommand("P2P_INVITE group=" + group.getInterface() + " peer=" + deviceAddress + " go_dev_addr=" + group.getOwner().deviceAddress);
        }
    }
}
#method_after
public boolean p2pInvite(WifiP2pGroup group, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress))
        return false;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.invite(group, deviceAddress);
    } else {
        if (group == null) {
            return doBooleanCommand("P2P_INVITE peer=" + deviceAddress);
        } else {
            return doBooleanCommand("P2P_INVITE group=" + group.getInterface() + " peer=" + deviceAddress + " go_dev_addr=" + group.getOwner().deviceAddress);
        }
    }
}
#end_block

#method_before
public boolean p2pReinvoke(int netId, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress) || netId < 0)
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reinvoke(netId, deviceAddress);
    } else {
        return doBooleanCommand("P2P_INVITE persistent=" + netId + " peer=" + deviceAddress);
    }
}
#method_after
public boolean p2pReinvoke(int netId, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress) || netId < 0)
        return false;
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reinvoke(netId, deviceAddress);
    } else {
        return doBooleanCommand("P2P_INVITE persistent=" + netId + " peer=" + deviceAddress);
    }
}
#end_block

#method_before
public String p2pGetSsid(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getSsid(deviceAddress);
    } else {
        return p2pGetParam(deviceAddress, "oper_ssid");
    }
}
#method_after
public String p2pGetSsid(String deviceAddress) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getSsid(deviceAddress);
    } else {
        return p2pGetParam(deviceAddress, "oper_ssid");
    }
}
#end_block

#method_before
public String p2pGetDeviceAddress() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getDeviceAddress();
    } else {
        Log.d(TAG, "p2pGetDeviceAddress");
        String status = null;
        synchronized (sLock) {
            status = doStringCommandNative("STATUS");
        }
        String result = "";
        if (status != null) {
            String[] tokens = status.split("\n");
            for (String token : tokens) {
                if (token.startsWith("p2p_device_address=")) {
                    String[] nameValue = token.split("=");
                    if (nameValue.length != 2)
                        break;
                    result = nameValue[1];
                }
            }
        }
        Log.d(TAG, "p2pGetDeviceAddress returning " + result);
        return result;
    }
}
#method_after
public String p2pGetDeviceAddress() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getDeviceAddress();
    } else {
        Log.d(TAG, "p2pGetDeviceAddress");
        String status = null;
        synchronized (sLock) {
            status = doStringCommandNative("STATUS");
        }
        String result = "";
        if (status != null) {
            String[] tokens = status.split("\n");
            for (String token : tokens) {
                if (token.startsWith("p2p_device_address=")) {
                    String[] nameValue = token.split("=");
                    if (nameValue.length != 2)
                        break;
                    result = nameValue[1];
                }
            }
        }
        Log.d(TAG, "p2pGetDeviceAddress returning " + result);
        return result;
    }
}
#end_block

#method_before
public int getGroupCapability(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getGroupCapability(deviceAddress);
    } else {
        int gc = 0;
        if (TextUtils.isEmpty(deviceAddress))
            return gc;
        String peerInfo = p2pPeer(deviceAddress);
        if (TextUtils.isEmpty(peerInfo))
            return gc;
        String[] tokens = peerInfo.split("\n");
        for (String token : tokens) {
            if (token.startsWith("group_capab=")) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2)
                    break;
                try {
                    return Integer.decode(nameValue[1]);
                } catch (NumberFormatException e) {
                    return gc;
                }
            }
        }
        return gc;
    }
}
#method_after
public int getGroupCapability(String deviceAddress) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getGroupCapability(deviceAddress);
    } else {
        int gc = 0;
        if (TextUtils.isEmpty(deviceAddress))
            return gc;
        String peerInfo = p2pPeer(deviceAddress);
        if (TextUtils.isEmpty(peerInfo))
            return gc;
        String[] tokens = peerInfo.split("\n");
        for (String token : tokens) {
            if (token.startsWith("group_capab=")) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2)
                    break;
                try {
                    return Integer.decode(nameValue[1]);
                } catch (NumberFormatException e) {
                    return gc;
                }
            }
        }
        return gc;
    }
}
#end_block

#method_before
public boolean p2pServiceAdd(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_ADD bonjour <query hexdump> <RDATA hexdump>
         * P2P_SERVICE_ADD upnp <version hex> <service>
         *
         * e.g)
         * [Bonjour]
         * # IP Printing over TCP (PTR) (RDATA=MyPrinter._ipp._tcp.local.)
         * P2P_SERVICE_ADD bonjour 045f697070c00c000c01 094d795072696e746572c027
         * # IP Printing over TCP (TXT) (RDATA=txtvers=1,pdl=application/postscript)
         * P2P_SERVICE_ADD bonjour 096d797072696e746572045f697070c00c001001
         *  09747874766572733d311a70646c3d6170706c69636174696f6e2f706f7374736372797074
         *
         * [UPnP]
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::upnp:rootdevice
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp
         * -org:device:InternetGatewayDevice:1
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9322-123456789012::urn:schemas-upnp
         * -org:service:ContentDirectory:2
         */
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceAdd(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_ADD";
                command += (" " + s);
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#method_after
public boolean p2pServiceAdd(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_ADD bonjour <query hexdump> <RDATA hexdump>
         * P2P_SERVICE_ADD upnp <version hex> <service>
         *
         * e.g)
         * [Bonjour]
         * # IP Printing over TCP (PTR) (RDATA=MyPrinter._ipp._tcp.local.)
         * P2P_SERVICE_ADD bonjour 045f697070c00c000c01 094d795072696e746572c027
         * # IP Printing over TCP (TXT) (RDATA=txtvers=1,pdl=application/postscript)
         * P2P_SERVICE_ADD bonjour 096d797072696e746572045f697070c00c001001
         *  09747874766572733d311a70646c3d6170706c69636174696f6e2f706f7374736372797074
         *
         * [UPnP]
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::upnp:rootdevice
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp
         * -org:device:InternetGatewayDevice:1
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9322-123456789012::urn:schemas-upnp
         * -org:service:ContentDirectory:2
         */
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceAdd(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_ADD";
                command += (" " + s);
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
public boolean p2pServiceDel(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_DEL bonjour <query hexdump>
         * P2P_SERVICE_DEL upnp <version hex> <service>
         */
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceRemove(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_DEL ";
                String[] data = s.split(" ");
                if (data.length < 2) {
                    return false;
                }
                if ("upnp".equals(data[0])) {
                    command += s;
                } else if ("bonjour".equals(data[0])) {
                    command += data[0];
                    command += (" " + data[1]);
                } else {
                    return false;
                }
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#method_after
public boolean p2pServiceDel(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_DEL bonjour <query hexdump>
         * P2P_SERVICE_DEL upnp <version hex> <service>
         */
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceRemove(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_DEL ";
                String[] data = s.split(" ");
                if (data.length < 2) {
                    return false;
                }
                if ("upnp".equals(data[0])) {
                    command += s;
                } else if ("bonjour".equals(data[0])) {
                    command += data[0];
                    command += (" " + data[1]);
                } else {
                    return false;
                }
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
public boolean p2pServiceFlush() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceFlush();
    } else {
        return doBooleanCommand("P2P_SERVICE_FLUSH");
    }
}
#method_after
public boolean p2pServiceFlush() {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceFlush();
    } else {
        return doBooleanCommand("P2P_SERVICE_FLUSH");
    }
}
#end_block

#method_before
public String p2pServDiscReq(String addr, String query) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.requestServiceDiscovery(addr, query);
    } else {
        String command = "P2P_SERV_DISC_REQ";
        command += (" " + addr);
        command += (" " + query);
        return doStringCommand(command);
    }
}
#method_after
public String p2pServDiscReq(String addr, String query) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.requestServiceDiscovery(addr, query);
    } else {
        String command = "P2P_SERV_DISC_REQ";
        command += (" " + addr);
        command += (" " + query);
        return doStringCommand(command);
    }
}
#end_block

#method_before
public boolean p2pServDiscCancelReq(String id) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelServiceDiscovery(id);
    } else {
        return doBooleanCommand("P2P_SERV_DISC_CANCEL_REQ " + id);
    }
}
#method_after
public boolean p2pServDiscCancelReq(String id) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelServiceDiscovery(id);
    } else {
        return doBooleanCommand("P2P_SERV_DISC_CANCEL_REQ " + id);
    }
}
#end_block

#method_before
public void setMiracastMode(int mode) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        mSupplicantP2pIfaceHal.setMiracastMode(mode);
    } else {
        // Note: optional feature on the driver. It is ok for this to fail.
        doBooleanCommand("DRIVER MIRACAST " + mode);
    }
}
#method_after
public void setMiracastMode(int mode) {
    if (HIDL_P2P_ENABLE && mSupplicantP2pIfaceHal != null) {
        mSupplicantP2pIfaceHal.setMiracastMode(mode);
    } else {
        // Note: optional feature on the driver. It is ok for this to fail.
        doBooleanCommand("DRIVER MIRACAST " + mode);
    }
}
#end_block

#method_before
public boolean removeAllNetworks() {
    return doBooleanCommand("REMOVE_NETWORK all");
}
#method_after
public boolean removeAllNetworks() {
    if (HIDL_SUP_ENABLE) {
        return mSupplicantStaIfaceHal.removeAllNetworks();
    } else {
        if (!doBooleanCommand("REMOVE_NETWORK all")) {
            Log.e(TAG, "Remove all networks in wpa_supplicant failed");
            return false;
        }
        return true;
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
@Override
protected String getLogRecString(Message msg) {
    WifiConfiguration config;
    Long now;
    String report;
    String key;
    StringBuilder sb = new StringBuilder();
    if (mScreenOn) {
        sb.append("!");
    }
    if (messageHandlingStatus != MESSAGE_HANDLING_STATUS_UNKNOWN) {
        sb.append("(").append(messageHandlingStatus).append(")");
    }
    sb.append(smToString(msg));
    if (msg.sendingUid > 0 && msg.sendingUid != Process.WIFI_UID) {
        sb.append(" uid=" + msg.sendingUid);
    }
    sb.append(" ").append(printTime());
    switch(msg.what) {
        case CMD_START_SCAN:
            now = mClock.getWallClockMillis();
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ic=");
            sb.append(Integer.toString(sScanAlarmIntentCount));
            if (msg.obj != null) {
                Bundle bundle = (Bundle) msg.obj;
                Long request = bundle.getLong(SCAN_REQUEST_TIME, 0);
                if (request != 0) {
                    sb.append(" proc(ms):").append(now - request);
                }
            }
            if (mIsScanOngoing)
                sb.append(" onGoing");
            if (mIsFullScanOngoing)
                sb.append(" full");
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            if (lastScanFreqs != null) {
                sb.append(" list=");
                for (int freq : lastScanFreqs) {
                    sb.append(freq).append(",");
                }
            }
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            StateChangeResult stateChangeResult = (StateChangeResult) msg.obj;
            if (stateChangeResult != null) {
                sb.append(stateChangeResult.toString());
            }
            break;
        case WifiManager.SAVE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null && !config.preSharedKey.equals("*")) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
            }
            break;
        case WifiManager.FORGET_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
            }
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            String bssid = (String) msg.obj;
            if (bssid != null && bssid.length() > 0) {
                sb.append(" ");
                sb.append(bssid);
            }
            sb.append(" blacklist=" + Boolean.toString(didBlackListBSSID));
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mScanResults != null) {
                sb.append(" found=");
                sb.append(mScanResults.size());
            }
            sb.append(" known=").append(mNumScanResultsKnown);
            sb.append(" got=").append(mNumScanResultsReturned);
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            sb.append(String.format(" con=%d", mConnectionReqCount));
            sb.append(String.format(" untrustedcn=%d", mUntrustedReqCount));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case WifiMonitor.SCAN_FAILED_EVENT:
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ").append(mLastBssid);
            sb.append(" nid=").append(mLastNetworkId);
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(" ").append(config.configKey());
            }
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case CMD_TARGET_BSSID:
        case CMD_ASSOCIATED_BSSID:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                sb.append(" BSSID=").append((String) msg.obj);
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" Target=").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            sb.append(" nid=").append(msg.arg1);
            sb.append(" reason=").append(msg.arg2);
            if (mLastBssid != null) {
                sb.append(" lastbssid=").append(mLastBssid);
            }
            if (mWifiInfo.getFrequency() != -1) {
                sb.append(" freq=").append(mWifiInfo.getFrequency());
                sb.append(" rssi=").append(mWifiInfo.getRssi());
            }
            if (isLinkDebouncing()) {
                sb.append(" debounce");
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
        case WifiMonitor.SSID_REENABLED:
            sb.append(" nid=").append(msg.arg1);
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            config = getCurrentWifiConfiguration();
            if (config != null) {
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" cur=").append(config.configKey());
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                if (config.status != 0) {
                    sb.append(" st=").append(config.status);
                    sb.append(" rs=").append(netWorkSelectionStatus.getNetworkDisableReasonString());
                }
                if (config.lastConnected != 0) {
                    now = mClock.getWallClockMillis();
                    sb.append(" lastconn=").append(now - config.lastConnected).append("(ms)");
                }
                if (mLastBssid != null) {
                    sb.append(" lastbssid=").append(mLastBssid);
                }
                if (mWifiInfo.getFrequency() != -1) {
                    sb.append(" freq=").append(mWifiInfo.getFrequency());
                    sb.append(" rssi=").append(mWifiInfo.getRssi());
                    sb.append(" bssid=").append(mWifiInfo.getBSSID());
                }
            }
            break;
        case CMD_RSSI_POLL:
        case CMD_UNWANTED_NETWORK:
        case WifiManager.RSSI_PKTCNT_FETCH:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mWifiInfo.getSSID() != null)
                if (mWifiInfo.getSSID() != null)
                    sb.append(" ").append(mWifiInfo.getSSID());
            if (mWifiInfo.getBSSID() != null)
                sb.append(" ").append(mWifiInfo.getBSSID());
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            if (mWifiScoreReport.isLastReportValid()) {
                sb.append(mWifiScoreReport.getLastReport());
            }
            break;
        case CMD_START_CONNECT:
        case WifiManager.CONNECT_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null) {
                sb.append(" ").append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            break;
        case CMD_START_ROAM:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            ScanResult result = (ScanResult) msg.obj;
            if (result != null) {
                now = mClock.getWallClockMillis();
                sb.append(" bssid=").append(result.BSSID);
                sb.append(" rssi=").append(result.level);
                sb.append(" freq=").append(result.frequency);
                if (result.seen > 0 && result.seen < now) {
                    sb.append(" seen=").append(now - result.seen);
                } else {
                    // Somehow the timestamp for this scan result is inconsistent
                    sb.append(" !seen=").append(result.seen);
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            sb.append(" fail count=").append(Integer.toString(mRoamFailCount));
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                config = (WifiConfiguration) msg.obj;
                sb.append(" ").append(config.configKey());
                sb.append(" prio=").append(config.priority);
                sb.append(" status=").append(config.status);
                if (config.BSSID != null) {
                    sb.append(" ").append(config.BSSID);
                }
                WifiConfiguration curConfig = getCurrentWifiConfiguration();
                if (curConfig != null) {
                    if (curConfig.configKey().equals(config.configKey())) {
                        sb.append(" is current");
                    } else {
                        sb.append(" current=").append(curConfig.configKey());
                        sb.append(" prio=").append(curConfig.priority);
                        sb.append(" status=").append(curConfig.status);
                    }
                }
            }
            break;
        case WifiManager.DISABLE_NETWORK:
        case CMD_ENABLE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null && (key == null || !config.configKey().equals(key))) {
                sb.append(" target=").append(key);
            }
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" num=").append(mWifiConfigManager.getConfiguredNetworks().size());
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" txpkts=").append(mWifiInfo.txSuccess);
            sb.append(",").append(mWifiInfo.txBad);
            sb.append(",").append(mWifiInfo.txRetries);
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append(" OK ");
            } else if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append(" FAIL ");
            }
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                NetworkInfo info = (NetworkInfo) msg.obj;
                NetworkInfo.State state = info.getState();
                NetworkInfo.DetailedState detailedState = info.getDetailedState();
                if (state != null) {
                    sb.append(" st=").append(state);
                }
                if (detailedState != null) {
                    sb.append("/").append(detailedState);
                }
            }
            break;
        case CMD_IP_CONFIGURATION_LOST:
            int count = -1;
            WifiConfiguration c = getCurrentWifiConfiguration();
            if (c != null) {
                count = c.getNetworkSelectionStatus().getDisableReasonCounter(WifiConfiguration.NetworkSelectionStatus.DISABLED_DHCP_FAILURE);
            }
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" failures: ");
            sb.append(Integer.toString(count));
            sb.append("/");
            sb.append(Integer.toString(mFacade.getIntegerSetting(mContext, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, 0)));
            if (mWifiInfo.getBSSID() != null) {
                sb.append(" ").append(mWifiInfo.getBSSID());
            }
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            break;
        case CMD_UPDATE_LINKPROPERTIES:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            break;
        case CMD_INSTALL_PACKET_FILTER:
            sb.append(" len=" + ((byte[]) msg.obj).length);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            sb.append(" enabled=" + (boolean) msg.obj);
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(roamWatchdogCount);
            break;
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(disconnectingWatchdogCount);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            sb.append(" rssi=");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" thresholds=");
            sb.append(Arrays.toString(mRssiRanges));
            break;
        case CMD_USER_SWITCH:
            sb.append(" userId=");
            sb.append(Integer.toString(msg.arg1));
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append("DHCP_OK");
            } else if (msg.arg1 == CMD_STATIC_IP_SUCCESS) {
                sb.append("STATIC_OK");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        case CMD_IPV4_PROVISIONING_FAILURE:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append("DHCP_FAIL");
            } else if (msg.arg1 == CMD_STATIC_IP_FAILURE) {
                sb.append("STATIC_FAIL");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        default:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            break;
    }
    return sb.toString();
}
#method_after
@Override
protected String getLogRecString(Message msg) {
    WifiConfiguration config;
    Long now;
    String report;
    String key;
    StringBuilder sb = new StringBuilder();
    if (mScreenOn) {
        sb.append("!");
    }
    if (messageHandlingStatus != MESSAGE_HANDLING_STATUS_UNKNOWN) {
        sb.append("(").append(messageHandlingStatus).append(")");
    }
    sb.append(smToString(msg));
    if (msg.sendingUid > 0 && msg.sendingUid != Process.WIFI_UID) {
        sb.append(" uid=" + msg.sendingUid);
    }
    sb.append(" rt=").append(mClock.getUptimeSinceBootMillis());
    sb.append("/").append(mClock.getElapsedSinceBootMillis());
    switch(msg.what) {
        case CMD_START_SCAN:
            now = mClock.getWallClockMillis();
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ic=");
            sb.append(Integer.toString(sScanAlarmIntentCount));
            if (msg.obj != null) {
                Bundle bundle = (Bundle) msg.obj;
                Long request = bundle.getLong(SCAN_REQUEST_TIME, 0);
                if (request != 0) {
                    sb.append(" proc(ms):").append(now - request);
                }
            }
            if (mIsScanOngoing)
                sb.append(" onGoing");
            if (mIsFullScanOngoing)
                sb.append(" full");
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            if (lastScanFreqs != null) {
                sb.append(" list=");
                for (int freq : lastScanFreqs) {
                    sb.append(freq).append(",");
                }
            }
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            StateChangeResult stateChangeResult = (StateChangeResult) msg.obj;
            if (stateChangeResult != null) {
                sb.append(stateChangeResult.toString());
            }
            break;
        case WifiManager.SAVE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null && !config.preSharedKey.equals("*")) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
            }
            break;
        case WifiManager.FORGET_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = (WifiConfiguration) msg.obj;
            if (config != null) {
                sb.append(" ").append(config.configKey());
                sb.append(" nid=").append(config.networkId);
                if (config.hiddenSSID) {
                    sb.append(" hidden");
                }
                if (config.preSharedKey != null) {
                    sb.append(" hasPSK");
                }
                if (config.ephemeral) {
                    sb.append(" ephemeral");
                }
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                sb.append(" cuid=").append(config.creatorUid);
                sb.append(" suid=").append(config.lastUpdateUid);
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
            }
            break;
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            String bssid = (String) msg.obj;
            if (bssid != null && bssid.length() > 0) {
                sb.append(" ");
                sb.append(bssid);
            }
            sb.append(" blacklist=" + Boolean.toString(didBlackListBSSID));
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mScanResults != null) {
                sb.append(" found=");
                sb.append(mScanResults.size());
            }
            sb.append(" known=").append(mNumScanResultsKnown);
            sb.append(" got=").append(mNumScanResultsReturned);
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            sb.append(String.format(" con=%d", mConnectionReqCount));
            sb.append(String.format(" untrustedcn=%d", mUntrustedReqCount));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case WifiMonitor.SCAN_FAILED_EVENT:
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" ").append(mLastBssid);
            sb.append(" nid=").append(mLastNetworkId);
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(" ").append(config.configKey());
            }
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            break;
        case CMD_TARGET_BSSID:
        case CMD_ASSOCIATED_BSSID:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                sb.append(" BSSID=").append((String) msg.obj);
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" Target=").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            sb.append(" nid=").append(msg.arg1);
            sb.append(" reason=").append(msg.arg2);
            if (mLastBssid != null) {
                sb.append(" lastbssid=").append(mLastBssid);
            }
            if (mWifiInfo.getFrequency() != -1) {
                sb.append(" freq=").append(mWifiInfo.getFrequency());
                sb.append(" rssi=").append(mWifiInfo.getRssi());
            }
            if (isLinkDebouncing()) {
                sb.append(" debounce");
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
        case WifiMonitor.SSID_REENABLED:
            sb.append(" nid=").append(msg.arg1);
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            config = getCurrentWifiConfiguration();
            if (config != null) {
                WifiConfiguration.NetworkSelectionStatus netWorkSelectionStatus = config.getNetworkSelectionStatus();
                sb.append(" cur=").append(config.configKey());
                sb.append(" ajst=").append(netWorkSelectionStatus.getNetworkStatusString());
                if (config.selfAdded) {
                    sb.append(" selfAdded");
                }
                if (config.status != 0) {
                    sb.append(" st=").append(config.status);
                    sb.append(" rs=").append(netWorkSelectionStatus.getNetworkDisableReasonString());
                }
                if (config.lastConnected != 0) {
                    now = mClock.getWallClockMillis();
                    sb.append(" lastconn=").append(now - config.lastConnected).append("(ms)");
                }
                if (mLastBssid != null) {
                    sb.append(" lastbssid=").append(mLastBssid);
                }
                if (mWifiInfo.getFrequency() != -1) {
                    sb.append(" freq=").append(mWifiInfo.getFrequency());
                    sb.append(" rssi=").append(mWifiInfo.getRssi());
                    sb.append(" bssid=").append(mWifiInfo.getBSSID());
                }
            }
            break;
        case CMD_RSSI_POLL:
        case CMD_UNWANTED_NETWORK:
        case WifiManager.RSSI_PKTCNT_FETCH:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mWifiInfo.getSSID() != null)
                if (mWifiInfo.getSSID() != null)
                    sb.append(" ").append(mWifiInfo.getSSID());
            if (mWifiInfo.getBSSID() != null)
                sb.append(" ").append(mWifiInfo.getBSSID());
            sb.append(" rssi=").append(mWifiInfo.getRssi());
            sb.append(" f=").append(mWifiInfo.getFrequency());
            sb.append(" sc=").append(mWifiInfo.score);
            sb.append(" link=").append(mWifiInfo.getLinkSpeed());
            sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
            sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
            sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
            sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            report = reportOnTime();
            if (report != null) {
                sb.append(" ").append(report);
            }
            if (mWifiScoreReport.isLastReportValid()) {
                sb.append(mWifiScoreReport.getLastReport());
            }
            break;
        case CMD_START_CONNECT:
        case WifiManager.CONNECT_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null) {
                sb.append(" ").append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            config = getCurrentWifiConfiguration();
            if (config != null) {
                sb.append(config.configKey());
                if (config.visibility != null) {
                    sb.append(" ").append(config.visibility.toString());
                }
            }
            break;
        case CMD_START_ROAM:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            ScanResult result = (ScanResult) msg.obj;
            if (result != null) {
                now = mClock.getWallClockMillis();
                sb.append(" bssid=").append(result.BSSID);
                sb.append(" rssi=").append(result.level);
                sb.append(" freq=").append(result.frequency);
                if (result.seen > 0 && result.seen < now) {
                    sb.append(" seen=").append(now - result.seen);
                } else {
                    // Somehow the timestamp for this scan result is inconsistent
                    sb.append(" !seen=").append(result.seen);
                }
            }
            if (mTargetRoamBSSID != null) {
                sb.append(" ").append(mTargetRoamBSSID);
            }
            sb.append(" roam=").append(Boolean.toString(mAutoRoaming));
            sb.append(" fail count=").append(Integer.toString(mRoamFailCount));
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                config = (WifiConfiguration) msg.obj;
                sb.append(" ").append(config.configKey());
                sb.append(" prio=").append(config.priority);
                sb.append(" status=").append(config.status);
                if (config.BSSID != null) {
                    sb.append(" ").append(config.BSSID);
                }
                WifiConfiguration curConfig = getCurrentWifiConfiguration();
                if (curConfig != null) {
                    if (curConfig.configKey().equals(config.configKey())) {
                        sb.append(" is current");
                    } else {
                        sb.append(" current=").append(curConfig.configKey());
                        sb.append(" prio=").append(curConfig.priority);
                        sb.append(" status=").append(curConfig.status);
                    }
                }
            }
            break;
        case WifiManager.DISABLE_NETWORK:
        case CMD_ENABLE_NETWORK:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            key = mWifiConfigManager.getLastSelectedNetworkConfigKey();
            if (key != null) {
                sb.append(" last=").append(key);
            }
            config = mWifiConfigManager.getConfiguredNetwork(msg.arg1);
            if (config != null && (key == null || !config.configKey().equals(key))) {
                sb.append(" target=").append(key);
            }
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" num=").append(mWifiConfigManager.getConfiguredNetworks().size());
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" txpkts=").append(mWifiInfo.txSuccess);
            sb.append(",").append(mWifiInfo.txBad);
            sb.append(",").append(mWifiInfo.txRetries);
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append(" OK ");
            } else if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append(" FAIL ");
            }
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (msg.obj != null) {
                NetworkInfo info = (NetworkInfo) msg.obj;
                NetworkInfo.State state = info.getState();
                NetworkInfo.DetailedState detailedState = info.getDetailedState();
                if (state != null) {
                    sb.append(" st=").append(state);
                }
                if (detailedState != null) {
                    sb.append("/").append(detailedState);
                }
            }
            break;
        case CMD_IP_CONFIGURATION_LOST:
            int count = -1;
            WifiConfiguration c = getCurrentWifiConfiguration();
            if (c != null) {
                count = c.getNetworkSelectionStatus().getDisableReasonCounter(WifiConfiguration.NetworkSelectionStatus.DISABLED_DHCP_FAILURE);
            }
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" failures: ");
            sb.append(Integer.toString(count));
            sb.append("/");
            sb.append(Integer.toString(mFacade.getIntegerSetting(mContext, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, 0)));
            if (mWifiInfo.getBSSID() != null) {
                sb.append(" ").append(mWifiInfo.getBSSID());
            }
            sb.append(String.format(" bcn=%d", mRunningBeaconCount));
            break;
        case CMD_UPDATE_LINKPROPERTIES:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            if (mLinkProperties != null) {
                sb.append(" ");
                sb.append(getLinkPropertiesSummary(mLinkProperties));
            }
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (msg.obj != null) {
                sb.append(" ").append((String) msg.obj);
            }
            break;
        case CMD_INSTALL_PACKET_FILTER:
            sb.append(" len=" + ((byte[]) msg.obj).length);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            sb.append(" enabled=" + (boolean) msg.obj);
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(roamWatchdogCount);
            break;
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            sb.append(" cur=").append(disconnectingWatchdogCount);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            sb.append(" rssi=");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" thresholds=");
            sb.append(Arrays.toString(mRssiRanges));
            break;
        case CMD_USER_SWITCH:
            sb.append(" userId=");
            sb.append(Integer.toString(msg.arg1));
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_SUCCESS) {
                sb.append("DHCP_OK");
            } else if (msg.arg1 == CMD_STATIC_IP_SUCCESS) {
                sb.append("STATIC_OK");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        case CMD_IPV4_PROVISIONING_FAILURE:
            sb.append(" ");
            if (msg.arg1 == DhcpClient.DHCP_FAILURE) {
                sb.append("DHCP_FAIL");
            } else if (msg.arg1 == CMD_STATIC_IP_FAILURE) {
                sb.append("STATIC_FAIL");
            } else {
                sb.append(Integer.toString(msg.arg1));
            }
            break;
        default:
            sb.append(" ");
            sb.append(Integer.toString(msg.arg1));
            sb.append(" ");
            sb.append(Integer.toString(msg.arg2));
            break;
    }
    return sb.toString();
}
#end_block

#method_before
void updateWifiMetrics() {
    mWifiMetrics.updateSavedNetworks(mWifiConfigManager.getSavedNetworks());
}
#method_after
public void updateWifiMetrics() {
    mWifiMetrics.updateSavedNetworks(mWifiConfigManager.getSavedNetworks());
}
#end_block

#method_before
public void assertDeserializedMetricsCorrect() throws Exception {
    assertEquals("mDeserializedWifiMetrics.numSavedNetworks == NUM_SAVED_NETWORKS", mDeserializedWifiMetrics.numSavedNetworks, NUM_SAVED_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numOpenNetworks == NUM_OPEN_NETWORKS", mDeserializedWifiMetrics.numOpenNetworks, NUM_OPEN_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numPersonalNetworks == NUM_PERSONAL_NETWORKS", mDeserializedWifiMetrics.numPersonalNetworks, NUM_PERSONAL_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numEnterpriseNetworks " + "== NUM_ENTERPRISE_NETWORKS", mDeserializedWifiMetrics.numEnterpriseNetworks, NUM_ENTERPRISE_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numNetworksAddedByUser " + "== NUM_NEWTORKS_ADDED_BY_USER", mDeserializedWifiMetrics.numNetworksAddedByUser, NUM_NEWTORKS_ADDED_BY_USER);
    assertEquals(NUM_HIDDEN_NETWORKS, mDeserializedWifiMetrics.numHiddenNetworks);
    assertEquals(NUM_PASSPOINT_NETWORKS, mDeserializedWifiMetrics.numPasspointNetworks);
    assertEquals("mDeserializedWifiMetrics.numNetworksAddedByApps " + "== NUM_NEWTORKS_ADDED_BY_APPS", mDeserializedWifiMetrics.numNetworksAddedByApps, NUM_NEWTORKS_ADDED_BY_APPS);
    assertEquals("mDeserializedWifiMetrics.isLocationEnabled == TEST_VAL_IS_LOCATION_ENABLED", mDeserializedWifiMetrics.isLocationEnabled, TEST_VAL_IS_LOCATION_ENABLED);
    assertEquals("mDeserializedWifiMetrics.isScanningAlwaysEnabled " + "== IS_SCANNING_ALWAYS_ENABLED", mDeserializedWifiMetrics.isScanningAlwaysEnabled, IS_SCANNING_ALWAYS_ENABLED);
    assertEquals("mDeserializedWifiMetrics.numEmptyScanResults == NUM_EMPTY_SCAN_RESULTS", mDeserializedWifiMetrics.numEmptyScanResults, NUM_EMPTY_SCAN_RESULTS);
    assertEquals("mDeserializedWifiMetrics.numNonEmptyScanResults == " + "NUM_NON_EMPTY_SCAN_RESULTS", mDeserializedWifiMetrics.numNonEmptyScanResults, NUM_NON_EMPTY_SCAN_RESULTS);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_UNKNOWN, NUM_SCAN_UNKNOWN);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_SUCCESS, NUM_SCAN_SUCCESS);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_FAILURE_INTERRUPTED, NUM_SCAN_FAILURE_INTERRUPTED);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_FAILURE_INVALID_CONFIGURATION, NUM_SCAN_FAILURE_INVALID_CONFIGURATION);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_UNKNOWN, false, NUM_WIFI_UNKNOWN_SCREEN_OFF);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_UNKNOWN, true, NUM_WIFI_UNKNOWN_SCREEN_ON);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_ASSOCIATED, false, NUM_WIFI_ASSOCIATED_SCREEN_OFF);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_ASSOCIATED, true, NUM_WIFI_ASSOCIATED_SCREEN_ON);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogPnoGood, NUM_CONNECTIVITY_WATCHDOG_PNO_GOOD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogPnoBad, NUM_CONNECTIVITY_WATCHDOG_PNO_BAD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogBackgroundGood, NUM_CONNECTIVITY_WATCHDOG_BACKGROUND_GOOD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogBackgroundBad, NUM_CONNECTIVITY_WATCHDOG_BACKGROUND_BAD);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS, mDeserializedWifiMetrics.numLastResortWatchdogTriggers);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_ASSOCIATION_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadAssociationNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_AUTHENTICATION_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadAuthenticationNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_DHCP_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadDhcpNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_OTHER_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadOtherNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_AVAILABLE_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogAvailableNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_ASSOCIATION, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadAssociation);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_AUTHENTICATION, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadAuthentication);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_DHCP, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadDhcp);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_OTHER, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadOther);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_SUCCESSES, mDeserializedWifiMetrics.numLastResortWatchdogSuccesses);
    assertEquals(TEST_RECORD_DURATION_SEC, mDeserializedWifiMetrics.recordDurationSec);
    for (int i = 0; i < NUM_RSSI_LEVELS_TO_INCREMENT; i++) {
        assertEquals(MIN_RSSI_LEVEL + i, mDeserializedWifiMetrics.rssiPollRssiCount[i].rssi);
        assertEquals(i + 1, mDeserializedWifiMetrics.rssiPollRssiCount[i].count);
    }
    StringBuilder sb_rssi = new StringBuilder();
    sb_rssi.append("Number of RSSIs = " + mDeserializedWifiMetrics.rssiPollRssiCount.length);
    assertTrue(sb_rssi.toString(), (mDeserializedWifiMetrics.rssiPollRssiCount.length <= (MAX_RSSI_LEVEL - MIN_RSSI_LEVEL + 1)));
    // Clamped reasons.
    assertEquals(2, mDeserializedWifiMetrics.alertReasonCount[0].count);
    assertEquals(3, mDeserializedWifiMetrics.alertReasonCount[1].count);
    assertEquals(1, mDeserializedWifiMetrics.alertReasonCount[2].count);
    assertEquals(3, mDeserializedWifiMetrics.alertReasonCount.length);
    assertEquals(NUM_TOTAL_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numTotalScanResults);
    assertEquals(NUM_OPEN_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numOpenNetworkScanResults);
    assertEquals(NUM_PERSONAL_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numPersonalNetworkScanResults);
    assertEquals(NUM_ENTERPRISE_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numEnterpriseNetworkScanResults);
    assertEquals(NUM_HIDDEN_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHiddenNetworkScanResults);
    assertEquals(NUM_HOTSPOT2_R1_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHotspot2R1NetworkScanResults);
    assertEquals(NUM_HOTSPOT2_R2_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHotspot2R2NetworkScanResults);
    assertEquals(NUM_SCANS, mDeserializedWifiMetrics.numScans);
    for (int score_index = 0; score_index < NUM_WIFI_SCORES_TO_INCREMENT; score_index++) {
        assertEquals(WIFI_SCORE_RANGE_MIN + score_index, mDeserializedWifiMetrics.wifiScoreCount[score_index].score);
        assertEquals(score_index + 1, mDeserializedWifiMetrics.wifiScoreCount[score_index].count);
    }
    StringBuilder sb_wifi_score = new StringBuilder();
    sb_wifi_score.append("Number of wifi_scores = " + mDeserializedWifiMetrics.wifiScoreCount.length);
    assertTrue(sb_wifi_score.toString(), (mDeserializedWifiMetrics.wifiScoreCount.length <= (WIFI_SCORE_RANGE_MAX - WIFI_SCORE_RANGE_MIN + 1)));
    StringBuilder sb_wifi_limits = new StringBuilder();
    sb_wifi_limits.append("Wifi Score limit is " + NetworkAgent.WIFI_BASE_SCORE + ">= " + WIFI_SCORE_RANGE_MAX);
    assertTrue(sb_wifi_limits.toString(), NetworkAgent.WIFI_BASE_SCORE <= WIFI_SCORE_RANGE_MAX);
}
#method_after
public void assertDeserializedMetricsCorrect() throws Exception {
    assertEquals("mDeserializedWifiMetrics.numSavedNetworks == NUM_SAVED_NETWORKS", mDeserializedWifiMetrics.numSavedNetworks, NUM_SAVED_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numOpenNetworks == NUM_OPEN_NETWORKS", mDeserializedWifiMetrics.numOpenNetworks, NUM_OPEN_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numPersonalNetworks == NUM_PERSONAL_NETWORKS", mDeserializedWifiMetrics.numPersonalNetworks, NUM_PERSONAL_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numEnterpriseNetworks " + "== NUM_ENTERPRISE_NETWORKS", mDeserializedWifiMetrics.numEnterpriseNetworks, NUM_ENTERPRISE_NETWORKS);
    assertEquals("mDeserializedWifiMetrics.numNetworksAddedByUser " + "== NUM_NETWORKS_ADDED_BY_USER", mDeserializedWifiMetrics.numNetworksAddedByUser, NUM_NETWORKS_ADDED_BY_USER);
    assertEquals(NUM_HIDDEN_NETWORKS, mDeserializedWifiMetrics.numHiddenNetworks);
    assertEquals(NUM_PASSPOINT_NETWORKS, mDeserializedWifiMetrics.numPasspointNetworks);
    assertEquals("mDeserializedWifiMetrics.numNetworksAddedByApps " + "== NUM_NETWORKS_ADDED_BY_APPS", mDeserializedWifiMetrics.numNetworksAddedByApps, NUM_NETWORKS_ADDED_BY_APPS);
    assertEquals("mDeserializedWifiMetrics.isLocationEnabled == TEST_VAL_IS_LOCATION_ENABLED", mDeserializedWifiMetrics.isLocationEnabled, TEST_VAL_IS_LOCATION_ENABLED);
    assertEquals("mDeserializedWifiMetrics.isScanningAlwaysEnabled " + "== IS_SCANNING_ALWAYS_ENABLED", mDeserializedWifiMetrics.isScanningAlwaysEnabled, IS_SCANNING_ALWAYS_ENABLED);
    assertEquals("mDeserializedWifiMetrics.numEmptyScanResults == NUM_EMPTY_SCAN_RESULTS", mDeserializedWifiMetrics.numEmptyScanResults, NUM_EMPTY_SCAN_RESULTS);
    assertEquals("mDeserializedWifiMetrics.numNonEmptyScanResults == " + "NUM_NON_EMPTY_SCAN_RESULTS", mDeserializedWifiMetrics.numNonEmptyScanResults, NUM_NON_EMPTY_SCAN_RESULTS);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_UNKNOWN, NUM_SCAN_UNKNOWN);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_SUCCESS, NUM_SCAN_SUCCESS);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_FAILURE_INTERRUPTED, NUM_SCAN_FAILURE_INTERRUPTED);
    assertScanReturnEntryEquals(WifiMetricsProto.WifiLog.SCAN_FAILURE_INVALID_CONFIGURATION, NUM_SCAN_FAILURE_INVALID_CONFIGURATION);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_UNKNOWN, false, NUM_WIFI_UNKNOWN_SCREEN_OFF);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_UNKNOWN, true, NUM_WIFI_UNKNOWN_SCREEN_ON);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_ASSOCIATED, false, NUM_WIFI_ASSOCIATED_SCREEN_OFF);
    assertSystemStateEntryEquals(WifiMetricsProto.WifiLog.WIFI_ASSOCIATED, true, NUM_WIFI_ASSOCIATED_SCREEN_ON);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogPnoGood, NUM_CONNECTIVITY_WATCHDOG_PNO_GOOD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogPnoBad, NUM_CONNECTIVITY_WATCHDOG_PNO_BAD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogBackgroundGood, NUM_CONNECTIVITY_WATCHDOG_BACKGROUND_GOOD);
    assertEquals(mDeserializedWifiMetrics.numConnectivityWatchdogBackgroundBad, NUM_CONNECTIVITY_WATCHDOG_BACKGROUND_BAD);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS, mDeserializedWifiMetrics.numLastResortWatchdogTriggers);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_ASSOCIATION_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadAssociationNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_AUTHENTICATION_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadAuthenticationNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_DHCP_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadDhcpNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_BAD_OTHER_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogBadOtherNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_AVAILABLE_NETWORKS_TOTAL, mDeserializedWifiMetrics.numLastResortWatchdogAvailableNetworksTotal);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_ASSOCIATION, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadAssociation);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_AUTHENTICATION, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadAuthentication);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_DHCP, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadDhcp);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_TRIGGERS_WITH_BAD_OTHER, mDeserializedWifiMetrics.numLastResortWatchdogTriggersWithBadOther);
    assertEquals(NUM_LAST_RESORT_WATCHDOG_SUCCESSES, mDeserializedWifiMetrics.numLastResortWatchdogSuccesses);
    assertEquals(TEST_RECORD_DURATION_SEC, mDeserializedWifiMetrics.recordDurationSec);
    for (int i = 0; i < NUM_RSSI_LEVELS_TO_INCREMENT; i++) {
        assertEquals(MIN_RSSI_LEVEL + i, mDeserializedWifiMetrics.rssiPollRssiCount[i].rssi);
        assertEquals(i + 1, mDeserializedWifiMetrics.rssiPollRssiCount[i].count);
    }
    StringBuilder sb_rssi = new StringBuilder();
    sb_rssi.append("Number of RSSIs = " + mDeserializedWifiMetrics.rssiPollRssiCount.length);
    assertTrue(sb_rssi.toString(), (mDeserializedWifiMetrics.rssiPollRssiCount.length <= (MAX_RSSI_LEVEL - MIN_RSSI_LEVEL + 1)));
    // Clamped reasons.
    assertEquals(2, mDeserializedWifiMetrics.alertReasonCount[0].count);
    assertEquals(3, mDeserializedWifiMetrics.alertReasonCount[1].count);
    assertEquals(1, mDeserializedWifiMetrics.alertReasonCount[2].count);
    assertEquals(3, mDeserializedWifiMetrics.alertReasonCount.length);
    assertEquals(NUM_TOTAL_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numTotalScanResults);
    assertEquals(NUM_OPEN_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numOpenNetworkScanResults);
    assertEquals(NUM_PERSONAL_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numPersonalNetworkScanResults);
    assertEquals(NUM_ENTERPRISE_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numEnterpriseNetworkScanResults);
    assertEquals(NUM_HIDDEN_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHiddenNetworkScanResults);
    assertEquals(NUM_HOTSPOT2_R1_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHotspot2R1NetworkScanResults);
    assertEquals(NUM_HOTSPOT2_R2_NETWORK_SCAN_RESULTS * NUM_SCANS, mDeserializedWifiMetrics.numHotspot2R2NetworkScanResults);
    assertEquals(NUM_SCANS, mDeserializedWifiMetrics.numScans);
    for (int score_index = 0; score_index < NUM_WIFI_SCORES_TO_INCREMENT; score_index++) {
        assertEquals(WIFI_SCORE_RANGE_MIN + score_index, mDeserializedWifiMetrics.wifiScoreCount[score_index].score);
        assertEquals(score_index + 1, mDeserializedWifiMetrics.wifiScoreCount[score_index].count);
    }
    StringBuilder sb_wifi_score = new StringBuilder();
    sb_wifi_score.append("Number of wifi_scores = " + mDeserializedWifiMetrics.wifiScoreCount.length);
    assertTrue(sb_wifi_score.toString(), (mDeserializedWifiMetrics.wifiScoreCount.length <= (WIFI_SCORE_RANGE_MAX - WIFI_SCORE_RANGE_MIN + 1)));
    StringBuilder sb_wifi_limits = new StringBuilder();
    sb_wifi_limits.append("Wifi Score limit is " + NetworkAgent.WIFI_BASE_SCORE + ">= " + WIFI_SCORE_RANGE_MAX);
    assertTrue(sb_wifi_limits.toString(), NetworkAgent.WIFI_BASE_SCORE <= WIFI_SCORE_RANGE_MAX);
}
#end_block

#method_before
private boolean registerStaIfaceCallback() {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiStaIface.registerEventCallback(mIWifiStaIfaceEventCallback);
            return (status.code == WifiStatusCode.SUCCESS);
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
private boolean registerStaIfaceCallback() {
    synchronized (sLock) {
        if (mIWifiStaIface == null || mIWifiStaIfaceEventCallback == null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiStaIface.registerEventCallback(mIWifiStaIfaceEventCallback);
            return (status.code == WifiStatusCode.SUCCESS);
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public int enableFirmwareRoaming(int state) {
    kilroy();
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return WifiStatusCode.ERROR_UNKNOWN;
        kilroy();
        try {
            kilroy();
            if (!isHalStarted())
                return WifiStatusCode.ERROR_NOT_STARTED;
            byte val;
            switch(state) {
                case WifiNative.DISABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.DISABLED;
                    break;
                case WifiNative.ENABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.ENABLED;
                    break;
                default:
                    Log.e(TAG, "enableFirmwareRoaming invalid argument " + state);
                    return WifiStatusCode.ERROR_INVALID_ARGS;
            }
            kilroy();
            WifiStatus status = mIWifiStaIface.setRoamingState(val);
            Log.d(TAG, "setRoamingState returned " + status.code);
            return status.code;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return WifiStatusCode.ERROR_UNKNOWN;
        }
    }
}
#method_after
public int enableFirmwareRoaming(int state) {
    kilroy();
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return WifiStatusCode.ERROR_NOT_STARTED;
        kilroy();
        try {
            kilroy();
            byte val;
            switch(state) {
                case WifiNative.DISABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.DISABLED;
                    break;
                case WifiNative.ENABLE_FIRMWARE_ROAMING:
                    val = StaRoamingState.ENABLED;
                    break;
                default:
                    Log.e(TAG, "enableFirmwareRoaming invalid argument " + state);
                    return WifiStatusCode.ERROR_INVALID_ARGS;
            }
            kilroy();
            WifiStatus status = mIWifiStaIface.setRoamingState(val);
            Log.d(TAG, "setRoamingState returned " + status.code);
            return status.code;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return WifiStatusCode.ERROR_UNKNOWN;
        }
    }
}
#end_block

#method_before
private void resetProxyAndRequestList() {
    mRadioProxy = null;
    RILRequest.resetSerial();
    // Clear request list on close
    clearRequestList(RADIO_NOT_AVAILABLE, false);
// todo: need to get service right away so setResponseFunctions() can be called for
// unsolicited indications. getService() is not a blocking call, so it doesn't help to call
// it here. Current hack is to call getService() on death notification after a delay.
}
#method_after
private void resetProxyAndRequestList() {
    mRadioProxy = null;
    mOemHookProxy = null;
    RILRequest.resetSerial();
    // Clear request list on close
    clearRequestList(RADIO_NOT_AVAILABLE, false);
// todo: need to get service right away so setResponseFunctions() can be called for
// unsolicited indications. getService() is not a blocking call, so it doesn't help to call
// it here. Current hack is to call getService() on death notification after a delay.
}
#end_block

#method_before
private IRadio getRadioProxy(Message result) {
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(RIL_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: mRadioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
        riljLoge("setResponseFunctions", e);
    }
    return mRadioProxy;
}
#method_after
private IRadio getRadioProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("Not calling getService(): wifi-only");
        return null;
    }
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(RIL_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: mRadioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
        riljLoge("setResponseFunctions", e);
    }
    return mRadioProxy;
}
#end_block

#method_before
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = ci.getMcc();
            c.mnc = ci.getMnc();
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = matchData;
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#method_after
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = ci.getMcc();
            c.mnc = ci.getMnc();
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = matchData;
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
static String requestToString(int request) {
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#method_after
static String requestToString(int request) {
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_REQUEST_SET_SIM_CARD_POWER:
            return "RIL_REQUEST_SET_SIM_CARD_POWER";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#end_block

#method_before
public boolean startPktFateMonitoring() {
    kilroy();
    try {
        kilroy();
        if (mIWifiStaIface == null)
            return false;
        WifiStatus status = mIWifiStaIface.startDebugPacketFateMonitoring();
        return status.code == WifiStatusCode.SUCCESS;
    } catch (RemoteException e) {
        kilroy();
        handleRemoteException(e);
        return false;
    }
}
#method_after
public boolean startPktFateMonitoring() {
    kilroy();
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return false;
        try {
            kilroy();
            WifiStatus status = mIWifiStaIface.startDebugPacketFateMonitoring();
            return status.code == WifiStatusCode.SUCCESS;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean getTxPktFates(WifiNative.TxFateReport[] reportBufs) {
    kilroy();
    if (ArrayUtils.isEmpty(reportBufs))
        return false;
    try {
        kilroy();
        MutableBoolean ok = new MutableBoolean(false);
        if (mIWifiStaIface == null)
            return false;
        mIWifiStaIface.getDebugTxPacketFates((status, fates) -> {
            kilroy();
            if (status.code != WifiStatusCode.SUCCESS)
                return;
            int i = 0;
            for (WifiDebugTxPacketFateReport fate : fates) {
                kilroy();
                if (i >= reportBufs.length)
                    break;
                byte code = halToFrameworkTxPktFate(fate.fate);
                long us = fate.frameInfo.driverTimestampUsec;
                byte type = halToFrameworkPktFateFrameType(fate.frameInfo.frameType);
                byte[] frame = NativeUtil.byteArrayFromArrayList(fate.frameInfo.frameContent);
                reportBufs[i++] = new WifiNative.TxFateReport(code, us, type, frame);
            }
            ok.value = true;
        });
        return ok.value;
    } catch (RemoteException e) {
        kilroy();
        handleRemoteException(e);
        return false;
    }
}
#method_after
public boolean getTxPktFates(WifiNative.TxFateReport[] reportBufs) {
    kilroy();
    if (ArrayUtils.isEmpty(reportBufs))
        return false;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return false;
        try {
            kilroy();
            MutableBoolean ok = new MutableBoolean(false);
            mIWifiStaIface.getDebugTxPacketFates((status, fates) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                int i = 0;
                for (WifiDebugTxPacketFateReport fate : fates) {
                    kilroy();
                    if (i >= reportBufs.length)
                        break;
                    byte code = halToFrameworkTxPktFate(fate.fate);
                    long us = fate.frameInfo.driverTimestampUsec;
                    byte type = halToFrameworkPktFateFrameType(fate.frameInfo.frameType);
                    byte[] frame = NativeUtil.byteArrayFromArrayList(fate.frameInfo.frameContent);
                    reportBufs[i++] = new WifiNative.TxFateReport(code, us, type, frame);
                }
                ok.value = true;
            });
            return ok.value;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean getRxPktFates(WifiNative.RxFateReport[] reportBufs) {
    kilroy();
    if (ArrayUtils.isEmpty(reportBufs))
        return false;
    try {
        kilroy();
        MutableBoolean ok = new MutableBoolean(false);
        if (mIWifiStaIface == null)
            return false;
        mIWifiStaIface.getDebugRxPacketFates((status, fates) -> {
            kilroy();
            if (status.code != WifiStatusCode.SUCCESS)
                return;
            int i = 0;
            for (WifiDebugRxPacketFateReport fate : fates) {
                kilroy();
                if (i >= reportBufs.length)
                    break;
                byte code = halToFrameworkRxPktFate(fate.fate);
                long us = fate.frameInfo.driverTimestampUsec;
                byte type = halToFrameworkPktFateFrameType(fate.frameInfo.frameType);
                byte[] frame = NativeUtil.byteArrayFromArrayList(fate.frameInfo.frameContent);
                reportBufs[i++] = new WifiNative.RxFateReport(code, us, type, frame);
            }
            ok.value = true;
        });
        return ok.value;
    } catch (RemoteException e) {
        kilroy();
        handleRemoteException(e);
        return false;
    }
}
#method_after
public boolean getRxPktFates(WifiNative.RxFateReport[] reportBufs) {
    kilroy();
    if (ArrayUtils.isEmpty(reportBufs))
        return false;
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return false;
        try {
            kilroy();
            MutableBoolean ok = new MutableBoolean(false);
            mIWifiStaIface.getDebugRxPacketFates((status, fates) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                int i = 0;
                for (WifiDebugRxPacketFateReport fate : fates) {
                    kilroy();
                    if (i >= reportBufs.length)
                        break;
                    byte code = halToFrameworkRxPktFate(fate.fate);
                    long us = fate.frameInfo.driverTimestampUsec;
                    byte type = halToFrameworkPktFateFrameType(fate.frameInfo.frameType);
                    byte[] frame = NativeUtil.byteArrayFromArrayList(fate.frameInfo.frameContent);
                    reportBufs[i++] = new WifiNative.RxFateReport(code, us, type, frame);
                }
                ok.value = true;
            });
            return ok.value;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null) {
        int[] ints = (int[]) ar.result;
        int state = ints[0];
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#method_after
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null && ar.result != null) {
        int state = (int) ar.result;
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#end_block

#method_before
public CellLocation getCellLocation() {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo();
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#method_after
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#end_block

#method_before
public List<CellInfo> getAllCellInfo() {
    CellInfoResult result = new CellInfoResult();
    if (VDBG)
        log("SST.getAllCellInfo(): E");
    int ver = mCi.getRilVersion();
    if (ver >= 8) {
        if (isCallerOnDifferentThread()) {
            if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime) > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
                Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST, result);
                synchronized (result.lockObj) {
                    result.list = null;
                    mCi.getCellInfoList(msg);
                    try {
                        result.lockObj.wait(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } else {
                if (DBG)
                    log("SST.getAllCellInfo(): return last, back to back calls");
                result.list = mLastCellInfoList;
            }
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): return last, same thread can't block");
            result.list = mLastCellInfoList;
        }
    } else {
        if (DBG)
            log("SST.getAllCellInfo(): not implemented");
        result.list = null;
    }
    synchronized (result.lockObj) {
        if (result.list != null) {
            if (VDBG)
                log("SST.getAllCellInfo(): X size=" + result.list.size() + " list=" + result.list);
            return result.list;
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): X size=0 list=null");
            return null;
        }
    }
}
#method_after
public List<CellInfo> getAllCellInfo(WorkSource workSource) {
    CellInfoResult result = new CellInfoResult();
    if (VDBG)
        log("SST.getAllCellInfo(): E");
    int ver = mCi.getRilVersion();
    if (ver >= 8) {
        if (isCallerOnDifferentThread()) {
            if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime) > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
                Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST, result);
                synchronized (result.lockObj) {
                    result.list = null;
                    mCi.getCellInfoList(msg, workSource);
                    try {
                        result.lockObj.wait(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } else {
                if (DBG)
                    log("SST.getAllCellInfo(): return last, back to back calls");
                result.list = mLastCellInfoList;
            }
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): return last, same thread can't block");
            result.list = mLastCellInfoList;
        }
    } else {
        if (DBG)
            log("SST.getAllCellInfo(): not implemented");
        result.list = null;
    }
    synchronized (result.lockObj) {
        if (result.list != null) {
            if (VDBG)
                log("SST.getAllCellInfo(): X size=" + result.list.size() + " list=" + result.list);
            return result.list;
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): X size=0 list=null");
            return null;
        }
    }
}
#end_block

#method_before
public void setSimPowerStateForSlot(int slotId, boolean powerUp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setSimPowerStateForSlot(slotId, powerUp);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setSimPowerState", e);
    } catch (SecurityException e) {
        Log.e(TAG, "Permission error calling ITelephony#setSimPowerStateForSlot", e);
    }
}
#method_after
public void setSimPowerStateForSlot(int slotId, boolean powerUp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setSimPowerStateForSlot(slotId, powerUp);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setSimPowerStateForSlot", e);
    } catch (SecurityException e) {
        Log.e(TAG, "Permission error calling ITelephony#setSimPowerStateForSlot", e);
    }
}
#end_block

#method_before
public String replace(char oldChar, char newChar) {
    String replaced = this;
    if (oldChar != newChar) {
        final int len = length();
        for (int i = 0; i < len; ++i) {
            if (charAt(i) == oldChar) {
                if (replaced == this) {
                    replaced = StringFactory.newStringFromString(this);
                }
                replaced.setCharAt(i, newChar);
            }
        }
    }
    return replaced;
}
#method_after
public String replace(char oldChar, char newChar) {
    if (oldChar != newChar) {
        final int len = length();
        for (int i = 0; i < len; ++i) {
            if (charAt(i) == oldChar) {
                return doReplace(oldChar, newChar);
            }
        }
    }
    return this;
}
#end_block

#method_before
public static Object newInstance(Class<?> componentType, int... dimensions) throws IllegalArgumentException, NegativeArraySizeException {
    if (dimensions.length <= 0 || dimensions.length > 255) {
        throw new IllegalArgumentException("Bad number of dimensions: " + dimensions.length);
    }
    if (componentType == void.class) {
        throw new IllegalArgumentException("Can't allocate an array of void");
    }
    if (componentType == null) {
        throw new NullPointerException("componentType == null");
    }
    return createMultiArray(componentType, dimensions);
}
#method_after
public static Object newInstance(Class<?> componentType, int length) throws NegativeArraySizeException {
    return newArray(componentType, length);
}
#end_block

#method_before
@Test
public void test_find() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    // depth will be 2. file4, file5, dir3 are not reachable.
    // Directory setup.
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir);
    expectedDirSet.add(dir1);
    expectedDirSet.add(dir2);
    expectedDirSet.add(dir4);
    expectedDirSet.add(dir5);
    Set<Path> dirSet = new HashSet<>();
    Stream<Path> pathStream = Files.find(rootDir, 2, (path, attr) -> Files.isDirectory(path));
    pathStream.forEach(path -> dirSet.add(path));
    assertEquals(expectedDirSet, dirSet);
}
#method_after
@Test
public void test_find() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    // Directory setup.
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    // When depth is 2 then file4, file5 and dir3 are not reachable.
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir);
    expectedDirSet.add(dir1);
    expectedDirSet.add(dir2);
    expectedDirSet.add(dir4);
    expectedDirSet.add(dir5);
    Set<Path> dirSet = new HashSet<>();
    Stream<Path> pathStream = Files.find(rootDir, 2, (path, attr) -> Files.isDirectory(path));
    pathStream.forEach(path -> dirSet.add(path));
    assertEquals(expectedDirSet, dirSet);
    // Test the case where depth is 0.
    expectedDirSet.clear();
    dirSet.clear();
    expectedDirSet.add(rootDir);
    pathStream = Files.find(rootDir, 0, (path, attr) -> Files.isDirectory(path));
    pathStream.forEach(path -> dirSet.add(path));
    assertEquals(expectedDirSet, dirSet);
    // Test the case where depth is -1.
    try {
        Files.find(rootDir, -1, (path, attr) -> Files.isDirectory(path));
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Test the case when BiPredicate always returns false.
    expectedDirSet.clear();
    dirSet.clear();
    pathStream = Files.find(rootDir, 2, (path, attr) -> false);
    pathStream.forEach(path -> dirSet.add(path));
    assertEquals(expectedDirSet, dirSet);
    // Test the case when start is not a directory.
    expectedDirSet.clear();
    dirSet.clear();
    expectedDirSet.add(file1);
    pathStream = Files.find(file1, 2, (path, attr) -> true);
    pathStream.forEach(path -> dirSet.add(path));
    assertEquals(expectedDirSet, dirSet);
}
#end_block

#method_before
@Test
public void test_lines$Path$Charset() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(TEST_FILE_DATA_2);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, Charset.forName("UTF-16"));
    try (Stream<String> readLines = Files.lines(filesSetup.getDataFilePath(), Charset.forName("UTF-16"))) {
        Iterator<String> lineIterator = lines.iterator();
        readLines.forEach(line -> assertEquals(line, lineIterator.next()));
    }
}
#method_after
@Test
public void test_lines$Path$Charset() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(UTF_16_DATA);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, StandardCharsets.UTF_16);
    try (Stream<String> readLines = Files.lines(filesSetup.getDataFilePath(), StandardCharsets.UTF_16)) {
        Iterator<String> lineIterator = lines.iterator();
        readLines.forEach(line -> assertEquals(line, lineIterator.next()));
    }
    // When Path is a directory
    filesSetup.reset();
    try (Stream<String> readLines = Files.lines(filesSetup.getTestDirPath(), StandardCharsets.UTF_16)) {
        try {
            readLines.count();
            fail();
        } catch (UncheckedIOException expected) {
        }
    }
    // When file doesn't exits.
    filesSetup.reset();
    try (Stream<String> readLines = Files.lines(filesSetup.getTestPath(), StandardCharsets.UTF_16)) {
        fail();
    } catch (NoSuchFileException expected) {
    }
}
#end_block

#method_before
@Test
public void test_lines$Path$Charset_NPE() throws IOException {
    try {
        Files.lines(null, Charset.forName("UTF-16"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.lines(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_lines$Path$Charset_NPE() throws IOException {
    try {
        Files.lines(null, StandardCharsets.UTF_16);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.lines(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_lines$Path() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(TEST_FILE_DATA_2);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, Charset.forName("UTF-8"));
    try (Stream<String> readLines = Files.lines(filesSetup.getDataFilePath())) {
        Iterator<String> lineIterator = lines.iterator();
        readLines.forEach(line -> assertEquals(line, lineIterator.next()));
    }
}
#method_after
@Test
public void test_lines$Path() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(TEST_FILE_DATA_2);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, StandardCharsets.UTF_8);
    try (Stream<String> readLines = Files.lines(filesSetup.getDataFilePath())) {
        Iterator<String> lineIterator = lines.iterator();
        readLines.forEach(line -> assertEquals(line, lineIterator.next()));
    }
    // When Path is a directory
    filesSetup.reset();
    try (Stream<String> readLines = Files.lines(filesSetup.getTestDirPath())) {
        try {
            readLines.count();
            fail();
        } catch (UncheckedIOException expected) {
        }
    }
    // When file doesn't exits.
    filesSetup.reset();
    try (Stream<String> readLines = Files.lines(filesSetup.getTestPath())) {
        fail();
    } catch (NoSuchFileException expected) {
    }
}
#end_block

#method_before
@Test
public void test_newBufferedReader() throws IOException {
    // Test the case where file doesn't exists.
    try {
        Files.newBufferedReader(filesSetup.getTestPath());
        fail();
    } catch (NoSuchFileException expected) {
    }
    BufferedReader bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath());
    assertEquals(TEST_FILE_DATA, bufferedReader.readLine());
    // Test the case where the file has unicode characters.
    writeToFile(filesSetup.getDataFilePath(), "");
    bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath());
    assertEquals("", bufferedReader.readLine());
    bufferedReader.close();
    // Test the case where file is write-only.
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("-w-------");
    Files.setPosixFilePermissions(filesSetup.getDataFilePath(), perm);
    try {
        Files.newBufferedReader(filesSetup.getDataFilePath());
        fail();
    } catch (AccessDeniedException expected) {
    }
}
#method_after
@Test
public void test_newBufferedReader() throws IOException {
    // Test the case where file doesn't exists.
    try {
        Files.newBufferedReader(filesSetup.getTestPath());
        fail();
    } catch (NoSuchFileException expected) {
    }
    BufferedReader bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath());
    assertEquals(TEST_FILE_DATA, bufferedReader.readLine());
    // Test the case where the file content has unicode characters.
    writeToFile(filesSetup.getDataFilePath(), UTF_16_DATA);
    bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath());
    assertEquals(UTF_16_DATA, bufferedReader.readLine());
    bufferedReader.close();
    // Test the case where file is write-only.
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("-w-------");
    Files.setPosixFilePermissions(filesSetup.getDataFilePath(), perm);
    try {
        Files.newBufferedReader(filesSetup.getDataFilePath());
        fail();
    } catch (AccessDeniedException expected) {
    }
}
#end_block

#method_before
@Test
public void test_newBufferedReader$Path$Charset() throws IOException {
    BufferedReader bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath(), Charset.forName("US-ASCII"));
    assertEquals(TEST_FILE_DATA, bufferedReader.readLine());
    // When the file has unicode characters.
    writeToFile(filesSetup.getDataFilePath(), "");
    bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath(), Charset.forName("US-ASCII"));
    try {
        bufferedReader.readLine();
        fail();
    } catch (MalformedInputException expected) {
    }
}
#method_after
@Test
public void test_newBufferedReader$Path$Charset() throws IOException {
    BufferedReader bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath(), StandardCharsets.US_ASCII);
    assertEquals(TEST_FILE_DATA, bufferedReader.readLine());
    // When the file has unicode characters.
    writeToFile(filesSetup.getDataFilePath(), UTF_16_DATA);
    bufferedReader = Files.newBufferedReader(filesSetup.getDataFilePath(), StandardCharsets.US_ASCII);
    try {
        bufferedReader.readLine();
        fail();
    } catch (MalformedInputException expected) {
    }
}
#end_block

#method_before
@Test
public void test_newBufferedReader$Path$Charset_NPE() throws IOException {
    try {
        Files.newBufferedReader(null, Charset.forName("US-ASCII"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.newBufferedReader(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_newBufferedReader$Path$Charset_NPE() throws IOException {
    try {
        Files.newBufferedReader(null, StandardCharsets.US_ASCII);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.newBufferedReader(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_newBufferedWriter$Path$Charset() throws IOException {
    BufferedWriter bufferedWriter = Files.newBufferedWriter(filesSetup.getTestPath(), Charset.forName("US-ASCII"));
    bufferedWriter.write(TEST_FILE_DATA);
    bufferedWriter.close();
    assertEquals(TEST_FILE_DATA, readFromFile(filesSetup.getTestPath()));
    // Writing unicode characters when charset is US-ASCII
    bufferedWriter = Files.newBufferedWriter(filesSetup.getTestPath(), Charset.forName("US-ASCII"));
    bufferedWriter.write("" + TEST_FILE_DATA);
    assertEquals("", readFromFile(filesSetup.getTestPath()));
}
#method_after
@Test
public void test_newBufferedWriter$Path$Charset() throws IOException {
    BufferedWriter bufferedWriter = Files.newBufferedWriter(filesSetup.getTestPath(), StandardCharsets.US_ASCII);
    bufferedWriter.write(TEST_FILE_DATA);
    bufferedWriter.close();
    assertEquals(TEST_FILE_DATA, readFromFile(filesSetup.getTestPath()));
}
#end_block

#method_before
@Test
public void test_newBufferedWriter$Path$Charset_NPE() throws IOException {
    try {
        Files.newBufferedWriter(null, Charset.forName("US-ASCII"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.newBufferedWriter(filesSetup.getTestPath(), (OpenOption[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_newBufferedWriter$Path$Charset_NPE() throws IOException {
    try {
        Files.newBufferedWriter(null, StandardCharsets.US_ASCII);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.newBufferedWriter(filesSetup.getTestPath(), (OpenOption[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_newByteChannel() throws IOException {
    // When file doesn't exist
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getTestPath())) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File opens in READ mode by default. The channel is non writable by default.
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath())) {
        sbc.write(ByteBuffer.allocate(10));
        fail();
    } catch (NonWritableChannelException expected) {
    }
    // Read a file.
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath())) {
        ByteBuffer readBuffer = ByteBuffer.allocate(10);
        int bytesReadCount = sbc.read(readBuffer);
        String readData = new String(Arrays.copyOf(readBuffer.array(), bytesReadCount), "UTF-8");
        assertEquals(TEST_FILE_DATA, readData);
    }
}
#method_after
@Test
public void test_newByteChannel() throws IOException {
    // When file doesn't exist
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getTestPath())) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File opens in READ mode by default. The channel is non writable by default.
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath())) {
        sbc.write(ByteBuffer.allocate(10));
        fail();
    } catch (NonWritableChannelException expected) {
    }
    // Read a file.
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath())) {
        ByteBuffer readBuffer = ByteBuffer.allocate(10);
        int bytesReadCount = sbc.read(readBuffer);
        String readData = new String(Arrays.copyOf(readBuffer.array(), bytesReadCount), StandardCharsets.UTF_8);
        assertEquals(TEST_FILE_DATA, readData);
    }
}
#end_block

#method_before
@Test
public void test_newByteChannel_openOption_WRITE_READ() throws IOException {
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath(), WRITE, READ, SYNC)) {
        ByteBuffer readBuffer = ByteBuffer.allocate(10);
        int bytesReadCount = sbc.read(readBuffer);
        String readData = new String(Arrays.copyOf(readBuffer.array(), bytesReadCount), "UTF-8");
        assertEquals(TEST_FILE_DATA, readData);
        // Pointer will move to the end of the file after read operation. The write should
        // append the data at the end of the file.
        sbc.write(ByteBuffer.wrap(TEST_FILE_DATA_2.getBytes()));
        try (InputStream is = Files.newInputStream(filesSetup.getDataFilePath())) {
            String expectedFileData = TEST_FILE_DATA + TEST_FILE_DATA_2;
            assertEquals(expectedFileData, readFromInputStream(is));
        }
    }
}
#method_after
@Test
public void test_newByteChannel_openOption_WRITE_READ() throws IOException {
    try (SeekableByteChannel sbc = Files.newByteChannel(filesSetup.getDataFilePath(), WRITE, READ, SYNC)) {
        ByteBuffer readBuffer = ByteBuffer.allocate(10);
        int bytesReadCount = sbc.read(readBuffer);
        String readData = new String(Arrays.copyOf(readBuffer.array(), bytesReadCount), StandardCharsets.UTF_8);
        assertEquals(TEST_FILE_DATA, readData);
        // Pointer will move to the end of the file after read operation. The write should
        // append the data at the end of the file.
        sbc.write(ByteBuffer.wrap(TEST_FILE_DATA_2.getBytes()));
        try (InputStream is = Files.newInputStream(filesSetup.getDataFilePath())) {
            String expectedFileData = TEST_FILE_DATA + TEST_FILE_DATA_2;
            assertEquals(expectedFileData, readFromInputStream(is));
        }
    }
}
#end_block

#method_before
@Test
public void test_readAllLine() throws IOException {
    // Multi-line file.
    assertTrue(Files.exists(filesSetup.getDataFilePath()));
    writeToFile(filesSetup.getDataFilePath(), "\n" + TEST_FILE_DATA_2, APPEND);
    List<String> out = Files.readAllLines(filesSetup.getDataFilePath());
    assertEquals(2, out.size());
    assertEquals(TEST_FILE_DATA, out.get(0));
    assertEquals(TEST_FILE_DATA_2, out.get(1));
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestPath());
        fail();
    } catch (NoSuchFileException expected) {
    }
}
#method_after
@Test
public void test_readAllLine() throws IOException {
    // Multi-line file.
    assertTrue(Files.exists(filesSetup.getDataFilePath()));
    writeToFile(filesSetup.getDataFilePath(), "\n" + TEST_FILE_DATA_2, APPEND);
    List<String> out = Files.readAllLines(filesSetup.getDataFilePath());
    assertEquals(2, out.size());
    assertEquals(TEST_FILE_DATA, out.get(0));
    assertEquals(TEST_FILE_DATA_2, out.get(1));
    // When file doesn't exist.
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestPath());
        fail();
    } catch (NoSuchFileException expected) {
    }
    // When file is a directory.
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestDirPath());
        fail();
    } catch (IOException expected) {
    }
}
#end_block

#method_before
@Test
public void test_readAllLine$Path$Charset() throws IOException {
    assertTrue(Files.exists(filesSetup.getDataFilePath()));
    writeToFile(filesSetup.getDataFilePath(), "\n" + TEST_FILE_DATA_2, APPEND);
    List<String> out = Files.readAllLines(filesSetup.getDataFilePath(), Charset.forName("UTF-8"));
    assertEquals(2, out.size());
    assertEquals(TEST_FILE_DATA, out.get(0));
    assertEquals(TEST_FILE_DATA_2, out.get(1));
    // With UTF-16.
    out = Files.readAllLines(filesSetup.getDataFilePath(), Charset.forName("UTF-16"));
    assertEquals(1, out.size());
    // UTF-8 data read as UTF-16
    assertEquals("", out.get(0));
    // When file doesn't exist.
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestPath(), Charset.forName("UTF-8"));
        fail();
    } catch (NoSuchFileException expected) {
    }
}
#method_after
@Test
public void test_readAllLine$Path$Charset() throws IOException {
    assertTrue(Files.exists(filesSetup.getDataFilePath()));
    writeToFile(filesSetup.getDataFilePath(), "\n" + TEST_FILE_DATA_2, APPEND);
    List<String> out = Files.readAllLines(filesSetup.getDataFilePath(), StandardCharsets.UTF_8);
    assertEquals(2, out.size());
    assertEquals(TEST_FILE_DATA, out.get(0));
    assertEquals(TEST_FILE_DATA_2, out.get(1));
    // With UTF-16.
    out = Files.readAllLines(filesSetup.getDataFilePath(), StandardCharsets.UTF_16);
    assertEquals(1, out.size());
    // UTF-8 data read as UTF-16
    String expectedOutput = new String((TEST_FILE_DATA + '\n' + TEST_FILE_DATA_2).getBytes(), StandardCharsets.UTF_16);
    assertEquals(expectedOutput, out.get(0));
    // When file doesn't exist.
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestPath(), StandardCharsets.UTF_16);
        fail();
    } catch (NoSuchFileException expected) {
    }
    // When file is a directory.
    filesSetup.reset();
    try {
        Files.readAllLines(filesSetup.getTestDirPath(), StandardCharsets.UTF_16);
        fail();
    } catch (IOException expected) {
    }
}
#end_block

#method_before
@Test
public void test_readAllLine$Path$Charset_NPE() throws IOException {
    try {
        Files.readAllLines(null, Charset.forName("UTF-16"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.readAllLines(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_readAllLine$Path$Charset_NPE() throws IOException {
    try {
        Files.readAllLines(null, StandardCharsets.UTF_16);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.readAllLines(filesSetup.getDataFilePath(), null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_walk$Path$FileVisitOption() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    // depth will be 2. file4, file5, dir3 is not reachable.
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir);
    expectedDirSet.add(dir1);
    expectedDirSet.add(dir2);
    expectedDirSet.add(dir4);
    expectedDirSet.add(file3);
    expectedDirSet.add(dir5);
    expectedDirSet.add(file1);
    Set<Path> dirSet = new HashSet<>();
    try (Stream<Path> pathStream = Files.walk(rootDir, 2, FileVisitOption.FOLLOW_LINKS)) {
        pathStream.forEach(path -> dirSet.add(path));
    }
    assertEquals(expectedDirSet, dirSet);
}
#method_after
@Test
public void test_walk$Path$FileVisitOption() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    // depth will be 2. file4, file5, dir3 is not reachable.
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir);
    expectedDirSet.add(dir1);
    expectedDirSet.add(dir2);
    expectedDirSet.add(dir4);
    expectedDirSet.add(file3);
    expectedDirSet.add(dir5);
    expectedDirSet.add(file1);
    Set<Path> dirSet = new HashSet<>();
    try (Stream<Path> pathStream = Files.walk(rootDir, 2, FileVisitOption.FOLLOW_LINKS)) {
        pathStream.forEach(path -> dirSet.add(path));
    }
    assertEquals(expectedDirSet, dirSet);
    // Test case when Path doesn't exist.
    try (Stream<Path> pathStream = Files.walk(filesSetup.getTestPath(), 2, FileVisitOption.FOLLOW_LINKS)) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // Test case when Path is a not a directory.
    expectedDirSet.clear();
    dirSet.clear();
    expectedDirSet.add(filesSetup.getDataFilePath());
    try (Stream<Path> pathStream = Files.walk(filesSetup.getDataFilePath(), 2, FileVisitOption.FOLLOW_LINKS)) {
        pathStream.forEach(path -> dirSet.add(path));
    }
    assertEquals(expectedDirSet, dirSet);
    // Test case when Path doesn't exist.
    try (Stream<Path> pathStream = Files.walk(rootDir, -1, FileVisitOption.FOLLOW_LINKS)) {
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
@Test
public void test_walk() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir.getFileName());
    expectedDirSet.add(dir1.getFileName());
    expectedDirSet.add(dir2.getFileName());
    expectedDirSet.add(dir4.getFileName());
    expectedDirSet.add(file3.getFileName());
    expectedDirSet.add(dir5.getFileName());
    expectedDirSet.add(file1.getFileName());
    expectedDirSet.add(file5.getFileName());
    expectedDirSet.add(dir3.getFileName());
    Set<Path> dirSet = new HashSet<>();
    try (Stream<Path> pathStream = Files.walk(rootDir)) {
        pathStream.forEach(path -> dirSet.add(path.getFileName()));
    }
    assertEquals(expectedDirSet, dirSet);
}
#method_after
@Test
public void test_walk() throws IOException {
    // Directory structure.
    // root
    //  dir1
    //     dir2
    //        dir3
    //        file5
    //     dir4
    //     file3
    //  dir5
    //  file1
    // 
    Path rootDir = Paths.get(filesSetup.getTestDir(), "root");
    Path dir1 = Paths.get(filesSetup.getTestDir(), "root/dir1");
    Path dir2 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2");
    Path dir3 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/dir3");
    Path dir4 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir4");
    Path dir5 = Paths.get(filesSetup.getTestDir(), "root/dir5");
    Path file1 = Paths.get(filesSetup.getTestDir(), "root/file1");
    Path file3 = Paths.get(filesSetup.getTestDir(), "root/dir1/file3");
    Path file5 = Paths.get(filesSetup.getTestDir(), "root/dir1/dir2/file5");
    Files.createDirectories(dir3);
    Files.createDirectories(dir4);
    Files.createDirectories(dir5);
    Files.createFile(file1);
    Files.createFile(file3);
    Files.createFile(file5);
    Set<Path> expectedDirSet = new HashSet<>();
    expectedDirSet.add(rootDir.getFileName());
    expectedDirSet.add(dir1.getFileName());
    expectedDirSet.add(dir2.getFileName());
    expectedDirSet.add(dir4.getFileName());
    expectedDirSet.add(file3.getFileName());
    expectedDirSet.add(dir5.getFileName());
    expectedDirSet.add(file1.getFileName());
    expectedDirSet.add(file5.getFileName());
    expectedDirSet.add(dir3.getFileName());
    Set<Path> dirSet = new HashSet<>();
    try (Stream<Path> pathStream = Files.walk(rootDir)) {
        pathStream.forEach(path -> dirSet.add(path.getFileName()));
    }
    assertEquals(expectedDirSet, dirSet);
    // Test case when Path doesn't exist.
    try (Stream<Path> pathStream = Files.walk(filesSetup.getTestPath())) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // Test case when Path is a not a directory.
    expectedDirSet.clear();
    dirSet.clear();
    expectedDirSet.add(filesSetup.getDataFilePath());
    try (Stream<Path> pathStream = Files.walk(filesSetup.getDataFilePath())) {
        pathStream.forEach(path -> dirSet.add(path));
    }
    assertEquals(expectedDirSet, dirSet);
}
#end_block

#method_before
@Test
public void test_write$Path$Iterable$Charset$OpenOption() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(TEST_FILE_DATA_2);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, Charset.forName("UTF-16"));
    List<String> readLines = Files.readAllLines(filesSetup.getDataFilePath(), Charset.forName("UTF-16"));
    assertEquals(readLines, lines);
}
#method_after
@Test
public void test_write$Path$Iterable$Charset$OpenOption() throws IOException {
    List<String> lines = new ArrayList<>();
    lines.add(TEST_FILE_DATA_2);
    lines.add(TEST_FILE_DATA);
    Files.write(filesSetup.getDataFilePath(), lines, StandardCharsets.UTF_16);
    List<String> readLines = Files.readAllLines(filesSetup.getDataFilePath(), StandardCharsets.UTF_16);
    assertEquals(readLines, lines);
}
#end_block

#method_before
@Test
public void test_write$Path$Iterable$Charset$OpenOption_NPE() throws IOException {
    try {
        Files.write(null, new ArrayList<>(), Charset.forName("UTF-16"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.write(filesSetup.getDataFilePath(), null, Charset.forName("UTF-16"));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.write(filesSetup.getDataFilePath(), new ArrayList<>(), (OpenOption[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_write$Path$Iterable$Charset$OpenOption_NPE() throws IOException {
    try {
        Files.write(null, new ArrayList<>(), StandardCharsets.UTF_16);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.write(filesSetup.getDataFilePath(), null, StandardCharsets.UTF_16);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.write(filesSetup.getDataFilePath(), new ArrayList<>(), (OpenOption[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_createTempDirectory$String$FileAttributes() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Path tmpDirectoryLocation = Paths.get(doPrivileged(new GetPropertyAction("java.io.tmpdir")));
    String tmpDir = "tmpDir";
    Path tmpDirPath = Files.createTempDirectory(tmpDir, attr);
    assertTrue(tmpDirPath.getFileName().toString().startsWith(tmpDir));
    assertEquals(tmpDirectoryLocation, tmpDirPath.getParent());
    assertTrue(Files.isDirectory(tmpDirPath));
    assertEquals(attr.value(), Files.getAttribute(tmpDirPath, attr.name()));
    // Test case when prefix is null.
    filesSetup.reset();
    tmpDirPath = Files.createTempDirectory(null, attr);
    assertEquals(tmpDirectoryLocation, tmpDirPath.getParent());
    assertTrue(Files.isDirectory(tmpDirPath));
    assertEquals(attr.value(), Files.getAttribute(tmpDirPath, attr.name()));
    try {
        Files.createTempDirectory(tmpDir, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_createTempDirectory$String$FileAttributes() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Path tmpDirectoryLocation = Paths.get(System.getProperty("java.io.tmpdir"));
    String tmpDir = "tmpDir";
    Path tmpDirPath = Files.createTempDirectory(tmpDir, attr);
    assertTrue(tmpDirPath.getFileName().toString().startsWith(tmpDir));
    assertEquals(tmpDirectoryLocation, tmpDirPath.getParent());
    assertTrue(Files.isDirectory(tmpDirPath));
    assertEquals(attr.value(), Files.getAttribute(tmpDirPath, attr.name()));
    // Test case when prefix is null.
    filesSetup.reset();
    tmpDirPath = Files.createTempDirectory(null, attr);
    assertEquals(tmpDirectoryLocation, tmpDirPath.getParent());
    assertTrue(Files.isDirectory(tmpDirPath));
    assertEquals(attr.value(), Files.getAttribute(tmpDirPath, attr.name()));
    try {
        Files.createTempDirectory(tmpDir, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Test
public void test_createTempFile$String$String$FileAttributes() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Path tmpDirectoryLocation = Paths.get(doPrivileged(new GetPropertyAction("java.io.tmpdir")));
    String tmpFilePrefix = "prefix";
    String tmpFileSuffix = "suffix";
    Path tmpFilePath = Files.createTempFile(tmpFilePrefix, tmpFileSuffix, attr);
    assertTrue(tmpFilePath.getFileName().toString().startsWith(tmpFilePrefix));
    assertTrue(tmpFilePath.getFileName().toString().endsWith(tmpFileSuffix));
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    // Test case when prefix is null.
    filesSetup.reset();
    tmpFilePath = Files.createTempFile(null, tmpFileSuffix, attr);
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(tmpFilePath.getFileName().toString().endsWith(tmpFileSuffix));
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    // Test case when suffix is null.
    filesSetup.reset();
    tmpFilePath = Files.createTempFile(tmpFilePrefix, null, attr);
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(tmpFilePath.getFileName().toString().startsWith(tmpFilePrefix));
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    try {
        Files.createTempFile(tmpFilePrefix, tmpFileSuffix, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_createTempFile$String$String$FileAttributes() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Path tmpDirectoryLocation = Paths.get(System.getProperty("java.io.tmpdir"));
    String tmpFilePrefix = "prefix";
    String tmpFileSuffix = "suffix";
    Path tmpFilePath = Files.createTempFile(tmpFilePrefix, tmpFileSuffix, attr);
    assertTrue(tmpFilePath.getFileName().toString().startsWith(tmpFilePrefix));
    assertTrue(tmpFilePath.getFileName().toString().endsWith(tmpFileSuffix));
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    // Test case when prefix is null.
    filesSetup.reset();
    tmpFilePath = Files.createTempFile(null, tmpFileSuffix, attr);
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(tmpFilePath.getFileName().toString().endsWith(tmpFileSuffix));
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    // Test case when suffix is null.
    filesSetup.reset();
    tmpFilePath = Files.createTempFile(tmpFilePrefix, null, attr);
    assertEquals(tmpDirectoryLocation, tmpFilePath.getParent());
    assertTrue(tmpFilePath.getFileName().toString().startsWith(tmpFilePrefix));
    assertTrue(Files.isRegularFile(tmpFilePath));
    assertEquals(attr.value(), Files.getAttribute(tmpFilePath, attr.name()));
    try {
        Files.createTempFile(tmpFilePrefix, tmpFileSuffix, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
private void addAnqpElementToMap(Map<Constants.ANQPElementType, ANQPElement> elementsMap, Constants.ANQPElementType infoID, ArrayList<Byte> payload) {
    ANQPElement element = parseAnqpElement(infoID, payload);
    if (element != null) {
        elementsMap.put(infoID, element);
    }
}
#method_after
private void addAnqpElementToMap(Map<Constants.ANQPElementType, ANQPElement> elementsMap, Constants.ANQPElementType infoID, ArrayList<Byte> payload) {
    if (payload == null || payload.isEmpty())
        return;
    ANQPElement element = parseAnqpElement(infoID, payload);
    if (element != null) {
        elementsMap.put(infoID, element);
    }
}
#end_block

#method_before
public boolean clearTargetBssid(String dbg) {
    WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mTargetNetworkId);
    if (config == null) {
        return false;
    }
    String bssid = SUPPLICANT_BSSID_ANY;
    if (config.BSSID != null) {
        bssid = config.BSSID;
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, "force BSSID to " + bssid + "due to config");
        }
    }
    if (mVerboseLoggingEnabled) {
        logd(dbg + " clearTargetBssid " + bssid + " key=" + config.configKey());
    }
    mTargetRoamBSSID = bssid;
    return mWifiSupplicantControl.setConfiguredNetworkBSSID(bssid);
}
#method_after
public boolean clearTargetBssid(String dbg) {
    WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mTargetNetworkId);
    if (config == null) {
        return false;
    }
    String bssid = SUPPLICANT_BSSID_ANY;
    if (config.BSSID != null) {
        bssid = config.BSSID;
        if (mVerboseLoggingEnabled) {
            Log.d(TAG, "force BSSID to " + bssid + "due to config");
        }
    }
    if (mVerboseLoggingEnabled) {
        logd(dbg + " clearTargetBssid " + bssid + " key=" + config.configKey());
    }
    mTargetRoamBSSID = bssid;
    return mWifiNative.setConfiguredNetworkBSSID(bssid);
}
#end_block

#method_before
private int lookupFrameworkNetworkId(int supplicantNetworkId) {
    return mWifiSupplicantControl.getFrameworkNetworkId(supplicantNetworkId);
}
#method_after
private int lookupFrameworkNetworkId(int supplicantNetworkId) {
    return mWifiNative.getFrameworkNetworkId(supplicantNetworkId);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiSupplicantControl.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiNative.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    int[] poll_result = null;
    try {
        poll_result = mClientInterface.signalPoll();
        if (poll_result == null || poll_result.length != 3) {
            return;
        }
    } catch (RemoteException e1) {
    }
    newRssi = poll_result[0];
    newLinkSpeed = poll_result[1];
    newFrequency = poll_result[2];
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#method_after
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    WifiNative.SignalPollResult pollResult = mWifiNative.signalPoll();
    if (pollResult == null) {
        return;
    }
    newRssi = pollResult.currentRssi;
    newLinkSpeed = pollResult.txBitrate;
    newFrequency = pollResult.associationFrequency;
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#end_block

#method_before
private void handleSupplicantConnectionLoss(boolean killSupplicant) {
    /* Socket connection can be lost when we do a graceful shutdown
        * or when the driver is hung. Ensure supplicant is stopped here.
        */
    if (killSupplicant) {
        mWifiMonitor.stopAllMonitoring();
        try {
            if (!mClientInterface.disableSupplicant()) {
                loge("Failed to disable supplicant after connection loss");
            }
        } catch (RemoteException e) {
        // Remote interface has died, there is no cleanup we can do.
        }
    }
    mWifiNative.closeSupplicantConnection();
    sendSupplicantConnectionChangedBroadcast(false);
    setWifiState(WIFI_STATE_DISABLED);
}
#method_after
private void handleSupplicantConnectionLoss(boolean killSupplicant) {
    /* Socket connection can be lost when we do a graceful shutdown
        * or when the driver is hung. Ensure supplicant is stopped here.
        */
    if (killSupplicant) {
        mWifiMonitor.stopAllMonitoring();
        if (!mWifiNative.disableSupplicant()) {
            loge("Failed to disable supplicant after connection loss");
        }
    }
    mWifiNative.closeSupplicantConnection();
    sendSupplicantConnectionChangedBroadcast(false);
    setWifiState(WIFI_STATE_DISABLED);
}
#end_block

#method_before
private void reportConnectionAttemptStart(WifiConfiguration config, String targetBSSID, int roamType) {
    mWifiMetrics.startConnectionEvent(config, targetBSSID, roamType);
    mWifiDiagnostics.reportConnectionEvent(WifiDiagnostics.CONNECTION_EVENT_STARTED);
}
#method_after
private void reportConnectionAttemptStart(WifiConfiguration config, String targetBSSID, int roamType) {
    mWifiMetrics.startConnectionEvent(config, targetBSSID, roamType);
    mDiagsConnectionStartMillis = mClock.getElapsedSinceBootMillis();
    mWifiDiagnostics.reportConnectionEvent(mDiagsConnectionStartMillis, WifiDiagnostics.CONNECTION_EVENT_STARTED);
    // TODO(b/35329124): Remove CMD_DIAGS_CONNECT_TIMEOUT, once WifiStateMachine
    // grows a proper CONNECTING state.
    sendMessageDelayed(CMD_DIAGS_CONNECT_TIMEOUT, mDiagsConnectionStartMillis, DIAGS_CONNECT_TIMEOUT_MILLIS);
}
#end_block

#method_before
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
            // Ideally, we'd wait until IP reachability has been confirmed. this code falls
            // short in two ways:
            // - at the time of the CMD_IP_CONFIGURATION_SUCCESSFUL event, we don't know if we
            // actually have ARP reachability. it might be better to wait until the wifi
            // network has been validated by IpManager.
            // - in the case of a roaming event (intra-SSID), we probably trigger when L2 is
            // complete.
            // 
            // TODO(b/34181219): Fix the above.
            mWifiDiagnostics.reportConnectionEvent(WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
            break;
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // where we failed to initiate a connection attempt with supplicant.
            break;
        default:
            mWifiDiagnostics.reportConnectionEvent(WifiDiagnostics.CONNECTION_EVENT_FAILED);
    }
}
#method_after
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
            // Ideally, we'd wait until IP reachability has been confirmed. this code falls
            // short in two ways:
            // - at the time of the CMD_IP_CONFIGURATION_SUCCESSFUL event, we don't know if we
            // actually have ARP reachability. it might be better to wait until the wifi
            // network has been validated by IpManager.
            // - in the case of a roaming event (intra-SSID), we probably trigger when L2 is
            // complete.
            // 
            // TODO(b/34181219): Fix the above.
            mWifiDiagnostics.reportConnectionEvent(mDiagsConnectionStartMillis, WifiDiagnostics.CONNECTION_EVENT_SUCCEEDED);
            break;
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // where we failed to initiate a connection attempt with supplicant.
            break;
        default:
            mWifiDiagnostics.reportConnectionEvent(mDiagsConnectionStartMillis, WifiDiagnostics.CONNECTION_EVENT_FAILED);
    }
    mDiagsConnectionStartMillis = -1;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_REMOVE_NETWORK:
            deleteNetworkConfigAndSendReply(message, false);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            deleteNetworkConfigAndSendReply(message, true);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
private void cleanup() {
    // Tearing down the client interfaces below is going to stop our supplicant.
    mWifiMonitor.stopAllMonitoring();
    mDeathRecipient.unlinkToDeath();
    if (mWificond != null) {
        try {
            mWificond.tearDownInterfaces();
        } catch (RemoteException e) {
            // There is very little we can do here
            Log.e(TAG, "Failed to tear down interfaces via wificond");
        }
        mWificond = null;
    }
    mWifiNative.stopHal();
}
#method_after
private void cleanup() {
    // Tearing down the client interfaces below is going to stop our supplicant.
    mWifiMonitor.stopAllMonitoring();
    mDeathRecipient.unlinkToDeath();
    mWifiNative.tearDownInterfaces();
    mWifiNative.stopHal();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal(true)) {
                // TODO(b/34859006): Handle failures.
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupDriverForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            if (!mWifiConfigManager.migrateFromLegacyStore()) {
                Log.e(TAG, "Failed to migrate from legacy config store");
            }
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            if (!mWifiConfigManager.migrateFromLegacyStore()) {
                Log.e(TAG, "Failed to migrate from legacy config store");
            }
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                mWifiNative.disableSupplicant();
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((long) message.obj, message.arg1 != 0);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            mPasspointManager.notifyIconDone((IconEvent) message.obj);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
    mWifiStateTracker.updateState(WifiStateTracker.CONNECT_MODE);
}
#method_after
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            setTargetBssid(config, bssid);
            mTargetNetworkId = netId;
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            setTargetBssid(config, bssid);
            mTargetNetworkId = netId;
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiNative.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = NativeUtil.macAddressToByteArray(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectingState State screenOn=" + mScreenOn);
    }
    // Make sure we disconnect: we enter this state prior to connecting to a new
    // network, waiting for either a DISCONNECT event or a SUPPLICANT_STATE_CHANGE
    // event which in this case will be indicating that supplicant started to associate.
    // In some cases supplicant doesn't ignore the connect requests (it might not
    // find the target SSID in its cache),
    // Therefore we end up stuck that state, hence the need for the watchdog.
    disconnectingWatchdogCount++;
    logd("Start Disconnecting Watchdog " + disconnectingWatchdogCount);
    sendMessageDelayed(obtainMessage(CMD_DISCONNECTING_WATCHDOG_TIMER, disconnectingWatchdogCount, 0), DISCONNECTING_GUARD_TIMER_MSEC);
    mWifiStateTracker.updateState(WifiStateTracker.DISCONNECTING);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectingState State screenOn=" + mScreenOn);
    }
    // Make sure we disconnect: we enter this state prior to connecting to a new
    // network, waiting for either a DISCONNECT event or a SUPPLICANT_STATE_CHANGE
    // event which in this case will be indicating that supplicant started to associate.
    // In some cases supplicant doesn't ignore the connect requests (it might not
    // find the target SSID in its cache),
    // Therefore we end up stuck that state, hence the need for the watchdog.
    disconnectingWatchdogCount++;
    logd("Start Disconnecting Watchdog " + disconnectingWatchdogCount);
    sendMessageDelayed(obtainMessage(CMD_DISCONNECTING_WATCHDOG_TIMER, disconnectingWatchdogCount, 0), DISCONNECTING_GUARD_TIMER_MSEC);
}
#end_block

#method_before
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = setupDriverForSoftAp();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
    mWifiStateTracker.updateState(WifiStateTracker.SOFT_AP);
}
#method_after
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = mWifiNative.setupDriverForSoftApMode();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
    mWifiStateTracker.updateState(WifiStateTracker.SOFT_AP);
}
#end_block

#method_before
public void updateState(int state) {
    int reportState;
    if (state != mWifiState) {
        switch(state) {
            case SCAN_MODE:
                reportState = BatteryStats.WIFI_STATE_OFF_SCANNING;
                break;
            case DISCONNECTED:
                reportState = BatteryStats.WIFI_STATE_ON_DISCONNECTED;
                break;
            case CONNECTED:
                reportState = BatteryStats.WIFI_STATE_ON_CONNECTED_STA;
                break;
            case DISCONNECTING:
                reportState = BatteryStats.WIFI_STATE_ON_NO_NETWORKS;
                break;
            case SOFT_AP:
                reportState = BatteryStats.WIFI_STATE_SOFT_AP;
                break;
            case INVALID:
                /* Reset to INVALID */
                break;
            default:
                return;
        }
        mWifiState = state;
        informWifiStateBatteryStats(reportState);
    }
    return;
}
#method_after
public void updateState(int state) {
    int reportState = BatteryStats.WIFI_STATE_OFF;
    if (state != mWifiState) {
        switch(state) {
            case SCAN_MODE:
                reportState = BatteryStats.WIFI_STATE_OFF_SCANNING;
                break;
            case DISCONNECTED:
                reportState = BatteryStats.WIFI_STATE_ON_DISCONNECTED;
                break;
            case CONNECTED:
                reportState = BatteryStats.WIFI_STATE_ON_CONNECTED_STA;
                break;
            case SOFT_AP:
                reportState = BatteryStats.WIFI_STATE_SOFT_AP;
                break;
            case INVALID:
                mWifiState = INVALID;
            /* Fall through */
            default:
                return;
        }
        mWifiState = state;
        informWifiStateBatteryStats(reportState);
    }
    return;
}
#end_block

#method_before
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        DBG = true;
    } else {
        DBG = false;
    }
}
#method_after
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        DBG = true;
    } else {
        DBG = false;
    }
    if (mWificondControl != null) {
        mWificondControl.enableVerboseLogging(verbose > 0 ? true : false);
    }
}
#end_block

#method_before
public boolean removeAllNetworks() {
    return doBooleanCommand("REMOVE_NETWORK all");
}
#method_after
public boolean removeAllNetworks() {
    if (!doBooleanCommand("REMOVE_NETWORK all")) {
        Log.e(TAG, "Remove all networks in wpa_supplicant failed");
        return false;
    }
    return true;
}
#end_block

#method_before
private static int frameworkRingBufferFlagsFromHal(int wifiDebugRingBufferFlag) {
    Checkoff checkoff = new Checkoff(wifiDebugRingBufferFlag);
    int flags = 0;
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_BINARY_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_BINARY_ENTRIES;
    }
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_ASCII_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_ASCII_ENTRIES;
    }
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_PER_PACKET_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_PER_PACKET_ENTRIES;
    }
    if (checkoff.value != 0)
        Log.e(TAG, "frameworkRingBufferFlagsFromHal got unknown flags");
    return flags;
}
#method_after
private static int frameworkRingBufferFlagsFromHal(int wifiDebugRingBufferFlag) {
    BitMask checkoff = new BitMask(wifiDebugRingBufferFlag);
    int flags = 0;
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_BINARY_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_BINARY_ENTRIES;
    }
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_ASCII_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_ASCII_ENTRIES;
    }
    if (checkoff.testAndClear(WifiDebugRingBufferFlags.HAS_PER_PACKET_ENTRIES)) {
        flags |= WifiNative.RingBufferStatus.HAS_PER_PACKET_ENTRIES;
    }
    if (checkoff.value != 0) {
        throw new IllegalArgumentException("Unknown WifiDebugRingBufferFlag " + checkoff.value);
    }
    return flags;
}
#end_block

#method_before
public WifiNative.RingBufferStatus[] getRingBufferStatus() {
    kilroy();
    class AnswerBox {

        public WifiNative.RingBufferStatus[] value = null;
    }
    AnswerBox ans = new AnswerBox();
    synchronized (sLock) {
        if (mIWifiChip == null)
            return null;
        try {
            kilroy();
            mIWifiChip.getDebugRingBuffersStatus((status, ringBuffers) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                ans.value = ringBufferStatusArray(ringBuffers);
            });
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return null;
        }
    }
    return ans.value;
}
#method_after
public WifiNative.RingBufferStatus[] getRingBufferStatus() {
    kilroy();
    class AnswerBox {

        public WifiNative.RingBufferStatus[] value = null;
    }
    AnswerBox ans = new AnswerBox();
    synchronized (sLock) {
        if (mIWifiChip == null)
            return null;
        try {
            kilroy();
            mIWifiChip.getDebugRingBuffersStatus((status, ringBuffers) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                ans.value = makeRingBufferStatusArray(ringBuffers);
            });
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return null;
        }
    }
    return ans.value;
}
#end_block

#method_before
public void enableVerboseLogging(boolean enable) {
    DBG = enable;
}
#method_after
public void enableVerboseLogging(boolean enable) {
    mVerboseLoggingEnabled = enable;
}
#end_block

#method_before
public ArrayList<ScanDetail> getScanResults() {
    ArrayList<ScanDetail> results = new ArrayList<>();
    if (mWificondScanner == null) {
        Log.e(TAG, "No valid wificond scanner interface handler");
        return results;
    }
    try {
        NativeScanResult[] nativeResults = mWificondScanner.getScanResults();
        for (NativeScanResult result : nativeResults) {
            WifiSsid wifiSsid = WifiSsid.createFromByteArray(result.ssid);
            String bssid = NativeUtil.macAddressFromByteArray(result.bssid);
            ScanResult.InformationElement[] ies = InformationElementUtil.parseInformationElements(result.infoElement);
            InformationElementUtil.Capabilities capabilities = new InformationElementUtil.Capabilities();
            capabilities.from(ies, result.capability);
            String flags = capabilities.generateCapabilitiesString();
            NetworkDetail networkDetail = new NetworkDetail(bssid, ies, null, result.frequency);
            if (!wifiSsid.toString().equals(networkDetail.getTrimmedSSID())) {
                Log.e(TAG, "Inconsistent SSID on BSSID: " + bssid);
                continue;
            }
            ScanDetail scanDetail = new ScanDetail(networkDetail, wifiSsid, bssid, flags, result.signalMbm / 100, result.frequency, result.tsf, ies, null);
            results.add(scanDetail);
        }
    } catch (RemoteException e1) {
        Log.e(TAG, "Failed to create ScanDetail ArrayList");
    }
    if (DBG)
        Log.d(TAG, "get " + results.size() + " scan results from wificond");
    return results;
}
#method_after
public ArrayList<ScanDetail> getScanResults() {
    ArrayList<ScanDetail> results = new ArrayList<>();
    if (mWificondScanner == null) {
        Log.e(TAG, "No valid wificond scanner interface handler");
        return results;
    }
    try {
        NativeScanResult[] nativeResults = mWificondScanner.getScanResults();
        for (NativeScanResult result : nativeResults) {
            WifiSsid wifiSsid = WifiSsid.createFromByteArray(result.ssid);
            String bssid = NativeUtil.macAddressFromByteArray(result.bssid);
            ScanResult.InformationElement[] ies = InformationElementUtil.parseInformationElements(result.infoElement);
            InformationElementUtil.Capabilities capabilities = new InformationElementUtil.Capabilities();
            capabilities.from(ies, result.capability);
            String flags = capabilities.generateCapabilitiesString();
            NetworkDetail networkDetail = new NetworkDetail(bssid, ies, null, result.frequency);
            if (!wifiSsid.toString().equals(networkDetail.getTrimmedSSID())) {
                Log.e(TAG, "Inconsistent SSID on BSSID: " + bssid);
                continue;
            }
            ScanDetail scanDetail = new ScanDetail(networkDetail, wifiSsid, bssid, flags, result.signalMbm / 100, result.frequency, result.tsf, ies, null);
            results.add(scanDetail);
        }
    } catch (RemoteException e1) {
        Log.e(TAG, "Failed to create ScanDetail ArrayList");
    }
    if (mVerboseLoggingEnabled) {
        Log.d(TAG, "get " + results.size() + " scan results from wificond");
    }
    return results;
}
#end_block

#method_before
public boolean removeAllNetworks() {
    return doBooleanCommand("REMOVE_NETWORK all");
}
#method_after
public boolean removeAllNetworks() {
    if (!doBooleanCommand("REMOVE_NETWORK all")) {
        Log.e(TAG, "Remove all networks in wpa_supplicant failed");
        return false;
    }
    return true;
}
#end_block

#method_before
private void retryGetImsService() {
    // Leave mImsManager as null, then CallStateException will be thrown when dialing
    mImsManager = null;
    // Exponential backoff during retry, limited to 32 seconds.
    loge("getImsService: Retrying getting ImsService...");
    removeMessages(EVENT_GET_IMS_SERVICE);
    sendEmptyMessageDelayed(EVENT_GET_IMS_SERVICE, (1 << mImsServiceRetryCount) * IMS_RETRY_STARTING_TIMEOUT_MS);
    if (mImsServiceRetryCount <= MAX_SERVICE_RETRY_COUNT) {
        mImsServiceRetryCount++;
    }
}
#method_after
private void retryGetImsService() {
    // Leave mImsManager as null, then CallStateException will be thrown when dialing
    mImsManager = null;
    // Exponential backoff during retry, limited to 32 seconds.
    loge("getImsService: Retrying getting ImsService...");
    removeMessages(EVENT_GET_IMS_SERVICE);
    sendEmptyMessageDelayed(EVENT_GET_IMS_SERVICE, (1 << mImsServiceRetryCount) * IMS_RETRY_STARTING_TIMEOUT_MS);
    if (mImsServiceRetryCount <= CEILING_SERVICE_RETRY_COUNT) {
        mImsServiceRetryCount++;
    }
}
#end_block

#method_before
public List<CellInfo> getAllCellInfo() {
    List<CellInfo> cellInfoList = getServiceStateTracker().getAllCellInfo();
    return privatizeCellInfoList(cellInfoList);
}
#method_after
public List<CellInfo> getAllCellInfo(WorkSource workSource) {
    List<CellInfo> cellInfoList = getServiceStateTracker().getAllCellInfo(workSource);
    return privatizeCellInfoList(cellInfoList);
}
#end_block

#method_before
public void setCellInfoListRate(int rateInMillis) {
    mCi.setCellInfoListRate(rateInMillis, null);
}
#method_after
public void setCellInfoListRate(int rateInMillis, WorkSource workSource) {
    mCi.setCellInfoListRate(rateInMillis, null, workSource);
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("Phone: subId=" + getSubId());
    pw.println(" mPhoneId=" + mPhoneId);
    pw.println(" mCi=" + mCi);
    pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
    pw.println(" mDcTracker=" + mDcTracker);
    pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
    pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
    pw.println(" mCallRingDelay=" + mCallRingDelay);
    pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
    pw.println(" mIccRecords=" + mIccRecords.get());
    pw.println(" mUiccApplication=" + mUiccApplication.get());
    pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
    pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
    pw.flush();
    pw.println(" mLooper=" + mLooper);
    pw.println(" mContext=" + mContext);
    pw.println(" mNotifier=" + mNotifier);
    pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
    pw.println(" mUnitTestMode=" + mUnitTestMode);
    pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
    pw.println(" getUnitTestMode()=" + getUnitTestMode());
    pw.println(" getState()=" + getState());
    pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
    pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
    pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
    pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
    pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
    pw.flush();
    pw.println(" isInEcm()=" + isInEcm());
    pw.println(" getPhoneName()=" + getPhoneName());
    pw.println(" getPhoneType()=" + getPhoneType());
    pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
    pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
    pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
    pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    if (mImsPhone != null) {
        try {
            mImsPhone.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mDcTracker != null) {
        try {
            mDcTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getServiceStateTracker() != null) {
        try {
            getServiceStateTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierActionAgent != null) {
        try {
            mCarrierActionAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierSignalAgent != null) {
        try {
            mCarrierSignalAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getCallTracker() != null) {
        try {
            getCallTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCi != null && mCi instanceof RIL) {
        try {
            ((RIL) mCi).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("Phone: subId=" + getSubId());
    pw.println(" mPhoneId=" + mPhoneId);
    pw.println(" mCi=" + mCi);
    pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
    pw.println(" mDcTracker=" + mDcTracker);
    pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
    pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
    pw.println(" mCallRingDelay=" + mCallRingDelay);
    pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
    pw.println(" mIccRecords=" + mIccRecords.get());
    pw.println(" mUiccApplication=" + mUiccApplication.get());
    pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
    pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
    pw.flush();
    pw.println(" mLooper=" + mLooper);
    pw.println(" mContext=" + mContext);
    pw.println(" mNotifier=" + mNotifier);
    pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
    pw.println(" mUnitTestMode=" + mUnitTestMode);
    pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
    pw.println(" getUnitTestMode()=" + getUnitTestMode());
    pw.println(" getState()=" + getState());
    pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
    pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
    pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
    pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
    pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
    pw.flush();
    pw.println(" isInEcm()=" + isInEcm());
    pw.println(" getPhoneName()=" + getPhoneName());
    pw.println(" getPhoneType()=" + getPhoneType());
    pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
    pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
    pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
    pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    if (mImsPhone != null) {
        try {
            mImsPhone.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mDcTracker != null) {
        try {
            mDcTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getServiceStateTracker() != null) {
        try {
            getServiceStateTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierActionAgent != null) {
        try {
            mCarrierActionAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierSignalAgent != null) {
        try {
            mCarrierSignalAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getCallTracker() != null) {
        try {
            getCallTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mSimActivationTracker != null) {
        try {
            mSimActivationTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCi != null && mCi instanceof RIL) {
        try {
            ((RIL) mCi).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
}
#end_block

#method_before
@Test
public void testbuildAnqpQueryCommandWithOnlyHsSubtypes() {
    String bssid = "34:12:ac:45:21:12";
    TreeSet<Integer> anqpIds = new TreeSet<>();
    TreeSet<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7));
    String expectedCommand = "HS20_ANQP_GET " + bssid + " 3,7";
    assertEquals(expectedCommand, WifiNative.buildAnqpQueryCommand(bssid, anqpIds, hs20Subtypes));
}
#method_after
@Test
public void testbuildAnqpQueryCommandWithOnlyHsSubtypes() {
    String bssid = "34:12:ac:45:21:12";
    Set<Integer> anqpIds = new TreeSet<>();
    Set<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7));
    String expectedCommand = "HS20_ANQP_GET " + bssid + " 3,7";
    assertEquals(expectedCommand, WifiNative.buildAnqpQueryCommand(bssid, anqpIds, hs20Subtypes));
}
#end_block

#method_before
@Test
public void testbuildAnqpQueryCommandWithMixedTypes() {
    String bssid = "34:12:ac:45:21:12";
    TreeSet<Integer> anqpIds = new TreeSet<>(Arrays.asList(1, 2, 5));
    TreeSet<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7));
    String expectedCommand = "ANQP_GET " + bssid + " 1,2,5,hs20:3,hs20:7";
    assertEquals(expectedCommand, WifiNative.buildAnqpQueryCommand(bssid, anqpIds, hs20Subtypes));
}
#method_after
@Test
public void testbuildAnqpQueryCommandWithMixedTypes() {
    String bssid = "34:12:ac:45:21:12";
    Set<Integer> anqpIds = new TreeSet<>(Arrays.asList(1, 2, 5));
    Set<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7));
    String expectedCommand = "ANQP_GET " + bssid + " 1,2,5,hs20:3,hs20:7";
    assertEquals(expectedCommand, WifiNative.buildAnqpQueryCommand(bssid, anqpIds, hs20Subtypes));
}
#end_block

#method_before
public Command createActionCommand(Action action, String skipPast, int monitorPort) {
    File workingDirectory = action.getUserDir();
    VmCommandBuilder vmCommandBuilder = run.mode.newVmCommandBuilder(action, workingDirectory);
    Classpath runtimeClasspath = run.mode.getRuntimeClasspath(action);
    if (run.useBootClasspath) {
        vmCommandBuilder.bootClasspath(runtimeClasspath);
    } else {
        vmCommandBuilder.classpath(runtimeClasspath);
    }
    if (monitorPort != -1) {
        vmCommandBuilder.args("--monitorPort", Integer.toString(monitorPort));
    }
    if (skipPast != null) {
        vmCommandBuilder.args("--skipPast", skipPast);
    }
    // Forward Caliper-specific parameters.
    if (run.runnerType.supportsCaliper()) {
        // Forward timeout value to Caliper which has its own separate timeout.
        vmCommandBuilder.args("--time-limit", String.format("%ds", timeoutSeconds));
        // Make caliper execute less slowly.
        // By default it takes an absurdly large amount of measurements and warms up
        // very slowly.
        // 
        // With this configuration execution is about 15x faster.
        vmCommandBuilder.args(// Don't run GC before each measurement. That will take forever.
        "-Cinstrument.runtime.options.gcBeforeEach=false", // Warmup super-quick, don't take more than 1sec.
        "-Cinstrument.runtime.options.warmup=1s", // measure themselves millions of times.
        "-Cinstrument.runtime.options.measurements=1");
    }
    return vmCommandBuilder.temp(workingDirectory).debugPort(run.debugPort).vmArgs(run.additionalVmArgs).mainClass(TestRunner.class.getName()).args(run.targetArgs).build(run.target);
}
#method_after
public Command createActionCommand(Action action, String skipPast, int monitorPort) {
    File workingDirectory = action.getUserDir();
    VmCommandBuilder vmCommandBuilder = run.mode.newVmCommandBuilder(action, workingDirectory);
    Classpath runtimeClasspath = run.mode.getRuntimeClasspath(action);
    if (run.useBootClasspath) {
        vmCommandBuilder.bootClasspath(runtimeClasspath);
    } else {
        vmCommandBuilder.classpath(runtimeClasspath);
    }
    if (monitorPort != -1) {
        vmCommandBuilder.args("--monitorPort", Integer.toString(monitorPort));
    }
    if (skipPast != null) {
        vmCommandBuilder.args("--skipPast", skipPast);
    }
    // Forward specific parameters to Caliper.
    if (run.runnerType.supportsCaliper()) {
        // Forward timeout value to Caliper which has its own separate timeout.
        vmCommandBuilder.args("--time-limit", String.format("%ds", timeoutSeconds));
        // This configuration runs about 15x faster than not having this configuration.
        vmCommandBuilder.args(// Don't run GC before each measurement. That will take forever.
        "-Cinstrument.runtime.options.gcBeforeEach=false", // Warmup super-quick, don't take more than 1sec.
        "-Cinstrument.runtime.options.warmup=1s", // measure themselves millions of times.
        "-Cinstrument.runtime.options.measurements=1");
    }
    return vmCommandBuilder.temp(workingDirectory).debugPort(run.debugPort).vmArgs(run.additionalVmArgs).mainClass(TestRunner.class.getName()).args(run.targetArgs).build(run.target);
}
#end_block

#method_before
@Test
public void testLoadFromStores() {
    WifiConfiguration pskNetwork = WifiConfigurationTestUtil.createPskNetwork();
    WifiConfiguration wepNetwork = WifiConfigurationTestUtil.createWepNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    eapNetwork.enterpriseConfig.setPassword("EapPassword");
    final List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(pskNetwork);
    networks.add(wepNetwork);
    networks.add(eapNetwork);
    // Return the config data with passwords masked from wpa_supplicant control interface.
    doAnswer(new AnswerWithArguments() {

        public int answer(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
            for (Map.Entry<String, WifiConfiguration> entry : createWpaSupplicantLoadData(networks).entrySet()) {
                configs.put(entry.getKey(), entry.getValue());
            }
            return 0;
        }
    }).when(mWifiNative).loadNetworks(any(Map.class), any(SparseArray.class));
    // Return the unmasked values during file parsing.
    doAnswer(new AnswerWithArguments() {

        public Map<String, String> answer(String fieldName) {
            if (fieldName.equals(WifiConfiguration.pskVarName)) {
                return createPskMap(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[0])) {
                return createWepKey0Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[1])) {
                return createWepKey1Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[2])) {
                return createWepKey2Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[3])) {
                return createWepKey3Map(networks);
            } else if (fieldName.equals(WifiEnterpriseConfig.PASSWORD_KEY)) {
                return createEapPasswordMap(networks);
            }
            return new HashMap<>();
        }
    }).when(mWifiNative).readNetworkVariablesFromSupplicantFile(anyString());
    WifiConfigStoreLegacy.WifiConfigStoreDataLegacy storeData = mWifiConfigStore.read();
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(networks, storeData.getConfigurations());
}
#method_after
@Test
public void testLoadFromStores() {
    WifiConfiguration pskNetwork = WifiConfigurationTestUtil.createPskNetwork();
    WifiConfiguration wepNetwork = WifiConfigurationTestUtil.createWepNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    eapNetwork.enterpriseConfig.setPassword("EapPassword");
    final List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(pskNetwork);
    networks.add(wepNetwork);
    networks.add(eapNetwork);
    // Return the config data with passwords masked from wpa_supplicant control interface.
    doAnswer(new AnswerWithArguments() {

        public int answer(Map<String, WifiConfiguration> configs, SparseArray<Map<String, String>> networkExtras) {
            for (Map.Entry<String, WifiConfiguration> entry : createWpaSupplicantLoadData(networks).entrySet()) {
                configs.put(entry.getKey(), entry.getValue());
            }
            return 0;
        }
    }).when(mWifiNative).migrateNetworksFromSupplicant(any(Map.class), any(SparseArray.class));
    // Return the unmasked values during file parsing.
    doAnswer(new AnswerWithArguments() {

        public Map<String, String> answer(String fieldName) {
            if (fieldName.equals(WifiConfiguration.pskVarName)) {
                return createPskMap(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[0])) {
                return createWepKey0Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[1])) {
                return createWepKey1Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[2])) {
                return createWepKey2Map(networks);
            } else if (fieldName.equals(WifiConfiguration.wepKeyVarNames[3])) {
                return createWepKey3Map(networks);
            } else if (fieldName.equals(WifiEnterpriseConfig.PASSWORD_KEY)) {
                return createEapPasswordMap(networks);
            }
            return new HashMap<>();
        }
    }).when(mWifiNative).readNetworkVariablesFromSupplicantFile(anyString());
    WifiConfigStoreLegacy.WifiConfigStoreDataLegacy storeData = mWifiConfigStore.read();
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(networks, storeData.getConfigurations());
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_REMOVE_NETWORK:
            deleteNetworkConfigAndSendReply(message, false);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            deleteNetworkConfigAndSendReply(message, true);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((long) message.obj, message.arg1 != 0);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            mPasspointManager.notifyIconDone((IconEvent) message.obj);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiNative.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiNative.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiNative.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiNative.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult = new WpsResult();
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    if (mWifiNative.startWpsPbc(wpsInfo.BSSID)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.KEYPAD:
                    if (mWifiNative.startWpsRegistrar(wpsInfo.BSSID, wpsInfo.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS push button configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult.pin = mWifiNative.startWpsPinDisplay(wpsInfo.BSSID);
                    if (!TextUtils.isEmpty(wpsResult.pin)) {
                        wpsResult.status = WpsResult.Status.SUCCESS;
                    } else {
                        Log.e(TAG, "Failed to start WPS pin method configuration");
                        wpsResult.status = WpsResult.Status.FAILURE;
                    }
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void loadFromWpaSupplicant(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    mWifiNative.loadNetworks(configurationMap, networkExtras);
    if (configurationMap.isEmpty()) {
        Log.w(TAG, "No wifi configurations found in wpa_supplicant");
        return;
    }
    // Now parse wpa_supplicant.conf for the masked fields.
    populateMaskedFieldsFromWpaSupplicantFile(configurationMap);
}
#method_after
private void loadFromWpaSupplicant(Map<String, WifiConfiguration> configurationMap, SparseArray<Map<String, String>> networkExtras) {
    mWifiNative.migrateNetworksFromSupplicant(configurationMap, networkExtras);
    if (configurationMap.isEmpty()) {
        Log.w(TAG, "No wifi configurations found in wpa_supplicant");
        return;
    }
    // Now parse wpa_supplicant.conf for the masked fields.
    populateMaskedFieldsFromWpaSupplicantFile(configurationMap);
}
#end_block

