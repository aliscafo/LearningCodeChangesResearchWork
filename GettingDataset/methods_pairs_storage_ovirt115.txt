611
#method_before
private static void updateNetworkInterfaceDataFromHost(VdsNetworkInterface iface, VDS host, Map<String, Object> nic) {
    if (nic != null) {
        if (nic.get("speed") != null) {
            Object speed = nic.get("speed");
            iface.setSpeed((Integer) speed);
        }
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        iface.setMacAddress((String) nic.get("hwaddr"));
        // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
        if (nic.get("permhwaddr") != null) {
            // in older VDSM version, slave's Mac is in upper case
            String macUpperCase = (String) nic.get("permhwaddr");
            iface.setMacAddress(macUpperCase.toLowerCase());
        }
        if (StringUtils.isNotBlank((String) nic.get(VdsProperties.MTU))) {
            iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.MTU)));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), host, iface);
    }
}
#method_after
private static void updateNetworkInterfaceDataFromHost(VdsNetworkInterface iface, VDS host, Map<String, Object> nic) {
    if (nic != null) {
        if (nic.get("speed") != null) {
            Object speed = nic.get("speed");
            iface.setSpeed((Integer) speed);
        }
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        iface.setMacAddress((String) nic.get("hwaddr"));
        // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
        if (nic.get("permhwaddr") != null) {
            // TODO remove when the minimal supported vdsm version is >=3.6
            // in older VDSM version, slave's Mac is in upper case
            String macUpperCase = (String) nic.get("permhwaddr");
            iface.setMacAddress(macUpperCase.toLowerCase());
        }
        if (StringUtils.isNotBlank((String) nic.get(VdsProperties.MTU))) {
            iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.MTU)));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), host, iface);
    }
}
#end_block

#method_before
private ExtMap mapLdapUser(LdapUser user) {
    ExtMap result = new ExtMap();
    result.mput(Authz.PrincipalRecord.NAMESPACE, NAMESPACE).mput(Authz.PrincipalRecord.ID, user.getUserId()).mput(Authz.PrincipalRecord.DEPARTMENT, user.getDepartment()).mput(Authz.PrincipalRecord.DISPLAY_NAME, user.getUserName()).mput(Authz.PrincipalRecord.EMAIL, user.getEmail()).mput(Authz.PrincipalRecord.FIRST_NAME, user.getName()).mput(Authz.PrincipalRecord.LAST_NAME, user.getSurName()).mput(Authz.PrincipalRecord.NAME, removeUpnSuffix(user.getUserName())).mput(Authz.PrincipalRecord.TITLE, user.getTitle());
    if (user.getGroups() != null) {
        List<ExtMap> groups = new ArrayList<>();
        for (LdapGroup group : user.getGroups().values()) {
            groups.add(mapLdapGroup(group));
        }
        result.put(Authz.PrincipalRecord.GROUPS, groups);
    }
    return result;
}
#method_after
private ExtMap mapLdapUser(LdapUser user) {
    ExtMap result = new ExtMap();
    result.mput(Authz.PrincipalRecord.NAMESPACE, NAMESPACE).mput(Authz.PrincipalRecord.ID, user.getUserId()).mput(Authz.PrincipalRecord.DEPARTMENT, user.getDepartment()).mput(Authz.PrincipalRecord.DISPLAY_NAME, user.getUserName()).mput(Authz.PrincipalRecord.EMAIL, user.getEmail()).mput(Authz.PrincipalRecord.FIRST_NAME, user.getName()).mput(Authz.PrincipalRecord.LAST_NAME, user.getSurName()).mput(Authz.PrincipalRecord.NAME, removeUpnSuffix(user.getUserName())).mput(Authz.PrincipalRecord.TITLE, user.getTitle()).mput(Authz.PrincipalRecord.PRINCIPAL, user.getUserName());
    if (user.getGroups() != null) {
        List<ExtMap> groups = new ArrayList<>();
        for (LdapGroup group : user.getGroups().values()) {
            groups.add(mapLdapGroup(group));
        }
        result.put(Authz.PrincipalRecord.GROUPS, groups);
    }
    return result;
}
#end_block

#method_before
public static ExtMap fetchPrincipalRecord(final ExtensionProxy extension, ExtMap authRecord) {
    ExtMap input = new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    return fetchPrincipalRecordImpl(extension, input);
}
#method_after
public static ExtMap fetchPrincipalRecord(final ExtensionProxy extension, ExtMap authRecord) {
    return fetchPrincipalRecordImpl(extension, Authn.InvokeKeys.AUTH_RECORD, authRecord);
}
#end_block

#method_before
public static ExtMap fetchPrincipalRecord(final ExtensionProxy extension, String principal) {
    ExtMap input = new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authz.InvokeKeys.PRINCIPAL, principal);
    return fetchPrincipalRecordImpl(extension, input);
}
#method_after
public static ExtMap fetchPrincipalRecord(final ExtensionProxy extension, String principal) {
    return fetchPrincipalRecordImpl(extension, Authz.InvokeKeys.PRINCIPAL, principal);
}
#end_block

#method_before
private static ExtMap fetchPrincipalRecordImpl(final ExtensionProxy extension, ExtMap input) {
    ExtMap ret = null;
    ExtMap output = extension.invoke(input);
    if (output.<Integer>get(Authz.InvokeKeys.STATUS) == Authz.Status.SUCCESS) {
        ret = output.<ExtMap>get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    }
    return ret;
}
#method_after
private static ExtMap fetchPrincipalRecordImpl(final ExtensionProxy extension, ExtKey key, Object value) {
    ExtMap ret = null;
    ExtMap output = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(key, value));
    if (output.<Integer>get(Authz.InvokeKeys.STATUS) == Authz.Status.SUCCESS) {
        ret = output.<ExtMap>get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    }
    return ret;
}
#end_block

#method_before
@Override
public int compareTo(GlusterVolumeOptionEntity obj) {
    return BusinessEntityComparator.newGuidInstance().compare(this, obj);
}
#method_after
@Override
public int compareTo(GlusterVolumeOptionEntity obj) {
    return BusinessEntityComparator.<GlusterVolumeOptionEntity, Guid>newInstance().compare(this, obj);
}
#end_block

#method_before
@Override
public int compareTo(DiskImageDynamic o) {
    return BusinessEntityComparator.newGuidInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(DiskImageDynamic o) {
    return BusinessEntityComparator.<DiskImageDynamic, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
@Override
public int compareTo(VmNetworkStatistics o) {
    return BusinessEntityComparator.newGuidInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmNetworkStatistics o) {
    return BusinessEntityComparator.<VmNetworkStatistics, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityComparator.newGuidInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityComparator.<VmDynamic, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
@Override
public int compareTo(VmStatistics o) {
    return BusinessEntityComparator.newGuidInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmStatistics o) {
    return BusinessEntityComparator.<VmStatistics, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
private void initTable(CommonApplicationConstants constants) {
    // $NON-NLS-1$
    String width = "284px";
    // Table Entity Columns
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getFirstName();
        }
    }, constants.firsNamePermissionsPopup(), width);
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getLastName();
        }
    }, constants.lastNamePermissionsPopup(), width);
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getLoginName();
        }
    }, constants.userNamePermissionsPopup(), width);
}
#method_after
private void initTable(CommonApplicationConstants constants) {
    // Table Entity Columns
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getFirstName();
        }
    }, constants.firsNamePermissionsPopup(), MAX_COL_WIDTH);
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getLastName();
        }
    }, constants.lastNamePermissionsPopup(), MAX_COL_WIDTH);
    searchItems.addColumn(new EntityModelTextColumn<DbUser>() {

        @Override
        public String getText(DbUser user) {
            return user.getLoginName();
        }
    }, constants.userNamePermissionsPopup(), MAX_COL_WIDTH);
}
#end_block

#method_before
public void init() {
    // the re-init can happen after logout/login.
    // As this class has it's state, it needs to be inited again
    initState();
    AsyncDataProvider.getRedirectServletReportsPage(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            setReportBaseUrl((String) returnValue);
        }
    }));
    parseReportsXML();
}
#method_after
public void init() {
    // the re-init can happen after logout/login.
    // As this class has it's state, it needs to be inited again
    initState();
    setReportBaseUrl(buildUrl(REDIRECT_SERVICE));
    parseReportsXML();
}
#end_block

#method_before
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    urlInitialized = false;
    scheduleParseReportsInProgress = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<String, Resource>();
    dashboardMap = new HashMap<String, Dashboard>();
    // $NON-NLS-1$
    reportsInitEvent = new Event("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#method_after
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    reportsWebappDeployed = false;
    scheduledStatusCheckInProgress = false;
    initEventRaised = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<String, Resource>();
    dashboardMap = new HashMap<String, Dashboard>();
    // $NON-NLS-1$
    reportsInitEvent = new Event("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#end_block

#method_before
private void parseReportsXML() {
    RequestBuilder requestBuilder = new RequestBuilder(RequestBuilder.GET, // $NON-NLS-1$
    "/" + BaseContextPathData.getInstance().getRelativePath() + // $NON-NLS-1$
    "services/reports-xml");
    try {
        requestBuilder.sendRequest(null, new RequestCallback() {

            @Override
            public void onError(Request request, Throwable exception) {
                setXmlInitialized();
                scheduleParseReportsXML();
            }

            @Override
            public void onResponseReceived(Request request, Response response) {
                try {
                    if (response.getStatusCode() == Response.SC_OK) {
                        if (response.getText().trim().equals(REPORTS_WEBAPP_NOT_DEPLOYED_MSG)) {
                            scheduleParseReportsXML();
                        } else if (ReportParser.getInstance().parseReport(response.getText())) {
                            resourceMap = ReportParser.getInstance().getResourceMap();
                            dashboardMap = ReportParser.getInstance().getDashboardMap();
                            isCommunityEdition = ReportParser.getInstance().isCommunityEdition();
                        }
                    }
                } catch (DOMParseException e) {
                } finally {
                    setXmlInitialized();
                }
            }
        });
    } catch (RequestException e) {
        setXmlInitialized();
    }
}
#method_after
private void parseReportsXML() {
    try {
        constructServiceRequestBuilder(XML_SERVICE).sendRequest(null, new RequestCallback() {

            @Override
            public void onError(Request request, Throwable exception) {
                scheduleCheckStatus();
                setXmlInitialized();
            }

            @Override
            public void onResponseReceived(Request request, Response response) {
                if (response.getStatusCode() == Response.SC_OK) {
                    try {
                        if (ReportParser.getInstance().parseReport(response.getText())) {
                            resourceMap = ReportParser.getInstance().getResourceMap();
                            dashboardMap = ReportParser.getInstance().getDashboardMap();
                            isCommunityEdition = ReportParser.getInstance().isCommunityEdition();
                        }
                    } catch (DOMParseException e) {
                    } finally {
                        setXmlInitialized();
                    }
                } else {
                    scheduleCheckStatus();
                    setXmlInitialized();
                }
            }
        });
    } catch (RequestException e) {
        setXmlInitialized();
    }
}
#end_block

#method_before
public void setReportBaseUrl(String reportBaseUrl) {
    this.reportBaseUrl = reportBaseUrl;
    this.urlInitialized = true;
    checkIfInitFinished();
}
#method_after
public void setReportBaseUrl(String reportBaseUrl) {
    if (reportBaseUrl != null) {
        this.reportBaseUrl = reportBaseUrl;
    }
    checkIfInitFinished();
}
#end_block

#method_before
private void checkIfInitFinished() {
    if (xmlInitialized && urlInitialized && ssoToken != null) {
        // Check if the reports should be enabled in this system
        if (!"".equals(reportBaseUrl) && !resourceMap.isEmpty() && !"".equals(ssoToken)) {
            // $NON-NLS-1$ $NON-NLS-2$
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        // The initialization process blocks on this event after the login
        reportsInitEvent.raise(this, null);
    }
}
#method_after
private void checkIfInitFinished() {
    if (xmlInitialized && ssoToken != null) {
        // Check if the reports should be enabled in this system
        if (!"".equals(reportBaseUrl) && !resourceMap.isEmpty() && !"".equals(ssoToken)) {
            // $NON-NLS-1$ $NON-NLS-2$
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        if (isReportsEnabled() && !initEventRaised) {
            reportsInitEvent.raise(this, null);
            initEventRaised = true;
        }
    }
}
#end_block

#method_before
protected static long copy(final InputStream input, final OutputStream output) throws IOException {
    final byte[] buffer = new byte[8024];
    long count = 0;
    int n;
    while ((n = input.read(buffer)) != -1) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}
#method_after
protected static long copy(final InputStream input, final OutputStream output) throws IOException {
    final byte[] buffer = new byte[8 * 1024];
    long count = 0;
    int n;
    while ((n = input.read(buffer)) != -1) {
        output.write(buffer, 0, n);
        count += n;
    }
    return count;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    /*
         * short circute if we have nothing to do.
         */
    if (url == null) {
        response.sendError(response.SC_NOT_FOUND, "Cannot proxy, no URL is configured.");
        return;
    }
    String targetURL = url;
    if (request.getQueryString() != null) {
        URL u = new URL(url);
        if (u.getQuery() == null) {
            targetURL += "?";
        } else {
            targetURL += "&";
        }
        targetURL += request.getQueryString();
    }
    URLConnection connection = new URL(targetURL).openConnection();
    connection.setDoInput(true);
    connection.setDoOutput(false);
    connection.setAllowUserInteraction(false);
    connection.setUseCaches(false);
    if (readTimeout != null) {
        connection.setReadTimeout(readTimeout);
    }
    if (connection instanceof HttpsURLConnection) {
        HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;
        try {
            TrustManager[] tm = null;
            if (verifyChain) {
                if (trustStore != null) {
                    try (InputStream is = new FileInputStream(trustStore)) {
                        KeyStore ks = KeyStore.getInstance(trustStoreType);
                        ks.load(is, trustStorePassword.toCharArray());
                        TrustManagerFactory tmf = TrustManagerFactory.getInstance(trustManagerAlgorithm);
                        tmf.init(ks);
                        tm = tmf.getTrustManagers();
                    }
                } else {
                    tm = new TrustManager[] { new X509TrustManager() {

                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[] {};
                        }

                        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                    } };
                }
            }
            SSLContext sslContext = SSLContext.getInstance(httpsProtocol);
            sslContext.init(null, tm, null);
            httpsConnection.setSSLSocketFactory(sslContext.getSocketFactory());
            if (!verifyHost) {
                httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                });
            }
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
    connection.connect();
    try {
        if (connection instanceof HttpURLConnection) {
            response.setStatus(((HttpURLConnection) connection).getResponseCode());
        }
        for (Map.Entry<String, List<String>> entry : connection.getHeaderFields().entrySet()) {
            if (entry.getKey() != null) {
                boolean first = true;
                for (String value : entry.getValue()) {
                    if (first) {
                        first = false;
                        response.setHeader(entry.getKey(), value);
                    } else {
                        response.addHeader(entry.getKey(), value);
                    }
                }
            }
        }
        copy(connection.getInputStream(), response.getOutputStream());
    } finally {
        if (connection instanceof HttpURLConnection) {
            ((HttpURLConnection) connection).disconnect();
        }
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    if (url == null) {
        response.sendError(response.SC_NOT_FOUND, "Cannot proxy, no URL is configured.");
    } else {
        URLConnection connection;
        try {
            connection = createConnection(new URL(mergeQuery(url, request.getQueryString())));
        } catch (Exception e) {
            throw new ServletException(e);
        }
        connection.connect();
        try {
            if (connection instanceof HttpURLConnection) {
                response.setStatus(((HttpURLConnection) connection).getResponseCode());
            }
            for (Map.Entry<String, List<String>> entry : connection.getHeaderFields().entrySet()) {
                if (entry.getKey() != null) {
                    boolean first = true;
                    for (String value : entry.getValue()) {
                        if (first) {
                            first = false;
                            response.setHeader(entry.getKey(), value);
                        } else {
                            response.addHeader(entry.getKey(), value);
                        }
                    }
                }
            }
            copy(connection.getInputStream(), response.getOutputStream());
        } finally {
            if (connection instanceof HttpURLConnection) {
                ((HttpURLConnection) connection).disconnect();
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected Guid getInstanceTypeId() {
    return instanceTypeId;
}
#method_after
protected Guid getInstanceTypeId() {
    if (getParameters().getVmStaticData() != null) {
        return getParameters().getVmStaticData().getInstanceTypeId();
    }
    return null;
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null && vmStatic != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!VmDeviceUtils.getSoundDevices(instanceType.getId()).isEmpty());
        getParameters().setVirtioScsiEnabled(!VmDeviceUtils.getVirtioScsiControllers(instanceType.getId()).isEmpty());
        getParameters().setUpdateWatchdog(true);
        List<VmDevice> vmDevices = VmDeviceUtils.getWatchdogs(instanceType.getId());
        if (!vmDevices.isEmpty()) {
            vmDevices.get(0).setVmId(getVmId());
            getParameters().setWatchdog(new VmWatchdog(vmDevices.get(0)));
        }
        getParameters().setUpdateRngDevice(true);
        vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.RNG);
        if (!vmDevices.isEmpty()) {
            vmDevices.get(0).setVmId(getVmId());
            getParameters().setRngDevice(new VmRngDevice(vmDevices.get(0)));
        }
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!VmDeviceUtils.getSoundDevices(instanceType.getId()).isEmpty());
        getParameters().setVirtioScsiEnabled(!VmDeviceUtils.getVirtioScsiControllers(instanceType.getId()).isEmpty());
        getParameters().setUpdateWatchdog(true);
        List<VmDevice> vmDevices = VmDeviceUtils.getWatchdogs(instanceType.getId());
        if (!vmDevices.isEmpty()) {
            vmDevices.get(0).setVmId(getVmId());
            getParameters().setWatchdog(new VmWatchdog(vmDevices.get(0)));
        }
        getParameters().setUpdateRngDevice(true);
        vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.RNG);
        if (!vmDevices.isEmpty()) {
            vmDevices.get(0).setVmId(getVmId());
            getParameters().setRngDevice(new VmRngDevice(vmDevices.get(0)));
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setvolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private void validateKdcServers(String ldapSecurityAuthentication, String domainName) throws ManageDomainsResult {
    KDCLocator locator = new KDCLocator();
    DnsSRVResult result = null;
    boolean foundServers = true;
    try {
        result = locator.getKdc(DnsSRVLocator.TCP, domainName);
        if (!foundSrvRecords(result)) {
            result = locator.getKdc(DnsSRVLocator.UDP, domainName);
            if (!foundSrvRecords(result)) {
                foundServers = false;
            }
        }
    } catch (Exception ex) {
        foundServers = false;
    }
    if (!foundServers) {
        throw new ManageDomainsResult("Could not locate KDC servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_KDC_SERVERS_FOR_DOMAIN, domainName);
    }
}
#method_after
private void validateKdcServers(String ldapSecurityAuthentication, String domainName) throws ManageDomainsResult {
    if (shouldResolveKdc()) {
        KDCLocator locator = new KDCLocator();
        DnsSRVResult result = null;
        boolean foundServers = true;
        try {
            result = locator.getKdc(DnsSRVLocator.TCP, domainName);
            if (!foundSrvRecords(result)) {
                result = locator.getKdc(DnsSRVLocator.UDP, domainName);
                if (!foundSrvRecords(result)) {
                    foundServers = false;
                }
            }
        } catch (Exception ex) {
            foundServers = false;
        }
        if (!foundServers) {
            throw new ManageDomainsResult("Could not locate KDC servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_KDC_SERVERS_FOR_DOMAIN, domainName);
        }
    }
}
#end_block

#method_before
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    if (shouldResolveKdc()) {
        validateKdcServers(authMode, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    if (ldapProviderType == null) {
        System.err.println("Provider typ was not provided. Use --providerType=<ldap_provider_type");
    } else {
        adUserNameEntry.setValueForDomain(domainName, userName);
        adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
        authModeEntry.setValueForDomain(domainName, authMode);
        ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
        if (args.contains(ARG_LDAP_SERVERS)) {
            setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
        }
        handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
        testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
        handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
        // Update the configuration
        setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
        printSuccessMessage(domainName, "added");
    }
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    if (ldapProviderType == null) {
        System.err.println("Provider typ was not provided. Use --providerType=<ldap_provider_type");
    } else {
        adUserNameEntry.setValueForDomain(domainName, userName);
        adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
        authModeEntry.setValueForDomain(domainName, authMode);
        ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
        if (args.contains(ARG_LDAP_SERVERS)) {
            setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
        }
        handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
        testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
        handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
        // Update the configuration
        setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
        printSuccessMessage(domainName, "added");
    }
}
#end_block

#method_before
@Override
public void dispatchEvent(AuditLogEvent event, String address) {
    Profile profile = profiles.get(address);
    if (profile == null) {
        profile = profiles.get("");
        if (profile == null) {
            log.warn("Could not find snmp profile: " + address);
            return;
        }
    }
    // PDU class is for SNMPv2c units
    PDU v2pdu = new PDU();
    v2pdu.setType(PDU.TRAP);
    int auditLogTypeVal = AuditLogType.UNASSIGNED.getValue();
    try {
        // TODO mtayer: what about db? add to audit log type
        auditLogTypeVal = AuditLogType.valueOf(event.getName()).getValue();
    } catch (IllegalArgumentException e) {
        log.warn("Could not find event: " + event.getName() + " in auditLogTypes");
    }
    OID trapOID = SnmpConstants.getTrapOID(profile.oid, ENTERPRISE_SPECIFIC, auditLogTypeVal);
    v2pdu.add(new VariableBinding(SnmpConstants.snmpTrapOID, trapOID));
    v2pdu.add(new VariableBinding(SnmpConstants.sysUpTime, new TimeTicks((System.nanoTime() - nanoStart) / 10000)));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(0), new OctetString(event.getMessage())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(1), new OctetString(event.getSeverity().name())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(2), new OctetString(event.getType().name())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(3), new OctetString(event.getLogTime().toString())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(4), new OctetString(event.getLogTypeName())));
    if (!StringUtils.isEmpty(event.getUserName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(5), new OctetString(event.getUserName())));
    }
    if (!StringUtils.isEmpty(event.getVmName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(6), new OctetString(event.getVmName())));
    }
    if (!StringUtils.isEmpty(event.getVdsName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(7), new OctetString(event.getVdsName())));
    }
    if (!StringUtils.isEmpty(event.getVmTemplateName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(8), new OctetString(event.getVmTemplateName())));
    }
    if (!StringUtils.isEmpty(event.getStoragePoolName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(9), new OctetString(event.getStoragePoolName())));
    }
    if (!StringUtils.isEmpty(event.getStorageDomainName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(10), new OctetString(event.getStorageDomainName())));
    }
    CommunityTarget target = new CommunityTarget();
    target.setCommunity(profile.community);
    target.setVersion(SnmpConstants.version2c);
    for (Host host : profile.hosts) {
        try {
            log.info(String.format("Generate an snmp trap for event: %s to address: %s ", event, host.name));
            target.setAddress(new UdpAddress(InetAddress.getByName(host.name), host.port));
            snmp.send(v2pdu, target);
            notifyObservers(DispatchResult.success(event, address, EventNotificationMethod.SNMP));
        } catch (Exception e) {
            log.error(e.getMessage());
            notifyObservers(DispatchResult.failure(event, address, EventNotificationMethod.SNMP, e.getMessage()));
        }
    }
}
#method_after
@Override
public void dispatchEvent(AuditLogEvent event, String address) {
    Profile profile = profiles.get(address);
    if (profile == null) {
        profile = profiles.get("");
        if (profile == null) {
            log.warn("Could not find snmp profile: " + address);
            return;
        }
    }
    // PDU class is for SNMPv2c units
    PDU v2pdu = new PDU();
    v2pdu.setType(PDU.TRAP);
    int auditLogTypeVal = AuditLogType.UNASSIGNED.getValue();
    try {
        // TODO mtayer: what about db? add to audit log type
        auditLogTypeVal = AuditLogType.valueOf(event.getName()).getValue();
    } catch (IllegalArgumentException e) {
        log.warn("Could not find event: " + event.getName() + " in auditLogTypes");
    }
    OID trapOID = SnmpConstants.getTrapOID(profile.oid, ENTERPRISE_SPECIFIC, auditLogTypeVal);
    v2pdu.add(new VariableBinding(SnmpConstants.snmpTrapOID, trapOID));
    v2pdu.add(new VariableBinding(SnmpConstants.sysUpTime, new TimeTicks((System.nanoTime() - nanoStart) / 10000000)));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(0), new OctetString(event.getMessage())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(1), new OctetString(event.getSeverity().name())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(2), new OctetString(event.getType().name())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(3), new OctetString(event.getLogTime().toString())));
    v2pdu.add(new VariableBinding(new OID(trapOID).append(4), new OctetString(event.getLogTypeName())));
    if (!StringUtils.isEmpty(event.getUserName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(5), new OctetString(event.getUserName())));
    }
    if (!StringUtils.isEmpty(event.getVmName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(6), new OctetString(event.getVmName())));
    }
    if (!StringUtils.isEmpty(event.getVdsName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(7), new OctetString(event.getVdsName())));
    }
    if (!StringUtils.isEmpty(event.getVmTemplateName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(8), new OctetString(event.getVmTemplateName())));
    }
    if (!StringUtils.isEmpty(event.getStoragePoolName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(9), new OctetString(event.getStoragePoolName())));
    }
    if (!StringUtils.isEmpty(event.getStorageDomainName())) {
        v2pdu.add(new VariableBinding(new OID(trapOID).append(10), new OctetString(event.getStorageDomainName())));
    }
    CommunityTarget target = new CommunityTarget();
    target.setCommunity(profile.community);
    target.setVersion(SnmpConstants.version2c);
    for (Host host : profile.hosts) {
        try {
            log.info(String.format("Generate an snmp trap for event: %s to address: %s ", event, host.name));
            target.setAddress(new UdpAddress(InetAddress.getByName(host.name), host.port));
            snmp.send(v2pdu, target);
            notifyObservers(DispatchResult.success(event, address, EventNotificationMethod.SNMP));
        } catch (Exception e) {
            log.error(e.getMessage());
            notifyObservers(DispatchResult.failure(event, address, EventNotificationMethod.SNMP, e.getMessage()));
        }
    }
}
#end_block

#method_before
private Response createVmFromSnapshot(VM vm) {
    // If Vm has snapshots collection - this is a clone vm from snapshot operation
    String snapshotId = getSnapshotId(vm.getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
    // If vm passed in the call has disks attached on them,
    // merge their data with the data of the disks on the configuration
    // The parameters to AddVmFromSnapshot hold an array list of Disks
    // and not List of Disks, as this is a GWT serialization limitation,
    // and this parameter class serves GWT clients as well.
    HashMap<Guid, DiskImage> diskImagesByImageId = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
    if (vm.isSetDisks()) {
        prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesByImageId);
    }
    return cloneVmFromSnapshot(vmConfiguration.getStaticData(), vm, snapshotId, diskImagesByImageId);
}
#method_after
private Response createVmFromSnapshot(VM vm) {
    // If Vm has snapshots collection - this is a clone vm from snapshot operation
    String snapshotId = getSnapshotId(vm.getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
    // If vm passed in the call has disks attached on them,
    // merge their data with the data of the disks on the configuration
    // The parameters to AddVmFromSnapshot hold an array list of Disks
    // and not List of Disks, as this is a GWT serialization limitation,
    // and this parameter class serves GWT clients as well.
    HashMap<Guid, DiskImage> diskImagesByImageId = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
    if (vm.isSetDisks()) {
        prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesByImageId);
    }
    return cloneVmFromSnapshot(vmConfiguration, vm, snapshotId, diskImagesByImageId);
}
#end_block

#method_before
private Response cloneVmFromSnapshot(VmStatic staticVm, VM vm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(vm.isSetSoundcardEnabled() && vm.isSoundcardEnabled());
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
private Response cloneVmFromSnapshot(org.ovirt.engine.core.common.businessentities.VM configVm, VM vm, String snapshotId, HashMap<Guid, DiskImage> images) {
    VmStatic staticVm = configVm.getStaticData();
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(isVMDeviceTypeExist(configVm.getManagedVmDeviceMap(), VmDeviceGeneralType.SOUND));
    }
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(vm.isSetSoundcardEnabled() && vm.isSoundcardEnabled());
    params.setBalloonEnabled(vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning() ? vm.getMemoryPolicy().isBallooning() : null);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(!VmHelper.getInstance().getSoundDevicesForEntity(templateId).isEmpty());
    }
    params.setBalloonEnabled(vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning() ? vm.getMemoryPolicy().isBallooning() : null);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(vm.isSetSoundcardEnabled() && vm.isSoundcardEnabled());
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    setupCloneTemplatePermissions(vm, params);
    params.setConsoleEnabled(vm.isSetConsole() && vm.getConsole().isSetEnabled() ? vm.getConsole().isEnabled() : !getConsoleDevicesForEntity(templateId).isEmpty());
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(!VmHelper.getInstance().getSoundDevicesForEntity(templateId).isEmpty());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(vm.isSetSoundcardEnabled() && vm.isSoundcardEnabled());
    if (vm.isSetConsole() && vm.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    params.setVirtioScsiEnabled(vm.isSetVirtioScsi() && vm.getVirtioScsi().isSetEnabled() ? vm.getVirtioScsi().isEnabled() : null);
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    }
    if (vm.isSetConsole() && vm.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    }
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    entity.setVmPoolType(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolWithVmsParameters params = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(template.getId()).isEmpty());
    params.setSoundDeviceEnabled(!VmHelper.getInstance().getSoundDevicesForEntity(template.getId()).isEmpty());
    return performCreate(VdcActionType.AddVmPoolWithVms, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    org.ovirt.engine.core.common.businessentities.VmPool entity = map(pool);
    entity.setVmPoolType(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    AddVmPoolWithVmsParameters params = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    params.setConsoleEnabled(!getConsoleDevicesForEntity(template.getId()).isEmpty());
    params.setVirtioScsiEnabled(!VmHelper.getInstance().getVirtioScsiControllersForEntity(template.getId()).isEmpty());
    params.setSoundDeviceEnabled((pool.isSetSoundcardEnabled() ? pool.isSoundcardEnabled() : !VmHelper.getInstance().getSoundDevicesForEntity(template.getId()).isEmpty()));
    return performCreate(VdcActionType.AddVmPoolWithVms, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster.getcompatibility_version() : lookupCluster(staticVm.getVdsGroupId()).getcompatibility_version()));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(template.isSetSoundcardEnabled() && template.isSoundcardEnabled());
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster.getcompatibility_version() : lookupCluster(staticVm.getVdsGroupId()).getcompatibility_version()));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    if (template.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(template.isSoundcardEnabled());
    } else {
        params.setSoundDeviceEnabled(!VmHelper.getInstance().getSoundDevicesForEntity(staticVm.getId()).isEmpty());
    }
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        vm = performGet(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    return removeRestrictedInfo(vm);
}
#method_after
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        org.ovirt.engine.core.common.businessentities.VM entity = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid), id, true);
        vm = addLinks(populate(VmMapper.map(entity, null, false), entity));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    return removeRestrictedInfo(vm);
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    vmConfiguration.setDiskMap(diskImageMap);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(2, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2);
    setUpGetRngDeviceExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(1, 2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(2, 1);
    setUpGetRngDeviceExpectations(2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    expect(vm.getVmtGuid()).andReturn(GUIDS[1]).anyTimes();
    expect(vm.isStateless()).andReturn(true).anyTimes();
    expect(vm.isUseLatestVersion()).andReturn(true).anyTimes();
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 1 });
    setUpGetRngDeviceExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetSoundcardExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    expect(entity.getId()).andReturn(vmId).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getVmDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getUsageMemPercent()).andReturn(Integer.valueOf(20)).anyTimes();
    expect(entity.getDisplayType()).andReturn(DisplayType.vnc).anyTimes();
    expect(entity.getDisplaySecurePort()).andReturn(5900).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    expect(entity.getRunOnVdsName()).andReturn(NAMES[NAMES.length - 1]).anyTimes();
    expect(entity.isHostedEngine()).andReturn(index == 0).anyTimes();
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics, int index, Guid vmId) {
    entity.setId(vmId);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setVmDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setUsageMemPercent(20);
    entity.setDisplayType(DisplayType.vnc);
    entity.setDisplaySecurePort(5900);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    entity.setRunOnVdsName(NAMES[NAMES.length - 1]);
    entity.setOrigin(index == 0 ? OriginType.HOSTED_ENGINE : OriginType.OVIRT);
    entity.setBootSequence(null);
    setUpStatisticalEntityExpectations(entity, statistics);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getVdsGroupId()).andReturn(GUIDS[2]).anyTimes();
    expect(entity.getName()).andReturn(NAMES[index]).anyTimes();
    expect(entity.getDescription()).andReturn(DESCRIPTIONS[index]).anyTimes();
    expect(entity.getNumOfCpus()).andReturn(8).anyTimes();
    expect(entity.getNumOfSockets()).andReturn(2).anyTimes();
    expect(entity.getDefaultDisplayType()).andReturn(DisplayType.vnc).anyTimes();
    expect(entity.getNumOfMonitors()).andReturn(2).anyTimes();
    expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VmTemplate setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.VmTemplate entity, int index) {
    entity.setId(GUIDS[index]);
    entity.setVdsGroupId(GUIDS[2]);
    entity.setName(NAMES[index]);
    entity.setDescription(DESCRIPTIONS[index]);
    entity.setCpuPerSocket(4);
    entity.setNumOfSockets(2);
    entity.setDefaultDisplayType(DisplayType.vnc);
    entity.setNumOfMonitors(2);
    entity.setVmType(VmType.Server);
    return entity;
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    expect(entity.getMemSizeMb()).andReturn(10).anyTimes();
    expect(entity.getStatisticsData()).andReturn(statistics).anyTimes();
    expect(statistics.getusage_mem_percent()).andReturn(20).anyTimes();
    expect(statistics.getcpu_user()).andReturn(Double.valueOf(30L)).anyTimes();
    expect(statistics.getcpu_sys()).andReturn(Double.valueOf(40L)).anyTimes();
    expect(statistics.getusage_cpu_percent()).andReturn(50).anyTimes();
    expect(entity.getMigrationProgressPercent()).andReturn(50).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.VM setUpStatisticalEntityExpectations(org.ovirt.engine.core.common.businessentities.VM entity, VmStatistics statistics) {
    entity.setVmMemSizeMb(10);
    entity.setStatisticsData(statistics);
    statistics.setusage_mem_percent(20);
    statistics.setcpu_user(30.0);
    statistics.setcpu_sys(40.0);
    statistics.setusage_cpu_percent(50);
    entity.setMigrationProgressPercent(50);
    return entity;
}
#end_block

#method_before
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#method_after
static VM getModel(int index) {
    VM model = new VM();
    model.setName(NAMES[index]);
    model.setDescription(DESCRIPTIONS[index]);
    model.setId(GUIDS[index].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    return model;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index, vmId);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getEntityWithProvidedId(int index, Guid vmId) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index, vmId);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VmTemplate.class), index);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VmTemplate getTemplateEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VmTemplate template = new org.ovirt.engine.core.common.businessentities.VmTemplate();
    return setUpEntityExpectations(template, index);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    params.setSoundDeviceEnabled(incoming.isSetSoundcardEnabled() && incoming.isSoundcardEnabled());
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId()).getcompatibility_version()));
    UpdateVmTemplateParameters params = new UpdateVmTemplateParameters(updated);
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, params);
}
#end_block

#method_before
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateMovingCluster() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(0);
    setUpGetVmOvfExpectations(0);
    setUpGetVirtioScsiExpectations(0);
    setUpGetSoundcardExpectations(0);
    setUpGetRngDeviceExpectations(0);
    setUriInfo(setUpActionExpectations(VdcActionType.ChangeVMCluster, ChangeVMClusterParameters.class, new String[] { "ClusterId", "VmId" }, new Object[] { GUIDS[1], GUIDS[0] }, true, true, false));
    setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true);
    VM model = getModel(0);
    model.setId(GUIDS[0].toString());
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    verifyModelOnNewCluster(resource.update(model), 0);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    VmStatistics stats = control.createMock(VmStatistics.class);
    org.ovirt.engine.core.common.businessentities.VM entity = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    setUpStatisticalEntityExpectations(entity, stats);
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM setUpStatisticalExpectations() throws Exception {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    setUpStatisticalEntityExpectations(entity, entity.getStatisticsData());
    setUpGetEntityExpectations(1, false, entity);
    control.replay();
    return entity;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    return setUpEntityExpectations(control.createMock(org.ovirt.engine.core.common.businessentities.VM.class), control.createMock(VmStatistics.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getEntity(int index) {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    return setUpEntityExpectations(vm, vm.getStatisticsData(), index);
}
#end_block

#method_before
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[2].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#method_after
protected void verifyModelOnNewCluster(VM model, int index) {
    assertNotNull(model.getCluster().getId());
    assertEquals(GUIDS[1].toString(), model.getCluster().getId());
    verifyModel(model, index);
}
#end_block

#method_before
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    addInstanceTypeParameters.setSoundDeviceEnabled(instanceType.isSetSoundcardEnabled() && instanceType.isSoundcardEnabled());
    return performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    if (instanceType.isSetSoundcardEnabled()) {
        addInstanceTypeParameters.setSoundDeviceEnabled(instanceType.isSoundcardEnabled());
    }
    return performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
private void doTestAddWithClonePermissions(Template model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description", "CopyVmPermissions" }, new Object[] { NAMES[0], DESCRIPTIONS[0], copy }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
private void doTestAddWithClonePermissions(Template model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description", "CopyVmPermissions" }, new Object[] { NAMES[0], DESCRIPTIONS[0], copy }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    Template created = (Template) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Response response = collection.add(getModel(0));
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    Template created = (Template) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
public void testAdd() throws Exception {
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    super.testAdd();
}
#method_after
public void testAdd() throws Exception {
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    super.testAdd();
}
#end_block

#method_before
@Test
public void testAddVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetConsoleExpectations(new int[] { 2, 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2, 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 2 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[2], DESCRIPTIONS[2] }, true, true, GUIDS[2], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(getModel(2));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    assertEquals(((Template) response.getEntity()).getVersion().getVersionName(), VERSION_NAME);
    assertEquals(((Template) response.getEntity()).getVersion().getBaseTemplate().getId(), GUIDS[1].toString());
    verifyModel((Template) response.getEntity(), 2);
}
#method_after
@Test
public void testAddVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetConsoleExpectations(new int[] { 2, 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2, 2 });
    setUpGetSoundcardExpectations(new int[] { 2, 2, 0 });
    setUpGetRngDeviceExpectations(new int[] { 2, 2 });
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[2], DESCRIPTIONS[2] }, true, true, GUIDS[2], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(getModel(2));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    assertEquals(((Template) response.getEntity()).getVersion().getVersionName(), VERSION_NAME);
    assertEquals(((Template) response.getEntity()).getVersion().getBaseTemplate().getId(), GUIDS[1].toString());
    verifyModel((Template) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddNamedVm() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddNamedVmFiltered() throws Exception {
    setUpFilteredQueryExpectations();
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddNamedVmFiltered() throws Exception {
    setUpFilteredQueryExpectations();
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmNameForDataCenter, GetVmByVmNameForDataCenterParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.getVm().setId(null);
    model.getVm().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddWithCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddWithCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[2].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddWithClusterName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddWithClusterName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetEntityExpectations(0);
    setUpGetConsoleExpectations(new int[] { 0, 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetSoundcardExpectations(new int[] { 0, 0, 0 });
    setUpGetRngDeviceExpectations(new int[] { 0, 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVmTemplate, AddVmTemplateParameters.class, new String[] { "Name", "Description" }, new Object[] { NAMES[0], DESCRIPTIONS[0] }, true, true, GUIDS[0], asList(GUIDS[2]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Template model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Template);
    verifyModel((Template) response.getEntity(), 0);
    assertNull(((Template) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
protected void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetConsoleExpectations(new int[] { 0 });
    super.doTestBadAdd(canDo, success, detail);
}
#method_after
protected void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, setUpVm(GUIDS[1]));
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetSoundcardExpectations(new int[] { 0 });
    super.doTestBadAdd(canDo, success, detail);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(InstanceType incoming, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    org.ovirt.engine.core.common.businessentities.InstanceType updated = getMapper(modelType, org.ovirt.engine.core.common.businessentities.InstanceType.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), Version.getLast()));
    UpdateVmTemplateParameters updateParams = new UpdateVmTemplateParameters((VmTemplate) updated);
    if (incoming.isSetRngDevice()) {
        updateParams.setUpdateRngDevice(true);
        updateParams.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    updateParams.setSoundDeviceEnabled(incoming.isSetSoundcardEnabled() && incoming.isSoundcardEnabled());
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, updateParams);
}
#method_after
@Override
public VdcActionParametersBase getParameters(InstanceType incoming, org.ovirt.engine.core.common.businessentities.InstanceType entity) {
    org.ovirt.engine.core.common.businessentities.InstanceType updated = getMapper(modelType, org.ovirt.engine.core.common.businessentities.InstanceType.class).map(incoming, entity);
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), Version.getLast()));
    UpdateVmTemplateParameters updateParams = new UpdateVmTemplateParameters((VmTemplate) updated);
    if (incoming.isSetRngDevice()) {
        updateParams.setUpdateRngDevice(true);
        updateParams.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    if (incoming.isSetSoundcardEnabled()) {
        updateParams.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    return getMapper(modelType, UpdateVmTemplateParameters.class).map(incoming, updateParams);
}
#end_block

#method_before
@Override
public void onSave() {
    if (getProgress() != null || !validate()) {
        return;
    }
    if (getIsAttachDisk().getEntity()) {
        onAttachDisks();
        return;
    }
    super.onSave();
    boolean isInternal = getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = (DiskImage) getDisk();
        diskImage.setSizeInGigabytes(Integer.parseInt(getSize().getEntity().toString()));
        diskImage.setVolumeType(getVolumeType().getSelectedItem());
        diskImage.setvolumeFormat(getVolumeFormat());
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        LUNs luns = (LUNs) getSanStorageModel().getAddedLuns().get(0).getEntity();
        luns.setLunType(getStorageType().getSelectedItem());
        lunDisk.setLun(luns);
    }
    startProgress(null);
    AddDiskParameters parameters = new AddDiskParameters(getVmId(), getDisk());
    parameters.setPlugDiskToVm(getIsPlugged().getEntity());
    if (getIsInternal().getEntity()) {
        StorageDomain storageDomain = getStorageDomain().getSelectedItem();
        parameters.setStorageDomainId(storageDomain.getId());
    }
    Frontend.getInstance().runAction(VdcActionType.AddDisk, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
            postSave();
        }
    }, this);
}
#method_after
@Override
public void onSave() {
    if (getProgress() != null || !validate()) {
        return;
    }
    if (getIsAttachDisk().getEntity()) {
        onAttachDisks();
        return;
    }
    super.onSave();
    boolean isInternal = getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = (DiskImage) getDisk();
        diskImage.setSizeInGigabytes(getSize().getEntity());
        diskImage.setVolumeType(getVolumeType().getSelectedItem());
        diskImage.setvolumeFormat(getVolumeFormat());
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        LUNs luns = (LUNs) getSanStorageModel().getAddedLuns().get(0).getEntity();
        luns.setLunType(getStorageType().getSelectedItem());
        lunDisk.setLun(luns);
    }
    startProgress(null);
    AddDiskParameters parameters = new AddDiskParameters(getVmId(), getDisk());
    parameters.setPlugDiskToVm(getIsPlugged().getEntity());
    if (getIsInternal().getEntity()) {
        StorageDomain storageDomain = getStorageDomain().getSelectedItem();
        parameters.setStorageDomainId(storageDomain.getId());
    }
    Frontend.getInstance().runAction(VdcActionType.AddDisk, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
            postSave();
        }
    }, this);
}
#end_block

#method_before
@Override
public boolean validate() {
    if (getIsAttachDisk().getEntity()) {
        if (isSelectionsEmpty(getInternalAttachableDisks()) && isSelectionsEmpty(getExternalAttachableDisks())) {
            getInvalidityReasons().add(CONSTANTS.noDisksSelected());
            setIsValid(false);
            return false;
        }
        return true;
    }
    if (!getIsInternal().getEntity() && getSanStorageModel() != null) {
        getSanStorageModel().validate();
        if (!getSanStorageModel().getIsValid()) {
            return false;
        }
        ArrayList<String> partOfSdLunsMessages = getSanStorageModel().getPartOfSdLunsMessages();
        if (!partOfSdLunsMessages.isEmpty() && !getSanStorageModel().isForce()) {
            forceCreationWarning(partOfSdLunsMessages);
            return false;
        }
    }
    StorageType storageType = getStorageDomain().getSelectedItem() == null ? StorageType.UNKNOWN : getStorageDomain().getSelectedItem().getStorageType();
    LongValidation sizeValidation = new LongValidation();
    sizeValidation.setMinimum(1);
    if (storageType.isBlockDomain()) {
        sizeValidation.setMaximum((Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MaxBlockDiskSize));
    }
    getSize().validateEntity(new IValidation[] { new NotEmptyValidation(), sizeValidation });
    getStorageDomain().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return super.validate() && getSize().getIsValid() && getStorageDomain().getIsValid();
}
#method_after
@Override
public boolean validate() {
    if (getIsAttachDisk().getEntity()) {
        if (isSelectionsEmpty(getInternalAttachableDisks()) && isSelectionsEmpty(getExternalAttachableDisks())) {
            getInvalidityReasons().add(CONSTANTS.noDisksSelected());
            setIsValid(false);
            return false;
        }
        return true;
    }
    if (!getIsInternal().getEntity() && getSanStorageModel() != null) {
        getSanStorageModel().validate();
        if (!getSanStorageModel().getIsValid()) {
            return false;
        }
        ArrayList<String> partOfSdLunsMessages = getSanStorageModel().getPartOfSdLunsMessages();
        if (!partOfSdLunsMessages.isEmpty() && !getSanStorageModel().isForce()) {
            forceCreationWarning(partOfSdLunsMessages);
            return false;
        }
    }
    StorageType storageType = getStorageDomain().getSelectedItem() == null ? StorageType.UNKNOWN : getStorageDomain().getSelectedItem().getStorageType();
    IntegerValidation sizeValidation = new IntegerValidation();
    sizeValidation.setMinimum(1);
    if (storageType.isBlockDomain()) {
        sizeValidation.setMaximum((Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MaxBlockDiskSize));
    }
    getSize().validateEntity(new IValidation[] { new NotEmptyValidation(), sizeValidation });
    getStorageDomain().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return super.validate() && getSize().getIsValid() && getStorageDomain().getIsValid();
}
#end_block

#method_before
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation() });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#method_after
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsAvailable(showTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void createImageForVmMetaData() {
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(storagePool.getId(), storageDomainId, vmConfImageGroupId, HibernateVmCommand.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, vmConfVolumeId, ""));
    if (!retVal.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError, "Failed to create image for vm configuration!");
    }
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(CREATE_IMAGE_FOR_VM_TASK_KEY);
    Guid guid = enclosingCommand.createTask(taskId, retVal.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid);
}
#method_after
private void createImageForVmMetaData() {
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(storagePool.getId(), storageDomainId, vmConfImageGroupId, MemoryUtils.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, vmConfVolumeId, ""));
    if (!retVal.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError, "Failed to create image for vm configuration!");
    }
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(CREATE_IMAGE_FOR_VM_TASK_KEY);
    Guid guid = enclosingCommand.createTask(taskId, retVal.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid);
}
#end_block

#method_before
private MemoryImageBuilder createMemoryImageBuilder() {
    if (!isMemorySnapshotSupported()) {
        return new NullableMemoryImageBuilder();
    }
    if (getParameters().getSnapshotType() == SnapshotType.STATELESS) {
        return new StatelessSnapshotMemoryImageBuilder(getVm());
    }
    if (getParameters().isSaveMemory() && isLiveSnapshotApplicable()) {
        return new LiveSnapshotMemoryImageBuilder(getVm(), memorySdId, getStoragePool(), this);
    }
    return new NullableMemoryImageBuilder();
}
#method_after
private MemoryImageBuilder createMemoryImageBuilder() {
    if (!isMemorySnapshotSupported()) {
        return new NullableMemoryImageBuilder();
    }
    if (getParameters().getSnapshotType() == SnapshotType.STATELESS) {
        return new StatelessSnapshotMemoryImageBuilder(getVm());
    }
    if (getParameters().isSaveMemory() && isLiveSnapshotApplicable()) {
        return new LiveSnapshotMemoryImageBuilder(getVm(), cachedStorageDomainId, getStoragePool(), this);
    }
    return new NullableMemoryImageBuilder();
}
#end_block

#method_before
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setLeaveLocked(true);
    }
    return result;
}
#method_after
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setDiskProfileId(image.getDiskProfileId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setLeaveLocked(true);
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    List<DiskImage> memoryDisksList = getMemoryImageBuilder().getDisksToBeCreated();
    memorySdId = getStorageDomainIdForVmMemory(memoryDisksList);
    if (getParameters().isSaveMemory() && Guid.Empty.equals(memorySdId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    if (!validateStorageDomains(disksList, memoryDisksList)) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
    getStorageDomainIdForVmMemory(memoryDisksList);
    if (getParameters().isSaveMemory() && Guid.Empty.equals(cachedStorageDomainId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    if (!validateStorageDomains(disksList, memoryDisksList)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testRemoveInterfacesForVds() {
    List<VdsNetworkInterface> before = dao.getAllInterfacesForVds(VDS_ID);
    // ensure we have records before the test
    boolean found = false;
    for (VdsNetworkInterface iface : before) {
        found |= (FixturesTool.VDS_NETWORK_INTERFACE.equals(iface.getId()));
    }
    assertTrue(found);
    dao.removeInterfaceFromVds(FixturesTool.VDS_NETWORK_INTERFACE);
    List<VdsNetworkInterface> after = dao.getAllInterfacesForVds(VDS_ID);
    for (VdsNetworkInterface iface : after) {
        assertNotSame(FixturesTool.VDS_NETWORK_INTERFACE, iface.getId());
    }
    assertNull(dbFacade.getNetworkQosDao().get(FixturesTool.VDS_NETWORK_INTERFACE));
}
#method_after
@Test
public void testRemoveInterfacesForVds() {
    List<VdsNetworkInterface> before = dao.getAllInterfacesForVds(VDS_ID);
    // ensure we have records before the test
    boolean found = false;
    for (VdsNetworkInterface iface : before) {
        found |= (FixturesTool.VDS_NETWORK_INTERFACE.equals(iface.getId()));
    }
    assertTrue(found);
    assertNotNull(dbFacade.getNetworkQosDao().get(FixturesTool.VDS_NETWORK_INTERFACE));
    dao.removeInterfaceFromVds(FixturesTool.VDS_NETWORK_INTERFACE);
    List<VdsNetworkInterface> after = dao.getAllInterfacesForVds(VDS_ID);
    for (VdsNetworkInterface iface : after) {
        assertNotSame(FixturesTool.VDS_NETWORK_INTERFACE, iface.getId());
    }
    assertNull(dbFacade.getNetworkQosDao().get(FixturesTool.VDS_NETWORK_INTERFACE));
}
#end_block

#method_before
@Override
protected void executeSave() {
    // New network QoS
    final QosParametersBase<NetworkQoS> parameters = new QosParametersBase<NetworkQoS>();
    parameters.setQosId(networkQoS.getId());
    parameters.setQos(networkQoS);
    Frontend.getInstance().runAction(VdcActionType.AddNetworkQoS, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
                networkQoS.setId((Guid) retVal.getActionReturnValue());
            }
            postSaveAction(succeeded);
        }
    });
}
#method_after
@Override
protected void executeSave() {
    // New network QoS
    final QosParametersBase<NetworkQoS> parameters = new QosParametersBase<NetworkQoS>();
    parameters.setQos(networkQoS);
    Frontend.getInstance().runAction(VdcActionType.AddNetworkQoS, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
                networkQoS.setId((Guid) retVal.getActionReturnValue());
            }
            postSaveAction(succeeded);
        }
    });
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    NetworkQoS deserialize = qosMapper.deserialize();
    if (deserialize != null) {
        deserialize.setId(expectedQos.getId());
    }
    assertEquals(expectedQos, deserialize);
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    NetworkQoS deserialize = qosMapper.deserialize();
    assertTrue((expectedQos == null && deserialize == null) || (expectedQos != null && expectedQos.equalValues(deserialize)));
}
#end_block

#method_before
@Override
protected QosDao<NetworkQoS> getQosDao() {
    return getDbFacade().getNetworkQosDao();
}
#method_after
@Override
protected NetworkQoSDao getQosDao() {
    return getDbFacade().getNetworkQosDao();
}
#end_block

#method_before
@Override
protected QosValidator<NetworkQoS> getQosValidator(NetworkQoS networkQos) {
    return new NetworkQosValidator(networkQos);
}
#method_after
@Override
protected NetworkQosValidator getQosValidator(NetworkQoS networkQos) {
    return new NetworkQosValidator(networkQos);
}
#end_block

#method_before
@Override
public void executeSave() {
    QosParametersBase<NetworkQoS> parameters = new QosParametersBase<NetworkQoS>();
    parameters.setQosId(networkQoS.getId());
    parameters.setQos(networkQoS);
    Frontend.getInstance().runAction(VdcActionType.UpdateNetworkQoS, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
            }
            postSaveAction(succeeded);
        }
    });
}
#method_after
@Override
public void executeSave() {
    QosParametersBase<NetworkQoS> parameters = new QosParametersBase<NetworkQoS>();
    parameters.setQos(networkQoS);
    Frontend.getInstance().runAction(VdcActionType.UpdateNetworkQoS, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
            }
            postSaveAction(succeeded);
        }
    });
}
#end_block

#method_before
@Override
protected QosValidator<NetworkQoS> getQosValidator(NetworkQoS qos) {
    return new NetworkQosValidator(qos);
}
#method_after
@Override
protected NetworkQosValidator getQosValidator(NetworkQoS qos) {
    return new NetworkQosValidator(qos);
}
#end_block

#method_before
@Override
public boolean equalValues(QosBase obj) {
    if (!(obj instanceof NetworkQoS)) {
        return false;
    }
    NetworkQoS other = (NetworkQoS) obj;
    return ObjectUtils.objectsEqual(getInboundAverage(), other.getInboundAverage()) && ObjectUtils.objectsEqual(getInboundPeak(), other.getInboundPeak()) && ObjectUtils.objectsEqual(getInboundBurst(), other.getInboundBurst()) && ObjectUtils.objectsEqual(getOutboundAverage(), other.getOutboundAverage()) && ObjectUtils.objectsEqual(getOutboundPeak(), other.getOutboundPeak()) && ObjectUtils.objectsEqual(getOutboundBurst(), other.getOutboundBurst());
}
#method_after
public boolean equalValues(NetworkQoS other) {
    return ObjectUtils.objectsEqual(getInboundAverage(), other.getInboundAverage()) && ObjectUtils.objectsEqual(getInboundPeak(), other.getInboundPeak()) && ObjectUtils.objectsEqual(getInboundBurst(), other.getInboundBurst()) && ObjectUtils.objectsEqual(getOutboundAverage(), other.getOutboundAverage()) && ObjectUtils.objectsEqual(getOutboundPeak(), other.getOutboundPeak()) && ObjectUtils.objectsEqual(getOutboundBurst(), other.getOutboundBurst());
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return super.equals(o) && equalValues((QosBase) o);
}
#method_after
@Override
public boolean equals(Object o) {
    return super.equals(o) && equalValues((NetworkQoS) o);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((inboundAverage == null) ? 0 : inboundAverage.hashCode());
    result = prime * result + ((inboundPeak == null) ? 0 : inboundPeak.hashCode());
    result = prime * result + ((inboundBurst == null) ? 0 : inboundBurst.hashCode());
    result = prime * result + ((outboundAverage == null) ? 0 : outboundAverage.hashCode());
    result = prime * result + ((outboundPeak == null) ? 0 : outboundPeak.hashCode());
    result = prime * result + ((outboundBurst == null) ? 0 : outboundBurst.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((inboundAverage == null) ? 0 : inboundAverage.hashCode());
    result = prime * result + ((inboundPeak == null) ? 0 : inboundPeak.hashCode());
    result = prime * result + ((inboundBurst == null) ? 0 : inboundBurst.hashCode());
    result = prime * result + ((outboundAverage == null) ? 0 : outboundAverage.hashCode());
    result = prime * result + ((outboundPeak == null) ? 0 : outboundPeak.hashCode());
    result = prime * result + ((outboundBurst == null) ? 0 : outboundBurst.hashCode());
    return result;
}
#end_block

#method_before
public void onRemove() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (Object networkQoS : sourceListModel.getSelectedItems()) {
        QosParametersBase<NetworkQoS> parameter = new QosParametersBase<NetworkQoS>();
        NetworkQoS tempQos = (NetworkQoS) networkQoS;
        parameter.setQosId(tempQos.getId());
        parameter.setQos(tempQos);
        parameters.add(parameter);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveNetworkQoS, parameters);
    cancel();
}
#method_after
public void onRemove() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (Object networkQoS : sourceListModel.getSelectedItems()) {
        QosParametersBase<NetworkQoS> parameter = new QosParametersBase<NetworkQoS>();
        NetworkQoS tempQos = (NetworkQoS) networkQoS;
        parameter.setQos(tempQos);
        parameters.add(parameter);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveNetworkQoS, parameters);
    cancel();
}
#end_block

#method_before
protected T getOldQos() {
    if (oldQos == null && qos != null) {
        oldQos = getQosDao().get(qos.getId());
    }
    return oldQos;
}
#method_after
protected T getOldQos() {
    if (oldQos == null) {
        oldQos = getQosDao().get(qos.getId());
    }
    return oldQos;
}
#end_block

#method_before
private boolean shouldOvfStoreBeShareable() {
    return getStorageDomain().getStorageType() != StorageType.GLUSTERFS;
}
#method_after
private boolean shouldOvfStoreBeShareable() {
    // split brain - see BZ 1024654
    return getStorageDomain().getStorageType() != StorageType.GLUSTERFS;
}
#end_block

#method_before
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    boolean isVirtioScsiDiskExists = CollectionUtils.exists(vmDisks, new Predicate() {

        @Override
        public boolean evaluate(Object disk) {
            return ((Disk) disk).getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    });
    if (isVirtioScsiDiskExists) {
        return new ValidationResult(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    boolean isVirtioScsiDiskExist = CollectionUtils.exists(vmDisks, new Predicate() {

        @Override
        public boolean evaluate(Object disk) {
            return ((Disk) disk).getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    });
    if (isVirtioScsiDiskExist) {
        return new ValidationResult(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
@UiChild(tagname = "header", limit = 1)
public void setHeader(Widget widget) {
    // $NON-NLS-1$
    widget.addStyleName("obrand_dialogHeaderTitleElement");
    // Put the label at the front.
    headerTitlePanel.insert(widget, 0);
}
#method_after
@Override
@UiChild(tagname = "header", limit = 1)
public void setHeader(Widget widget) {
    widget.addStyleName(style.obrand_dialogHeaderTitleElement());
    // Put the label at the front.
    headerTitlePanel.insert(widget, 0);
}
#end_block

#method_before
@Override
protected DbUser getEntity(int index) {
    DbUser entity = new DbUser();
    entity.setId(GUIDS[index]);
    entity.setExternalId(EXTERNAL_IDS[index]);
    entity.setLoginName(NAMES[index]);
    entity.setGroupNames(new HashSet<String>(Arrays.asList(GROUPS.split(","))));
    entity.setNamespace(NAMESPACE);
    entity.setDomain(DOMAIN);
    return entity;
}
#method_after
@Override
protected DbUser getEntity(int index) {
    DbUser entity = new DbUser();
    entity.setId(GUIDS[index]);
    entity.setExternalId(EXTERNAL_IDS[index]);
    entity.setLoginName(NAMES[index]);
    entity.setGroupNames(new LinkedList<String>(Arrays.asList(GROUPS.split(","))));
    entity.setNamespace(NAMESPACE);
    entity.setDomain(DOMAIN);
    return entity;
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation() });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#method_after
private void validatePmModels(boolean primary) {
    EntityModel<String> ip = primary ? getManagementIp() : getPmSecondaryIp();
    EntityModel<String> userName = primary ? getPmUserName() : getPmSecondaryUserName();
    EntityModel<String> password = primary ? getPmPassword() : getPmSecondaryPassword();
    ListModel<String> type = primary ? getPmType() : getPmSecondaryType();
    EntityModel<String> port = primary ? getPmPort() : getPmSecondaryPort();
    EntityModel<String> options = primary ? getPmOptions() : getPmSecondaryOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    if (_oldVds.getProtocol() != getParameters().getVdsStaticData().getProtocol()) {
        ResourceManager.getInstance().reestablishConnection(_oldVds.getId());
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    if (_oldVds.getProtocol() != getParameters().getVdsStaticData().getProtocol()) {
        ResourceManager.getInstance().reestablishConnection(_oldVds.getId());
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#end_block

#method_before
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
}
#method_after
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMemoryUsageHistory(null);
    vm.setCpuUsageHistory(null);
    vm.setNetworkUsageHistory(null);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
}
#end_block

#method_before
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    try {
        final int interestedOps = SelectionKey.OP_READ;
        reactor.wakeup();
        final ReactorClient client = this;
        final FutureTask<SelectionKey> task = scheduleTask(new Retryable<SelectionKey>(new Callable<SelectionKey>() {

            @Override
            public SelectionKey call() throws ClosedChannelException {
                int ops = interestedOps | SelectionKey.OP_WRITE;
                return channel.register(selector, ops, client);
            }
        }, this.policy));
        key = task.get();
        this.nioEngine = new SSLEngineNioHelper(channel, createSSLEngine(this.client), callback, this);
        this.nioEngine.beginHandshake();
    } catch (SSLException | InterruptedException | ExecutionException e) {
        log.error("Connection issues during ssl client creation", e);
        throw new ClientConnectionException(e);
    }
    if (key == null) {
        throw new ClientConnectionException("Connection issue during post connect");
    }
}
#method_after
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    try {
        final ReactorClient client = this;
        final FutureTask<SelectionKey> task = scheduleTask(new Retryable<SelectionKey>(new Callable<SelectionKey>() {

            @Override
            public SelectionKey call() throws ClosedChannelException {
                return channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, client);
            }
        }, this.policy));
        key = task.get();
        this.nioEngine = new SSLEngineNioHelper(channel, createSSLEngine(this.client), callback, this);
        this.nioEngine.beginHandshake();
    } catch (SSLException | InterruptedException | ExecutionException e) {
        log.error("Connection issues during ssl client creation", e);
        throw new ClientConnectionException(e);
    }
    if (key == null) {
        throw new ClientConnectionException("Connection issue during post connect");
    }
}
#end_block

#method_before
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    try {
        final int interestedOps = SelectionKey.OP_READ;
        reactor.wakeup();
        final ReactorClient client = this;
        final FutureTask<SelectionKey> task = scheduleTask(new Retryable<SelectionKey>(new Callable<SelectionKey>() {

            @Override
            public SelectionKey call() throws ClosedChannelException {
                return channel.register(selector, interestedOps, client);
            }
        }, this.policy));
        key = task.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new ClientConnectionException(e);
    }
    if (key == null) {
        throw new ClientConnectionException("Connection issue during post connect");
    }
}
#method_after
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    try {
        final ReactorClient client = this;
        final FutureTask<SelectionKey> task = scheduleTask(new Retryable<SelectionKey>(new Callable<SelectionKey>() {

            @Override
            public SelectionKey call() throws ClosedChannelException {
                return channel.register(selector, SelectionKey.OP_READ, client);
            }
        }, this.policy));
        key = task.get();
    } catch (InterruptedException | ExecutionException e) {
        throw new ClientConnectionException(e);
    }
    if (key == null) {
        throw new ClientConnectionException("Connection issue during post connect");
    }
}
#end_block

#method_before
@Test
public void testConnection() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(1);
    StompServer server = new StompServer(HOSTNAME, PORT);
    StompClient clientSubscriber = new StompClient(HOSTNAME, PORT);
    clientSubscriber.subscribe("/queue/a", new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
        }
    });
    StompClient clientSender = new StompClient(HOSTNAME, PORT);
    clientSender.send("Hello World!", "/queue/a");
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(0, messages.getCount());
    clientSubscriber.unsubscribe("/queue/a");
    clientSubscriber.disconnect();
    clientSubscriber.stop();
    clientSender.disconnect();
    clientSender.stop();
    server.stop();
}
#method_after
@Test
public void testConnection() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(1);
    StompServer server = new StompServer(HOSTNAME, 0);
    StompClient clientSubscriber = new StompClient(HOSTNAME, server.getPort());
    clientSubscriber.subscribe("/queue/a", new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
            fail();
        }
    });
    StompClient clientSender = new StompClient(HOSTNAME, server.getPort());
    clientSender.send("Hello World!", "/queue/a");
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(0, messages.getCount());
    clientSubscriber.unsubscribe("/queue/a");
    clientSubscriber.disconnect();
    clientSubscriber.stop();
    clientSender.disconnect();
    clientSender.stop();
    server.stop();
}
#end_block

#method_before
@Test
public void testMultipeSubs() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(3);
    Listener listener = new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
        }
    };
    StompServer server = new StompServer(HOSTNAME, PORT - 1);
    StompClient clientSubscriber1 = new StompClient(HOSTNAME, PORT - 1);
    StompClient clientSubscriber2 = new StompClient(HOSTNAME, PORT - 1);
    StompClient clientSubscriber3 = new StompClient(HOSTNAME, PORT - 1);
    clientSubscriber1.subscribe("/queue/a", listener);
    clientSubscriber2.subscribe("/queue/a", listener);
    clientSubscriber3.subscribe("/queue/a", listener);
    StompClient clientSender = new StompClient(HOSTNAME, PORT - 1);
    clientSender.send("Hello World!", "/queue/a");
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(0, messages.getCount());
    clientSubscriber1.unsubscribe("/queue/a");
    clientSubscriber2.unsubscribe("/queue/a");
    clientSubscriber3.unsubscribe("/queue/a");
    clientSubscriber1.disconnect();
    clientSubscriber2.disconnect();
    clientSubscriber3.disconnect();
    clientSubscriber1.stop();
    clientSubscriber2.stop();
    clientSubscriber3.stop();
    clientSender.disconnect();
    server.stop();
}
#method_after
@Test
public void testMultipeSubs() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(3);
    Listener listener = new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
            fail();
        }
    };
    StompServer server = new StompServer(HOSTNAME, 0);
    StompClient clientSubscriber1 = new StompClient(HOSTNAME, server.getPort());
    StompClient clientSubscriber2 = new StompClient(HOSTNAME, server.getPort());
    StompClient clientSubscriber3 = new StompClient(HOSTNAME, server.getPort());
    clientSubscriber1.subscribe("/queue/a", listener);
    clientSubscriber2.subscribe("/queue/a", listener);
    clientSubscriber3.subscribe("/queue/a", listener);
    StompClient clientSender = new StompClient(HOSTNAME, server.getPort());
    clientSender.send("Hello World!", "/queue/a");
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(0, messages.getCount());
    clientSubscriber1.unsubscribe("/queue/a");
    clientSubscriber2.unsubscribe("/queue/a");
    clientSubscriber3.unsubscribe("/queue/a");
    clientSubscriber1.disconnect();
    clientSubscriber2.disconnect();
    clientSubscriber3.disconnect();
    clientSubscriber1.stop();
    clientSubscriber2.stop();
    clientSubscriber3.stop();
    clientSender.disconnect();
    server.stop();
}
#end_block

#method_before
@Test
public void testTransactionCommit() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(3);
    Listener listener = new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
        }
    };
    StompServer server = new StompServer(HOSTNAME, PORT - 2);
    StompClient clientSubscriber1 = new StompClient(HOSTNAME, PORT - 2);
    StompClient clientSubscriber2 = new StompClient(HOSTNAME, PORT - 2);
    StompClient clientSubscriber3 = new StompClient(HOSTNAME, PORT - 2);
    clientSubscriber1.subscribe("/queue/a", listener);
    clientSubscriber2.subscribe("/queue/b", listener);
    clientSubscriber3.subscribe("/queue/c", listener);
    StompClient clientSender = new StompClient(HOSTNAME, PORT - 2);
    clientSender.begin();
    clientSender.send("Hello World!", "/queue/a");
    clientSender.send("Hello World!", "/queue/b");
    clientSender.send("Hello World!", "/queue/c");
    clientSender.commit();
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(3, messages.getCount());
    clientSubscriber1.unsubscribe("/queue/a");
    clientSubscriber2.unsubscribe("/queue/b");
    clientSubscriber3.unsubscribe("/queue/c");
    clientSubscriber1.disconnect();
    clientSubscriber2.disconnect();
    clientSubscriber3.disconnect();
    clientSubscriber1.stop();
    clientSubscriber2.stop();
    clientSubscriber3.stop();
    clientSender.disconnect();
    server.stop();
}
#method_after
@Test
public void testTransactionCommit() throws IOException, InterruptedException {
    final CountDownLatch messages = new CountDownLatch(3);
    Listener listener = new Listener() {

        @Override
        public void update(String message) {
            messages.countDown();
        }

        @Override
        public void error(Map<String, String> error) {
            fail();
        }
    };
    StompServer server = new StompServer(HOSTNAME, 0);
    StompClient clientSubscriber1 = new StompClient(HOSTNAME, server.getPort());
    StompClient clientSubscriber2 = new StompClient(HOSTNAME, server.getPort());
    StompClient clientSubscriber3 = new StompClient(HOSTNAME, server.getPort());
    clientSubscriber1.subscribe("/queue/a", listener);
    clientSubscriber2.subscribe("/queue/b", listener);
    clientSubscriber3.subscribe("/queue/c", listener);
    StompClient clientSender = new StompClient(HOSTNAME, server.getPort());
    clientSender.begin();
    clientSender.send("Hello World!", "/queue/a");
    clientSender.send("Hello World!", "/queue/b");
    clientSender.send("Hello World!", "/queue/c");
    clientSender.commit();
    messages.await(TIMEOUT, TimeUnit.SECONDS);
    assertEquals(0, messages.getCount());
    clientSubscriber1.unsubscribe("/queue/a");
    clientSubscriber2.unsubscribe("/queue/b");
    clientSubscriber3.unsubscribe("/queue/c");
    clientSubscriber1.disconnect();
    clientSubscriber2.disconnect();
    clientSubscriber3.disconnect();
    clientSubscriber1.stop();
    clientSubscriber2.stop();
    clientSubscriber3.stop();
    clientSender.disconnect();
    server.stop();
}
#end_block

#method_before
public SelectionKey connect() throws IOException {
    final InetSocketAddress addr = new InetSocketAddress(InetAddress.getByName(this.host), this.port);
    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.connect(addr);
    socketChannel.configureBlocking(false);
    int interestedOps = SelectionKey.OP_READ;
    SelectionKey key = socketChannel.register(this.selector, interestedOps, new ConcurrentLinkedDeque<>());
    setDaemon(true);
    start();
    return key;
}
#method_after
public SelectionKey connect(int port) throws IOException {
    final InetSocketAddress addr = new InetSocketAddress(InetAddress.getByName(this.host), port);
    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.connect(addr);
    socketChannel.configureBlocking(false);
    int interestedOps = SelectionKey.OP_READ;
    SelectionKey key = socketChannel.register(this.selector, interestedOps, new ConcurrentLinkedDeque<>());
    setDaemon(true);
    start();
    return key;
}
#end_block

#method_before
public void listen() throws IOException {
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT, new ConcurrentLinkedDeque<>());
    serverSocketChannel.bind(new InetSocketAddress(this.host, this.port));
    setDaemon(true);
    start();
}
#method_after
public void listen() throws IOException {
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT, new ConcurrentLinkedDeque<>());
    serverSocketChannel.bind(new InetSocketAddress(this.host, 0));
    this.port = serverSocketChannel.socket().getLocalPort();
    setDaemon(true);
    start();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void run() {
    while (this.isRunning) {
        try {
            this.selector.select();
            if (!selector.isOpen()) {
                continue;
            }
            for (final SelectionKey key : this.selector.selectedKeys()) {
                if (!key.isValid()) {
                    continue;
                }
                if (key.isAcceptable()) {
                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    if (socketChannel != null) {
                        socketChannel.configureBlocking(false);
                        int interestedOps = SelectionKey.OP_READ;
                        socketChannel.register(selector, interestedOps, new ConcurrentLinkedDeque<>());
                    }
                }
                if (key.isValid() && key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    int read = socketChannel.read(this.readBuffer);
                    if (read > 0) {
                        byte[] msgBuff = new byte[read];
                        this.readBuffer.rewind();
                        this.readBuffer.get(msgBuff);
                        this.readBuffer.clear();
                        Message message = Message.parse(msgBuff);
                        this.reciever.recieve(message, key);
                    }
                }
                if (key.isValid() && key.isWritable()) {
                    Deque<ByteBuffer> outbox = (Deque<ByteBuffer>) key.attachment();
                    ByteBuffer buffer = outbox.pollLast();
                    if (buffer != null) {
                        SocketChannel socketChannel = (SocketChannel) key.channel();
                        socketChannel.write(buffer);
                        updateInterestedOps(key);
                    }
                }
                if (!key.channel().isOpen()) {
                    key.cancel();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void run() {
    while (this.isRunning) {
        try {
            this.selector.select();
            if (!selector.isOpen()) {
                continue;
            }
            for (final SelectionKey key : this.selector.selectedKeys()) {
                if (key.isValid() && key.isAcceptable()) {
                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    if (socketChannel != null) {
                        socketChannel.configureBlocking(false);
                        int interestedOps = SelectionKey.OP_READ;
                        socketChannel.register(selector, interestedOps, new ConcurrentLinkedDeque<>());
                    }
                }
                if (key.isValid() && key.isReadable()) {
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    int read = socketChannel.read(this.readBuffer);
                    if (read > 0) {
                        byte[] msgBuff = new byte[read];
                        this.readBuffer.rewind();
                        this.readBuffer.get(msgBuff);
                        this.readBuffer.clear();
                        String[] messages = new String(msgBuff, UTF8).split(END_OF_MESSAGE);
                        for (String message : messages) {
                            message = message + END_OF_MESSAGE;
                            this.reciever.recieve(Message.parse(message.getBytes(UTF8)), key);
                        }
                    }
                }
                if (key.isValid() && key.isWritable()) {
                    Deque<ByteBuffer> outbox = (Deque<ByteBuffer>) key.attachment();
                    ByteBuffer buffer = outbox.pollLast();
                    if (buffer != null) {
                        SocketChannel socketChannel = (SocketChannel) key.channel();
                        socketChannel.write(buffer);
                        updateInterestedOps(key);
                    }
                }
                if (!key.channel().isOpen()) {
                    key.cancel();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
#end_block

#method_before
@Override
protected void processIncoming() throws IOException, ClientConnectionException {
    if (this.ibuff == null) {
        int read = readBuffer(headerBuffer);
        if (read <= 0) {
            return;
        }
        updateLastHeartbeat();
        this.message = getMessage(headerBuffer, read);
        if (this.message == null) {
            clean();
            return;
        }
        int contentLength = this.message.getContentLength();
        if (contentLength == -1) {
            // only for control messages, all other have the header
            emitOnMessageReceived(this.message);
            return;
        }
        int length = this.message.getContent().length;
        if (contentLength == length - 1) {
            emitOnMessageReceived(this.message);
            return;
        } else if (contentLength > length) {
            this.ibuff = ByteBuffer.allocate(contentLength - length + 1);
        } else {
            byte[] content = this.message.getContent();
            this.message.withContent(Arrays.copyOfRange(content, 0, contentLength));
            emitOnMessageReceived(this.message);
            headerBuffer.put(Arrays.copyOfRange(content, contentLength, content.length));
        }
    }
    readBuffer(this.ibuff);
    updateLastHeartbeat();
    int length = this.message.getContent().length + this.ibuff.position();
    if (this.message.getContentLength() != length - 1) {
        return;
    }
    this.message.withAdditionalContent(this.ibuff.array());
    emitOnMessageReceived(this.message);
}
#method_after
@Override
protected void processIncoming() throws IOException, ClientConnectionException {
    if (this.ibuff == null) {
        int read = readBuffer(headerBuffer);
        if (read <= 0) {
            return;
        }
        updateLastHeartbeat();
        this.message = getMessage(headerBuffer, read);
        if (this.message == null) {
            clean();
            return;
        }
        int contentLength = this.message.getContentLength();
        if (contentLength == -1) {
            // only for control messages, all other have the header
            // according to stomp spec: The commands and headers are encoded in UTF-8
            String[] messages = new String(headerBuffer.array(), UTF8).split(END_OF_MESSAGE);
            for (String message : messages) {
                message = message + END_OF_MESSAGE;
                emitOnMessageReceived(Message.parse(message.getBytes(UTF8)));
            }
            return;
        }
        int length = this.message.getContent().length;
        if (contentLength == length - 1) {
            emitOnMessageReceived(this.message);
            return;
        } else if (contentLength > length) {
            this.ibuff = ByteBuffer.allocate(contentLength - length + 1);
        } else {
            byte[] content = this.message.getContent();
            this.message.withContent(Arrays.copyOfRange(content, 0, contentLength));
            emitOnMessageReceived(this.message);
            headerBuffer.put(Arrays.copyOfRange(content, contentLength, content.length));
        }
    }
    readBuffer(this.ibuff);
    updateLastHeartbeat();
    int length = this.message.getContent().length + this.ibuff.position();
    if (this.message.getContentLength() != length - 1) {
        return;
    }
    this.message.withAdditionalContent(this.ibuff.array());
    emitOnMessageReceived(this.message);
}
#end_block

#method_before
public void run() {
    this.isRunning = true;
    while (this.isRunning) {
        select();
        try {
            this.scheduler.performPendingOperations();
        } catch (Exception e) {
            LOG.error(e);
        }
        processChannels();
    }
}
#method_after
public void run() {
    this.isRunning = true;
    while (this.isRunning) {
        select();
        try {
            this.scheduler.performPendingOperations();
        } catch (Exception e) {
            LOG.error("Exception occured during running scheduled task", e);
        }
        processChannels();
    }
}
#end_block

#method_before
public static String[] getFilteredLocaleNames(List<String> allLocaleNames, List<String> visibleLocales) {
    List<String> result = new ArrayList<String>(allLocaleNames);
    List<String> hiddenList = new ArrayList<String>(allLocaleNames);
    hiddenList.removeAll(visibleLocales);
    result.removeAll(hiddenList);
    Collections.sort(result);
    return result.toArray(new String[result.size()]);
}
#method_after
public String[] getFilteredLocaleNames(List<String> allLocaleNames) {
    List<String> result = new ArrayList<String>(allLocaleNames);
    List<String> hiddenList = new ArrayList<String>(allLocaleNames);
    hiddenList.removeAll(getVisibleList());
    result.removeAll(hiddenList);
    Collections.sort(result);
    return result.toArray(new String[result.size()]);
}
#end_block

#method_before
public static List<String> getDisplayedLocales(List<String> allLocales, List<String> unsupportedLocalesFilterOverrides, List<String> unsupportedLocalesFilter) {
    List<String> result = new ArrayList<String>(allLocales);
    // Override unsupported locales that we do want to display.
    List<String> unsupportedLocalesTemp = new ArrayList<String>(unsupportedLocalesFilter);
    unsupportedLocalesTemp.removeAll(unsupportedLocalesFilterOverrides);
    // Remove remaining unsupported locales from the result.
    result.removeAll(unsupportedLocalesTemp);
    Collections.sort(result);
    return result;
}
#method_after
public static List<String> getDisplayedLocales(List<String> allLocales) {
    return getDisplayedLocales(allLocales, getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides), getLocalesKeys(ConfigValues.UnsupportedLocalesFilter));
}
#end_block

#method_before
public static List<String> getDisplayedLocales(List<String> allLocales, List<String> unsupportedLocalesFilterOverrides, List<String> unsupportedLocalesFilter) {
    List<String> result = new ArrayList<String>(allLocales);
    // Override unsupported locales that we do want to display.
    List<String> unsupportedLocalesTemp = new ArrayList<String>(unsupportedLocalesFilter);
    unsupportedLocalesTemp.removeAll(unsupportedLocalesFilterOverrides);
    // Remove remaining unsupported locales from the result.
    result.removeAll(unsupportedLocalesTemp);
    Collections.sort(result);
    return result;
}
#method_after
static List<String> getDisplayedLocales(List<String> allLocales, List<String> unsupportedLocalesFilterOverrides, List<String> unsupportedLocalesFilter) {
    List<String> result = new ArrayList<String>(allLocales);
    // Override unsupported locales that we do want to display.
    List<String> unsupportedLocalesTemp = new ArrayList<String>(unsupportedLocalesFilter);
    unsupportedLocalesTemp.removeAll(unsupportedLocalesFilterOverrides);
    // Remove remaining unsupported locales from the result.
    result.removeAll(unsupportedLocalesTemp);
    Collections.sort(result);
    return result;
}
#end_block

#method_before
public static List<String> getLocalesKeys(ConfigValues configValues) {
    if (!configValues.equals(ConfigValues.UnsupportedLocalesFilter) && !configValues.equals(ConfigValues.UnsupportedLocalesFilterOverrides)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("Passed in config value not related to locales");
    }
    List<String> locales = Config.<List<String>>getValue(configValues);
    List<String> result = new ArrayList<String>();
    if (locales != null && !locales.isEmpty()) {
        for (String localeKey : locales) {
            try {
                // Check for valid locale.
                String underScoredLocaleKey = localeKey.replaceAll("-", "_");
                org.apache.commons.lang.LocaleUtils.toLocale(underScoredLocaleKey);
                result.add(underScoredLocaleKey);
            } catch (IllegalArgumentException iae) {
                // The locale passed in is not valid, don't add it to the list.
                // $NON-NLS-1$
                log.info("Invalid locale found in configuration: " + localeKey);
            }
        }
    }
    return result;
}
#method_after
public static List<String> getLocalesKeys(ConfigValues configValues) {
    if (!configValues.equals(ConfigValues.UnsupportedLocalesFilter) && !configValues.equals(ConfigValues.UnsupportedLocalesFilterOverrides)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("Passed in config value not related to locales");
    }
    List<String> locales = Config.<List<String>>getValue(configValues);
    List<String> result = new ArrayList<String>();
    if (locales != null && !locales.isEmpty()) {
        for (String localeKey : locales) {
            try {
                // Check for valid locale.
                String underScoredLocaleKey = localeKey.replaceAll("-", "_");
                LocaleUtils.toLocale(underScoredLocaleKey);
                result.add(underScoredLocaleKey);
            } catch (IllegalArgumentException iae) {
                // The locale passed in is not valid, don't add it to the list.
                // $NON-NLS-1$
                log.info("Invalid locale found in configuration: " + localeKey);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys(), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilter)));
    String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
    request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
    request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
    RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
    response.setContentType("text/html;charset=UTF-8");
    if (dispatcher != null) {
        dispatcher.include(request, response);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()));
    String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
    request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
    request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
    RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
    response.setContentType("text/html;charset=UTF-8");
    if (dispatcher != null) {
        dispatcher.include(request, response);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys(), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilter)), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(request.getSession().getId()));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(request.getSession().getId()));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    localeNames = VisibleLocalesInfoData.getFilteredLocaleNames(Arrays.asList(localeNames), VisibleLocalesInfoData.instance().getVisibleList());
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#method_after
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    localeNames = VisibleLocalesInfoData.instance().getFilteredLocaleNames(Arrays.asList(localeNames));
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#end_block

#method_before
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    if (vm.getStatus().isUpOrPaused()) {
        model.setWarningAvailable(true);
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#method_after
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    if (vm.isRunningAndQualifyForDisksMigration()) {
        model.setWarningAvailable(true);
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DirectoryUtils.flatGroups(principalRecord);
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    if (!dbUser.isActive()) {
        dbUser.setActive(true);
        log.info(String.format("The user %1$s was reactivated as it was found in authz provider %2$s during login attempt.", dbUser.getLoginName(), dbUser.getDomain()));
    }
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
    if (!dbUser.isActive()) {
        dbUser.setActive(true);
        log.info(String.format("The user %1$s was reactivated as it was found in authz provider %2$s during login attempt.", dbUser.getLoginName(), dbUser.getDomain()));
    }
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getVdsGroup().getcompatibility_version()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVm().getStaticData().setVdsGroupId(getVdsGroupId());
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getVdsGroup().getcompatibility_version()));
}
#end_block

#method_before
public static List<DbUser> sync(List<DbUser> dbUsers) {
    List<DbUser> usersToUpdate = new ArrayList<>();
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), userIdsPerNamespace.getValue())) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        activeUser.setAdmin(dbUser.isAdmin());
                        log.infoFormat("Principal {0}::{1} synchronized", activeUser.getLoginName(), activeUser.getDomain());
                        usersToUpdate.add(activeUser);
                    }
                } else {
                    log.infoFormat("Deactivating non existing principal {0}::{1}", dbUser.getLoginName(), dbUser.getDomain());
                    dbUser.setActive(false);
                    usersToUpdate.add(dbUser);
                }
            }
        } catch (Exception ex) {
            log.errorFormat("Error during user synchronization of extension {0}. Exception message is {1}", authz, ex.getMessage());
            log.debug("", ex);
        }
    }
    return usersToUpdate;
}
#method_after
public static List<DbUser> sync(List<DbUser> dbUsers) {
    List<DbUser> usersToUpdate = new ArrayList<>();
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), userIdsPerNamespace.getValue())) {
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        activeUser.setAdmin(dbUser.isAdmin());
                        log.infoFormat("Principal {0}::{1} synchronized", activeUser.getLoginName(), activeUser.getDomain());
                        usersToUpdate.add(activeUser);
                    }
                } else {
                    log.infoFormat("Deactivating non existing principal {0}::{1}", dbUser.getLoginName(), dbUser.getDomain());
                    dbUser.setActive(false);
                    usersToUpdate.add(dbUser);
                }
            }
        } catch (Exception ex) {
            log.errorFormat("Error during user synchronization of extension {0}. Exception message is {1}", authz, ex.getMessage());
            log.debug("", ex);
        }
    }
    return usersToUpdate;
}
#end_block

#method_before
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: Vitaly check if luns in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUN_storage_server_connection_map, String>() {

                    @Override
                    public String eval(LUN_storage_server_connection_map a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.infoFormat("The lun with id {0} was reported as problematic !", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#method_after
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUN_storage_server_connection_map, String>() {

                    @Override
                    public String eval(LUN_storage_server_connection_map a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.infoFormat("The lun with id {0} was reported as problematic !", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void testAddUser_2() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: username=" + NAMES[0]);
    User model = new User();
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    model.setDomain(domain);
    model.setUserName(NAMES[0]);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_2() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: allnames=" + NAMES[0]);
    User model = new User();
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    model.setDomain(domain);
    model.setUserName(NAMES[0]);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
@Test
public void testAddUser_3() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: username=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0] + "@" + DOMAIN);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_3() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0] + "@" + DOMAIN);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: username=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(Charset.forName("UTF-8")), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(Charset.forName("UTF-8")), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
public static DbUser mapPrincipalRecordToDbUser(String authz, ExtMap principal) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(authz, principal.<String>get(PrincipalRecord.ID));
    Guid userId = dbUser != null ? dbUser.getId() : Guid.newGuid();
    dbUser = new DbUser(mapPrincipalRecordToDirectoryUser(authz, principal));
    dbUser.setId(userId);
    DbGroupDAO dao = DbFacade.getInstance().getDbGroupDao();
    LinkedList<Guid> groupIds = new LinkedList<Guid>();
    LinkedList<String> groupsNames = new LinkedList<String>();
    for (ExtMap group : principal.get(PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList())) {
        DbGroup dbGroup = dao.getByExternalId(authz, group.<String>get(GroupRecord.ID));
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
            groupsNames.add(dbGroup.getName());
        }
    }
    dbUser.setGroupIds(groupIds);
    dbUser.setGroupNames(groupsNames);
    return dbUser;
}
#method_after
public static DbUser mapPrincipalRecordToDbUser(String authz, ExtMap principal) {
    principal = principal.clone();
    flatGroups(principal);
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(authz, principal.<String>get(PrincipalRecord.ID));
    Guid userId = dbUser != null ? dbUser.getId() : Guid.newGuid();
    dbUser = new DbUser(mapPrincipalRecordToDirectoryUser(authz, principal));
    dbUser.setId(userId);
    DbGroupDAO dao = DbFacade.getInstance().getDbGroupDao();
    LinkedList<Guid> groupIds = new LinkedList<Guid>();
    LinkedList<String> groupsNames = new LinkedList<String>();
    for (ExtMap group : principal.get(PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList())) {
        DbGroup dbGroup = dao.getByExternalId(authz, group.<String>get(GroupRecord.ID));
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
            groupsNames.add(dbGroup.getName());
        }
    }
    dbUser.setGroupIds(groupIds);
    dbUser.setGroupNames(groupsNames);
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        retValue = false;
    }
    if (retValue && !getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'cdImagePath' means eject CD
        if (!StringUtils.isEmpty(cdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    } else if (retValue && !canRunActionOnNonManagedVm()) {
        retValue = false;
    } else if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    } else if (StringUtils.isNotEmpty(cdImagePath) && !cdImagePath.endsWith(ValidationUtils.ISO_SUFFIX)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
        setSucceeded(false);
        retValue = false;
    } else {
        cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    cdImagePath = getParameters().getCdImagePath();
    if (!getVm().isRunningOrPaused()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'cdImagePath' means eject CD
        if (!StringUtils.isEmpty(cdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        return failCanDoAction(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (StringUtils.isNotEmpty(cdImagePath) && !cdImagePath.endsWith(ValidationUtils.ISO_SUFFIX)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
    }
    return true;
}
#end_block

#method_before
@Override
protected void perform() {
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void verify(QoS model, QoS transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getDescription(), transform.getDescription());
    // storage limits:
    assertEquals(model.getMaxThroughput(), transform.getMaxThroughput());
    assertEquals(model.getMaxReadThroughput(), transform.getMaxReadThroughput());
    assertEquals(model.getMaxWriteThroughput(), transform.getMaxWriteThroughput());
    assertEquals(model.getMaxIops(), transform.getMaxIops());
    assertEquals(model.getMaxReadIops(), transform.getMaxReadIops());
    assertEquals(model.getMaxWriteIops(), transform.getMaxWriteIops());
}
#method_after
@Override
protected void verify(QoS model, QoS transform) {
    super.verify(model, transform);
    // storage limits:
    assertEquals(model.getMaxThroughput(), transform.getMaxThroughput());
    assertEquals(model.getMaxReadThroughput(), transform.getMaxReadThroughput());
    assertEquals(model.getMaxWriteThroughput(), transform.getMaxWriteThroughput());
    assertEquals(model.getMaxIops(), transform.getMaxIops());
    assertEquals(model.getMaxReadIops(), transform.getMaxReadIops());
    assertEquals(model.getMaxWriteIops(), transform.getMaxWriteIops());
}
#end_block

#method_before
@Mapping(from = QosBase.class, to = QoS.class)
public static QoS map(QosBase entity, QoS template) {
    QoS model = template != null ? template : new QoS();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setType(org.ovirt.engine.api.model.QosType.fromValue(entity.getQosType().toString()).name().toLowerCase());
    model.setDataCenter(new DataCenter());
    model.getDataCenter().setId(entity.getStoragePoolId().toString());
    model.setDescription(entity.getDescription());
    switch(entity.getQosType()) {
        case STORAGE:
            StorageQos storageQos = null;
            // avoid findbugs error.
            if (entity instanceof StorageQos) {
                storageQos = (StorageQos) entity;
            }
            // avoid findbugs error.
            if (storageQos == null) {
                return model;
            }
            model.setMaxThroughput(storageQos.getMaxThroughput());
            model.setMaxReadThroughput(storageQos.getMaxReadThroughput());
            model.setMaxWriteThroughput(storageQos.getMaxWriteThroughput());
            model.setMaxIops(storageQos.getMaxIops());
            model.setMaxReadIops(storageQos.getMaxReadIops());
            model.setMaxWriteIops(storageQos.getMaxWriteIops());
        case CPU:
            CpuQos cpuQos = null;
            // avoid findbugs error.
            if (entity instanceof CpuQos) {
                cpuQos = (CpuQos) entity;
            }
            // avoid findbugs error.
            if (cpuQos == null) {
                return model;
            }
            model.setCpuLimit(cpuQos.getCpuLimit());
        default:
            break;
    }
    return model;
}
#method_after
@Mapping(from = QosBase.class, to = QoS.class)
public static QoS map(QosBase entity, QoS template) {
    QoS model = template != null ? template : new QoS();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setType(org.ovirt.engine.api.model.QosType.fromValue(entity.getQosType().toString()).name().toLowerCase());
    model.setDataCenter(new DataCenter());
    model.getDataCenter().setId(entity.getStoragePoolId().toString());
    model.setDescription(entity.getDescription());
    switch(entity.getQosType()) {
        case STORAGE:
            StorageQos storageQos = null;
            // avoid findbugs error.
            if (entity instanceof StorageQos) {
                storageQos = (StorageQos) entity;
            }
            // avoid findbugs error.
            if (storageQos == null) {
                return model;
            }
            model.setMaxThroughput(storageQos.getMaxThroughput());
            model.setMaxReadThroughput(storageQos.getMaxReadThroughput());
            model.setMaxWriteThroughput(storageQos.getMaxWriteThroughput());
            model.setMaxIops(storageQos.getMaxIops());
            model.setMaxReadIops(storageQos.getMaxReadIops());
            model.setMaxWriteIops(storageQos.getMaxWriteIops());
            break;
        case CPU:
            CpuQos cpuQos = null;
            // avoid findbugs error.
            if (entity instanceof CpuQos) {
                cpuQos = (CpuQos) entity;
            }
            // avoid findbugs error.
            if (cpuQos == null) {
                return model;
            }
            model.setCpuLimit(cpuQos.getCpuLimit());
            break;
        default:
            break;
    }
    return model;
}
#end_block

#method_before
@Mapping(from = QoS.class, to = QosBase.class)
public static QosBase map(QoS model, QosBase template) {
    QosBase entity = null;
    if (template != null) {
        entity = template;
    }
    QosType qosType = model.getType() != null ? QosType.valueOf(model.getType().toUpperCase()) : entity != null ? QosType.valueOf(entity.getQosType().toString().toUpperCase()) : QosType.STORAGE;
    switch(qosType) {
        case STORAGE:
            if (entity == null) {
                entity = new StorageQos();
            }
            if (model.isSetMaxThroughput()) {
                ((StorageQos) entity).setMaxThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxThroughput()));
            }
            if (model.isSetMaxReadThroughput()) {
                ((StorageQos) entity).setMaxReadThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxReadThroughput()));
            }
            if (model.isSetMaxWriteThroughput()) {
                ((StorageQos) entity).setMaxWriteThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxWriteThroughput()));
            }
            if (model.isSetMaxIops()) {
                ((StorageQos) entity).setMaxIops(IntegerMapper.mapMinusOneToNull(model.getMaxIops()));
            }
            if (model.isSetMaxReadIops()) {
                ((StorageQos) entity).setMaxReadIops(IntegerMapper.mapMinusOneToNull(model.getMaxReadIops()));
            }
            if (model.isSetMaxWriteIops()) {
                ((StorageQos) entity).setMaxWriteIops(IntegerMapper.mapMinusOneToNull(model.getMaxWriteIops()));
            }
            break;
        case CPU:
            if (entity == null) {
                entity = new CpuQos();
            }
            if (model.isSetCpuLimit()) {
                ((CpuQos) entity).setCpuLimit(IntegerMapper.mapMinusOneToNull(model.getCpuLimit()));
            }
        default:
            break;
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    return entity;
}
#method_after
@Mapping(from = QoS.class, to = QosBase.class)
public static QosBase map(QoS model, QosBase template) {
    QosBase entity = null;
    if (template != null) {
        entity = template;
    }
    QosType qosType = model.getType() != null ? QosType.valueOf(model.getType().toUpperCase()) : entity != null ? QosType.valueOf(entity.getQosType().toString().toUpperCase()) : QosType.STORAGE;
    switch(qosType) {
        case STORAGE:
            if (entity == null) {
                entity = new StorageQos();
            }
            if (model.isSetMaxThroughput()) {
                ((StorageQos) entity).setMaxThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxThroughput()));
            }
            if (model.isSetMaxReadThroughput()) {
                ((StorageQos) entity).setMaxReadThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxReadThroughput()));
            }
            if (model.isSetMaxWriteThroughput()) {
                ((StorageQos) entity).setMaxWriteThroughput(IntegerMapper.mapMinusOneToNull(model.getMaxWriteThroughput()));
            }
            if (model.isSetMaxIops()) {
                ((StorageQos) entity).setMaxIops(IntegerMapper.mapMinusOneToNull(model.getMaxIops()));
            }
            if (model.isSetMaxReadIops()) {
                ((StorageQos) entity).setMaxReadIops(IntegerMapper.mapMinusOneToNull(model.getMaxReadIops()));
            }
            if (model.isSetMaxWriteIops()) {
                ((StorageQos) entity).setMaxWriteIops(IntegerMapper.mapMinusOneToNull(model.getMaxWriteIops()));
            }
            break;
        case CPU:
            if (entity == null) {
                entity = new CpuQos();
            }
            if (model.isSetCpuLimit()) {
                ((CpuQos) entity).setCpuLimit(IntegerMapper.mapMinusOneToNull(model.getCpuLimit()));
            }
            break;
        default:
            break;
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    return entity;
}
#end_block

#method_before
@Override
protected void verify(QoS model, QoS transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getDescription(), transform.getDescription());
    // cpu limits:
    assertEquals(model.getCpuLimit(), transform.getCpuLimit());
}
#method_after
@Override
protected void verify(QoS model, QoS transform) {
    super.verify(model, transform);
    // cpu limits:
    assertEquals(model.getCpuLimit(), transform.getCpuLimit());
}
#end_block

#method_before
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 3, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size
        validateParameters(disk, 3, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#method_after
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 3, "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size and format
        validateParameters(disk, 3, "provisionedSize|size", "format");
    }
    validateEnums(Disk.class, disk);
}
#end_block

#method_before
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 2, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size
        validateParameters(disk, 2, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#method_after
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 2, "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size and format
        validateParameters(disk, 2, "provisionedSize|size", "format");
    }
    validateEnums(Disk.class, disk);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.areBootableAndSharableCompatibleWithDisk())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!setAndValidateDiskProfiles()) {
            return false;
        }
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public ValidationResult isLunDiskVisible(final LUNs lun, VDS vds) {
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(vds.getId(), lun.getLunType());
    List<LUNs> luns = (List<LUNs>) getVdsBroker().RunVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    // Search LUN in the device list
    boolean lunExists = CollectionUtils.exists(luns, new Predicate() {

        @Override
        public boolean evaluate(Object o) {
            return ((LUNs) o).getId().equals(lun.getId());
        }
    });
    return lunExists ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_NOT_VALID);
}
#method_after
public ValidationResult isLunDiskVisible(final LUNs lun, VDS vds) {
    List<LUNs> luns = executeGetDeviceList(vds.getId(), lun.getLunType());
    // Search LUN in the device list
    boolean lunExists = CollectionUtils.exists(luns, new Predicate() {

        @Override
        public boolean evaluate(Object o) {
            return ((LUNs) o).getId().equals(lun.getId());
        }
    });
    return lunExists ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
}
#end_block

#method_before
private void setupConsole(final UserPortalBasicListProvider modelProvider) {
    UserPortalItemModel item = modelProvider.getModel().getSelectedItem();
    getView().setConsoleConnectLinkEnabled(canConnectToConsole(item));
    getView().setEditConsoleEnabled(isEditConsoleEnabled(item));
    getView().setConsoleProtocolMessage(determineProtocolMessage(item.getVmConsoles()));
}
#method_after
private void setupConsole(final UserPortalBasicListProvider modelProvider) {
    UserPortalItemModel item = modelProvider.getModel().getSelectedItem();
    getView().setEditConsoleEnabled(isEditConsoleEnabled(item));
    getView().setConsoleConnectLinkEnabled(canConnectToConsole(item));
    getView().setConsoleProtocolMessage(determineProtocolMessage(item));
}
#end_block

#method_before
private String determineProtocolMessage(VmConsoles vmConsoles) {
    ConsoleProtocol selectedProcotol = vmConsoles.getSelectedProcotol();
    if (selectedProcotol == null) {
        return "";
    }
    boolean smartcardEnabled = selectedProcotol == ConsoleProtocol.SPICE && vmConsoles.getVm().isSmartcardEnabled();
    boolean smartcardOverriden = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().isSmartcardEnabledOverridden();
    if (smartcardEnabled && !smartcardOverriden) {
        return messages.consoleWithSmartcard(consoleTypeToName.get(selectedProcotol));
    }
    return consoleTypeToName.get(selectedProcotol);
}
#method_after
private String determineProtocolMessage(UserPortalItemModel item) {
    VmConsoles vmConsoles = (item == null) ? null : item.getVmConsoles();
    if (item == null || vmConsoles == null || !canConnectToConsole(item)) {
        return "";
    }
    ConsoleProtocol selectedProcotol = vmConsoles.getSelectedProcotol();
    boolean smartcardEnabled = selectedProcotol == ConsoleProtocol.SPICE && vmConsoles.getVm().isSmartcardEnabled();
    boolean smartcardOverriden = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().isSmartcardEnabledOverridden();
    if (smartcardEnabled && !smartcardOverriden) {
        return messages.consoleWithSmartcard(consoleTypeToName.get(selectedProcotol));
    }
    return consoleTypeToName.get(selectedProcotol);
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    param.setProxyPreferences(getPmProxyPreferences());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetNewVdsFenceStatusParameters param = new GetNewVdsFenceStatusParameters();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    param.setOrder(isPrimary ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
    param.setManagementIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    param.setPmType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    param.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    param.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setFencingOptions(getPmOptionsMap());
    param.setPmProxyPreferences(getPmProxyPreferences());
    Frontend.getInstance().runQuery(VdcQueryType.GetNewVdsFenceStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded()) {
                String message;
                if (response != null && response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    message = fenceStatusReturnValue.toString();
                } else {
                    message = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
                }
                setMessage(message);
                getTestCommand().setIsExecutionAllowed(true);
            } else {
                if (response.getReturnValue() != null) {
                    FenceStatusReturnValue fenceStatusReturnValue = response.getReturnValue();
                    String message = fenceStatusReturnValue.toString();
                    setMessage(message);
                    getTestCommand().setIsExecutionAllowed(true);
                }
            }
        }
    }, true));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final String UNKNOWN = "unknown";
    Guid id = getParameters().getVdsId();
    VDS tempVar = new VDS();
    tempVar.setId((Guid) ((id != null) ? id : Guid.Empty));
    tempVar.setStoragePoolId(getParameters().getStoragePoolId());
    if (getParameters().getOrder() == FenceAgentOrder.Primary) {
        tempVar.setManagementIp(getParameters().getManagementIp());
        tempVar.setPmOptionsMap(getParameters().getFencingOptions());
        tempVar.setPmType(getParameters().getPmType());
        tempVar.setPmUser(getParameters().getUser());
        tempVar.setPmPassword(getParameters().getPassword());
    } else if (getParameters().getOrder() == FenceAgentOrder.Secondary) {
        tempVar.setPmSecondaryIp(getParameters().getManagementIp());
        tempVar.setPmSecondaryOptionsMap(getParameters().getFencingOptions());
        tempVar.setPmSecondaryType(getParameters().getPmType());
        tempVar.setPmSecondaryUser(getParameters().getUser());
        tempVar.setPmSecondaryPassword(getParameters().getPassword());
    }
    tempVar.setPmProxyPreferences(getParameters().getProxyPreferences());
    VDS vds = tempVar;
    FenceExecutor executor = new FenceExecutor(vds, FenceActionType.Status);
    if (executor.findProxyHost()) {
        VDSReturnValue returnValue = executor.fence(getParameters().getOrder());
        if (returnValue.getReturnValue() != null) {
            getQueryReturnValue().setReturnValue(returnValue.getReturnValue());
        }
    } else {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue(UNKNOWN, AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST)));
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    final String UNKNOWN = "unknown";
    Guid id = getParameters().getVdsId();
    VDS tempVar = new VDS();
    tempVar.setId((Guid) ((id != null) ? id : Guid.Empty));
    tempVar.setStoragePoolId(getParameters().getStoragePoolId());
    if (getParameters().getOrder() == FenceAgentOrder.Primary) {
        tempVar.setManagementIp(getParameters().getManagementIp());
        tempVar.setPmOptionsMap(getParameters().getFencingOptions());
        tempVar.setPmType(getParameters().getPmType());
        tempVar.setPmUser(getParameters().getUser());
        tempVar.setPmPassword(getParameters().getPassword());
    } else if (getParameters().getOrder() == FenceAgentOrder.Secondary) {
        tempVar.setPmSecondaryIp(getParameters().getManagementIp());
        tempVar.setPmSecondaryOptionsMap(getParameters().getFencingOptions());
        tempVar.setPmSecondaryType(getParameters().getPmType());
        tempVar.setPmSecondaryUser(getParameters().getUser());
        tempVar.setPmSecondaryPassword(getParameters().getPassword());
    }
    tempVar.setPmProxyPreferences(getParameters().getPmProxyPreferences());
    VDS vds = tempVar;
    FenceExecutor executor = new FenceExecutor(vds, FenceActionType.Status);
    if (executor.findProxyHost()) {
        VDSReturnValue returnValue = executor.fence(getParameters().getOrder());
        if (returnValue.getReturnValue() != null) {
            getQueryReturnValue().setReturnValue(returnValue.getReturnValue());
        }
    } else {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setReturnValue(new FenceStatusReturnValue(UNKNOWN, AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST)));
    }
}
#end_block

#method_before
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    for (XmlNode node : section.SelectNodes("Item")) {
        switch(node.SelectSingleNode("rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial ? true : VmDeviceType.VIRTIOSERIAL == VmDeviceType.getByName(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#method_after
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    for (XmlNode node : section.SelectNodes("Item")) {
        switch(node.SelectSingleNode("rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#end_block

#method_before
public void init(Provider<OpenstackNetworkProviderProperties> provider) {
    OpenstackNetworkProviderProperties properties = provider.getAdditionalProperties();
    // $NON-NLS-1$
    String pluginName = (properties == null) ? EnumTranslator.getInstance().get(OpenstackNetworkPluginType.OPEN_VSWITCH) : properties.getPluginType();
    getPluginType().setSelectedItem(NeutronPluginTranslator.getDisplayStringForPluginName(pluginName));
    if (properties != null) {
        AgentConfiguration agentConfiguration = properties.getAgentConfiguration();
        if (agentConfiguration != null) {
            getInterfaceMappings().setEntity(agentConfiguration.getNetworkMappings());
            MessagingConfiguration messagingConfiguration = agentConfiguration.getMessagingConfiguration();
            if (messagingConfiguration != null) {
                getBrokerType().setSelectedItem(messagingConfiguration.getBrokerType());
                getMessagingServer().setEntity(messagingConfiguration.getAddress());
                Integer port = messagingConfiguration.getPort();
                getMessagingServerPort().setEntity(port == null ? null : Integer.toString(port));
                getMessagingServerUsername().setEntity(messagingConfiguration.getUsername());
                getMessagingServerPassword().setEntity(messagingConfiguration.getPassword());
            }
        }
    }
}
#method_after
public void init(Provider<OpenstackNetworkProviderProperties> provider) {
    OpenstackNetworkProviderProperties properties = provider.getAdditionalProperties();
    String pluginName = (properties == null) ? getDefaultPluginTypeString() : properties.getPluginType();
    getPluginType().setSelectedItem(NeutronPluginTranslator.getDisplayStringForPluginName(pluginName));
    if (properties != null) {
        AgentConfiguration agentConfiguration = properties.getAgentConfiguration();
        if (agentConfiguration != null) {
            getInterfaceMappings().setEntity(agentConfiguration.getNetworkMappings());
            MessagingConfiguration messagingConfiguration = agentConfiguration.getMessagingConfiguration();
            if (messagingConfiguration != null) {
                getBrokerType().setSelectedItem(messagingConfiguration.getBrokerType());
                getMessagingServer().setEntity(messagingConfiguration.getAddress());
                Integer port = messagingConfiguration.getPort();
                getMessagingServerPort().setEntity(port == null ? null : Integer.toString(port));
                getMessagingServerUsername().setEntity(messagingConfiguration.getUsername());
                getMessagingServerPassword().setEntity(messagingConfiguration.getPassword());
            }
        }
    }
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            isVmContainBootableDisk = false;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        isVmContainBootableDisk = true;
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getcompatibility_version().getValue());
    getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#method_after
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getcompatibility_version().getValue());
    if (getIsShareable().getIsChangable()) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
        getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
    }
}
#end_block

#method_before
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#method_after
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else if (getIsShareable().getIsChangable()) {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#end_block

#method_before
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        updateWipeAfterDelete(selectedStorage.getStorageType());
    }
    updateQuota(getDataCenter().getSelectedItem());
}
#method_after
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
    }
    updateQuota(getDataCenter().getSelectedItem());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsWipeAfterDelete()) {
            wipeAfterDelete_EntityChanged(args);
        } else if (sender == getIsAttachDisk()) {
            attachDisk_EntityChanged(args);
        } else if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getIsInternal()) {
            isInternal_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsAttachDisk()) {
            attachDisk_EntityChanged(args);
        } else if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getIsInternal()) {
            isInternal_EntityChanged();
        } else if (sender == getIsBootable()) {
            isBootable_EntityChanged();
        } else if (sender == getIsShareable()) {
            isShareable_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = (List<CpuProfile>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                    }
                }
            }
        }
    }));
}
#method_after
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = (List<CpuProfile>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        buildModel(template);
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateTimeZone(template.getTimeZone());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            updateRngDevice(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initStorageDomains();
        InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
        int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
        // do not update if specified on template or instance type
        if (template.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
            updateMinAllocatedMemory();
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        updateCpuProfile(template.getVdsGroupId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        buildModel(template);
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateTimeZone(template.getTimeZone());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            updateRngDevice(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initStorageDomains();
        InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
        int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
        // do not update if specified on template or instance type
        if (template.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
            updateMinAllocatedMemory();
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        if (getModel().getSelectedCluster() != null) {
            updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
        }
    }
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        buildModel(vmBase);
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getVmType().setSelectedItem(vmBase.getVmType());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initStorageDomains();
        InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
        int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
        // do not update if specified on template or instance type
        if (vmBase.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
            updateMinAllocatedMemory();
        }
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        updateCpuProfile(vmBase.getVdsGroupId(), getClusterCompatibilityVersion(), vmBase.getCpuProfileId());
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        buildModel(vmBase);
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getVmType().setSelectedItem(vmBase.getVmType());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initStorageDomains();
        InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
        int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
        // do not update if specified on template or instance type
        if (vmBase.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
            updateMinAllocatedMemory();
        }
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        if (getModel().getSelectedCluster() != null) {
            updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), vmBase.getCpuProfileId());
        }
    }
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    updateCpuProfile(template.getCpuProfileId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
    }
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    updateCpuProfile(vm.getVdsGroupId(), vm.getVdsGroupCompatibilityVersion(), vm.getCpuProfileId());
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getModel().getSelectedCluster().getcompatibility_version(), vm.getCpuProfileId());
    }
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getCpuProfiles().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel> getStorageCpuProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuProfilePopupPresenterWidget> newProfilePopupProvider, final Provider<CpuProfilePopupPresenterWidget> editProfilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel>(eventBus, defaultConfirmPopupProvider, ClusterListModel.class, CpuProfileListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newProfilePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editProfilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel> getStorageCpuProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuProfilePopupPresenterWidget> profilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel>(eventBus, defaultConfirmPopupProvider, ClusterListModel.class, CpuProfileListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return profilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(vdcActionType, getParameters(), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#method_after
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(vdcActionType, getParameters(), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            cancel();
        }
    }, this);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new SpecialAsciiI18NOrNoneValidation() });
    return getName().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new SpecialAsciiI18NOrNoneValidation() });
    getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    return getName().getIsValid();
}
#end_block

#method_before
@Override
protected VDSGroup getParentEntity() {
    return (VDSGroup) ((super.getEntity() instanceof VDSGroup) ? super.getEntity() : null);
}
#method_after
@Override
protected VDSGroup getParentEntity() {
    return (VDSGroup) getEntity();
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel> getDataCenterCpuQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuQosPopupPresenterWidget> CpuQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterCpuQosListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return CpuQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel> getDataCenterCpuQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuQosPopupPresenterWidget> cpuQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterCpuQosListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return cpuQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean canDo = true;
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    return canDo;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (!FeatureSupported.vmSlaPolicy(getVm().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.VM_SLA_POLICY_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UpdateVmPolicy, new UpdateVmPolicyVDSCommand.Params(getVm().getRunOnVds(), getVm().getId(), getParameters().getVm().getStaticData().getCpuLimit()));
    if (vdsReturnValue.getSucceeded()) {
        setSucceeded(true);
    } else {
        VdcFault fault = new VdcFault();
        fault.setError(vdsReturnValue.getVdsError().getCode());
        fault.setMessage(vdsReturnValue.getVdsError().getMessage());
        getReturnValue().setFault(fault);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UpdateVmPolicy, new UpdateVmPolicyVDSParams(getVm().getRunOnVds(), getVmId(), getParameters().getCpuLimit()));
    setSucceeded(vdsReturnValue.getSucceeded());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue(LOGABLE_FIELD_CPU_LIMIT, String.valueOf(getParameters().getVm().getStaticData().getCpuLimit()));
    if (getSucceeded()) {
        return AuditLogType.VM_SLA_POLICY;
    } else {
        addCustomValue(LOGABLE_FIELD_ERROR_MESSAGE, getReturnValue().getFault().getMessage());
        return AuditLogType.FAILED_VM_SLA_POLICY;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue(LOGABLE_FIELD_CPU_LIMIT, String.valueOf(getParameters().getCpuLimit()));
    return getSucceeded() ? AuditLogType.VM_SLA_POLICY : AuditLogType.FAILED_VM_SLA_POLICY;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
// addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_SET_CPUS);
// addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
// addCanDoActionMessage(String.format("$clusterVersion %1$s",
// getVm().getVdsGroupCompatibilityVersion() ));
// addCanDoActionMessage(String.format("$architecture %1$s",
// getVm().getClusterArch()));
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE_SLA_POLICY);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    try {
        init();
        status = getBroker().updateVmPolicy(struct);
        proceedProxyReturnValue();
    } catch (RuntimeException e) {
        setVdsRuntimeError(e);
        // prevent exception handler from re-throwing an exception
        getVDSReturnValue().setExceptionString(null);
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    getBroker().updateVmPolicy(build());
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options);
        FenceStatusReturnForXmlRpc wrapper = new FenceStatusReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    try {
        Map<String, Object> xmlRpcReturnValue;
        if (fencingPolicy == null) {
            // if fencing policy is null, fence proxy does not support fencing policy parameter
            xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options);
        } else {
            xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options, fencingPolicy);
        }
        FenceStatusReturnForXmlRpc wrapper = new FenceStatusReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    try {
        Map<String, Object> xmlRpcReturnValue;
        if (storageDomains == null) {
            xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion);
        } else {
            xmlRpcReturnValue = vdsServer.connectStoragePool(spUUID, hostSpmId, SCSIKey, masterdomainId, masterVersion, storageDomains);
        }
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickDirectories, int replicaCount) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeRemoveBrickStop(volumeName, brickDirectories, replicaCount));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickDirectories, int replicaCount) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRemoveBrickStop(volumeName, brickDirectories, replicaCount);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeProfileInfo(volumeName);
        GlusterVolumeProfileInfoReturnForXmlRpc wrapper = new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeProfileInfo(volumeName, nfs);
        GlusterVolumeProfileInfoReturnForXmlRpc wrapper = new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<DiskProfile> nameColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.diskProfileNameLabel(), "200px");
    TextColumnWithTooltip<DiskProfile> descriptionColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.diskProfileDescriptionLabel(), "200px");
    TextColumnWithTooltip<DiskProfile> qosColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            String name = constants.UnlimitedStorageQos();
            if (object.getQosId() != null) {
                StorageQos storageQos = getModel().getStorageQos(object.getQosId());
                if (storageQos != null) {
                    name = storageQos.getName();
                }
            }
            return name;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.storageQosName(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.newDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.editDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.removeDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updatePermissionPanel();
        }
    });
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updatePermissionPanel();
        }
    });
}
#method_after
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<DiskProfile> nameColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.diskProfileNameLabel(), "200px");
    nameColumn.makeSortable();
    TextColumnWithTooltip<DiskProfile> descriptionColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.diskProfileDescriptionLabel(), "200px");
    descriptionColumn.makeSortable();
    TextColumnWithTooltip<DiskProfile> qosColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            String name = constants.UnlimitedStorageQos();
            if (object.getQosId() != null) {
                StorageQos storageQos = getModel().getStorageQos(object.getQosId());
                if (storageQos != null) {
                    name = storageQos.getName();
                }
            }
            return name;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.storageQosName(), "200px");
    qosColumn.makeSortable();
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.newDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.editDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.removeDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updatePermissionPanel();
        }
    });
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updatePermissionPanel();
        }
    });
}
#end_block

#method_before
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewDiskProfileModel model = new NewDiskProfileModel(this, getCompatibilityVersion(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#method_after
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewDiskProfileModel model = new NewDiskProfileModel(this, getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#end_block

#method_before
public void edit() {
    if (getWindow() != null) {
        return;
    }
    EditDiskProfileModel model = new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#method_after
public void edit() {
    if (getWindow() != null) {
        return;
    }
    EditDiskProfileModel model = new EditDiskProfileModel(this, (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskProfileModel model = new RemoveDiskProfileModel(this, getSelectedItems(), false);
    setWindow(model);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskProfileModel model = new RemoveDiskProfileModel(this, getSelectedItems());
    setWindow(model);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(getEntity().getStoragePoolId(), QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageQos> qosList = (ArrayList<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            qosMap = new HashMap<Guid, StorageQos>();
            if (qosList != null) {
                for (StorageQos storageQos : qosList) {
                    qosMap.put(storageQos.getId(), storageQos);
                }
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(DiskProfileListModel.this.getEntity().getId()), new AsyncQuery(new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object returnValue1) {
                    DiskProfileListModel.this.setItems((List<DiskProfile>) ((VdcQueryReturnValue) returnValue1).getReturnValue());
                }
            }));
        }
    }));
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    Guid dcId = getEntity().getStoragePoolId();
    if (dcId == null) {
        // not attached to data center
        fetchDiskProfiles();
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<StorageQos> qosList = (ArrayList<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                qosMap = new HashMap<Guid, StorageQos>();
                if (qosList != null) {
                    for (StorageQos storageQos : qosList) {
                        qosMap.put(storageQos.getId(), storageQos);
                    }
                }
                fetchDiskProfiles();
            }
        }));
    }
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl(), ReportInit.getInstance().getSsoToken());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    instanceTypeListModel = new InstanceTypeListModel();
    list.add(instanceTypeListModel);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl(), ReportInit.getInstance().getSsoToken());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    instanceTypeListModel = new InstanceTypeListModel();
    list.add(instanceTypeListModel);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    sharedMacPoolListModel = new SharedMacPoolListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { roleListModel, systemPermissionListModel, clusterPolicyListModel });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#method_after
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { roleListModel, systemPermissionListModel, clusterPolicyListModel, sharedMacPoolListModel });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSearchCommand()) {
        search();
    } else if (command == getSignOutCommand()) {
        signOut();
    } else if (command == getConfigureCommand()) {
        configure();
    } else if (command == getClearSearchStringCommand()) {
        clearSearchString();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSearchCommand()) {
        search();
    } else if (command == getConfigureCommand()) {
        configure();
    } else if (command == getClearSearchStringCommand()) {
        clearSearchString();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#end_block

#method_before
void bindModels() {
    // All model providers are ultimately referenced via ModelBoundTabData
    // and are therefore created early on, just like eager singletons
    install(new DataCenterModule());
    install(new StorageModule());
    install(new ClusterModule());
    install(new VirtualMachineModule());
    install(new HostModule());
    install(new PoolModule());
    install(new TemplateModule());
    install(new UserModule());
    install(new EventModule());
    install(new ReportsModule());
    install(new QuotaModule());
    install(new VolumeModule());
    install(new DiskModule());
    install(new NetworkModule());
    install(new ProviderModule());
    install(new VnicProfileModule());
    // SystemTreeModel
    bind(SystemTreeModelProvider.class).asEagerSingleton();
    // BookmarkListModel
    bind(BookmarkModelProvider.class).asEagerSingleton();
    // TagListModel
    bind(TagModelProvider.class).asEagerSingleton();
    // AlertListModel
    bind(AlertModelProvider.class).asEagerSingleton();
    bind(AlertFirstRowModelProvider.class).asEagerSingleton();
    // TaskListModel
    bind(TaskModelProvider.class).asEagerSingleton();
    bind(TaskFirstRowModelProvider.class).asEagerSingleton();
    // EventListModel
    bind(EventModelProvider.class).asEagerSingleton();
    bind(EventFirstRowModelProvider.class).asEagerSingleton();
    // RoleListModel
    bind(RoleModelProvider.class).asEagerSingleton();
    // RolePermissionListModel
    bind(RolePermissionModelProvider.class).asEagerSingleton();
    // SystemPermissionListModel
    bind(SystemPermissionModelProvider.class).asEagerSingleton();
    // ClusterPolicyListModel
    bind(ClusterPolicyModelProvider.class).asEagerSingleton();
    // ClusterPolicyClusterListModel
    bind(ClusterPolicyClusterModelProvider.class).asEagerSingleton();
    bind(InstanceTypeModelProvider.class).asEagerSingleton();
    bind(InstanceTypeGeneralModelProvider.class).asEagerSingleton();
    // disk profiles permissions
    bind(DiskProfilePermissionModelProvider.class).asEagerSingleton();
}
#method_after
void bindModels() {
    // All model providers are ultimately referenced via ModelBoundTabData
    // and are therefore created early on, just like eager singletons
    install(new DataCenterModule());
    install(new StorageModule());
    install(new ClusterModule());
    install(new VirtualMachineModule());
    install(new HostModule());
    install(new PoolModule());
    install(new TemplateModule());
    install(new UserModule());
    install(new EventModule());
    install(new ReportsModule());
    install(new QuotaModule());
    install(new VolumeModule());
    install(new DiskModule());
    install(new NetworkModule());
    install(new ProviderModule());
    install(new VnicProfileModule());
    // SystemTreeModel
    bind(SystemTreeModelProvider.class).asEagerSingleton();
    // BookmarkListModel
    bind(BookmarkModelProvider.class).asEagerSingleton();
    // TagListModel
    bind(TagModelProvider.class).asEagerSingleton();
    // AlertListModel
    bind(AlertModelProvider.class).asEagerSingleton();
    bind(AlertFirstRowModelProvider.class).asEagerSingleton();
    // TaskListModel
    bind(TaskModelProvider.class).asEagerSingleton();
    bind(TaskFirstRowModelProvider.class).asEagerSingleton();
    // EventListModel
    bind(EventModelProvider.class).asEagerSingleton();
    bind(EventFirstRowModelProvider.class).asEagerSingleton();
    // RoleListModel
    bind(RoleModelProvider.class).asEagerSingleton();
    // RolePermissionListModel
    bind(RolePermissionModelProvider.class).asEagerSingleton();
    // SystemPermissionListModel
    bind(SystemPermissionModelProvider.class).asEagerSingleton();
    // ClusterPolicyListModel
    bind(ClusterPolicyModelProvider.class).asEagerSingleton();
    // ClusterPolicyClusterListModel
    bind(ClusterPolicyClusterModelProvider.class).asEagerSingleton();
    bind(InstanceTypeModelProvider.class).asEagerSingleton();
    bind(InstanceTypeGeneralModelProvider.class).asEagerSingleton();
    // SharedMacPoolListModel
    bind(SharedMacPoolModelProvider.class).asEagerSingleton();
    // disk profiles permissions
    bind(DiskProfilePermissionModelProvider.class).asEagerSingleton();
}
#end_block

#method_before
protected void addMoveOrCopyParameters(ArrayList<VdcActionParametersBase> parameters, Guid sourceStorageDomainGuid, Guid destStorageDomainGuid, DiskImage disk) {
    MoveOrCopyImageGroupParameters params = createParameters(sourceStorageDomainGuid, destStorageDomainGuid, disk);
    params.setQuotaId(disk.getQuotaId());
    parameters.add(params);
}
#method_after
protected void addMoveOrCopyParameters(ArrayList<VdcActionParametersBase> parameters, Guid sourceStorageDomainGuid, Guid destStorageDomainGuid, DiskImage disk) {
    MoveOrCopyImageGroupParameters params = createParameters(sourceStorageDomainGuid, destStorageDomainGuid, disk);
    params.setQuotaId(disk.getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId());
    parameters.add(params);
}
#end_block

#method_before
void updateListHeader(DisksAllocationModel model) {
    // $NON-NLS-1$ //$NON-NLS-2$
    String width = showQuota ? "85px" : "100px";
    listHeader = new EntityModelCellTable(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn(), constants.aliasDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.provisionedSizeDisk(), width);
    if (showVolumeType)
        listHeader.addColumn(new EmptyColumn(), constants.allocationDisk(), width);
    if (showSource)
        listHeader.addColumn(new EmptyColumn(), constants.sourceDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.targetDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.diskProfile(), width);
    if (showQuota)
        listHeader.addColumn(new EmptyColumn(), constants.quotaDisk(), width);
    listHeader.setRowData(new ArrayList());
    // $NON-NLS-1$
    listHeader.setWidth("100%", true);
    diskListHeaderPanel.setWidget(listHeader);
}
#method_after
void updateListHeader(DisksAllocationModel model) {
    // $NON-NLS-1$
    String width = "85px";
    listHeader = new EntityModelCellTable(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn(), constants.aliasDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.provisionedSizeDisk(), width);
    if (showVolumeType)
        listHeader.addColumn(new EmptyColumn(), constants.allocationDisk(), width);
    if (showSource)
        listHeader.addColumn(new EmptyColumn(), constants.sourceDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.targetDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.diskProfile(), width);
    if (showQuota)
        listHeader.addColumn(new EmptyColumn(), constants.quotaDisk(), width);
    listHeader.setRowData(new ArrayList());
    // $NON-NLS-1$
    listHeader.setWidth("100%", true);
    diskListHeaderPanel.setWidget(listHeader);
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            isVmContainBootableDisk = false;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        isVmContainBootableDisk = true;
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getcompatibility_version().getValue());
    getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#method_after
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getcompatibility_version().getValue());
    if (getIsShareable().getIsChangable()) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
        getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
    }
}
#end_block

#method_before
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#method_after
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else if (getIsShareable().getIsChangable()) {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#end_block

#method_before
private void updateDiskProfiles(StoragePool selectedItem) {
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomain.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object innerReturnValue) {
            List<DiskProfile> diskProfiles = ((VdcQueryReturnValue) innerReturnValue).getReturnValue();
            if (diskProfiles != null && !diskProfiles.isEmpty()) {
                getDiskProfile().setItems(diskProfiles);
            }
            Guid defaultProfileId = getDisk() != null ? ((DiskImage) getDisk()).getDiskProfileId() : null;
            if (defaultProfileId != null) {
                for (DiskProfile profile : diskProfiles) {
                    if (profile.getId().equals(defaultProfileId)) {
                        getDiskProfile().setSelectedItem(profile);
                        return;
                    }
                }
                DiskProfile diskProfile = new DiskProfile();
                diskProfile.setId(defaultProfileId);
                if (getDisk() != null) {
                    diskProfile.setName(getDiskImage().getDiskProfileName());
                }
                diskProfiles.add(diskProfile);
                getDiskProfile().setItems(diskProfiles);
                getDiskProfile().setSelectedItem(diskProfile);
            }
        }
    }, getHash()));
}
#method_after
private void updateDiskProfiles(StoragePool selectedItem) {
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomain.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object value) {
            AbstractDiskModel.this.setDiskProfilesList((List<DiskProfile>) ((VdcQueryReturnValue) value).getReturnValue());
        }
    }, getHash()));
}
#end_block

#method_before
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        updateWipeAfterDelete(selectedStorage.getStorageType());
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
}
#method_after
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsWipeAfterDelete()) {
            wipeAfterDelete_EntityChanged(args);
        } else if (sender == getIsAttachDisk()) {
            attachDisk_EntityChanged(args);
        } else if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getIsInternal()) {
            isInternal_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsAttachDisk()) {
            attachDisk_EntityChanged(args);
        } else if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getIsInternal()) {
            isInternal_EntityChanged();
        } else if (sender == getIsBootable()) {
            isBootable_EntityChanged();
        } else if (sender == getIsShareable()) {
            isShareable_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
void updateStyles(Boolean isNarrowStyle) {
    String editorStyle = isNarrowStyle ? style.editorContentNarrow() : style.editorContent();
    updateEditorStyle(diskAliasLabel, editorStyle);
    updateEditorStyle(diskAliasEditor, editorStyle);
    updateEditorStyle(diskSizeLabel, editorStyle);
    updateEditorStyle(sourceStorageLabel, editorStyle);
    updateEditorStyle(volumeTypeListEditor, editorStyle);
    updateEditorStyle(sourceStorageListEditor, editorStyle);
    updateEditorStyle(storageListEditor, editorStyle);
    updateEditorStyle(diskProfileListEditor, editorStyle);
    updateEditorStyle(quotaListEditor, editorStyle);
}
#method_after
void updateStyles(Boolean isNarrowStyle) {
    String editorStyle = style.editorContentNarrow();
    updateEditorStyle(diskAliasLabel, editorStyle);
    updateEditorStyle(diskAliasEditor, editorStyle);
    updateEditorStyle(diskSizeLabel, editorStyle);
    updateEditorStyle(sourceStorageLabel, editorStyle);
    updateEditorStyle(volumeTypeListEditor, editorStyle);
    updateEditorStyle(sourceStorageListEditor, editorStyle);
    updateEditorStyle(storageListEditor, editorStyle);
    updateEditorStyle(diskProfileListEditor, editorStyle);
    updateEditorStyle(quotaListEditor, editorStyle);
}
#end_block

#method_before
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> isItem) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<DiskProfile> list = (List<DiskProfile>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (list != null) {
                if (isItem == null) {
                    for (DiskModel diskModel : DisksAllocationModel.this.getDisks()) {
                        diskModel.getDiskProfile().setItems(list);
                        for (DiskProfile diskProfile : list) {
                            if (diskModel.getDisk() instanceof DiskImage && diskProfile.getId().equals(((DiskImage) diskModel.getDisk()).getDiskProfileId())) {
                                diskModel.getDiskProfile().setSelectedItem(diskProfile);
                            }
                        }
                    }
                } else {
                    DiskProfile selectedDiskProfile = null;
                    if (isItem.getSelectedItem() != null) {
                        selectedDiskProfile = isItem.getSelectedItem();
                    }
                    isItem.setItems(list);
                    if (selectedDiskProfile != null && list.size() > 1) {
                        for (DiskProfile diskProfile : list) {
                            if (diskProfile.getId().equals(selectedDiskProfile.getId())) {
                                isItem.setSelectedItem(diskProfile);
                            }
                        }
                    }
                }
            }
        }
    }));
}
#method_after
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> diskProfiles) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<DiskProfile> fetchedDiskProfiles = (List<DiskProfile>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            DisksAllocationModel.this.setDiskProfilesList(diskProfiles, fetchedDiskProfiles);
        }
    }));
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<DiskProfile> nameColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.diskProfileNameLabel(), "200px");
    TextColumnWithTooltip<DiskProfile> descriptionColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionVnicProfile(), "200px");
    TextColumnWithTooltip<DiskProfile> qosColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            String name = constants.UnlimitedStorageQos();
            if (object.getQosId() != null) {
                StorageQos storageQos = getDetailModel().getStorageQos(object.getQosId());
                if (storageQos != null) {
                    name = storageQos.getName();
                }
            }
            return name;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.storageQosName(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.newDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.editDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.removeDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<DiskProfile> nameColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.diskProfileNameLabel(), "200px");
    TextColumnWithTooltip<DiskProfile> descriptionColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.diskProfileDescriptionLabel(), "200px");
    TextColumnWithTooltip<DiskProfile> qosColumn = new TextColumnWithTooltip<DiskProfile>() {

        @Override
        public String getValue(DiskProfile object) {
            String name = constants.UnlimitedStorageQos();
            if (object.getQosId() != null) {
                StorageQos storageQos = getDetailModel().getStorageQos(object.getQosId());
                if (storageQos != null) {
                    name = storageQos.getName();
                }
            }
            return name;
        }
    };
    qosColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.storageQosName(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.newDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.editDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DiskProfile>(constants.removeDiskProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    items = AsyncDataProvider.getDataStorageModels();
    items.addAll(AsyncDataProvider.getIsoStorageModels());
    items.addAll(AsyncDataProvider.getExportStorageModels());
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSave");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    items = AsyncDataProvider.getInstance().getDataStorageModels();
    items.addAll(AsyncDataProvider.getInstance().getIsoStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getExportStorageModels());
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSave");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private IStorageModel prepareNfsStorageForEdit(StorageDomain storage) {
    final NfsStorageModel model = new NfsStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isNfsPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isNfsPathEditable);
    model.getOverride().setIsChangable(isNfsPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getRetransmissions().setEntity(connection.getNfsRetrans());
            model.getTimeout().setEntity(connection.getNfsTimeo());
            model.getMountOptions().setEntity(connection.getMountOptions());
            for (EntityModel<NfsVersion> item : model.getVersion().getItems()) {
                EntityModel itemModel = item;
                boolean noNfsVersion = itemModel.getEntity() == null && connection.getNfsVersion() == null;
                boolean foundNfsVersion = itemModel.getEntity() != null && itemModel.getEntity().equals(connection.getNfsVersion());
                if (noNfsVersion || foundNfsVersion) {
                    model.getVersion().setSelectedItem(item);
                    break;
                }
            }
            // If any settings were overridden, reflect this in the override checkbox
            model.getOverride().setEntity(connection.getNfsVersion() != null || connection.getNfsRetrans() != null || connection.getNfsTimeo() != null || connection.getMountOptions() != null);
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel prepareNfsStorageForEdit(StorageDomain storage) {
    final NfsStorageModel model = new NfsStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isNfsPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isNfsPathEditable);
    model.getOverride().setIsChangable(isNfsPathEditable);
    AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getRetransmissions().setEntity(connection.getNfsRetrans());
            model.getTimeout().setEntity(connection.getNfsTimeo());
            model.getMountOptions().setEntity(connection.getMountOptions());
            for (EntityModel<NfsVersion> item : model.getVersion().getItems()) {
                EntityModel itemModel = item;
                boolean noNfsVersion = itemModel.getEntity() == null && connection.getNfsVersion() == null;
                boolean foundNfsVersion = itemModel.getEntity() != null && itemModel.getEntity().equals(connection.getNfsVersion());
                if (noNfsVersion || foundNfsVersion) {
                    model.getVersion().setSelectedItem(item);
                    break;
                }
            }
            // If any settings were overridden, reflect this in the override checkbox
            model.getOverride().setEntity(connection.getNfsVersion() != null || connection.getNfsRetrans() != null || connection.getNfsTimeo() != null || connection.getMountOptions() != null);
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private IStorageModel prepareLocalStorageForEdit(StorageDomain storage) {
    LocalStorageModel model = new LocalStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            LocalStorageModel localStorageModel = (LocalStorageModel) target;
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            localStorageModel.getPath().setEntity(connection.getconnection());
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel prepareLocalStorageForEdit(StorageDomain storage) {
    LocalStorageModel model = new LocalStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isPathEditable);
    AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            LocalStorageModel localStorageModel = (LocalStorageModel) target;
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            localStorageModel.getPath().setEntity(connection.getconnection());
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private IStorageModel preparePosixStorageForEdit(StorageDomain storage) {
    final PosixStorageModel model = new PosixStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isPathEditable);
    model.getVfsType().setIsChangable(isPathEditable);
    model.getMountOptions().setIsChangable(isPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getVfsType().setEntity(connection.getVfsType());
            model.getMountOptions().setEntity(connection.getMountOptions());
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel preparePosixStorageForEdit(StorageDomain storage) {
    final PosixStorageModel model = new PosixStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isPathEditable);
    model.getVfsType().setIsChangable(isPathEditable);
    model.getMountOptions().setIsChangable(isPathEditable);
    AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getVfsType().setEntity(connection.getVfsType());
            model.getMountOptions().setEntity(connection.getMountOptions());
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private IStorageModel prepareGlusterStorageForEdit(StorageDomain storage) {
    final GlusterStorageModel model = new GlusterStorageModel();
    model.setRole(storage.getStorageDomainType());
    model.getPath().setIsChangable(true);
    model.getVfsType().setIsChangable(false);
    model.getMountOptions().setIsChangable(false);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getVfsType().setEntity(connection.getVfsType());
            model.getMountOptions().setEntity(connection.getMountOptions());
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel prepareGlusterStorageForEdit(StorageDomain storage) {
    final GlusterStorageModel model = new GlusterStorageModel();
    model.setRole(storage.getStorageDomainType());
    model.getPath().setIsChangable(true);
    model.getVfsType().setIsChangable(false);
    model.getMountOptions().setIsChangable(false);
    AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            model.getPath().setEntity(connection.getconnection());
            model.getVfsType().setEntity(connection.getVfsType());
            model.getMountOptions().setEntity(connection.getMountOptions());
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private void postPrepareSanStorageForEdit(SanStorageModel model, boolean isStorageActive) {
    StorageModel storageModel = (StorageModel) getWindow();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    model.setStorageDomain(storage);
    VDS host = storageModel.getHost().getSelectedItem();
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    AsyncDataProvider.getLunsByVgId(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SanStorageModel sanStorageModel = (SanStorageModel) target;
            ArrayList<LUNs> lunList = (ArrayList<LUNs>) returnValue;
            sanStorageModel.applyData(lunList, true);
        }
    }, storageModel.getHash()), storage.getStorage(), hostId);
}
#method_after
private void postPrepareSanStorageForEdit(SanStorageModel model, boolean isStorageActive) {
    StorageModel storageModel = (StorageModel) getWindow();
    StorageDomain storage = (StorageDomain) getSelectedItem();
    model.setStorageDomain(storage);
    VDS host = storageModel.getHost().getSelectedItem();
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    AsyncDataProvider.getInstance().getLunsByVgId(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SanStorageModel sanStorageModel = (SanStorageModel) target;
            ArrayList<LUNs> lunList = (ArrayList<LUNs>) returnValue;
            sanStorageModel.applyData(lunList, true);
        }
    }, storageModel.getHash()), storage.getStorage(), hostId);
}
#end_block

#method_before
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    List<IStorageModel> items = AsyncDataProvider.getIsoStorageModels();
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    List<IStorageModel> items = AsyncDataProvider.getInstance().getIsoStorageModels();
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#method_after
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType().isIsoOrImportExportDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType().isIsoOrImportExportDomain());
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        updateStorageDomain();
    }
}
#method_after
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void importFileStoragePostInit() {
    // Check storage domain existence
    AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setconnection(storageListModel.path);
                tempVar.setstorage_type(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (nfsModel.getOverride().getEntity()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                storageListModel.importFileStorageConnect();
            }
        }
    }), null, path);
}
#method_after
public void importFileStoragePostInit() {
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setconnection(storageListModel.path);
                tempVar.setstorage_type(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (nfsModel.getOverride().getEntity()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                storageListModel.importFileStorageConnect();
            }
        }
    }), null, path);
}
#end_block

#method_before
public void importFileStorageConnect() {
    Frontend.getInstance().runAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                storageListModel.fileConnection.setid((String) returnVal.getActionReturnValue());
                AsyncDataProvider.getExistingStorageDomainList(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        StorageListModel storageListModel1 = (StorageListModel) target;
                        ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) returnValue;
                        if (domains != null && !domains.isEmpty()) {
                            storageListModel1.importFileStorageAddDomain(domains);
                        } else {
                            String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                            postImportFileStorage(storageListModel1.context, false, storageListModel1.storageModel, errorMessage);
                            storageListModel1.cleanConnection(storageListModel1.fileConnection, storageListModel1.hostId);
                        }
                    }
                }), hostId, domainType, storageType, path);
            } else {
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg());
            }
        }
    }, this);
}
#method_after
public void importFileStorageConnect() {
    Frontend.getInstance().runAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                storageListModel.fileConnection.setid((String) returnVal.getActionReturnValue());
                AsyncDataProvider.getInstance().getExistingStorageDomainList(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        StorageListModel storageListModel1 = (StorageListModel) target;
                        ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) returnValue;
                        if (domains != null && !domains.isEmpty()) {
                            storageListModel1.importFileStorageAddDomain(domains);
                        } else {
                            String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                            postImportFileStorage(storageListModel1.context, false, storageListModel1.storageModel, errorMessage);
                            storageListModel1.cleanConnection(storageListModel1.fileConnection, storageListModel1.hostId);
                        }
                    }
                }), hostId, domainType, storageType, path);
            } else {
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg());
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected void openReport() {
    final ReportModel reportModel = super.createReportModel();
    List<StorageDomain> items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList<StorageDomain>();
    StorageDomain storage = items.iterator().next();
    AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StoragePool> dataCenters = (List<StoragePool>) returnValue;
            for (StoragePool dataCenter : dataCenters) {
                reportModel.addDataCenterID(dataCenter.getId().toString());
            }
            if (reportModel == null) {
                return;
            }
            setWidgetModel(reportModel);
        }
    }), storage.getId());
}
#method_after
@Override
protected void openReport() {
    final ReportModel reportModel = super.createReportModel();
    List<StorageDomain> items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList<StorageDomain>();
    StorageDomain storage = items.iterator().next();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StoragePool> dataCenters = (List<StoragePool>) returnValue;
            for (StoragePool dataCenter : dataCenters) {
                reportModel.addDataCenterID(dataCenter.getId().toString());
            }
            if (reportModel == null) {
                return;
            }
            setWidgetModel(reportModel);
        }
    }), storage.getId());
}
#end_block

#method_before
public void initStorageQosList(Guid dataCenterId) {
    if (dataCenterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dataCenterId, QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageQos> qosList = returnValue == null ? new ArrayList<StorageQos>() : (List<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            qosList.add(0, EMPTY_QOS);
            getQos().setItems(qosList);
            if (defaultQosId != null) {
                for (StorageQos storageQos : qosList) {
                    if (defaultQosId.equals(storageQos.getId())) {
                        getQos().setSelectedItem(storageQos);
                        break;
                    }
                }
            }
        }
    }));
}
#method_after
public void initStorageQosList(Guid dataCenterId) {
    if (dataCenterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dataCenterId, QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            DiskProfileBaseModel.this.initQosList(returnValue == null ? new ArrayList<StorageQos>() : (List<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    return getName().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new SpecialAsciiI18NOrNoneValidation() });
    return getName().getIsValid();
}
#end_block

#method_before
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewDiskProfileModel model = new NewDiskProfileModel(this, getCompatibilityVersion(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#method_after
public void newProfile() {
    if (getWindow() != null) {
        return;
    }
    NewDiskProfileModel model = new NewDiskProfileModel(this, getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#end_block

#method_before
public void edit() {
    if (getWindow() != null) {
        return;
    }
    EditDiskProfileModel model = new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#method_after
public void edit() {
    if (getWindow() != null) {
        return;
    }
    EditDiskProfileModel model = new EditDiskProfileModel(this, (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId());
    setWindow(model);
    initProfileStorageDomains(model);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskProfileModel model = new RemoveDiskProfileModel(this, getSelectedItems(), false);
    setWindow(model);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskProfileModel model = new RemoveDiskProfileModel(this, getSelectedItems());
    setWindow(model);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(getEntity().getStoragePoolId(), QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageQos> qosList = (ArrayList<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            qosMap = new HashMap<Guid, StorageQos>();
            if (qosList != null) {
                for (StorageQos storageQos : qosList) {
                    qosMap.put(storageQos.getId(), storageQos);
                }
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(DiskProfileListModel.this.getEntity().getId()), new AsyncQuery(new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object returnValue1) {
                    DiskProfileListModel.this.setItems((List<DiskProfile>) ((VdcQueryReturnValue) returnValue1).getReturnValue());
                }
            }));
        }
    }));
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    Guid dcId = getEntity().getStoragePoolId();
    if (dcId == null) {
        // not attached to data center
        fetchDiskProfiles();
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.STORAGE), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<StorageQos> qosList = (ArrayList<StorageQos>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                qosMap = new HashMap<Guid, StorageQos>();
                if (qosList != null) {
                    for (StorageQos storageQos : qosList) {
                        qosMap.put(storageQos.getId(), storageQos);
                    }
                }
                fetchDiskProfiles();
            }
        }));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage qos
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
protected Guid getEntityGuid() {
    return AsyncDataProvider.getEntityGuid(getEntity());
}
#method_after
protected Guid getEntityGuid() {
    return AsyncDataProvider.getInstance().getEntityGuid(getEntity());
}
#end_block

#method_before
private void onRemove() {
    if (getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DiskProfile profile : getProfiles()) {
        VdcActionParametersBase parameters = getRemoveDiskProfileParams(profile);
        list.add(parameters);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveDiskProfile, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            cancel();
        }
    }, null);
}
#method_after
private void onRemove() {
    if (getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> vdcActionParametersBaseList = new ArrayList<VdcActionParametersBase>();
    for (DiskProfile profile : getProfiles()) {
        VdcActionParametersBase parameters = getRemoveDiskProfileParams(profile);
        vdcActionParametersBaseList.add(parameters);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveDiskProfile, vdcActionParametersBaseList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            cancel();
        }
    }, null);
}
#end_block

#method_before
public void remove() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = getRemoveQosModel();
    setConfirmWindow(model);
}
#method_after
public void remove() {
    if (getConfirmWindow() != null) {
        return;
    }
    setConfirmWindow(getRemoveQosModel());
}
#end_block

#method_before
public void edit() {
    final T qos = (T) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final EditQosModel<T, P> qosModel = getEditQosModel(qos);
    setWindow(qosModel);
    qosModel.getDataCenters().setItems(Arrays.asList(getEntity()));
    qosModel.getDataCenters().setSelectedItem(getEntity());
}
#method_after
public void edit() {
    T qos = (T) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final EditQosModel<T, P> qosModel = getEditQosModel(qos);
    setWindow(qosModel);
    qosModel.getDataCenters().setItems(Arrays.asList(getEntity()), getEntity());
}
#end_block

#method_before
public void newQos() {
    if (getWindow() != null) {
        return;
    }
    final NewQosModel<T, P> newQosModel = getNewQosModel();
    setWindow(newQosModel);
    newQosModel.getDataCenters().setItems(Arrays.asList(getEntity()));
    newQosModel.getDataCenters().setSelectedItem(getEntity());
}
#method_after
public void newQos() {
    if (getWindow() != null) {
        return;
    }
    final NewQosModel<T, P> newQosModel = getNewQosModel();
    setWindow(newQosModel);
    newQosModel.getDataCenters().setItems(Arrays.asList(getEntity()), getEntity());
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            // $NON-NLS-1$
            return object.getName() == null ? "" : object.getName();
        }
    }, constants.storageQosName(), // $NON-NLS-1$
    "200px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.storageQosDescription(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxThroughput().toString();
        }
    }, constants.storageQosThroughputTotal(), // $NON-NLS-1$
    "105px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxReadThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxReadThroughput().toString();
        }
    }, constants.storageQosThroughputRead(), // $NON-NLS-1$
    "105px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxWriteThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxWriteThroughput().toString();
        }
    }, constants.storageQosThroughputWrite(), // $NON-NLS-1$
    "105px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxIops() == null ? constants.UnlimitedStorageQos() : object.getMaxIops().toString();
        }
    }, constants.storageQosIopsTotal(), // $NON-NLS-1$
    "105px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxReadIops() == null ? constants.UnlimitedStorageQos() : object.getMaxReadIops().toString();
        }
    }, constants.storageQosIopsRead(), // $NON-NLS-1$
    "105px");
    getTable().addColumn(new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxWriteIops() == null ? constants.UnlimitedStorageQos() : object.getMaxWriteIops().toString();
        }
    }, constants.storageQosIopsWrite(), // $NON-NLS-1$
    "105px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.newStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.editStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.removeStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<StorageQos> nameColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            // $NON-NLS-1$
            return object.getName() == null ? "" : object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.storageQosName(), "200px");
    TextColumnWithTooltip<StorageQos> descColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.storageQosDescription(), "150px");
    TextColumnWithTooltip<StorageQos> throughputColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxThroughput().toString();
        }
    };
    throughputColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(throughputColumn, constants.storageQosThroughputTotal(), "105px");
    TextColumnWithTooltip<StorageQos> readThroughputColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxReadThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxReadThroughput().toString();
        }
    };
    readThroughputColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readThroughputColumn, constants.storageQosThroughputRead(), "105px");
    TextColumnWithTooltip<StorageQos> writeThroughputColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxWriteThroughput() == null ? constants.UnlimitedStorageQos() : object.getMaxWriteThroughput().toString();
        }
    };
    writeThroughputColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(writeThroughputColumn, constants.storageQosThroughputWrite(), "105px");
    TextColumnWithTooltip<StorageQos> iopsColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxIops() == null ? constants.UnlimitedStorageQos() : object.getMaxIops().toString();
        }
    };
    iopsColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(iopsColumn, constants.storageQosIopsTotal(), "105px");
    TextColumnWithTooltip<StorageQos> readIopsColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxReadIops() == null ? constants.UnlimitedStorageQos() : object.getMaxReadIops().toString();
        }
    };
    readIopsColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readIopsColumn, constants.storageQosIopsRead(), "105px");
    TextColumnWithTooltip<StorageQos> writeIopsColumn = new TextColumnWithTooltip<StorageQos>() {

        @Override
        public String getValue(StorageQos object) {
            return object.getMaxWriteIops() == null ? constants.UnlimitedStorageQos() : object.getMaxWriteIops().toString();
        }
    };
    writeIopsColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(writeIopsColumn, constants.storageQosIopsWrite(), "105px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.newStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.editStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageQos>(constants.removeStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    model.setAddMacPoolCommand(addMacPoolCommand);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    model.setAddMacPoolCommand(addMacPoolCommand);
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#method_after
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    dataCenter.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getForceRemoveCommand()) {
        forceRemove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRecoveryStorageCommand()) {
        recoveryStorage();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnForceRemove".equals(command.getName())) {
        onForceRemove();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRecover".equals(command.getName())) {
        onRecover();
    }
}
#method_after
@Override
public void executeCommand(UICommand command, Object... parameters) {
    super.executeCommand(command, parameters);
    if (command == getAddMacPoolCommand()) {
        addMacPool((DataCenterModel) parameters[0]);
    }
}
#end_block

#method_before
public boolean validate() {
    if (!getEnabled().getEntity()) {
        return true;
    }
    getTotal().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxTotal)) });
    getRead().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxRead)) });
    getWrite().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxWrite)) });
    setIsValid(getTotal().getIsValid() && getRead().getIsValid() && getWrite().getIsValid());
    return getIsValid();
}
#method_after
public boolean validate() {
    if (!getEnabled().getEntity()) {
        return true;
    }
    validateValue(getTotal(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxTotal));
    validateValue(getRead(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxRead));
    validateValue(getWrite(), (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(maxWrite));
    setIsValid(getTotal().getIsValid() && getRead().getIsValid() && getWrite().getIsValid());
    return getIsValid();
}
#end_block

#method_before
@Override
public String getHashName() {
    // $NON-NLS-1$
    return "edit_network_qos";
}
#method_after
@Override
public String getHashName() {
    // $NON-NLS-1$
    return "edit_storage_qos";
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    setIsValid(getIsValid() && getName().getIsValid());
    return getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    setIsValid(getIsValid() && getName().getIsValid() && getDescription().getIsValid());
    return getIsValid();
}
#end_block

#method_before
protected void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("OnSave", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar2.setIsDefault(true);
    getCommands().add(tempVar2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    getCommands().add(tempVar3);
}
#method_after
protected void addCommands() {
    getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("onRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getCommands().add(tempVar2);
}
#method_after
private void addCommands() {
    getCommands().add(// $NON-NLS-1$
    new UICommand("onRemove", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    getCommands().add(// $NON-NLS-1$
    new UICommand("cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage qos
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
@Override
public void edit(QosModel<StorageQos, StorageQosParametersModel> object) {
    qosWidget.edit(object.getQosParametersModel());
    driver.edit(object);
}
#method_after
@Override
public void edit(QosModel<StorageQos, StorageQosParametersModel> object) {
    driver.edit(object);
    qosWidget.edit(object.getQosParametersModel());
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<StoragePool, DataCenterListModel> getDataCenterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<DataCenterForceRemovePopupPresenterWidget> forceRemovePopupProvider) {
    return new MainTabModelProvider<StoragePool, DataCenterListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return forceRemovePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<StoragePool, DataCenterListModel> getDataCenterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<DataCenterForceRemovePopupPresenterWidget> forceRemovePopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider) {
    return new MainTabModelProvider<StoragePool, DataCenterListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return forceRemovePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                for (Guid vmId : _succededToRunVms) {
                    CpuQos qos = DbFacade.getInstance().getCpuQosDao().getCpuQosByVmId(vmId);
                    if (qos != null && qos.getCpuLimit() != null) {
                        getResourceManager().runVdsCommand(VDSCommandType.UpdateVmPolicy, new UpdateVmPolicyVDSParams(_vds.getId(), vmId, qos.getCpuLimit().intValue()));
                    }
                }
            }
        });
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        getVdsEventListener().updateSlaPolicies(_succededToRunVms, _vds.getId());
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            getVdsEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        getVdsEventListener().processOnVmStop(_vmsMovedToDown);
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device, deviceMap);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private static Guid getDeviceId(Map device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map device, Map<VmDeviceId, VmDevice> deviceMap) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    if (deviceId != null) {
        return new Guid(deviceId);
    }
    if (VdsProperties.VirtioSerial.equals(device.get(VdsProperties.Device))) {
        for (VmDevice dev : deviceMap.values()) {
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(dev.getDevice())) {
                return dev.getDeviceId();
            }
        }
    }
    return null;
}
#end_block

#method_before
protected void updateMemoryBalloon() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        boolean hasMemoryBalloon = (cluster.getcompatibility_version().compareTo(VmListModel.BALLOON_DEVICE_MIN_VERSION) >= 0 && cluster.getArchitecture().compareTo(VmListModel.BALLOON_DEVICE_BLACKLISTED_ARCH) != 0);
        getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(hasMemoryBalloon);
    }
}
#method_after
protected void updateMemoryBalloon() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        boolean hasMemoryBalloon = (cluster.getcompatibility_version().compareTo(VmListModel.BALLOON_DEVICE_MIN_VERSION) >= 0 && cluster.getArchitecture().equals(VmListModel.BALLOON_DEVICE_BLACKLISTED_ARCH));
        getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(hasMemoryBalloon);
    }
}
#end_block

#method_before
private void localize(ApplicationConstants constants, ApplicationDynamicMessages dynamicMessages) {
    userNameEditor.setLabel(constants.loginFormUserNameLabel());
    passwordEditor.setLabel(constants.loginFormPasswordLabel());
    domainEditor.setLabel(constants.loginFormProfileLabel());
    loginButton.setLabel(constants.loginButtonLabel());
}
#method_after
private void localize(ApplicationConstants constants, ApplicationDynamicMessages dynamicMessages) {
    userNameEditor.setLabel(constants.loginFormUserNameLabel());
    passwordEditor.setLabel(constants.loginFormPasswordLabel());
    profileEditor.setLabel(constants.loginFormProfileLabel());
    loginButton.setLabel(constants.loginButtonLabel());
}
#end_block

#method_before
void localize(ApplicationConstants constants, ApplicationDynamicMessages dynamicMessages) {
    userNameEditor.setLabel(constants.loginFormUserNameLabel());
    passwordEditor.setLabel(constants.loginFormPasswordLabel());
    domainEditor.setLabel(constants.loginFormProfileLabel());
    connectAutomaticallyEditor.setLabel(constants.loginFormConnectAutomaticallyLabel());
    loginButton.setLabel(constants.loginButtonLabel());
    motdHeaderLabel.setText(constants.motdHeaderLabel());
}
#method_after
void localize(ApplicationConstants constants, ApplicationDynamicMessages dynamicMessages) {
    userNameEditor.setLabel(constants.loginFormUserNameLabel());
    passwordEditor.setLabel(constants.loginFormPasswordLabel());
    profileEditor.setLabel(constants.loginFormProfileLabel());
    connectAutomaticallyEditor.setLabel(constants.loginFormConnectAutomaticallyLabel());
    loginButton.setLabel(constants.loginButtonLabel());
    motdHeaderLabel.setText(constants.motdHeaderLabel());
}
#end_block

#method_before
void initListBoxEditors() {
    timeZoneEditor = new ListModelListBoxEditor<Map.Entry<String, String>>(new NullSafeRenderer<Map.Entry<String, String>>() {

        @Override
        public String renderNullSafe(Map.Entry<String, String> object) {
            return object.getValue();
        }
    });
    windowsSysprepTimeZoneEditor = new ListModelListBoxEditor<Map.Entry<String, String>>(new NullSafeRenderer<Map.Entry<String, String>>() {

        @Override
        public String renderNullSafe(Map.Entry<String, String> object) {
            return object.getValue();
        }
    });
    networkBootProtocolEditor = new ListModelListBoxEditor<Map.Entry<String, NetworkBootProtocol>>(new NullSafeRenderer<Map.Entry<String, NetworkBootProtocol>>() {

        @Override
        protected String renderNullSafe(Map.Entry<String, NetworkBootProtocol> object) {
            return object.getKey();
        }
    });
}
#method_after
void initListBoxEditors() {
    timeZoneEditor = new ListModelListBoxEditor<Map.Entry<String, String>>(new NullSafeRenderer<Map.Entry<String, String>>() {

        @Override
        public String renderNullSafe(Map.Entry<String, String> object) {
            return object.getValue();
        }
    });
    windowsSysprepTimeZoneEditor = new ListModelListBoxEditor<Map.Entry<String, String>>(new NullSafeRenderer<Map.Entry<String, String>>() {

        @Override
        public String renderNullSafe(Map.Entry<String, String> object) {
            return object.getValue();
        }
    });
    networkBootProtocolEditor = new ListModelListBoxEditor<NetworkBootProtocol>(new EnumRenderer<NetworkBootProtocol>());
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkBootProtocolList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkBootProtocolList().getSelectedItem() == null || model.getNetworkBootProtocolList().getSelectedItem().getValue() == NetworkBootProtocol.STATIC_IP);
        }
    });
    model.getCloudInitPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args != null && args instanceof PropertyChangedEventArgs) {
                String propName = ((PropertyChangedEventArgs) args).propertyName;
                if ("IsChangable".equals(propName)) {
                    // $NON-NLS-1$
                    cloudInitPasswordSetEditor.setTitle(model.getCloudInitPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
                }
            }
        }
    });
    model.getSysprepPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args != null && args instanceof PropertyChangedEventArgs) {
                String propName = ((PropertyChangedEventArgs) args).propertyName;
                if ("IsChangable".equals(propName)) {
                    // $NON-NLS-1$
                    sysprepPasswordSetEditor.setTitle(model.getSysprepPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
                }
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkBootProtocolList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkBootProtocolList().getSelectedItem() != null && model.getNetworkBootProtocolList().getSelectedItem() == NetworkBootProtocol.STATIC_IP);
        }
    });
    model.getCloudInitPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args != null && args instanceof PropertyChangedEventArgs) {
                String propName = ((PropertyChangedEventArgs) args).propertyName;
                if ("IsChangable".equals(propName)) {
                    // $NON-NLS-1$
                    cloudInitPasswordSetEditor.setTitle(model.getCloudInitPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
                }
            }
        }
    });
    model.getSysprepPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args != null && args instanceof PropertyChangedEventArgs) {
                String propName = ((PropertyChangedEventArgs) args).propertyName;
                if ("IsChangable".equals(propName)) {
                    // $NON-NLS-1$
                    sysprepPasswordSetEditor.setTitle(model.getSysprepPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
                }
            }
        }
    });
}
#end_block

#method_before
public ListModel<Map.Entry<String, NetworkBootProtocol>> getNetworkBootProtocolList() {
    return privateNetworkBootProtocolList;
}
#method_after
public ListModel<NetworkBootProtocol> getNetworkBootProtocolList() {
    return networkBootProtocolList;
}
#end_block

#method_before
private void setNetworkBootProtocolList(ListModel<Map.Entry<String, NetworkBootProtocol>> value) {
    privateNetworkBootProtocolList = value;
}
#method_after
private void setNetworkBootProtocolList(ListModel<NetworkBootProtocol> value) {
    networkBootProtocolList = value;
}
#end_block

#method_before
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getCloudInitPasswordSet().setEntity(false);
    getCloudInitPasswordSet().setIsChangable(false);
    getSysprepPasswordSet().setEntity(false);
    getSysprepPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getSysprepOrgName().setEntity("");
    getInputLocale().setEntity("");
    getUiLanguage().setEntity("");
    getSystemLocale().setEntity("");
    getUserLocale().setEntity("");
    getSysprepScript().setEntity("");
    getHostname().setEntity("");
    getUserName().setEntity("");
    getCloudInitRootPassword().setEntity("");
    getCloudInitRootPasswordVerification().setEntity("");
    getSysprepAdminPassword().setEntity("");
    getSysprepAdminPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    getActiveDirectoryOU().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.getInstance().isWindowsOsType(vm.getOsId()) : true;
    Map<String, NetworkBootProtocol> networkBootProtocols = new HashMap<String, NetworkBootProtocol>();
    // $NON-NLS-1$
    networkBootProtocols.put("None", NetworkBootProtocol.NONE);
    // $NON-NLS-1$
    networkBootProtocols.put("DHCP", NetworkBootProtocol.DHCP);
    // $NON-NLS-1$
    networkBootProtocols.put("Static IP", NetworkBootProtocol.STATIC_IP);
    getNetworkBootProtocolList().setItems(networkBootProtocols.entrySet());
    getNetworkBootProtocolList().setSelectedItem(Linq.firstOrDefault(networkBootProtocols.entrySet(), new IPredicate<Map.Entry<String, NetworkBootProtocol>>() {

        @Override
        public boolean match(Map.Entry<String, NetworkBootProtocol> item) {
            return item.getValue() == NetworkBootProtocol.NONE;
        }
    }));
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getOrgName())) {
            getSysprepOrgName().setEntity(vmInit.getOrgName());
        }
        updateSysprepDomain(vmInit.getDomain());
        if (!StringHelper.isNullOrEmpty(vmInit.getInputLocale())) {
            getInputLocale().setEntity(vmInit.getInputLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUiLanguage())) {
            getUiLanguage().setEntity(vmInit.getUiLanguage());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getSystemLocale())) {
            getSystemLocale().setEntity(vmInit.getSystemLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserLocale())) {
            getUserLocale().setEntity(vmInit.getUserLocale());
        }
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.getInstance().isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserName())) {
            getUserName().setEntity(vmInit.getUserName());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getCloudInitRootPassword().setEntity(vmInit.getRootPassword());
            getCloudInitRootPasswordVerification().setEntity(vmInit.getRootPassword());
            getSysprepAdminPassword().setEntity(vmInit.getRootPassword());
            getSysprepAdminPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getCloudInitPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getCloudInitPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        getSysprepPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getSysprepPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            if (isWindowsOS) {
                getSysprepScript().setEntity(vmInit.getCustomScript());
            } else {
                getCustomScript().setEntity(vmInit.getCustomScript());
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getActiveDirectoryOU())) {
            getActiveDirectoryOU().setEntity(vmInit.getActiveDirectoryOU());
        }
        initNetworks(vmInit);
    }
}
#method_after
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getCloudInitPasswordSet().setEntity(false);
    getCloudInitPasswordSet().setIsChangable(false);
    getSysprepPasswordSet().setEntity(false);
    getSysprepPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getSysprepOrgName().setEntity("");
    getInputLocale().setEntity("");
    getUiLanguage().setEntity("");
    getSystemLocale().setEntity("");
    getUserLocale().setEntity("");
    getSysprepScript().setEntity("");
    getHostname().setEntity("");
    getUserName().setEntity("");
    getCloudInitRootPassword().setEntity("");
    getCloudInitRootPasswordVerification().setEntity("");
    getSysprepAdminPassword().setEntity("");
    getSysprepAdminPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    getActiveDirectoryOU().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.getInstance().isWindowsOsType(vm.getOsId()) : true;
    getNetworkBootProtocolList().setItems(Arrays.asList(NetworkBootProtocol.values()));
    getNetworkBootProtocolList().setSelectedItem(NetworkBootProtocol.NONE);
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getOrgName())) {
            getSysprepOrgName().setEntity(vmInit.getOrgName());
        }
        updateSysprepDomain(vmInit.getDomain());
        if (!StringHelper.isNullOrEmpty(vmInit.getInputLocale())) {
            getInputLocale().setEntity(vmInit.getInputLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUiLanguage())) {
            getUiLanguage().setEntity(vmInit.getUiLanguage());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getSystemLocale())) {
            getSystemLocale().setEntity(vmInit.getSystemLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserLocale())) {
            getUserLocale().setEntity(vmInit.getUserLocale());
        }
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.getInstance().isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserName())) {
            getUserName().setEntity(vmInit.getUserName());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getCloudInitRootPassword().setEntity(vmInit.getRootPassword());
            getCloudInitRootPasswordVerification().setEntity(vmInit.getRootPassword());
            getSysprepAdminPassword().setEntity(vmInit.getRootPassword());
            getSysprepAdminPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getCloudInitPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getCloudInitPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        getSysprepPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getSysprepPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            if (isWindowsOS) {
                getSysprepScript().setEntity(vmInit.getCustomScript());
            } else {
                getCustomScript().setEntity(vmInit.getCustomScript());
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getActiveDirectoryOU())) {
            getActiveDirectoryOU().setEntity(vmInit.getActiveDirectoryOU());
        }
        initNetworks(vmInit);
    }
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    getSysprepAdminPassword().setIsValid(true);
    getSysprepAdminPasswordVerification().setIsValid(true);
    getCloudInitRootPassword().setIsValid(true);
    getCloudInitRootPasswordVerification().setIsValid(true);
    if (this.isWindowsOS) {
        if (getSysprepPasswordEnabled()) {
            getSysprepAdminPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getSysprepAdminPassword().getEntity(), getSysprepAdminPasswordVerification().getEntity()) });
        }
    } else {
        if (getRootPasswordEnabled()) {
            getCloudInitRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getCloudInitRootPassword().getEntity(), getCloudInitRootPasswordVerification().getEntity()) });
        }
    }
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getSysprepDomain().setIsValid(true);
    if (getDomainEnabled()) {
        getSysprepDomain().setIsValid(new HostAddressValidation().validate(getSysprepDomain().getSelectedItem()).getSuccess());
    }
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getSysprepDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getCloudInitRootPassword().getIsValid() && getSysprepAdminPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    getSysprepAdminPassword().setIsValid(true);
    getSysprepAdminPasswordVerification().setIsValid(true);
    getCloudInitRootPassword().setIsValid(true);
    getCloudInitRootPasswordVerification().setIsValid(true);
    if (this.isWindowsOS) {
        if (getSysprepPasswordEnabled()) {
            getSysprepAdminPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getSysprepAdminPassword().getEntity(), getSysprepAdminPasswordVerification().getEntity()) });
        }
    } else {
        if (getRootPasswordEnabled()) {
            getCloudInitRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getCloudInitRootPassword().getEntity(), getCloudInitRootPasswordVerification().getEntity()) });
        }
    }
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getSysprepDomain().setIsValid(true);
    if (getDomainEnabled()) {
        getSysprepDomain().setIsValid(new HostAddressValidation().validate(getSysprepDomain().getSelectedItem()).getSuccess());
    }
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation(), new NotEmptyValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getSysprepDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getCloudInitRootPassword().getIsValid() && getSysprepAdminPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol(getNetworkBootProtocolList().getSelectedItem().getValue());
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol(getNetworkBootProtocolList().getSelectedItem());
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    final NetworkBootProtocol bootProtocol = ((obj == null || obj.getBootProtocol() == null) ? NetworkBootProtocol.NONE : obj.getBootProtocol());
    getNetworkBootProtocolList().setSelectedItem(Linq.firstOrDefault(getNetworkBootProtocolList().getItems(), new IPredicate<Map.Entry<String, NetworkBootProtocol>>() {

        @Override
        public boolean match(Map.Entry<String, NetworkBootProtocol> item) {
            return item.getValue() == bootProtocol;
        }
    }));
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    if (obj == null || obj.getBootProtocol() == null) {
        getNetworkBootProtocolList().setSelectedItem(NetworkBootProtocol.NONE);
    } else {
        getNetworkBootProtocolList().setSelectedItem(obj.getBootProtocol());
    }
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
@Mapping(from = IscsiBond.class, to = org.ovirt.engine.core.common.businessentities.IscsiBond.class)
public static org.ovirt.engine.core.common.businessentities.IscsiBond map(IscsiBond from, org.ovirt.engine.core.common.businessentities.IscsiBond to) {
    org.ovirt.engine.core.common.businessentities.IscsiBond iscsiBond = (to != null) ? to : new org.ovirt.engine.core.common.businessentities.IscsiBond();
    if (from.isSetName()) {
        iscsiBond.setName(from.getName());
    }
    if (from.isSetDescription()) {
        iscsiBond.setDescription(from.getDescription());
    }
    if (from.isSetConnectionId()) {
        iscsiBond.setStorageConnectionIds(from.getConnectionId());
    }
    if (from.isSetNetworkId()) {
        for (String id : from.getNetworkId()) {
            iscsiBond.getNetworkIds().add(Guid.createGuidFromString(id));
        }
    }
    return iscsiBond;
}
#method_after
@Mapping(from = IscsiBond.class, to = org.ovirt.engine.core.common.businessentities.IscsiBond.class)
public static org.ovirt.engine.core.common.businessentities.IscsiBond map(IscsiBond from, org.ovirt.engine.core.common.businessentities.IscsiBond to) {
    org.ovirt.engine.core.common.businessentities.IscsiBond iscsiBond = (to != null) ? to : new org.ovirt.engine.core.common.businessentities.IscsiBond();
    if (from.isSetId()) {
        iscsiBond.setId(Guid.createGuidFromString(from.getId()));
    }
    if (from.isSetDataCenter() && from.getDataCenter().isSetId()) {
        iscsiBond.setStoragePoolId(Guid.createGuidFromString(from.getDataCenter().getId()));
    }
    if (from.isSetName()) {
        iscsiBond.setName(from.getName());
    }
    if (from.isSetDescription()) {
        iscsiBond.setDescription(from.getDescription());
    }
    if (from.isSetStorageConnections()) {
        for (StorageConnection conn : from.getStorageConnections().getStorageConnections()) {
            iscsiBond.getStorageConnectionIds().add(conn.getId());
        }
    }
    if (from.isSetNetworks()) {
        for (Network network : from.getNetworks().getNetworks()) {
            iscsiBond.getNetworkIds().add(Guid.createGuidFromString(network.getId()));
        }
    }
    return iscsiBond;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.IscsiBond.class, to = IscsiBond.class)
public static IscsiBond map(org.ovirt.engine.core.common.businessentities.IscsiBond from, IscsiBond to) {
    IscsiBond iscsiBond = (to != null) ? to : new IscsiBond();
    iscsiBond.setName(from.getName());
    iscsiBond.setDescription(from.getDescription());
    if (from.getId() != null) {
        iscsiBond.setId(from.getId().toString());
    }
    for (String connectionId : from.getStorageConnectionIds()) {
        iscsiBond.getConnectionId().add(connectionId);
    }
    for (Guid networkId : from.getNetworkIds()) {
        iscsiBond.getNetworkId().add(networkId.toString());
    }
    return iscsiBond;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.IscsiBond.class, to = IscsiBond.class)
public static IscsiBond map(org.ovirt.engine.core.common.businessentities.IscsiBond from, IscsiBond to) {
    IscsiBond iscsiBond = (to != null) ? to : new IscsiBond();
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(from.getStoragePoolId().toString());
    iscsiBond.setDataCenter(dataCenter);
    iscsiBond.setName(from.getName());
    iscsiBond.setDescription(from.getDescription());
    if (from.getId() != null) {
        iscsiBond.setId(from.getId().toString());
    }
    Networks networks = new Networks();
    for (Guid id : from.getNetworkIds()) {
        Network network = new Network();
        network.setId(id.toString());
        networks.getNetworks().add(network);
    }
    iscsiBond.setNetworks(networks);
    StorageConnections connections = new StorageConnections();
    for (String id : from.getStorageConnectionIds()) {
        StorageConnection conn = new StorageConnection();
        conn.setId(id);
        connections.getStorageConnections().add(conn);
    }
    iscsiBond.setStorageConnections(connections);
    return iscsiBond;
}
#end_block

#method_before
public NetworksResource getNetworksResource() {
    return inject(new BackendDataCenterNetworksResource(id));
}
#method_after
@Override
public NetworksResource getNetworksResource() {
    return inject(new BackendDataCenterNetworksResource(id));
}
#end_block

#method_before
@Override
public IscsiBondsResource getIscsiBondsResource() {
    return inject(new BackendDataCenterIscsiBondsResource(id));
}
#method_after
@Override
public IscsiBondsResource getIscsiBondsResource() {
    return inject(new BackendIscsiBondsResource(id));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        String clusterName = cluster.getDataCenter().getName();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(clusterName), "Datacenter: name=" + clusterName);
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#method_after
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(DataCenter dataCenter, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (dataCenter.isSetId()) {
        String id = dataCenter.getId();
        Guid guid;
        try {
            // can't use asGuid() because the method is static.
            guid = new Guid(id);
        } catch (IllegalArgumentException e) {
            throw new MalformedIdException(e);
        }
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(guid), "Datacenter: id=" + id);
    } else {
        String clusterName = dataCenter.getName();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(clusterName), "Datacenter: name=" + clusterName);
        dataCenter.setId(pool.getId().toString());
    }
    return pool;
}
#end_block

#method_before
@Override
public IscsiBond update(IscsiBond iscsiBond) {
    // TODO
    return null;
}
#method_after
@Override
public IscsiBond update(IscsiBond iscsiBond) {
    return performUpdate(iscsiBond, new QueryIdResolver<Guid>(VdcQueryType.GetIscsiBondById, IdQueryParameters.class), VdcActionType.EditIscsiBond, new ParametersProvider<IscsiBond, org.ovirt.engine.core.common.businessentities.IscsiBond>() {

        @Override
        public VdcActionParametersBase getParameters(IscsiBond incoming, org.ovirt.engine.core.common.businessentities.IscsiBond entity) {
            return new EditIscsiBondParameters(getMapper(modelType, org.ovirt.engine.core.common.businessentities.IscsiBond.class).map(incoming, entity));
        }
    });
}
#end_block

#method_before
public static String combine(String head, String tail) {
    if (head.endsWith("/")) {
        head = head.substring(0, head.length() - 1);
    }
    if (tail.startsWith("/")) {
        tail = tail.substring(1);
    }
    return head + "/" + tail;
}
#method_after
public static String combine(String head, String tail) {
    return StringUtils.removeEnd(head, "/") + "/" + StringUtils.removeStart(tail, "/");
}
#end_block

#method_before
@Override
protected DataCenter deprecatedPopulate(DataCenter model, StoragePool entity) {
    IdQueryParameters parameters = new IdQueryParameters(new Guid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(List.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#method_after
@Override
protected DataCenter deprecatedPopulate(DataCenter model, StoragePool entity) {
    IdQueryParameters parameters = new IdQueryParameters(asGuid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(List.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getDiskProfileDao().getAllForQos(getParameters().getId()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getCpuProfileDao().getAllForQos(getParameters().getId()));
}
#end_block

#method_before
public ValidationResult profileIsSet() {
    return getProfile() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_PROFILE_NOT_EXISTS) : ValidationResult.VALID;
}
#method_after
public ValidationResult profileIsSet() {
    return getProfile() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_PROFILE_MISSING) : ValidationResult.VALID;
}
#end_block

#method_before
@Override
public ValidationResult parentEntityExists() {
    // TODO:
    return ValidationResult.VALID;
}
#method_after
@Override
public ValidationResult parentEntityExists() {
    if (DbFacade.getInstance().getVdsGroupDao().get(getProfile().getClusterId()) == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
public ValidationResult isParentEntityValid(Guid clusterId) {
    if (clusterId == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_CLUSTER_NOT_PROVIDED);
    }
    Guid id = getProfile().getId();
    if (id == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_EMPTY);
    }
    CpuProfile fetchedDiskProfile = getProfileDao().get(id);
    if (fetchedDiskProfile == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CPU_PROFILE_NOT_FOUND);
    }
    if (!clusterId.equals(fetchedDiskProfile.getClusterId())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_NOT_MATCH_CLUSTER);
    }
    return ValidationResult.VALID;
}
#method_after
@Override
public ValidationResult isParentEntityValid(Guid clusterId) {
    if (clusterId == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_CLUSTER_NOT_PROVIDED);
    }
    Guid id = getProfile().getId();
    if (id == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_EMPTY);
    }
    CpuProfile fetchedCpuProfile = getProfileDao().get(id);
    if (fetchedCpuProfile == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CPU_PROFILE_NOT_FOUND);
    }
    if (!clusterId.equals(fetchedCpuProfile.getClusterId())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_CPU_PROFILE_NOT_MATCH_CLUSTER);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void testGetEntityNameByIdAndTypeForCpuProfile() {
    CpuProfile cpuProfile = dbFacade.getCpuProfileDao().get(FixturesTool.CPU_PROFILE_1);
    assertNotNull(cpuProfile);
    String name = cpuProfile.getName();
    assertTrue(name.equals(dbFacade.getEntityNameByIdAndType(FixturesTool.CPU_PROFILE_1, VdcObjectType.CpuProfile)));
}
#method_after
@Test
public void testGetEntityNameByIdAndTypeForCpuProfile() {
    CpuProfile cpuProfile = dbFacade.getCpuProfileDao().get(FixturesTool.CPU_PROFILE_1);
    assertNotNull(cpuProfile);
    String name = cpuProfile.getName();
    assertEquals(name, dbFacade.getEntityNameByIdAndType(FixturesTool.CPU_PROFILE_1, VdcObjectType.CpuProfile));
}
#end_block

#method_before
public void setClusterId(Guid storageDomainId) {
    this.clusterId = storageDomainId;
}
#method_after
public void setClusterId(Guid clusterId) {
    this.clusterId = clusterId;
}
#end_block

#method_before
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new QosValidator<CpuQos>(qos) {

        @Override
        protected QosDao<CpuQos> getQosDao() {
            return AddCpuQosCommand.this.getQosDao();
        }

        @Override
        public ValidationResult allValuesPresent() {
            // TODO: implement
            return ValidationResult.VALID;
        }
    };
}
#method_after
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new CpuQosValidator(qos);
}
#end_block

#method_before
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new QosValidator<CpuQos>(qos) {

        @Override
        protected QosDao<CpuQos> getQosDao() {
            return RemoveCpuQosCommand.this.getQosDao();
        }

        @Override
        public ValidationResult allValuesPresent() {
            // TODO impl
            return ValidationResult.VALID;
        }
    };
}
#method_after
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new CpuQosValidator(qos);
}
#end_block

#method_before
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        qosType = QosType.STORAGE;
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        case CPU:
            qosDao = getDbFacade().getCpuQosDao();
            break;
        default:
            break;
    }
    return qosDao;
}
#method_after
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        return getDbFacade().getQosBaseDao();
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        case CPU:
            qosDao = getDbFacade().getCpuQosDao();
            break;
        default:
            log.debugFormat("Not handled QoS type: {0}", qosType);
            break;
    }
    return qosDao;
}
#end_block

#method_before
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new QosValidator<CpuQos>(qos) {

        @Override
        protected QosDao<CpuQos> getQosDao() {
            return UpdateCpuQosCommand.this.getQosDao();
        }

        @Override
        public ValidationResult allValuesPresent() {
            // TODO: implement
            return ValidationResult.VALID;
        }
    };
}
#method_after
@Override
protected QosValidator<CpuQos> getQosValidator(CpuQos qos) {
    return new CpuQosValidator(qos);
}
#end_block

#method_before
public static boolean setupManagementNetwork(Version version) {
    return supportedInConfig(ConfigValues.NormalizedMgmgNetworkEnabled, version);
}
#method_after
public static boolean setupManagementNetwork(Version version) {
    return supportedInConfig(ConfigValues.NormalizedMgmtNetworkEnabled, version);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    HashMap<String, List<String>> namespacesMap = new HashMap<>();
    for (ExtensionProxy authz : EngineExtensionsManager.getInstance().getExtensionsByService(Authz.class.getName())) {
        for (String namespace : authz.getContext().get(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList("*"))) {
            MultiValueMapUtils.addToMap(AuthzUtils.getName(authz), namespace, namespacesMap);
        }
    }
    for (Entry<String, List<String>> entry : namespacesMap.entrySet()) {
        Collections.sort(entry.getValue());
    }
    setReturnValue(namespacesMap);
}
#method_after
@Override
protected void executeQueryCommand() {
    HashMap<String, List<String>> namespacesMap = new HashMap<>();
    for (ExtensionProxy authz : EngineExtensionsManager.getInstance().getExtensionsByService(Authz.class.getName())) {
        for (String namespace : authz.getContext().get(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList("*"))) {
            MultiValueMapUtils.addToMap(AuthzUtils.getName(authz), namespace, namespacesMap);
        }
    }
    for (List<String> entry : namespacesMap.values()) {
        Collections.sort(entry);
    }
    setReturnValue(namespacesMap);
}
#end_block

#method_before
@Override
public boolean equalValues(BaseQos obj) {
    if (this == obj)
        return true;
    if (getClass() != obj.getClass())
        return false;
    CpuQos other = (CpuQos) obj;
    if (cpuLimit == null) {
        if (other.cpuLimit != null)
            return false;
    } else if (!cpuLimit.equals(other.cpuLimit))
        return false;
    return true;
}
#method_after
@Override
public boolean equalValues(QosBase obj) {
    if (!(obj instanceof CpuQos)) {
        return false;
    }
    CpuQos other = (CpuQos) obj;
    return ObjectUtils.objectsEqual(cpuLimit, other.getCpuLimit());
}
#end_block

#method_before
@Override
public String getString() {
    StringBuilder builder = new StringBuilder();
    builder.append("CpuQos [cpuLimit=");
    builder.append(cpuLimit);
    builder.append("]");
    return builder.toString();
}
#method_after
@Override
public String getString() {
    StringBuilder builder = new StringBuilder();
    builder.append("[").append("cpu limit=").append(cpuLimit).append("]");
    return builder.toString();
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                Map<String, Integer> ioTune = buildIoTune(diskImage);
                if (ioTune != null) {
                    if (vmDevice.getSpecParams() != null) {
                        vmDevice.setSpecParams(new HashMap<String, Object>());
                    }
                    vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Integer>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
                    Map<String, Integer> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    if (ioTune != null) {
                        if (vmDevice.getSpecParams() == null) {
                            vmDevice.setSpecParams(new HashMap<String, Object>());
                        }
                        vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                    }
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
private Map<String, Integer> buildIoTune(DiskImage diskImage) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getByDiskProfile(diskProfileId);
    if (storageQos == null) {
        return null;
    }
    // build map
    Map<String, Integer> ioTuneMap = new HashMap<>();
    if (storageQos.getMaxThroughput() != null) {
        ioTuneMap.put(VdsProperties.TotalBytesSec, storageQos.getMaxThroughput());
    }
    if (storageQos.getMaxReadThroughput() != null) {
        ioTuneMap.put(VdsProperties.ReadBytesSec, storageQos.getMaxReadThroughput());
    }
    if (storageQos.getMaxWriteThroughput() != null) {
        ioTuneMap.put(VdsProperties.WriteBytesSec, storageQos.getMaxWriteThroughput());
    }
    if (storageQos.getMaxIops() != null) {
        ioTuneMap.put(VdsProperties.TotalIopsSec, storageQos.getMaxIops());
    }
    if (storageQos.getMaxReadIops() != null) {
        ioTuneMap.put(VdsProperties.ReadIopsSec, storageQos.getMaxReadIops());
    }
    if (storageQos.getMaxWriteIops() != null) {
        ioTuneMap.put(VdsProperties.WriteIopsSec, storageQos.getMaxWriteIops());
    }
    // return map with values
    if (ioTuneMap.size() > 0) {
        return ioTuneMap;
    }
    return null;
}
#method_after
private Map<String, Integer> buildIoTune(DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Integer>> storageQosIoTuneMap) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    Guid storageQosId = diskProfileStorageQosMap.get(diskProfileId);
    if (storageQosId == null) {
        StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getQosByDiskProfileId(diskProfileId);
        if (storageQos == null) {
            return null;
        }
        storageQosId = storageQos.getId();
        diskProfileStorageQosMap.put(diskProfileId, storageQosId);
        storageQosIoTuneMap.put(storageQosId, buildIoTuneMap(storageQos));
    }
    Map<String, Integer> ioTuneMap = storageQosIoTuneMap.get(storageQosId);
    // return map with values
    if (!ioTuneMap.isEmpty()) {
        return ioTuneMap;
    }
    return null;
}
#end_block

#method_before
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<String, String>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (vmDevices.size() > 0) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#method_after
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<String, String>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#end_block

#method_before
private static void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
    if (addressMap.size() > 0) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#method_after
private static void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
    if (!addressMap.isEmpty()) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#end_block

#method_before
private void addMemBalloonDevice(VmDevice vmDevice) {
    Map<String, Object> struct = new HashMap<String, Object>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    Map<String, Object> specParams = vmDevice.getSpecParams();
    // validate & set spec params for balloon device
    if (specParams == null) {
        specParams = new HashMap<String, Object>();
        vmDevice.setSpecParams(specParams);
    }
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    addDevice(struct, vmDevice, null);
}
#method_after
private void addMemBalloonDevice(VmDevice vmDevice) {
    Map<String, Object> struct = new HashMap<String, Object>();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    Map<String, Object> specParams = vmDevice.getSpecParams();
    // validate & set spec params for balloon device
    if (specParams == null) {
        specParams = new HashMap<String, Object>();
        vmDevice.setSpecParams(specParams);
    }
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    addAddress(vmDevice, struct);
    addDevice(struct, vmDevice, null);
}
#end_block

#method_before
@Override
protected void buildVmRngDevice() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.RNG.getValue());
        struct.put(VdsProperties.Model, VdsProperties.Virtio);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        addDevice(struct, vmDevice, null);
    }
}
#method_after
protected void buildVmRngDevice() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.RNG.getValue());
        struct.put(VdsProperties.Model, VdsProperties.Virtio);
        struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
@Test
public void testGetAllForStorageEmpty() {
    List<DiskProfile> result = dao.getAllForStorageDomain(Guid.newGuid(), null, false);
    assertNotNull(result);
    assertTrue(result.isEmpty());
}
#method_after
@Test
public void testGetAllForStorageEmpty() {
    List<DiskProfile> result = dao.getAllForStorageDomain(Guid.newGuid());
    assertNotNull(result);
    assertTrue(result.isEmpty());
}
#end_block

#method_before
@Test
public void testGetAllForStorageDomainFull() {
    List<DiskProfile> result = dao.getAllForStorageDomain(FixturesTool.STORAGE_DOAMIN_SCALE_SD5, null, false);
    assertNotNull(result);
    assertEquals(2, result.size());
    for (DiskProfile diskProfile : result) {
        assertEquals(FixturesTool.STORAGE_DOAMIN_SCALE_SD5, diskProfile.getStorageDomainId());
    }
}
#method_after
@Test
public void testGetAllForStorageDomainFull() {
    checkResults(dao.getAllForStorageDomain(FixturesTool.STORAGE_DOAMIN_SCALE_SD5));
}
#end_block

#method_before
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpace = 1073741824;
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(lotsOfSpace);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpace = 1073741824;
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(lotsOfSpace);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(final int diskSpaceRequired) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, diskSpaceRequired);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(createParameters()));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    return cmd;
}
#method_after
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(final int diskSpaceRequired) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, diskSpaceRequired);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(createParameters()));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    doReturn(macPoolManagerStrategy).when(cmd).getMacPool();
    return cmd;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    for (final DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
            diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
        }
        if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(diskImage.getStorageIds().get(0)))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params);
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#method_after
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && validate(diskValidator.areBootableAndSharableCompatibleWithDisk()) && setAndValidateDiskProfiles();
}
#end_block

#method_before
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                diskImage.setDiskProfileId(((DiskImage) getNewDisk()).getDiskProfileId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile(diskImage);
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
protected void updateDiskProfile(DiskImage diskImage) {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), diskImage.getDiskProfileId())) {
            getImageStorageDomainMapDao().updateDiskProfileForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getDiskProfileIds().get(0));
        }
    }
}
#method_after
protected void updateDiskProfile() {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        DiskImage newDisk = (DiskImage) getNewDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), newDisk.getDiskProfileId())) {
            getImageStorageDomainMapDao().updateDiskProfileByImageGroupIdAndStorageDomainId(newDisk.getId(), newDisk.getStorageIds().get(0), newDisk.getDiskProfileId());
        }
    }
}
#end_block

#method_before
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = getBackend().runInternalAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (ret.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    } else {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#method_after
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (ret.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    } else {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#method_after
@Override
protected void endSuccessfully() {
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addCanDoActionMessage(String.format("$VmsName %1$s", StringUtils.join(vmsWithBoot.toArray(), ", ")));
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addCanDoActionMessageVariable("VmsName", StringUtils.join(vmsWithBoot.toArray(), ", "));
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void endInternalCommandWithFailure() {
    ExtendImageSizeParameters params = createExtendImageSizeParameters();
    params.setTaskGroupSuccess(false);
    getBackend().endAction(VdcActionType.ExtendImageSize, params);
}
#method_after
private void endInternalCommandWithFailure() {
    ExtendImageSizeParameters params = createExtendImageSizeParameters();
    params.setTaskGroupSuccess(false);
    getBackend().endAction(VdcActionType.ExtendImageSize, params, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    if (isDiskImage()) {
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        if (!validate(new DiskProfileValidator(newDiskImage.getDiskProfileId()).isStorageDomainValid(newDiskImage.getStorageIds().get(0)))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
private boolean updateDiskParametersRequiringVmDownRequested() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription());
}
#method_after
private boolean updateDiskParametersRequiringVmDownRequested() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.areBootableAndSharableCompatibleWithDisk())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!setAndValidateDiskProfiles()) {
            return false;
        }
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    return validate(new DiskProfileValidator(getDiskProfileId()).isStorageDomainValid(getStorageDomainId()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getDiskImageInfo(), getStorageDomainId()), getStoragePool().getcompatibility_version()));
}
#end_block

#method_before
private List<DiskImage> getAllImageSnapshots() {
    return ImagesHandler.getAllImageSnapshots(getImage().getImageId(), getImage().getImageTemplateId());
}
#method_after
protected List<DiskImage> getAllImageSnapshots() {
    return ImagesHandler.getAllImageSnapshots(getImage().getImageId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), getParameters());
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void endCommandActions() {
    getBackend().endAction(getImagesActionType(), getParameters());
    setSucceeded(true);
}
#method_after
private void endCommandActions() {
    getBackend().endAction(getImagesActionType(), getParameters(), getContext().clone().withoutCompensationContext().withoutLock());
    setSucceeded(true);
}
#end_block

#method_before
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(true);
    } else {
        getParameters().setUseCopyCollapse(false);
    }
    getParameters().setDestinationImageId(getImageId());
    getParameters().setImageGroupID(getImageGroupId());
    getParameters().setDestImageGroupId(getImageGroupId());
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
}
#method_after
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(true);
    } else {
        getParameters().setUseCopyCollapse(false);
    }
    getParameters().setDestinationImageId(getImageId());
    getParameters().setImageGroupID(getImageGroupId());
    getParameters().setDestImageGroupId(getImageGroupId());
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    getParameters().setDiskProfileId(getImage().getDiskProfileId());
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    return validate(new DiskProfileValidator(getParameters().getDiskProfileId()).isStorageDomainValid(getParameters().getStorageDomainId()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    getImage().setDiskProfileId(getParameters().getDiskProfileId());
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getImage(), getParameters().getStorageDomainId()), getStoragePool().getcompatibility_version()));
}
#end_block

#method_before
public ValidationResult diskProfileExists() {
    return getOldDiskProfile() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_PROFILE_NOT_EXISTS) : ValidationResult.VALID;
}
#method_after
public ValidationResult diskProfileExists() {
    return getDiskProfileFromDb() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_PROFILE_NOT_EXISTS) : ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult qosExistsOrNull() {
    return getDiskProfile().getQosId() == null || getDbFacade().getQosDao().get(getDiskProfile().getQosId()) != null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_QOS_NOT_EXISTS);
}
#method_after
public ValidationResult qosExistsOrNull() {
    return getDiskProfile().getQosId() == null || getDbFacade().getStorageQosDao().get(getDiskProfile().getQosId()) != null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_QOS_NOT_FOUND);
}
#end_block

#method_before
public ValidationResult storageDomainNotChanged() {
    if (ObjectUtils.equals(getDiskProfile().getStorageDomainId(), getOldDiskProfile().getStorageDomainId())) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_PROFILE);
}
#method_after
public ValidationResult storageDomainNotChanged() {
    if (ObjectUtils.equals(getDiskProfile().getStorageDomainId(), getDiskProfileFromDb().getStorageDomainId())) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_PROFILE);
}
#end_block

#method_before
public ValidationResult isStorageDomainValid(Guid storageDomainId) {
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_PROFILE_STORAGE_DOMAIN_NOT_PROVIDED);
    }
    if (!storageDomainId.equals(getDiskProfileDao().get(diskProfileId).getStorageDomainId())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_PROFILE_NOT_MATCH_STORAGE_DOMAIN);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isStorageDomainValid(Guid storageDomainId) {
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_PROFILE_STORAGE_DOMAIN_NOT_PROVIDED);
    }
    if (diskProfileId == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_PROFILE_EMPTY);
    }
    DiskProfile fetchedDiskProfile = getDiskProfileDao().get(diskProfileId);
    if (fetchedDiskProfile == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_PROFILE_NOT_FOUND);
    }
    if (!storageDomainId.equals(fetchedDiskProfile.getStorageDomainId())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_PROFILE_NOT_MATCH_STORAGE_DOMAIN);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    ejbRule.mockResource(ContainerManagedResourceType.TRANSACTION_MANAGER, new DummyTransactionManager());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#end_block

#method_before
private DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskImageGuid);
    disk.setSize(100000L);
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setStorageIds(new ArrayList<>(Collections.singleton(sdId)));
    disk.setStoragePoolId(spId);
    return disk;
}
#method_after
private DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskImageGuid);
    disk.setSize(100000L);
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setStorageIds(new ArrayList<>(Collections.singleton(sdId)));
    disk.setStoragePoolId(spId);
    disk.setDescription(RandomUtils.instance().nextString(10));
    return disk;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Currently this only supports importing images and does not work with luns.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE) {
        addCanDoActionMessage("$diskId " + getParameters().getDiskImage().getId());
        addCanDoActionMessage("$storageType " + getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        addCanDoActionMessage("$diskId " + getParameters().getDiskImage().getId());
        addCanDoActionMessage("$domainId " + getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        addCanDoActionMessage("$domainId " + getParameters().getStorageDomainId());
        addCanDoActionMessage("$domainType " + getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Currently this only supports importing images and does not work with luns.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("storageType", getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("domainId", getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        addCanDoActionMessageVariable("domainId", getParameters().getStorageDomainId());
        addCanDoActionMessageVariable("domainType", getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    return validate(new DiskProfileValidator(getParameters().getDiskImage().getDiskProfileId()).isStorageDomainValid(getStorageDomainId()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(Collections.singletonMap(getParameters().getDiskImage(), getStorageDomainId()), getStoragePool().getcompatibility_version()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (retVal && !setAndValidateDiskProfiles()) {
        return false;
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (retVal && !setAndValidateDiskProfiles()) {
        return false;
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
                Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getVolumeType());
                tempVar.setVolumeFormat(disk.getVolumeFormat());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(getParameters().getForceOverride());
                tempVar.setImportEntity(true);
                tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
                tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (originalDiskId.equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
                Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getVolumeType());
                tempVar.setVolumeFormat(disk.getVolumeFormat());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(getParameters().getForceOverride());
                tempVar.setImportEntity(true);
                tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
                tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (originalDiskId.equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    if (getParameters().getVmTemplate().getDiskList() != null) {
        for (final DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
            if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
                diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
            }
            if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(imageToDestinationDomainMap.get(diskImage.getId())))) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVmTemplate().getDiskList() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
            map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().get(parameters.getImageId());
        if (diskImage != null) {
            permissionList.add(new PermissionSubject(diskImage.getId(), VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        }
        permissionList.add(new PermissionSubject(parameters.getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().get(parameters.getImageId());
        if (diskImage != null) {
            permissionList.add(new PermissionSubject(diskImage.getId(), VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        }
        permissionList.add(new PermissionSubject(parameters.getTargetStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return permissionList;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
            diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
        }
        if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(diskImage.getStorageIds().get(0)))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        list.add(new QuotaStorageConsumptionParameter(parameters.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, parameters.getStorageDomainId(), (double) diskImage.getSizeInGigabytes()));
        if (diskImage.getQuotaId() != null && !Guid.Empty.equals(diskImage.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, parameters.getSourceDomainId(), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        list.add(new QuotaStorageConsumptionParameter(parameters.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, parameters.getTargetStorageDomainId(), (double) diskImage.getSizeInGigabytes()));
        if (diskImage.getQuotaId() != null && !Guid.Empty.equals(diskImage.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, parameters.getSourceDomainId(), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !isValidSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean performStorageDomainsChecks(LiveMigrateDiskParameters parameters) {
    StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
    StorageDomain destDomain = getStorageDomainById(parameters.getStorageDomainId(), getStoragePoolId());
    return validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain) && validateDestStorageAndSourceStorageOfSameTypes(destDomain, sourceDomain);
}
#method_after
private boolean performStorageDomainsChecks(LiveMigrateDiskParameters parameters) {
    StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
    StorageDomain destDomain = getStorageDomainById(parameters.getTargetStorageDomainId(), getStoragePoolId());
    return validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain) && validateDestStorageAndSourceStorageOfSameTypes(destDomain, sourceDomain);
}
#end_block

#method_before
private boolean isSameSourceAndDest(LiveMigrateDiskParameters parameters) {
    StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
    if (sourceDomain.getId().equals(parameters.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SOURCE_AND_TARGET_SAME);
    }
    return true;
}
#method_after
private boolean isSameSourceAndDest(LiveMigrateDiskParameters parameters) {
    if (parameters.getSourceStorageDomainId().equals(parameters.getTargetStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SOURCE_AND_TARGET_SAME);
    }
    return true;
}
#end_block

#method_before
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", diskImage.getDiskAlias()));
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#method_after
private boolean isDiskNotShareable(Guid imageId) {
    DiskImage diskImage = getDiskImageByImageId(imageId);
    if (diskImage.isShareable()) {
        addCanDoActionMessageVariable("diskAliases", diskImage.getDiskAlias());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    for (final DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
            diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
        }
        if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(diskImage.getStorageIds().get(0)))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPool());
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmDisksSource.getId(), VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(vmDisksSource.getId(), getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = new CommandContext(ctx);
    } catch (RuntimeException e) {
        log.errorFormat("Failed to create command context of adding VM {0} to Pool {1}", currentVmName, getParameters().getVmPool().getName(), e);
    }
    return commandCtx;
}
#method_after
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContextAndDetachFromParent().withExecutionContext(ctx);
    } catch (RuntimeException e) {
        log.errorFormat("Failed to create command context of adding VM {0} to Pool {1}", currentVmName, getParameters().getVmPool().getName(), e);
    }
    return commandCtx;
}
#end_block

#method_before
protected boolean verifyAddVM() {
    return VmHandler.verifyAddVm(getReturnValue().getCanDoActionMessages(), getParameters().getVmsCount() * getVmNicDao().getAllForTemplate(getVmTemplateId()).size(), getParameters().getVmStaticData().getPriority());
}
#method_after
protected boolean verifyAddVM() {
    final List<String> reasons = getReturnValue().getCanDoActionMessages();
    final int nicsCount = getParameters().getVmsCount() * getVmNicDao().getAllForTemplate(getVmTemplateId()).size();
    final int priority = getParameters().getVmStaticData().getPriority();
    return VmHandler.verifyAddVm(reasons, nicsCount, priority, getMacPool());
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    if (diskInfoDestinationMap != null) {
        for (final DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
                diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
            }
            if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(diskImage.getStorageIds().get(0)))) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
private void initSpyCommand() {
    command = spy(new LiveMigrateVmDisksCommand<LiveMigrateVmDisksParameters>(new LiveMigrateVmDisksParameters(new ArrayList<LiveMigrateDiskParameters>(), vmId)));
    doReturn(true).when(command).isValidSpaceRequirements();
    doReturn(true).when(command).checkImagesStatus();
    doReturn(true).when(command).setAndValidateDiskProfiles();
}
#method_after
private void initSpyCommand() {
    command = spy(new LiveMigrateVmDisksCommand<LiveMigrateVmDisksParameters>(new LiveMigrateVmDisksParameters(new ArrayList<LiveMigrateDiskParameters>(), vmId), null));
    doReturn(true).when(command).validateSpaceRequirements();
    doReturn(true).when(command).checkImagesStatus();
    doReturn(true).when(command).setAndValidateDiskProfiles();
}
#end_block

#method_before
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void canDoActionSpaceValidationFails() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Sparse);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void canDoActionSpaceValidationFails() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Sparse);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
private static StorageDomainValidator mockStorageDomainValidatorWithoutSpace() {
    StorageDomainValidator storageDomainValidator = mockStorageDomainValidator();
    when(storageDomainValidator.hasSpaceForNewDisk(any(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN));
    return storageDomainValidator;
}
#method_after
private static StorageDomainValidator mockStorageDomainValidatorWithoutSpace() {
    StorageDomainValidator storageDomainValidator = mockStorageDomainValidator();
    when(storageDomainValidator.hasSpaceForNewDisk(any(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    return storageDomainValidator;
}
#end_block

#method_before
@Test
public void testCanDoSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit(any(Disk.class));
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskValidator.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testCanDoSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit(any(Disk.class));
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskValidator.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(ValidationResult.VALID);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmDiskImage();
    initVmForFail();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#method_after
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmDiskImage();
    initVmForFail();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#end_block

#method_before
@Test
public void canDoActionNotEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN);
}
#method_after
@Test
public void canDoActionNotEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#end_block

#method_before
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage();
    initSrcStorageDomain();
    initDestStorageDomain();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
private static StorageDomainValidator mockStorageDomainValidatorWithoutSpace() {
    StorageDomainValidator storageDomainValidator = mockStorageDomainValidator();
    when(storageDomainValidator.hasSpaceForClonedDisk(any(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN));
    return storageDomainValidator;
}
#method_after
private static StorageDomainValidator mockStorageDomainValidatorWithoutSpace() {
    StorageDomainValidator storageDomainValidator = mockStorageDomainValidator();
    when(storageDomainValidator.hasSpaceForClonedDisk(any(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    return storageDomainValidator;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        getMacPool().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId() != null ? disk.getDiskProfileId() : getParameters().getDiskProfileId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager().removeAll(getVmId());
}
#method_after
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(getMacPool()).removeAll(getVmId());
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    setDiskProfileParameters();
    final Map<Guid, DiskProfileValidator> diskProfileValidationMap = new HashMap<>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            if (!diskProfileValidationMap.containsKey(diskImage.getDiskProfileId())) {
                diskProfileValidationMap.put(diskImage.getDiskProfileId(), new DiskProfileValidator(diskImage.getDiskProfileId()));
            }
            if (!validate(diskProfileValidationMap.get(diskImage.getDiskProfileId()).isStorageDomainValid(imageToDestinationDomainMap.get(diskImage.getId())))) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getcompatibility_version()));
    }
    return true;
}
#end_block

#method_before
public static DiskProfile createDiskProfile(Guid storageDomainId, String storageDomainName) {
    DiskProfile profile = new DiskProfile();
    profile.setId(Guid.newGuid());
    profile.setName(storageDomainName);
    profile.setStorageDomainId(storageDomainId);
    return profile;
}
#method_after
public static DiskProfile createDiskProfile(Guid storageDomainId, String name) {
    DiskProfile profile = new DiskProfile();
    profile.setId(Guid.newGuid());
    profile.setName(name);
    profile.setStorageDomainId(storageDomainId);
    return profile;
}
#end_block

#method_before
protected boolean addStorageDomainInIrs() {
    // No need to run in separate transaction - counting on rollback of external transaction wrapping the command
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateStorageDomain, new CreateStorageDomainVDSCommandParameters(getVds().getId(), getStorageDomain().getStorageStaticData(), getStorageArgs())).getSucceeded();
}
#method_after
protected boolean addStorageDomainInIrs() {
    // No need to run in separate transaction - counting on rollback of external transaction wrapping the command
    return runVdsCommand(VDSCommandType.CreateStorageDomain, new CreateStorageDomainVDSCommandParameters(getVds().getId(), getStorageDomain().getStorageStaticData(), getStorageArgs())).getSucceeded();
}
#end_block

#method_before
protected void addStorageDomainInDb() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainStatic storageStaticData = getStorageDomain().getStorageStaticData();
            DbFacade.getInstance().getStorageDomainStaticDao().save(storageStaticData);
            // create default disk profile for type master or data storage domains
            if (storageStaticData.getStorageDomainType() == StorageDomainType.Master || storageStaticData.getStorageDomainType() == StorageDomainType.Data) {
                getDiskProfileDao().save(DiskProfileHelper.createDiskProfile(storageStaticData.getId(), storageStaticData.getStorageName()));
            }
            getCompensationContext().snapshotNewEntity(storageStaticData);
            StorageDomainDynamic newStorageDynamic = new StorageDomainDynamic(null, getStorageDomain().getId(), null);
            getReturnValue().setActionReturnValue(getStorageDomain().getId());
            DbFacade.getInstance().getStorageDomainDynamicDao().save(newStorageDynamic);
            getCompensationContext().snapshotNewEntity(newStorageDynamic);
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
protected void addStorageDomainInDb() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainStatic storageStaticData = getStorageDomain().getStorageStaticData();
            DbFacade.getInstance().getStorageDomainStaticDao().save(storageStaticData);
            // create default disk profile for type master or data storage domains
            if (storageStaticData.getStorageDomainType().isDataDomain()) {
                getDiskProfileDao().save(DiskProfileHelper.createDiskProfile(storageStaticData.getId(), storageStaticData.getStorageName()));
            }
            getCompensationContext().snapshotNewEntity(storageStaticData);
            StorageDomainDynamic newStorageDynamic = new StorageDomainDynamic(null, getStorageDomain().getId(), null);
            getReturnValue().setActionReturnValue(getStorageDomain().getId());
            DbFacade.getInstance().getStorageDomainDynamicDao().save(newStorageDynamic);
            getCompensationContext().snapshotNewEntity(newStorageDynamic);
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
protected void updateStorageDomainDynamicFromIrs() {
    final StorageDomain sd = (StorageDomain) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetStorageDomainStats, new GetStorageDomainStatsVDSCommandParameters(getVds().getId(), getStorageDomain().getId())).getReturnValue();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStorageDomain().getStorageDynamicData());
            DbFacade.getInstance().getStorageDomainDynamicDao().update(sd.getStorageDynamicData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
protected void updateStorageDomainDynamicFromIrs() {
    final StorageDomain sd = (StorageDomain) runVdsCommand(VDSCommandType.GetStorageDomainStats, new GetStorageDomainStatsVDSCommandParameters(getVds().getId(), getStorageDomain().getId())).getReturnValue();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStorageDomain().getStorageDynamicData());
            DbFacade.getInstance().getStorageDomainDynamicDao().update(sd.getStorageDynamicData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
protected Pair<Boolean, Integer> connectStorage() {
    String connectionId = getStorageDomain().getStorage();
    StorageServerConnections connection = getStorageServerConnectionDAO().get(connectionId);
    HashMap<String, String> result = (HashMap<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getParameters().getVdsId(), Guid.Empty, connection.getstorage_type(), new ArrayList<StorageServerConnections>(Arrays.asList(new StorageServerConnections[] { connection })))).getReturnValue();
    return new Pair<Boolean, Integer>(StorageHelperDirector.getInstance().getItem(connection.getstorage_type()).isConnectSucceeded(result, Arrays.asList(connection)), Integer.parseInt(result.values().iterator().next()));
}
#method_after
protected Pair<Boolean, Integer> connectStorage() {
    String connectionId = getStorageDomain().getStorage();
    StorageServerConnections connection = getStorageServerConnectionDAO().get(connectionId);
    Map<String, String> result = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getParameters().getVdsId(), Guid.Empty, connection.getstorage_type(), new ArrayList<>(Collections.singletonList(connection)))).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(connection.getstorage_type()).isConnectSucceeded(result, Collections.singletonList(connection)), Integer.parseInt(result.values().iterator().next()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && initializeVds() && checkStorageDomainNameLengthValid();
    if (returnValue && isStorageWithSameNameExists()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
        returnValue = false;
    }
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        returnValue = false;
    }
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        returnValue = false;
    }
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        returnValue = false;
    }
    boolean isSupportedStorageFormat = isStorageFormatSupportedByStoragePool() && isStorageFormatCompatibleWithDomain();
    if (returnValue && !isSupportedStorageFormat) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST);
        getReturnValue().getCanDoActionMessages().add(String.format("$storageFormat %1$s", getStorageDomain().getStorageFormat().toString()));
        returnValue = false;
    }
    return returnValue && canAddDomain();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    if (!isStorageFormatSupportedByStoragePool() || !isStorageFormatCompatibleWithDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST);
        getReturnValue().getCanDoActionMessages().add(String.format("$storageFormat %1$s", getStorageDomain().getStorageFormat()));
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private boolean isStorageFormatSupportedByStoragePool() {
    StorageFormatType storageFormat = getStorageDomain().getStorageFormat();
    StoragePool targetStoragePool = getStoragePool();
    if (targetStoragePool == null) {
        targetStoragePool = getStoragePoolDAO().get(getVds().getStoragePoolId());
        if (targetStoragePool == null) {
            return false;
        }
    }
    Set<StorageFormatType> supportedStorageFormats = getSupportedStorageFormatSet(targetStoragePool.getcompatibility_version());
    if (!supportedStorageFormats.contains(storageFormat)) {
        return false;
    }
    return true;
}
#method_after
private boolean isStorageFormatSupportedByStoragePool() {
    StorageFormatType storageFormat = getStorageDomain().getStorageFormat();
    StoragePool targetStoragePool = getTargetStoragePool();
    if (targetStoragePool == null) {
        return false;
    }
    Set<StorageFormatType> supportedStorageFormats = getSupportedStorageFormatSet(targetStoragePool.getcompatibility_version());
    return supportedStorageFormats.contains(storageFormat);
}
#end_block

#method_before
private boolean isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = getStorageDomain().getStorageFormat();
    StorageType storageType = getStorageDomain().getStorageType();
    StorageDomainType storageDomainFunction = getStorageDomain().getStorageDomainType();
    boolean isBlockStorage = storageType.isBlockDomain();
    boolean isDataStorageDomain = storageDomainFunction == StorageDomainType.Data;
    // V2 is applicable only for block data storage domains
    if (storageFormat == StorageFormatType.V2 && (!isBlockStorage || !isDataStorageDomain)) {
        return false;
    }
    // V3 is applicable only for data storage domains
    if (storageFormat == StorageFormatType.V3 && !isDataStorageDomain) {
        return false;
    }
    return true;
}
#method_after
private boolean isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = getStorageDomain().getStorageFormat();
    StorageType storageType = getStorageDomain().getStorageType();
    StorageDomainType storageDomainFunction = getStorageDomain().getStorageDomainType();
    // V2 is applicable only for block data storage domains
    if (storageFormat == StorageFormatType.V2) {
        return storageDomainFunction.isDataDomain() && storageType.isBlockDomain();
    }
    // V3 is applicable only for data storage domains
    if (storageFormat == StorageFormatType.V3) {
        return storageDomainFunction.isDataDomain();
    }
    return true;
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params);
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#method_after
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : getVmDAO().getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && validate(diskValidator.areBootableAndSharableCompatibleWithDisk());
}
#end_block

#method_before
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                diskImage.setDiskProfileId(((DiskImage) getNewDisk()).getDiskProfileId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile(diskImage);
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
private void performDiskUpdate(final boolean unlockImage) {
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
protected void updateDiskProfile(DiskImage diskImage) {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), diskImage.getDiskProfileId())) {
            getImageStorageDomainMapDao().updateDiskProfileForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getDiskProfileIds().get(0));
        }
    }
}
#method_after
protected void updateDiskProfile() {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        DiskImage newDisk = (DiskImage) getNewDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), newDisk.getDiskProfileId())) {
            getImageStorageDomainMapDao().updateDiskProfileByImageGroupIdAndStorageDomainId(newDisk.getId(), newDisk.getStorageIds().get(0), newDisk.getDiskProfileId());
        }
    }
}
#end_block

#method_before
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = getBackend().runInternalAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (ret.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    } else {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#method_after
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (ret.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    } else {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#method_after
@Override
protected void endSuccessfully() {
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addCanDoActionMessage(String.format("$VmsName %1$s", StringUtils.join(vmsWithBoot.toArray(), ", ")));
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addCanDoActionMessageVariable("VmsName", StringUtils.join(vmsWithBoot.toArray(), ", "));
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void endInternalCommandWithFailure() {
    ExtendImageSizeParameters params = createExtendImageSizeParameters();
    params.setTaskGroupSuccess(false);
    getBackend().endAction(VdcActionType.ExtendImageSize, params);
}
#method_after
private void endInternalCommandWithFailure() {
    ExtendImageSizeParameters params = createExtendImageSizeParameters();
    params.setTaskGroupSuccess(false);
    getBackend().endAction(VdcActionType.ExtendImageSize, params, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
}
#end_block

#method_before
private boolean updateDiskParametersRequiringVmDownRequested() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription());
}
#method_after
private boolean updateDiskParametersRequiringVmDownRequested() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio();
}
#end_block

#method_before
protected void addDiskImageToDb(DiskImage image, CompensationContext compensationContext) {
    image.setActive(true);
    getImageDao().save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setactual_size(image.getActualSizeInBytes());
    getDiskImageDynamicDAO().save(diskDynamic);
    image_storage_domain_map image_storage_domain_map = new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileIds().get(0));
    getImageStorageDomainMapDao().save(image_storage_domain_map);
    boolean isDiskAdded = saveDiskIfNotExists(image);
    if (compensationContext != null) {
        compensationContext.snapshotNewEntity(image.getImage());
        compensationContext.snapshotNewEntity(diskDynamic);
        compensationContext.snapshotNewEntity(image_storage_domain_map);
        if (isDiskAdded) {
            compensationContext.snapshotNewEntity(image);
        }
        compensationContext.stateChanged();
    }
}
#method_after
protected void addDiskImageToDb(DiskImage image, CompensationContext compensationContext) {
    image.setActive(true);
    getImageDao().save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setactual_size(image.getActualSizeInBytes());
    getDiskImageDynamicDAO().save(diskDynamic);
    image_storage_domain_map image_storage_domain_map = new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId());
    getImageStorageDomainMapDao().save(image_storage_domain_map);
    boolean isDiskAdded = saveDiskIfNotExists(image);
    if (compensationContext != null) {
        compensationContext.snapshotNewEntity(image.getImage());
        compensationContext.snapshotNewEntity(diskDynamic);
        compensationContext.snapshotNewEntity(image_storage_domain_map);
        if (isDiskAdded) {
            compensationContext.snapshotNewEntity(image);
        }
        compensationContext.stateChanged();
    }
}
#end_block

#method_before
static public image_storage_domain_map saveImage(DiskImage diskImage) {
    DbFacade.getInstance().getImageDao().save(diskImage.getImage());
    image_storage_domain_map image_storage_domain_map = new image_storage_domain_map(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileIds().get(0));
    DbFacade.getInstance().getImageStorageDomainMapDao().save(image_storage_domain_map);
    return image_storage_domain_map;
}
#method_after
static public image_storage_domain_map saveImage(DiskImage diskImage) {
    DbFacade.getInstance().getImageDao().save(diskImage.getImage());
    image_storage_domain_map image_storage_domain_map = new image_storage_domain_map(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId());
    DbFacade.getInstance().getImageStorageDomainMapDao().save(image_storage_domain_map);
    return image_storage_domain_map;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
                Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getVolumeType());
                tempVar.setVolumeFormat(disk.getVolumeFormat());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(getParameters().getForceOverride());
                tempVar.setImportEntity(true);
                tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
                tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (originalDiskId.equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
                Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getVolumeType());
                tempVar.setVolumeFormat(disk.getVolumeFormat());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(getParameters().getForceOverride());
                tempVar.setImportEntity(true);
                tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
                tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (originalDiskId.equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId() : getDiskImage().getStorageIds().get(0);
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getVolumeTypeForDomain(getParameters().getStorageDomainId()), isWipeAfterDelete(), getParameters().getForceOverride()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage() != null ? getDiskImage().getStoragePoolId() : getStorageDomain().getStoragePoolId(), sourceDomainId, getDiskImage() != null ? getDiskImage().getId() : getParameters().getImageGroupID(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // Add storage domain in db only if there is new entity in DB.
        if (!shouldUpdateStorageDisk() && getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId(), getParameters().getQuotaId(), getParameters().getDiskProfileId()));
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId() : getDiskImage().getStorageIds().get(0);
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getVolumeFormatForDomain(), getParameters().getVolumeType(), isWipeAfterDelete(), getParameters().getForceOverride()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage() != null ? getDiskImage().getStoragePoolId() : getStorageDomain().getStoragePoolId(), sourceDomainId, getDiskImage() != null ? getDiskImage().getId() : getParameters().getImageGroupID(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // Add storage domain in db only if there is new entity in DB.
        if (!shouldUpdateStorageDisk() && getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId(), getParameters().getQuotaId(), getParameters().getDiskProfileId()));
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume);
    getSnapshotDao().save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, snapshotStatus, snapshotType, vm, saveVmConfiguration, memoryVolume, disks, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume);
    getSnapshotDao().save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume);
    getSnapshotDao().save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
    }
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().ExportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        VmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
    }
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().ExportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#method_after
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool(vm.getStoragePoolId()));
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    mNewCreatedDiskImage = new DiskImage();
    mNewCreatedDiskImage.setImageId(getDestinationImageId());
    mNewCreatedDiskImage.setBoot(getParameters().getDiskInfo().isBoot());
    mNewCreatedDiskImage.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
    mNewCreatedDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    mNewCreatedDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    mNewCreatedDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    mNewCreatedDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    mNewCreatedDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    mNewCreatedDiskImage.setId(getImageGroupId());
    mNewCreatedDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    mNewCreatedDiskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getStorageDomainId())));
    mNewCreatedDiskImage.setSize(getParameters().getDiskInfo().getSize());
    mNewCreatedDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    mNewCreatedDiskImage.setvolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    mNewCreatedDiskImage.setDescription("");
    mNewCreatedDiskImage.setCreationDate(new Date());
    mNewCreatedDiskImage.setLastModified(new Date());
    mNewCreatedDiskImage.setActive(true);
    mNewCreatedDiskImage.setImageStatus(ImageStatus.LOCKED);
    mNewCreatedDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    mNewCreatedDiskImage.setQuotaId(getParameters().getQuotaId());
    mNewCreatedDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
                addDiskImageToDb(mNewCreatedDiskImage, getCompensationContext());
            } else {
                addDiskImageToDb(mNewCreatedDiskImage, null);
                getCompensationContext().snapshotEntityStatus(mNewCreatedDiskImage.getImage(), ImageStatus.ILLEGAL);
            }
            return null;
        }
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(mNewCreatedDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(mNewCreatedDiskImage);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setBoot(getParameters().getDiskInfo().isBoot());
    newDiskImage.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setvolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
                addDiskImageToDb(newDiskImage, getCompensationContext());
            } else {
                addDiskImageToDb(newDiskImage, null);
                getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
            }
            return null;
        }
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.areBootableAndSharableCompatibleWithDisk())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getStorageType();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        for (DiskImage disk : getVmTemplate().getDiskTemplateMap().values()) {
            VdcReturnValueBase result = runInternalAction(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
    }
    return true;
}
#method_after
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        for (DiskImage disk : getVmTemplate().getDiskTemplateMap().values()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
    }
    return true;
}
#end_block

#method_before
private CreateCloneOfTemplateParameters buildCreateCloneOfTemplateParameters(DiskImage disk) {
    DiskImageBase diskInfo = getParameters().getDiskInfoDestinationMap().get(disk.getId());
    CreateCloneOfTemplateParameters params = new CreateCloneOfTemplateParameters(disk.getImageId(), getParameters().getVmStaticData().getId(), diskInfo);
    params.setStorageDomainId(diskInfoSourceMap.get(disk.getId()));
    params.setDestStorageDomainId(retrieveDestinationDomainForDisk(disk.getId()));
    params.setDiskAlias(diskInfoDestinationMap.get(disk.getId()).getDiskAlias());
    params.setVmSnapshotId(getVmSnapshotId());
    params.setParentCommand(VdcActionType.AddVmFromTemplate);
    params.setParentParameters(getParameters());
    params.setEntityInfo(getParameters().getEntityInfo());
    params.setQuotaId(diskInfoDestinationMap.get(disk.getId()).getQuotaId() != null ? diskInfoDestinationMap.get(disk.getId()).getQuotaId() : null);
    params.setDiskProfileId(diskInfoDestinationMap.get(disk.getId()).getDiskProfileId() != null ? diskInfoDestinationMap.get(disk.getId()).getDiskProfileId() : null);
    return params;
}
#method_after
private CreateCloneOfTemplateParameters buildCreateCloneOfTemplateParameters(DiskImage disk) {
    DiskImageBase diskInfo = getParameters().getDiskInfoDestinationMap().get(disk.getId());
    CreateCloneOfTemplateParameters params = new CreateCloneOfTemplateParameters(disk.getImageId(), getParameters().getVmStaticData().getId(), diskInfo);
    params.setStorageDomainId(diskInfoSourceMap.get(disk.getId()));
    params.setDestStorageDomainId(retrieveDestinationDomainForDisk(disk.getId()));
    params.setDiskAlias(diskInfoDestinationMap.get(disk.getId()).getDiskAlias());
    params.setVmSnapshotId(getVmSnapshotId());
    params.setParentCommand(VdcActionType.AddVmFromTemplate);
    params.setParentParameters(getParameters());
    params.setEntityInfo(getParameters().getEntityInfo());
    params.setQuotaId(diskInfoDestinationMap.get(disk.getId()).getQuotaId() != null ? diskInfoDestinationMap.get(disk.getId()).getQuotaId() : null);
    params.setDiskProfileId(diskInfoDestinationMap.get(disk.getId()).getDiskProfileId());
    return params;
}
#end_block

#method_before
protected List<DiskImage> getAllImageSnapshots(DiskImage diskImage) {
    return ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getImageTemplateId());
}
#method_after
protected List<DiskImage> getAllImageSnapshots(DiskImage diskImage) {
    return ImagesHandler.getAllImageSnapshots(diskImage.getImageId());
}
#end_block

#method_before
private void addDisksDeactivatedMessage(List<MoveDiskParameters> moveDiskParamsList) {
    setActionMessageParameters();
    addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(getDisksAliases(moveDiskParamsList), ", ")));
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MOVE_DISKS_MIXED_PLUGGED_STATUS);
    getReturnValue().setCanDoAction(false);
}
#method_after
private void addDisksDeactivatedMessage(List<MoveDiskParameters> moveDiskParamsList) {
    setActionMessageParameters();
    addCanDoActionMessageVariable("diskAliases", StringUtils.join(getDisksAliases(moveDiskParamsList), ", "));
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MOVE_DISKS_MIXED_PLUGGED_STATUS);
    getReturnValue().setCanDoAction(false);
}
#end_block

#method_before
private void addInvalidVmStateMessage(VM vm) {
    setActionMessageParameters();
    addCanDoActionMessage(String.format("$%1$s %2$s", "VmName", vm.getName()));
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP);
    getReturnValue().setCanDoAction(false);
}
#method_after
private void addInvalidVmStateMessage(VM vm) {
    setActionMessageParameters();
    addCanDoActionMessageVariable("VmName", vm.getName());
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP);
    getReturnValue().setCanDoAction(false);
}
#end_block

#method_before
@Override
protected void beforeTask() {
    // Split the image
    VmReplicateDiskParameters migrationCompleteParams = new VmReplicateDiskParameters(getEnclosingCommand().getParameters().getVdsId(), getEnclosingCommand().getParameters().getVmId(), getEnclosingCommand().getParameters().getStoragePoolId(), getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getDestinationImageId());
    // Update the DB before sending the command (perform rollback on failure)
    moveDiskInDB(getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getTargetStorageDomainId());
    VDSReturnValue ret = null;
    try {
        ret = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmReplicateDiskFinish, migrationCompleteParams);
        if (ret.getSucceeded()) {
            updateImagesInfo();
            ImagesHandler.updateAllDiskImageSnapshotsStatus(getEnclosingCommand().getParameters().getImageGroupID(), ImageStatus.OK);
        } else {
            throw new VdcBLLException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
        }
    } catch (Exception e) {
        moveDiskInDB(getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getSourceStorageDomainId());
        log.errorFormat("Failed VmReplicateDiskFinish (Disk {0} , VM {1})", getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getVmId());
        throw e;
    }
}
#method_after
@Override
protected void beforeTask() {
    // Split the image
    VmReplicateDiskParameters migrationCompleteParams = new VmReplicateDiskParameters(getEnclosingCommand().getParameters().getVdsId(), getEnclosingCommand().getParameters().getVmId(), getEnclosingCommand().getParameters().getStoragePoolId(), getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getDestinationImageId());
    // Update the DB before sending the command (perform rollback on failure)
    moveDiskInDB(getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getTargetStorageDomainId());
    VDSReturnValue ret = null;
    try {
        ret = runVdsCommand(VDSCommandType.VmReplicateDiskFinish, migrationCompleteParams);
        if (ret.getSucceeded()) {
            updateImagesInfo();
            ImagesHandler.updateAllDiskImageSnapshotsStatus(getEnclosingCommand().getParameters().getImageGroupID(), ImageStatus.OK);
        } else {
            throw new VdcBLLException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
        }
    } catch (Exception e) {
        moveDiskInDB(getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getSourceStorageDomainId());
        log.errorFormat("Failed VmReplicateDiskFinish (Disk {0} , VM {1})", getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getVmId());
        throw e;
    }
}
#end_block

#method_before
private void updateImagesInfo() {
    for (DiskImage image : getDiskImageDao().getAllSnapshotsForImageGroup(getEnclosingCommand().getParameters().getImageGroupID())) {
        VDSReturnValue ret = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getEnclosingCommand().getParameters().getStoragePoolId(), getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), image.getImageId()));
        DiskImage imageFromIRS = (DiskImage) ret.getReturnValue();
        DiskImageDynamic diskImageDynamic = getDiskImageDynamicDao().get(image.getImageId());
        // Update image's actual size in DB
        if (imageFromIRS != null && diskImageDynamic != null) {
            diskImageDynamic.setactual_size(imageFromIRS.getActualSizeInBytes());
            getDiskImageDynamicDao().update(diskImageDynamic);
        }
    }
}
#method_after
private void updateImagesInfo() {
    for (DiskImage image : getDiskImageDao().getAllSnapshotsForImageGroup(getEnclosingCommand().getParameters().getImageGroupID())) {
        VDSReturnValue ret = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getEnclosingCommand().getParameters().getStoragePoolId(), getEnclosingCommand().getParameters().getTargetStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), image.getImageId()));
        DiskImage imageFromIRS = (DiskImage) ret.getReturnValue();
        DiskImageDynamic diskImageDynamic = getDiskImageDynamicDao().get(image.getImageId());
        // Update image's actual size in DB
        if (imageFromIRS != null && diskImageDynamic != null) {
            diskImageDynamic.setactual_size(imageFromIRS.getActualSizeInBytes());
            getDiskImageDynamicDao().update(diskImageDynamic);
        }
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = createMemoryImageBuilder();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    createSnapshotsForDisks();
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    if (getTaskIdList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    createSnapshotsForDisks();
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    if (getTaskIdList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#method_after
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()))) {
            return false;
        }
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    if (!validateStorageDomains(disksList)) {
        return false;
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileIds().get(0)));
}
#method_after
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#end_block

#method_before
public static ArrayList<DiskImage> getAllImageSnapshots(Guid imageId, Guid imageTemplateId) {
    ArrayList<DiskImage> snapshots = new ArrayList<DiskImage>();
    Guid curImage = imageId;
    while (!imageTemplateId.equals(curImage) && !curImage.equals(Guid.Empty)) {
        DiskImage curDiskImage = DbFacade.getInstance().getDiskImageDao().getSnapshotById(curImage);
        snapshots.add(curDiskImage);
        curImage = curDiskImage.getParentId();
    }
    return snapshots;
}
#method_after
public static List<DiskImage> getAllImageSnapshots(Guid imageId) {
    return DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForLeaf(imageId);
}
#end_block

#method_before
public static void fillImagesBySnapshots(VM vm) {
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getImageTemplateId()));
        }
    }
}
#method_after
public static void fillImagesBySnapshots(VM vm) {
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId()));
        }
    }
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<DiskImage>();
            ovfManager.ImportVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(imageId)) {
                    log.debugFormat("Recreating vmSnapshot {0} without the image {1}", snapshot.getId(), imageId);
                    diskIter.remove();
                    break;
                }
            }
            String newOvf = ovfManager.ExportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.errorFormat("Can't remove image {0} from snapshot {1}", imageId, snapshot.getId());
    }
    return snapshot;
}
#method_after
public static Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId) {
    return prepareSnapshotConfigWithAlternateImage(snapshot, imageId, null);
}
#end_block

#method_before
@Override
public void execute() {
    if (enclosingCommand.getParameters().getTaskGroupSuccess()) {
        enclosingCommand.getParameters().setImageGroupID(Guid.newGuid());
        enclosingCommand.getParameters().setDestinationImageId(Guid.newGuid());
        enclosingCommand.getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, enclosingCommand.getParameters().getImageGroupID()));
        // Filling in all the remaining fields of the target DiskImage
        DiskImage diskImage = enclosingCommand.getParameters().getDiskImage();
        ArrayList<Guid> storageIds = new ArrayList<>();
        storageIds.add(enclosingCommand.getParameters().getStorageDomainId());
        diskImage.setStorageIds(storageIds);
        diskImage.setStoragePoolId(enclosingCommand.getParameters().getStoragePoolId());
        diskImage.setId(enclosingCommand.getParameters().getImageGroupID());
        diskImage.setDiskInterface(DiskInterface.VirtIO);
        if (diskImage.getVolumeFormat() == VolumeFormat.RAW && getDestinationStorageDomain().getStorageType().isBlockDomain()) {
            diskImage.setVolumeType(VolumeType.Preallocated);
        } else {
            diskImage.setVolumeType(VolumeType.Sparse);
        }
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, getAddImageFromScratchParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
        enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        if (vdcReturnValue.getActionReturnValue() != null) {
            DiskImage newDiskImage = (DiskImage) vdcReturnValue.getActionReturnValue();
            enclosingCommand.getParameters().setDestinationImageId(newDiskImage.getImageId());
            enclosingCommand.getParameters().getDiskImage().setImageId(newDiskImage.getImageId());
            MultiLevelAdministrationHandler.addPermission(new Permissions(enclosingCommand.getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImage.getId(), VdcObjectType.Disk));
        }
        ExecutionHandler.setAsyncJob(enclosingCommand.getExecutionContext(), true);
        enclosingCommand.getReturnValue().setSucceeded(true);
    }
}
#method_after
@Override
public void execute() {
    if (enclosingCommand.getParameters().getTaskGroupSuccess()) {
        enclosingCommand.getParameters().setImageGroupID(Guid.newGuid());
        enclosingCommand.getParameters().setDestinationImageId(Guid.newGuid());
        enclosingCommand.getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, enclosingCommand.getParameters().getImageGroupID()));
        // Filling in all the remaining fields of the target DiskImage
        DiskImage diskImage = enclosingCommand.getParameters().getDiskImage();
        ArrayList<Guid> storageIds = new ArrayList<>();
        storageIds.add(enclosingCommand.getParameters().getStorageDomainId());
        diskImage.setStorageIds(storageIds);
        diskImage.setStoragePoolId(enclosingCommand.getParameters().getStoragePoolId());
        diskImage.setId(enclosingCommand.getParameters().getImageGroupID());
        diskImage.setDiskInterface(DiskInterface.VirtIO);
        if (diskImage.getVolumeFormat() == VolumeFormat.RAW && getDestinationStorageDomain().getStorageType().isBlockDomain()) {
            diskImage.setVolumeType(VolumeType.Preallocated);
        } else {
            diskImage.setVolumeType(VolumeType.Sparse);
        }
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, getAddImageFromScratchParameters(), ExecutionHandler.createDefaultContextForTasks(enclosingCommand.getContext()));
        enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        if (vdcReturnValue.getActionReturnValue() != null) {
            DiskImage newDiskImage = (DiskImage) vdcReturnValue.getActionReturnValue();
            enclosingCommand.getParameters().setDestinationImageId(newDiskImage.getImageId());
            enclosingCommand.getParameters().getDiskImage().setImageId(newDiskImage.getImageId());
            MultiLevelAdministrationHandler.addPermission(new Permissions(enclosingCommand.getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImage.getId(), VdcObjectType.Disk));
        }
        ExecutionHandler.setAsyncJob(enclosingCommand.getExecutionContext(), true);
        enclosingCommand.getReturnValue().setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getStoragePoolId() != null ? mNewCreatedDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), mNewCreatedDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getVolumeFormat(), mNewCreatedDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    } catch (VdcBLLException e) {
        log.errorFormat("Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    } catch (VdcBLLException e) {
        log.errorFormat("Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#end_block

#method_before
private void initSpyCommand() {
    command = spy(new LiveMigrateVmDisksCommand<LiveMigrateVmDisksParameters>(new LiveMigrateVmDisksParameters(new ArrayList<LiveMigrateDiskParameters>(), vmId)));
    doReturn(true).when(command).isValidSpaceRequirements();
    doReturn(true).when(command).checkImagesStatus();
}
#method_after
private void initSpyCommand() {
    command = spy(new LiveMigrateVmDisksCommand<LiveMigrateVmDisksParameters>(new LiveMigrateVmDisksParameters(new ArrayList<LiveMigrateDiskParameters>(), vmId), null));
    doReturn(true).when(command).validateSpaceRequirements();
    doReturn(true).when(command).checkImagesStatus();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPool());
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmDisksSource.getId(), VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(vmDisksSource.getId(), getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            tempVar.setDiskProfileId(diskInfoDestinationMap.get(dit.getId()).getDiskProfileId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DiskImage other = (DiskImage) obj;
    return (ObjectUtils.objectsEqual(getImage(), other.getImage()) && ObjectUtils.objectsEqual(snapshots, other.snapshots) && actualSizeInBytes == other.actualSizeInBytes && ObjectUtils.objectsEqual(appList, other.appList) && ObjectUtils.objectsEqual(description, other.description) && readRateKbPerSec == other.readRateKbPerSec && writeRateKbPerSec == other.writeRateKbPerSec && ObjectUtils.objectsEqual(storagePath, other.storagePath) && readRateFromDiskImageDynamic == other.readRateFromDiskImageDynamic && ObjectUtils.objectsEqual(storageIds, other.storageIds) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagesNames, other.storagesNames) && writeRateFromDiskImageDynamic == other.writeRateFromDiskImageDynamic && ObjectUtils.objectsEqual(readLatency, other.readLatency) && ObjectUtils.objectsEqual(writeLatency, other.writeLatency) && ObjectUtils.objectsEqual(flushLatency, other.flushLatency) && ObjectUtils.objectsEqual(diskProfileIds, other.diskProfileIds) && ObjectUtils.objectsEqual(diskProfileNames, other.diskProfileNames));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DiskImage other = (DiskImage) obj;
    return (ObjectUtils.objectsEqual(getImage(), other.getImage()) && ObjectUtils.objectsEqual(snapshots, other.snapshots) && actualSizeInBytes == other.actualSizeInBytes && ObjectUtils.objectsEqual(appList, other.appList) && ObjectUtils.objectsEqual(description, other.description) && readRateKbPerSec == other.readRateKbPerSec && writeRateKbPerSec == other.writeRateKbPerSec && ObjectUtils.objectsEqual(storagePath, other.storagePath) && readRateFromDiskImageDynamic == other.readRateFromDiskImageDynamic && ObjectUtils.objectsEqual(storageIds, other.storageIds) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagesNames, other.storagesNames) && writeRateFromDiskImageDynamic == other.writeRateFromDiskImageDynamic && ObjectUtils.objectsEqual(readLatency, other.readLatency) && ObjectUtils.objectsEqual(writeLatency, other.writeLatency) && ObjectUtils.objectsEqual(flushLatency, other.flushLatency) && ObjectUtils.haveSameElements(diskProfileIds, other.diskProfileIds) && ObjectUtils.haveSameElements(diskProfileNames, other.diskProfileNames));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    Guid taskId = getAsyncTaskId();
    VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getDescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, newImage.getVolumeFormat(), newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    Guid taskId = getAsyncTaskId();
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getDescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        getMacPool().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId() != null ? disk.getDiskProfileId() : getParameters().getDiskProfileId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    params.setDiskProfileId(disk.getDiskProfileId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager().removeAll(getVmId());
}
#method_after
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(getMacPool()).removeAll(getVmId());
}
#end_block

#method_before
public boolean equalValues(QosBase other) {
    return false;
}
#method_after
public boolean equalValues(QosBase other) {
    // no extra values, should be called for the derivative classes.
    return false;
}
#end_block

#method_before
@Override
public /**
 * qosType can be null in order to fetch all entities
 */
List<QosBase> getAllForStoragePoolId(Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId.getUuid());
    return getCallsHandler().executeReadList("GetAllQosForStoragePool", createEntityRowMapper(), parameterSource);
}
#method_after
@Override
public List<QosBase> getAllForStoragePoolId(Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId);
    return getCallsHandler().executeReadList("GetAllQosForStoragePool", createEntityRowMapper(), parameterSource);
}
#end_block

#method_before
@Override
protected QosBase createQosEntity(ResultSet rs) throws SQLException {
    switch(QosType.forValue(rs.getInt("qos_type"))) {
        case STORAGE:
            return StorageQosDaoDbFacadeImpl.StorageDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        default:
            break;
    }
    return null;
}
#method_after
@Override
protected QosBase createQosEntity(ResultSet rs) throws SQLException {
    QosType qosType = QosType.forValue(rs.getInt("qos_type"));
    switch(qosType) {
        case STORAGE:
            return StorageQosDaoDbFacadeImpl.StorageDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        default:
            log.debugFormat("not handled/missing qos_type", qosType);
            break;
    }
    return null;
}
#end_block

#method_before
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        return getDbFacade().getQosBaseDao();
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        default:
            break;
    }
    return qosDao;
}
#method_after
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        return getDbFacade().getQosBaseDao();
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        default:
            log.debugFormat("Not handled QoS type: {0}", qosType);
            break;
    }
    return qosDao;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.isDiskShareableAndBootable())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskValidator.areBootableAndSharableCompatibleWithDisk())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
private void prepareForDiskShareableBootableTest(ValidationResult isDiskShareableAndBootableValidationResult) {
    UpdateVmDiskParameters parameters = createParameters();
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    when(diskValidator.isDiskShareableAndBootable()).thenReturn(isDiskShareableAndBootableValidationResult);
    doReturn(true).when(command).validateCanUpdateReadOnly(diskValidator);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
}
#method_after
private void prepareForDiskShareableBootableTest(ValidationResult isDiskShareableAndBootableValidationResult) {
    UpdateVmDiskParameters parameters = createParameters();
    initializeCommand(parameters);
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(isDiskShareableAndBootableValidationResult);
    doReturn(true).when(command).validateCanUpdateReadOnly(diskValidator);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    ejbRule.mockResource(ContainerManagedResourceType.TRANSACTION_MANAGER, new DummyTransactionManager());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#end_block

#method_before
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskShareableAndBootable()).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void testCanDoSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit(any(Disk.class));
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskValidator.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
    when(diskValidator.isDiskShareableAndBootable()).thenReturn(ValidationResult.VALID);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testCanDoSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit(any(Disk.class));
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskValidator.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface();
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(ValidationResult.VALID);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
private void prepareForDiskShareableBootableTest(ValidationResult isDiskShareableAndBootableValidationResult) {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    VM vm = mockVm();
    mockMaxPciSlots();
    when(diskValidator.isDiskShareableAndBootable()).thenReturn(isDiskShareableAndBootableValidationResult);
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(vm, diskValidator);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
}
#method_after
private void prepareForDiskShareableBootableTest(ValidationResult isDiskShareableAndBootableValidationResult) {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    VM vm = mockVm();
    mockMaxPciSlots();
    when(diskValidator.areBootableAndSharableCompatibleWithDisk()).thenReturn(isDiskShareableAndBootableValidationResult);
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(vm, diskValidator);
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && validate(diskValidator.isDiskShareableAndBootable());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && validate(diskValidator.areBootableAndSharableCompatibleWithDisk());
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            containsBootableDisk = false;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        containsBootableDisk = true;
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            isVmContainBootableDisk = false;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        isVmContainBootableDisk = true;
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
private void isShareable_EntityChanged() {
    // When the "isShareable" entity value changes, there are two main cases
    // in which we want to handle the changeability of the "isBootable" entity:
    // 1. "isBootable" is changeable.
    // 2. "isBootable" is not changeable because the disk is already shareable.
    // Note - if the VM already contains a bootable disk, the changeability of "isBootable" should not change.
    boolean isShareable = getIsShareable().getEntity();
    if (getIsBootable().getIsChangable() || (!containsBootableDisk && !isShareable)) {
        getIsBootable().setIsChangable(!isShareable);
        getIsBootable().setChangeProhibitionReason(CONSTANTS.cannotEnableBootableForShareableDisk());
    }
}
#method_after
private void isShareable_EntityChanged() {
    // When the "isShareable" entity value changes, there are two main cases
    // in which we want to handle the changeability of the "isBootable" entity:
    // 1. "isBootable" is changeable.
    // 2. "isBootable" is not changeable because the disk is already shareable.
    // Note - if the VM already contains a bootable disk, the changeability of "isBootable" should not change.
    boolean isShareable = getIsShareable().getEntity();
    if (getIsBootable().getIsChangable() || (!isVmContainBootableDisk && !isShareable)) {
        getIsBootable().setIsChangable(!isShareable);
        getIsBootable().setChangeProhibitionReason(CONSTANTS.cannotEnableBootableForShareableDisk());
    }
}
#end_block

#method_before
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = getIsInternal().getEntity();
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateReadOnlyChangeability();
    updatePlugChangeability();
}
#method_after
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = getIsInternal().getEntity();
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiPassthrough().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateScsiPassthroguhChangeability();
    updateReadOnlyChangeability();
    updatePlugChangeability();
}
#end_block

#method_before
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = Boolean.FALSE.equals(getIsInternal().getEntity());
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableVirtIoScsiInterfaceForLunReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    getIsReadOnly().setIsChangable(isEditEnabled());
}
#method_after
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = !getIsInternal().getEntity();
    boolean isScsiPassthrough = getIsScsiPassthrough().getEntity();
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN && isScsiPassthrough) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableReadonlyWhenScsiPassthroughEnabled());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    getIsReadOnly().setIsChangable(isEditEnabled());
    getIsReadOnly().setEntity(getIsNew() ? Boolean.FALSE : getDisk().getReadOnly());
}
#end_block

#method_before
public void onSave() {
    boolean isInternal = getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = getDiskImage();
        if (getQuota().getIsAvailable() && getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(getQuota().getSelectedItem().getId());
        }
        long sizeToAddInGigabytes = Long.valueOf(getSizeExtend().getEntity());
        if (sizeToAddInGigabytes > 0) {
            diskImage.setSizeInGigabytes(diskImage.getSizeInGigabytes() + sizeToAddInGigabytes);
        }
        setDisk(diskImage);
    } else {
        LunDisk lunDisk = getLunDisk();
        DiskInterface diskInterface = getDiskInterface().getSelectedItem();
        if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
            lunDisk.setSgio(Boolean.TRUE.equals(getIsSgIoUnfiltered().getEntity()) ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
        }
        setDisk(lunDisk);
    }
    getDisk().setDiskAlias(getAlias().getEntity());
    getDisk().setDiskDescription(getDescription().getEntity());
    getDisk().setDiskInterface(getDiskInterface().getSelectedItem());
    getDisk().setWipeAfterDelete(getIsWipeAfterDelete().getEntity());
    getDisk().setBoot(getIsBootable().getEntity());
    getDisk().setShareable(getIsShareable().getEntity());
    getDisk().setPlugged(getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    getDisk().setReadOnly(getIsReadOnly().getIsAvailable() ? getIsReadOnly().getEntity() : null);
}
#method_after
public void onSave() {
    boolean isInternal = getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = getDiskImage();
        if (getQuota().getIsAvailable() && getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(getQuota().getSelectedItem().getId());
        }
        long sizeToAddInGigabytes = Long.valueOf(getSizeExtend().getEntity());
        if (sizeToAddInGigabytes > 0) {
            diskImage.setSizeInGigabytes(diskImage.getSizeInGigabytes() + sizeToAddInGigabytes);
        }
        setDisk(diskImage);
    } else {
        LunDisk lunDisk = getLunDisk();
        DiskInterface diskInterface = getDiskInterface().getSelectedItem();
        if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
            lunDisk.setSgio(!getIsScsiPassthrough().getEntity() ? null : getIsSgIoUnfiltered().getEntity() ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
        }
        setDisk(lunDisk);
    }
    getDisk().setDiskAlias(getAlias().getEntity());
    getDisk().setDiskDescription(getDescription().getEntity());
    getDisk().setDiskInterface(getDiskInterface().getSelectedItem());
    getDisk().setWipeAfterDelete(getIsWipeAfterDelete().getEntity());
    getDisk().setBoot(getIsBootable().getEntity());
    getDisk().setShareable(getIsShareable().getEntity());
    getDisk().setPlugged(getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    getDisk().setReadOnly(getIsReadOnly().getIsAvailable() ? getIsReadOnly().getEntity() : null);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.entityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.entityChangedEventDefinition) && sender == getIsBootable()) {
        isBootable_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.entityChangedEventDefinition) && sender == getIsShareable()) {
        isShareable_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsWipeAfterDelete()) {
            wipeAfterDelete_EntityChanged(args);
        } else if (sender == getIsAttachDisk()) {
            attachDisk_EntityChanged(args);
        } else if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
        } else if (sender == getIsInternal()) {
            isInternal_EntityChanged();
        } else if (sender == getIsBootable()) {
            isBootable_EntityChanged();
        } else if (sender == getIsShareable()) {
            isShareable_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(disk.getReadOnly())) {
        DiskInterface diskInterface = disk.getDiskInterface();
        if (diskInterface == DiskInterface.IDE || (diskInterface == DiskInterface.VirtIO_SCSI && disk.getDiskStorageType() == DiskStorageType.LUN)) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(disk.getReadOnly())) {
        DiskInterface diskInterface = disk.getDiskInterface();
        if (diskInterface == DiskInterface.IDE) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
        if (disk.isScsiPassthrough()) {
            return new ValidationResult(VdcBllMessages.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).and(replacements(hasItem(String.format("$interface %1$s", DiskInterface.IDE)))));
    setupForLun();
    lunDisk.setReadOnly(true);
    lunDisk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    assertThat(lunValidator.isReadOnlyPropertyCompatibleWithInterface(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).and(replacements(hasItem(String.format("$interface %1$s", DiskInterface.VirtIO_SCSI)))));
}
#method_after
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).and(replacements(hasItem(String.format("$interface %1$s", DiskInterface.IDE)))));
    setupForLun();
    lunDisk.setReadOnly(true);
    lunDisk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    lunDisk.setSgio(ScsiGenericIO.FILTERED);
    assertThat(lunValidator.isReadOnlyPropertyCompatibleWithInterface(), failsWith(VdcBllMessages.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK));
}
#end_block

#method_before
@Test
public void bootableAndShareableDiskFail() {
    disk.setBoot(true);
    disk.setShareable(true);
    assertThat(validator.isDiskShareableAndBootable(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CANNOT_BE_BOTH_SHAREABLE_AND_BOOTABLE));
}
#method_after
@Test
public void bootableAndShareableDiskFail() {
    disk.setBoot(true);
    disk.setShareable(true);
    assertThat(validator.areBootableAndSharableCompatibleWithDisk(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CANNOT_BE_BOTH_SHAREABLE_AND_BOOTABLE));
}
#end_block

#method_before
@Test
public void bootableAndNotShareableDiskSuccess() {
    disk.setBoot(true);
    disk.setShareable(false);
    assertThat(validator.isDiskShareableAndBootable(), isValid());
}
#method_after
@Test
public void bootableAndNotShareableDiskSuccess() {
    disk.setBoot(true);
    disk.setShareable(false);
    assertThat(validator.areBootableAndSharableCompatibleWithDisk(), isValid());
}
#end_block

#method_before
@Test
public void shareableAndNotBootableDiskSuccess() {
    disk.setShareable(true);
    disk.setBoot(false);
    assertThat(validator.isDiskShareableAndBootable(), isValid());
}
#method_after
@Test
public void shareableAndNotBootableDiskSuccess() {
    disk.setShareable(true);
    disk.setBoot(false);
    assertThat(validator.areBootableAndSharableCompatibleWithDisk(), isValid());
}
#end_block

#method_before
@Test
public void notBootableAndNotShareableDiskSuccess() {
    disk.setBoot(false);
    disk.setShareable(false);
    assertThat(validator.isDiskShareableAndBootable(), isValid());
}
#method_after
@Test
public void notBootableAndNotShareableDiskSuccess() {
    disk.setBoot(false);
    disk.setShareable(false);
    assertThat(validator.areBootableAndSharableCompatibleWithDisk(), isValid());
}
#end_block

#method_before
@Override
public DbUser mapRow(ResultSet rs, int rowNum) throws SQLException {
    DbUser entity = new DbUser();
    entity.setDepartment(rs.getString("department"));
    entity.setDomain(rs.getString("domain"));
    entity.setEmail(rs.getString("email"));
    entity.setGroupNames(new HashSet<String>(Arrays.asList(StringUtils.split(rs.getString("groups")))));
    entity.setFirstName(rs.getString("name"));
    entity.setNote(rs.getString("note"));
    entity.setNote(rs.getString("note"));
    entity.setRole(rs.getString("role"));
    entity.setActive(rs.getBoolean("active"));
    entity.setLastName(rs.getString("surname"));
    entity.setId(getGuidDefaultEmpty(rs, "user_id"));
    entity.setLoginName(rs.getString("username"));
    entity.setAdmin(rs.getBoolean("last_admin_check_status"));
    entity.setGroupIds(convertToGuidSet(rs.getString("group_ids"), ','));
    entity.setExternalId(rs.getString("external_id"));
    entity.setNamespace(rs.getString("namespace"));
    return entity;
}
#method_after
@Override
public DbUser mapRow(ResultSet rs, int rowNum) throws SQLException {
    DbUser entity = new DbUser();
    entity.setDepartment(rs.getString("department"));
    entity.setDomain(rs.getString("domain"));
    entity.setEmail(rs.getString("email"));
    entity.setGroupNames(new HashSet<String>(Arrays.asList(StringUtils.split(rs.getString("groups"), ','))));
    entity.setFirstName(rs.getString("name"));
    entity.setNote(rs.getString("note"));
    entity.setNote(rs.getString("note"));
    entity.setRole(rs.getString("role"));
    entity.setActive(rs.getBoolean("active"));
    entity.setLastName(rs.getString("surname"));
    entity.setId(getGuidDefaultEmpty(rs, "user_id"));
    entity.setLoginName(rs.getString("username"));
    entity.setAdmin(rs.getBoolean("last_admin_check_status"));
    entity.setGroupIds(convertToGuidSet(rs.getString("group_ids"), ','));
    entity.setExternalId(rs.getString("external_id"));
    entity.setNamespace(rs.getString("namespace"));
    return entity;
}
#end_block

#method_before
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    if (ldapProviderType != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
        adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
        authModeEntry.setValueForDomain(domainName, authMode);
        ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
        if (args.contains(ARG_LDAP_SERVERS)) {
            setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
        }
        handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
        testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
        handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
        // Update the configuration
        setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
        printSuccessMessage(domainName, "added");
    } else {
        System.err.println("Provider typ was not provided. Use --providerType=<ldap_provider_type");
    }
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    if (ldapProviderType == null) {
        System.err.println("Provider typ was not provided. Use --providerType=<ldap_provider_type");
    } else {
        adUserNameEntry.setValueForDomain(domainName, userName);
        adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
        authModeEntry.setValueForDomain(domainName, authMode);
        ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
        if (args.contains(ARG_LDAP_SERVERS)) {
            setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
        }
        handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
        testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
        handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
        // Update the configuration
        setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
        printSuccessMessage(domainName, "added");
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    getVdsGroup().setDetectEmulatedMachine(true);
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    if (!getVdsGroup().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = new AuditLogableBase();
        alb.setVdsGroupId(getVdsGroup().getId());
        AuditLogDirector.log(alb, AuditLogType.FENCING_DISABLED_IN_CLUSTER_POLICY);
    }
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, true));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    checkMaxMemoryOverCommitValue();
    getVdsGroup().setDetectEmulatedMachine(true);
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    alertIfFencingDisabled();
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, true));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    if (!getVdsGroup().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = new AuditLogableBase();
        alb.setVdsGroupId(getParameters().getVdsGroup().getId());
        AuditLogDirector.log(alb, AuditLogType.FENCING_DISABLED_IN_CLUSTER_POLICY);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogDirector.log(new AuditLogableBase(getVds().getId()), AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
private void handleFencingSkippedDueToPolicy(VDSReturnValue vdsReturnValue) {
    skippedDueToFencingPolicy = true;
    setFenceSucceeded(false);
    vdsReturnValue.setSucceeded(false);
    setActionReturnValue(vdsReturnValue.getReturnValue());
}
#method_after
protected void handleFencingSkippedDueToPolicy(VDSReturnValue vdsReturnValue) {
    skippedDueToFencingPolicy = true;
    setFenceSucceeded(false);
    vdsReturnValue.setSucceeded(false);
    setActionReturnValue(vdsReturnValue.getReturnValue());
    // when fencing is skipped we want to suppress command result logging, because
    // we fire an alert in VdsNotRespondingTreatment
    setCommandShouldBeLogged(false);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        setSucceeded(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (isConnectivityBrokenThresholdReached(getVds())) {
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogDirector.log(new AuditLogableBase(getVds().getId()), AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.VDS_RECOVER;
    } else {
        return skippedDueToFencingPolicy ? AuditLogType.VDS_NOT_RESTARTED_DUE_TO_POLICY : AuditLogType.VDS_RECOVER_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.VDS_RECOVER : AuditLogType.VDS_RECOVER_FAILED;
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#end_block

#method_before
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool object) {
            return object.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<ServerCpu>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Version>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    architectureEditor = new ListModelListBoxEditor<ArchitectureType>(new NullSafeRenderer<ArchitectureType>() {

        @Override
        public String renderNullSafe(ArchitectureType object) {
            return object.toString();
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<ClusterPolicy>(new NullSafeRenderer<ClusterPolicy>() {

        @Override
        public String renderNullSafe(ClusterPolicy object) {
            return object.getName();
        }
    });
}
#method_after
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool object) {
            return object.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<ServerCpu>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Version>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    architectureEditor = new ListModelListBoxEditor<ArchitectureType>(new NullSafeRenderer<ArchitectureType>() {

        @Override
        public String renderNullSafe(ArchitectureType object) {
            return object.toString();
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<ClusterPolicy>(new NullSafeRenderer<ClusterPolicy>() {

        @Override
        public String renderNullSafe(ClusterPolicy object) {
            return object.getName();
        }
    });
    hostsWithBrokenConnectivityThresholdEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    });
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    fencingEnabledCheckBox.getContentWidgetContainer().setWidth("300px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("300px");
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    fencingEnabledCheckBox.getContentWidgetContainer().setWidth("300px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("300px");
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfConnectivityBrokenCheckBox.getContentWidgetContainer().setWidth("300px");
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
    fencingEnabledInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.fencingEnabledInfo()), resources);
    skipFencingIfSDActiveInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingIfSDActiveInfo()), resources);
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
    fencingEnabledInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.fencingEnabledInfo()), resources);
    skipFencingIfSDActiveInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingIfSDActiveInfo()), resources);
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingWhenConnectivityBrokenInfo()), resources);
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getFencingEnabledModel().getEntity()) {
                Version ver = getVersion().getSelectedItem();
                if (ver != null) {
                    updateFencingPolicyContent(ver);
                }
            } else {
                // when fencing is disabled, all fencing policy content should also be disabled
                getSkipFencingIfSDActiveEnabled().setIsChangable(false);
            }
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
private void updateFencingPolicyContent(Version ver) {
    boolean supported = AsyncDataProvider.getInstance().isSkipFencingIfSDActiveSupported(ver.getValue());
    getSkipFencingIfSDActiveEnabled().setIsChangable(supported && getFencingEnabledModel().getEntity());
    if (supported) {
        if (getEntity() == null) {
            // this can happen when creating new cluster and cluster dialog is shown
            getSkipFencingIfSDActiveEnabled().setEntity(true);
        } else {
            getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
        }
    } else {
        getSkipFencingIfSDActiveEnabled().setEntity(false);
    }
}
#method_after
private void updateFencingPolicyContent(Version ver) {
    // skipFencingIfConnectivityBroken option is enabled when fencing is enabled for all cluster versions
    getSkipFencingIfConnectivityBrokenEnabled().setIsChangable(getFencingEnabledModel().getEntity());
    getHostsWithBrokenConnectivityThreshold().setIsChangable(getFencingEnabledModel().getEntity());
    if (ver == null) {
        if (!getFencingEnabledModel().getEntity()) {
            // fencing is disabled and cluster version not selected yet, so disable skipFencingIfSDActive
            getSkipFencingIfSDActiveEnabled().setIsChangable(false);
        }
    } else {
        // skipFencingIfSDActive is enabled for supported cluster level if fencing is not disabled
        boolean supported = AsyncDataProvider.getInstance().isSkipFencingIfSDActiveSupported(ver.getValue());
        getSkipFencingIfSDActiveEnabled().setIsChangable(supported && getFencingEnabledModel().getEntity());
        if (supported) {
            if (getEntity() == null) {
                // this can happen when creating new cluster and cluster dialog is shown
                getSkipFencingIfSDActiveEnabled().setEntity(true);
            } else {
                getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
            }
        } else {
            getSkipFencingIfSDActiveEnabled().setEntity(false);
        }
    }
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
                allowOptimize = getAllowOptimizeAvailability(volume);
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("CancelOptimizeForVirtStore")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equalsIgnoreCase("ConfirmOptimiseForVirtStore")) {
        // $NON-NLS-1$
        List<GlusterVolumeEntity> selectedVolumes = new ArrayList<GlusterVolumeEntity>();
        for (Object selectedVolume : getSelectedItems()) {
            selectedVolumes.add((GlusterVolumeEntity) selectedVolume);
        }
        optimizeVolumesForVirtStore(selectedVolumes);
    }
}
#end_block

#method_before
private void optimizeForVirtStore() {
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        return;
    }
    ArrayList<Guid> volumeIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        volumeIds.add(((GlusterVolumeEntity) item).getId());
    }
    optimizeVolumesForVirtStore(volumeIds);
}
#method_after
private void optimizeForVirtStore() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        return;
    }
    ArrayList<GlusterVolumeEntity> volumesForOptimiseForVirtStore = new ArrayList<GlusterVolumeEntity>();
    Boolean isDiscouragedVolumePresent = false;
    StringBuilder discouragedConfigVolumeNamesBuilder = new StringBuilder();
    discouragedConfigVolumeNamesBuilder.append(constants.optimiseForVirtStoreWarning());
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        volumesForOptimiseForVirtStore.add(volume);
        if (volume.getReplicaCount() != 3) {
            // $NON-NLS-1$
            discouragedConfigVolumeNamesBuilder.append(volume.getName() + "\n");
            isDiscouragedVolumePresent = true;
        }
    }
    discouragedConfigVolumeNamesBuilder.append(constants.optimiseForVirtStoreContinueMessage());
    if (isDiscouragedVolumePresent) {
        ConfirmationModel cModel = new ConfirmationModel();
        cModel.setMessage(discouragedConfigVolumeNamesBuilder.toString());
        // $NON-NLS-1$
        UICommand cancelOptimiseVirtStoreCommand = new UICommand("CancelOptimizeForVirtStore", this);
        cancelOptimiseVirtStoreCommand.setTitle(constants.doNotOptimiseForVirtStore());
        cancelOptimiseVirtStoreCommand.setIsCancel(true);
        cModel.getCommands().add(cancelOptimiseVirtStoreCommand);
        // $NON-NLS-1$
        UICommand confirmOptimiseForVirtStoreCommand = new UICommand("ConfirmOptimiseForVirtStore", this);
        confirmOptimiseForVirtStoreCommand.setTitle(constants.continueOptimiseForVirtStore());
        confirmOptimiseForVirtStoreCommand.setIsDefault(true);
        cModel.getCommands().add(confirmOptimiseForVirtStoreCommand);
        setConfirmWindow(cModel);
    } else {
        optimizeVolumesForVirtStore(volumesForOptimiseForVirtStore);
    }
}
#end_block

#method_before
private void optimizeVolumesForVirtStore(final List<Guid> volumeList) {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            final String optionGroupVirt = (String) result;
                            final String optionOwnerUserVirt = (String) resultInner;
                            final String optionOwnerGroupVirt = (String) resultInner1;
                            final ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (final Guid volumeId : volumeList) {
                                AsyncQuery volumeQuery = new AsyncQuery();
                                volumeQuery.setModel(this);
                                volumeQuery.asyncCallback = new INewAsyncCallback() {

                                    @Override
                                    public void onSuccess(Object model, Object returnValue) {
                                        int quorumEnabled = 1;
                                        int timeOutEnabled = 2;
                                        int enabled = 0;
                                        VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
                                        GlusterVolumeEntity volume = vdcValue.getReturnValue();
                                        Collection<GlusterVolumeOptionEntity> options = volume.getOptions();
                                        GlusterVolumeOptionEntity timeOutOption = new GlusterVolumeOptionEntity(volumeId, "network.ping-timeout", // $NON-NLS-1$//$NON-NLS-2$
                                        "10");
                                        GlusterVolumeOptionEntity quorumOption = new GlusterVolumeOptionEntity(volumeId, "cluster.quorum-type", // $NON-NLS-1$//$NON-NLS-2$
                                        "auto");
                                        for (GlusterVolumeOptionEntity option : options) {
                                            if (option.getKey() == quorumOption.getKey()) {
                                                enabled = enabled + quorumEnabled;
                                            }
                                            if (option.getKey() == timeOutOption.getKey()) {
                                                enabled = enabled + timeOutEnabled;
                                            }
                                        }
                                        if (enabled == quorumEnabled || enabled == (quorumEnabled ^ timeOutEnabled)) {
                                            list.add(new GlusterVolumeOptionParameters(quorumOption));
                                        }
                                        if (enabled == timeOutEnabled || enabled == (quorumEnabled ^ timeOutEnabled)) {
                                            list.add(new GlusterVolumeOptionParameters(timeOutOption));
                                        }
                                        GlusterVolumeOptionEntity optionGroup = new GlusterVolumeOptionEntity();
                                        optionGroup.setVolumeId(volumeId);
                                        // $NON-NLS-1$
                                        optionGroup.setKey("group");
                                        optionGroup.setValue(optionGroupVirt);
                                        list.add(new GlusterVolumeOptionParameters(optionGroup));
                                        GlusterVolumeOptionEntity optionOwnerUser = new GlusterVolumeOptionEntity();
                                        optionOwnerUser.setVolumeId(volumeId);
                                        // $NON-NLS-1$
                                        optionOwnerUser.setKey("storage.owner-uid");
                                        optionOwnerUser.setValue(optionOwnerUserVirt);
                                        list.add(new GlusterVolumeOptionParameters(optionOwnerUser));
                                        GlusterVolumeOptionEntity optionOwnerGroup = new GlusterVolumeOptionEntity();
                                        optionOwnerGroup.setVolumeId(volumeId);
                                        // $NON-NLS-1$
                                        optionOwnerGroup.setKey("storage.owner-gid");
                                        optionOwnerGroup.setValue(optionOwnerGroupVirt);
                                        list.add(new GlusterVolumeOptionParameters(optionOwnerGroup));
                                        if (volumeList.indexOf(volumeId) == volumeList.size() - 1) {
                                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                                        }
                                    }
                                };
                                Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(volumeId), volumeQuery);
                            }
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#method_after
private void optimizeVolumesForVirtStore(final List<GlusterVolumeEntity> volumeList) {
    if (getConfirmWindow() != null) {
        setConfirmWindow(null);
    }
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (GlusterVolumeEntity volume : volumeList) {
                                Guid volumeId = volume.getId();
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "group", optionGroupVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-uid", optionOwnerUserVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-gid", optionOwnerGroupVirt)));
                                // $NON-NLS-1$//$NON-NLS-2$
                                final GlusterVolumeOptionEntity checkOption = getOption(volumeId, "network.ping-timeout", "10");
                                List<PredicateFilter<GlusterVolumeOptionEntity>> predicaetFilters = Collections.singletonList(new PredicateFilter<GlusterVolumeOptionEntity>(new Predicate<GlusterVolumeOptionEntity>() {

                                    @Override
                                    public boolean evaluate(GlusterVolumeOptionEntity obj) {
                                        return obj.getKey().equalsIgnoreCase(checkOption.getKey());
                                    }
                                }));
                                if (!isOptionEnabledOnVolume(volume, predicaetFilters)) {
                                    // $NON-NLS-1$
                                    list.add(new GlusterVolumeOptionParameters(checkOption));
                                }
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    final GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue(), volume);
        }
    }, this);
}
#end_block

#method_before
public void postOnCreateVolume(VdcReturnValueBase returnValue) {
    VolumeModel model = (VolumeModel) getWindow();
    model.stopProgress();
    if (returnValue != null && returnValue.getSucceeded()) {
        cancel();
        Guid volumeId = (Guid) returnValue.getActionReturnValue();
        if ((Boolean) model.getOptimizeForVirtStore().getEntity()) {
            optimizeVolumesForVirtStore(Arrays.asList(volumeId));
        }
    }
}
#method_after
public void postOnCreateVolume(VdcReturnValueBase returnValue, GlusterVolumeEntity volume) {
    VolumeModel model = (VolumeModel) getWindow();
    model.stopProgress();
    if (returnValue != null && returnValue.getSucceeded()) {
        cancel();
        if ((Boolean) model.getOptimizeForVirtStore().getEntity()) {
            optimizeVolumesForVirtStore(Arrays.asList(volume));
        }
    }
}
#end_block

#method_before
private VolumeFormat getTargetVolumeFormat(VolumeFormat volumeFormat, VolumeType volumeType, Guid storageDomainId) {
    if (volumeFormat == VolumeFormat.RAW && volumeType == VolumeType.Sparse) {
        // 
        StorageDomainStatic destDomain = getStorageDomainStaticDAO().get(storageDomainId);
        if (destDomain.getStorageType().isBlockDomain()) {
            return VolumeFormat.COW;
        }
    }
    return volumeFormat;
}
#method_after
private VolumeFormat getTargetVolumeFormat(VolumeFormat volumeFormat, VolumeType volumeType, Guid storageDomainId) {
    if (volumeFormat == VolumeFormat.RAW && volumeType == VolumeType.Sparse) {
        StorageDomainStatic destDomain = getStorageDomainStaticDAO().get(storageDomainId);
        if (destDomain.getStorageType().isBlockDomain()) {
            return VolumeFormat.COW;
        }
    }
    return volumeFormat;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
private String getSearchPattern() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DirectoryUser.class, false);
    StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(SEARCH_TEMPLATE, parent.getDirectory().getName(), ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=*" : constraint);
    return sb.toString();
}
#method_after
private String getSearchPattern() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DirectoryUser.class, false);
    StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(ResourceConstants.AAA_PRINCIPALS_SEARCH_TEMPLATE, parent.getDirectory().getName(), ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=*" : constraint);
    return sb.toString();
}
#end_block

#method_before
private String getDirectoryGroupSearchPattern(String groupname, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DbGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(DIRECTORY_GROUP_SEARCH_TEMPLATE, domain, ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=" + groupname : constraint);
    return sb.toString();
}
#method_after
private String getDirectoryGroupSearchPattern(String groupname, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DbGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(ResourceConstants.AAA_GROUPS_SEARCH_TEMPLATE, domain, ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=" + groupname : constraint);
    return sb.toString();
}
#end_block

#method_before
private DirectoryGroup findDirectoryGroup(String directoryName, Group groupModel) {
    // Try to find a group that matches the identifier contained in the model:
    if (groupModel.isSetId()) {
        String groupId = DirectoryEntryIdUtils.decode(groupModel.getId());
        return getEntity(DirectoryGroup.class, VdcQueryType.GetDirectoryGroupById, new DirectoryIdQueryParameters(directoryName, groupModel.getNamespace(), groupId), groupId, true);
    } else if (groupModel.isSetName()) {
        String groupName = groupModel.getName();
        if (groupName.startsWith(directoryName + "/")) {
            int lastSlash = groupName.lastIndexOf("/");
            groupName = groupName.substring(lastSlash + 1);
        }
        return getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(groupName, directoryName));
    }
    return null;
}
#method_after
private DirectoryGroup findDirectoryGroup(String directoryName, Group groupModel) {
    // Try to find a group that matches the identifier contained in the model:
    String namespace = groupModel.getNamespace();
    if (groupModel.isSetId()) {
        return getGroupById(directoryName, namespace, groupModel.getId());
    } else if (groupModel.isSetDomainEntryId()) {
        return getGroupById(directoryName, namespace, groupModel.getDomainEntryId());
    } else if (groupModel.isSetName()) {
        String groupName = groupModel.getName();
        if (groupName.startsWith(directoryName + "/")) {
            int lastSlash = groupName.lastIndexOf("/");
            groupName = groupName.substring(lastSlash + 1);
        }
        return getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(groupName, directoryName));
    }
    return null;
}
#end_block

#method_before
private String getSearchPattern() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DirectoryGroup.class, false);
    StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(SEARCH_TEMPLATE, parent.getDirectory().getName(), ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=*" : constraint);
    return sb.toString();
}
#method_after
private String getSearchPattern() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DirectoryGroup.class, false);
    StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(ResourceConstants.AAA_GROUPS_SEARCH_TEMPLATE, parent.getDirectory().getName(), ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=*" : constraint);
    return sb.toString();
}
#end_block

#method_before
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = asGuid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (user.isSetUserName() && user.getUserName().contains("@")) {
        return user.getUserName().substring(user.getUserName().indexOf("@") + 1);
    }
    return null;
}
#method_after
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = asGuid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (isNameContainsDomain(user)) {
        return user.getUserName().substring(user.getUserName().lastIndexOf("@") + 1);
    }
    return null;
}
#end_block

#method_before
private String getDirectoryUserSearchPattern(String username, String namespace, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DbUser.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(DIRECTORY_USER_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain, namespace != null ? namespace : ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=" + username : constraint);
    return sb.toString();
}
#method_after
private String getDirectoryUserSearchPattern(String username, String namespace, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), DbUser.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(ResourceConstants.AAA_PRINCIPALS_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain, namespace != null ? namespace : ""));
    sb.append(StringUtils.isEmpty(constraint) ? "allnames=" + username : constraint);
    return sb.toString();
}
#end_block

#method_before
private boolean isNameContainsDomain(User user) {
    return ((user.getUserName().contains("@")) && (user.getUserName().indexOf('@') != user.getUserName().length() - 1));
}
#method_after
private boolean isNameContainsDomain(User user) {
    return ((user.getUserName().contains("@")) && (user.getUserName().lastIndexOf('@') != user.getUserName().length() - 1));
}
#end_block

#method_before
private DirectoryUser findDirectoryUser(String directoryName, User user) {
    DirectoryUser result = null;
    if (user.isSetId()) {
        String userId = DirectoryEntryIdUtils.decode(user.getId());
        result = getEntity(DirectoryUser.class, VdcQueryType.GetDirectoryUserById, new DirectoryIdQueryParameters(directoryName, user.getNamespace(), userId), userId, true);
    } else {
        if (user.isSetUserName()) {
            result = getEntity(DirectoryUser.class, SearchType.DirectoryUser, getDirectoryUserSearchPattern(user.getUserName(), user.getNamespace(), directoryName));
        }
    }
    return result;
}
#method_after
private DirectoryUser findDirectoryUser(String directoryName, User user) {
    DirectoryUser result = null;
    String namespace = user.getNamespace();
    if (user.isSetDomainEntryId()) {
        result = getUserById(directoryName, namespace, user.getDomainEntryId());
    } else if (user.isSetId()) {
        result = getUserById(directoryName, namespace, user.getId());
    } else {
        if (user.isSetUserName()) {
            result = getEntity(DirectoryUser.class, SearchType.DirectoryUser, getDirectoryUserSearchPattern(isNameContainsDomain(user) ? user.getUserName().substring(0, user.getUserName().lastIndexOf("@")) : user.getUserName(), user.getNamespace(), directoryName));
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void testAddUser_3() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: allnames=" + NAMES[0] + "@" + DOMAIN);
    User model = new User();
    model.setUserName(NAMES[0] + "@" + DOMAIN);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_3() throws Exception {
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ":: allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0] + "@" + DOMAIN);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
@Test
public void testGetAllSnapshotsForLeaf() {
    List<DiskImage> images = dao.getAllSnapshotsForLeaf(FixturesTool.IMAGE_ID);
    assertFalse(images.isEmpty());
}
#method_after
@Test
public void testGetAllSnapshotsForLeaf() {
    List<DiskImage> images = dao.getAllSnapshotsForLeaf(FixturesTool.IMAGE_ID);
    assertFalse(images.isEmpty());
    assertFalse(CollectionUtils.exists(images, new Predicate() {

        public boolean evaluate(Object disk) {
            return ((DiskImage) disk).getVmEntityType() == VmEntityType.TEMPLATE;
        }
    }));
}
#end_block

#method_before
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            List<LogicalNetworkModel> networks = model.getNetworks();
            List<NetworkInterfaceModel> nics = model.getNics();
            updateNetworks(networks);
            updateNics(nics);
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            OperationCadidateEventArgs evtArgs = (OperationCadidateEventArgs) args;
            NetworkOperation candidate = evtArgs.getCandidate();
            NetworkItemModel<?> op1 = evtArgs.getOp1();
            NetworkItemModel<?> op2 = evtArgs.getOp2();
            if (evtArgs.isDryRun()) {
                return;
            }
            if (candidate == null) {
                setErrorStatus(constants.noValidActionSetupNetwork());
            } else {
                if (candidate.isErroneousOperation()) {
                    setErrorStatus(candidate.getMessage(op1, op2));
                } else {
                    if (candidate.isDisplayNetworkAffected(op1, op2)) {
                        setWarningStatus(applicationMessages.moveDisplayNetworkWarning(candidate.getMessage(op1, op2)));
                    } else {
                        setValidStatus(candidate.getMessage(op1, op2));
                    }
                }
            }
        }
    });
    internalNetworkList.setSetupModel(uicommonModel);
    externalNetworkList.setSetupModel(uicommonModel);
}
#method_after
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            List<LogicalNetworkModel> networks = model.getNetworks();
            List<NetworkInterfaceModel> nics = model.getNics();
            if (!keepStatusText) {
                initStatusPanel();
            }
            keepStatusText = false;
            updateNetworks(networks);
            updateNics(nics);
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            OperationCadidateEventArgs evtArgs = (OperationCadidateEventArgs) args;
            NetworkOperation candidate = evtArgs.getCandidate();
            NetworkItemModel<?> op1 = evtArgs.getOp1();
            NetworkItemModel<?> op2 = evtArgs.getOp2();
            if (candidate == null) {
                setErrorStatus(constants.noValidActionSetupNetwork());
            } else {
                if (candidate.isErroneousOperation()) {
                    setErrorStatus(candidate.getMessage(op1, op2));
                } else {
                    if (candidate.isDisplayNetworkAffected(op1, op2)) {
                        setWarningStatus(applicationMessages.moveDisplayNetworkWarning(candidate.getMessage(op1, op2)));
                    } else {
                        setValidStatus(candidate.getMessage(op1, op2));
                    }
                }
            }
        }
    });
    internalNetworkList.setSetupModel(uicommonModel);
    externalNetworkList.setSetupModel(uicommonModel);
}
#end_block

#method_before
private void setValidStatus(String message) {
    statusPanel.setTextAndStyle(message, style.statusPanel(), style.statusLabel());
}
#method_after
private void setValidStatus(String message) {
    keepStatusText = false;
    statusPanel.setTextAndStyle(message, style.statusPanel(), style.statusLabel());
}
#end_block

#method_before
private void setWarningStatus(String message) {
    statusPanel.setTextAndStyle(message, style.warningPanel(), style.warningLabel());
}
#method_after
private void setWarningStatus(String message) {
    keepStatusText = true;
    statusPanel.setTextAndStyle(message, style.warningPanel(), style.warningLabel());
}
#end_block

#method_before
private void setErrorStatus(String message) {
    statusPanel.setTextAndStyle(message, style.errorPanel(), style.errorLabel());
}
#method_after
private void setErrorStatus(String message) {
    keepStatusText = false;
    statusPanel.setTextAndStyle(message, style.errorPanel(), style.errorLabel());
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (NIC.equals(op1Type)) {
        nic1 = nicMap.get(op1Key);
    } else if (NETWORK.equals(op1Type)) {
        network1 = networkMap.get(op1Key);
    }
    if (NIC.equals(op2Type)) {
        nic2 = nicMap.get(op2Key);
    } else if (NETWORK.equals(op2Type)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    return candidateOperation(op1, op2, drop, false);
}
#method_after
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (NIC.equals(op1Type)) {
        nic1 = nicMap.get(op1Key);
    } else if (NETWORK.equals(op1Type)) {
        network1 = networkMap.get(op1Key);
    }
    if (NIC.equals(op2Type)) {
        nic2 = nicMap.get(op2Key);
    } else if (NETWORK.equals(op2Type)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    return candidateOperation(op1, op2, drop);
}
#end_block

#method_before
private boolean candidateOperation(NetworkItemModel<?> op1, NetworkItemModel<?> op2, boolean drop, boolean dryRun) {
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop && !dryRun) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed or if a drop occurred
    if (drop || !candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCadidateEventArgs(candidate, op1, op2, drop, dryRun));
    }
    return !candidate.isNullOperation();
}
#method_after
private boolean candidateOperation(NetworkItemModel<?> op1, NetworkItemModel<?> op2, boolean drop) {
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCadidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#end_block

#method_before
private boolean validateLabelChanges(Collection<LogicalNetworkModel> potentialNetworks) {
    NetworkInterfaceModel mockSrc = new NetworkInterfaceModel(this);
    NetworkInterfaceModel mockDst = new NetworkInterfaceModel(this);
    mockSrc.setEntity(new VdsNetworkInterface());
    mockDst.setEntity(new VdsNetworkInterface());
    mockDst.setItems(new ArrayList<LogicalNetworkModel>(potentialNetworks));
    boolean res = candidateOperation(mockSrc, mockDst, false, true);
    if (!res) {
        // trick to get a red-highlighted error status
        candidateOperation(mockSrc, mockDst, true, false);
    }
    return res;
}
#method_after
private boolean validateLabelChanges(Collection<LogicalNetworkModel> potentialNetworks) {
    NetworkInterfaceModel mockSrc = new NetworkInterfaceModel(this);
    NetworkInterfaceModel mockDst = new NetworkInterfaceModel(this);
    mockSrc.setEntity(new VdsNetworkInterface());
    mockDst.setEntity(new VdsNetworkInterface());
    mockDst.setItems(new ArrayList<LogicalNetworkModel>(potentialNetworks));
    boolean res = candidateOperation(mockSrc, mockDst, false);
    if (!res) {
        // trick to get a red-highlighted error status
        candidateOperation(mockSrc, mockDst, true);
    }
    return res;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        Set<String> usageNics = new HashSet<String>();
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!Boolean.TRUE.equals(iface.getBonded()) && !iface.isVlanDevice()) {
                    usageNics.add(iface.isBondSlave() ? iface.getBondName() : iface.getName());
                }
            }
        }
        double networkUsage = 0;
        int networkCapacity = 0;
        for (String nicName : usageNics) {
            VdsNetworkInterface iface = nicsByName.get(nicName);
            networkUsage += iface.getSpeed() * (truncatePercentage(iface.getStatistics().getReceiveRate()) + truncatePercentage(iface.getStatistics().getTransmitRate()));
            // TODO: this assumes full-duplex, when half-duplex is reported only count speed once
            networkCapacity += 2 * iface.getSpeed();
        }
        vds.setUsageNetworkPercent((int) (networkUsage / networkCapacity));
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
public boolean isBondSlave() {
    return bondName != null;
}
#method_after
public boolean isBondSlave() {
    return getBondName() != null;
}
#end_block

#method_before
private boolean validate() {
    boolean valid = true;
    Set<String> encounteredNames = new HashSet<String>();
    Set<String> duplicateNames = new HashSet<String>();
    for (ExternalNetwork network : (Iterable<ExternalNetwork>) importedNetworks.getItems()) {
        String networkName = network.getDisplayName();
        if (encounteredNames.contains(networkName)) {
            duplicateNames.add(networkName);
            valid = false;
        } else {
            encounteredNames.add(networkName);
        }
    }
    if (!valid) {
        Frontend.getInstance().getFrontendFailureEvent().raise(this, new FrontendFailureEventArgs(Collections.singletonList(new Message(ConstantsManager.getInstance().getMessages().duplicateNetworkNamesOnImport(// $NON-NLS-1$
        StringUtils.join(duplicateNames, ", "))))));
    }
    return valid;
}
#method_after
private boolean validate() {
    String errorDuplicate = ConstantsManager.getInstance().getConstants().importDuplicateName();
    boolean valid = true;
    Collection<ExternalNetwork> networks = importedNetworks.getItems();
    List<String> errors = new ArrayList<String>(networks.size());
    Map<String, Integer> nameToIndex = new HashMap<String, Integer>();
    int i = 0;
    for (ExternalNetwork network : networks) {
        String networkName = network.getDisplayName();
        Integer encounteredIndex = nameToIndex.get(networkName);
        // if this name has been encountered, invalidate that entry; else store it for future invalidation
        if (encounteredIndex != null) {
            errors.set(encounteredIndex, errorDuplicate);
            valid = false;
        } else {
            nameToIndex.put(networkName, i);
        }
        // invalidate current entry
        errors.add(encounteredIndex == null ? null : errorDuplicate);
        ++i;
    }
    getErrors().setItems(errors);
    return valid;
}
#end_block

#method_before
public void validate(List<String> errors) {
    for (int i = 0; i < getRowCount(); ++i) {
        String error = errors.get(i);
        Element element = getRowElement(i);
        boolean valid = StringUtils.isEmpty(error);
        element.setTitle(valid ? null : error);
        element.getStyle().setOutlineStyle(valid ? OutlineStyle.NONE : OutlineStyle.SOLID);
        // $NON-NLS-1$
        element.getStyle().setOutlineColor("red");
        element.getStyle().setOutlineWidth(1, Unit.PX);
    }
}
#method_after
public void validate(List<String> errors) {
    for (int i = 0; i < getRowCount(); ++i) {
        String error = errors.get(i);
        Element element = getRowElement(i);
        boolean valid = StringUtils.isEmpty(error);
        element.setTitle(valid ? null : error);
        if (!valid) {
            element.addClassName(style.invalidRow());
        } else {
            element.removeClassName(style.invalidRow());
        }
    }
}
#end_block

#method_before
public DiskProfile getProfile() {
    if (profile == null) {
        if (getParameters().getProfile() == null) {
            if (getParameters().getProfileId() != null) {
                profile = getProfileDao().get(getParameters().getProfileId());
            }
        } else {
            profile = getParameters().getProfile();
        }
    }
    return profile;
}
#method_after
public DiskProfile getProfile() {
    if (profile == null) {
        if (getParameters().getProfile() != null) {
            profile = getParameters().getProfile();
        } else if (getParameters().getProfileId() != null) {
            profile = getProfileDao().get(getParameters().getProfileId());
        }
    }
    return profile;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters) {
    try {
        Constructor<CommandBase<? extends VdcActionParametersBase>> constructor = findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass());
        return (CommandBase<P>) constructor.newInstance(new Object[] { parameters });
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command " + action.name() + ". Exception is ", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command " + action.name(), ex);
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters) {
    return createCommand(action, parameters, null);
}
#end_block

#method_before
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        return (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters, CommandContext commandContext) {
    try {
        CommandBase<P> result = null;
        if (commandContext == null) {
            result = (CommandBase<P>) findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass()).newInstance(parameters);
        } else {
            result = (CommandBase<P>) findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass(), commandContext.getClass()).newInstance(parameters, commandContext);
        }
        Injector.injectMembers(result);
        return result;
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command " + action.name() + ". Exception is ", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command " + action.name(), ex);
        return null;
    }
}
#end_block

#method_before
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        return (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#method_after
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        CommandBase<?> cmd = (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
        Injector.injectMembers(cmd);
        return cmd;
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#end_block

#method_before
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters) {
    Class<?> type = null;
    try {
        type = getCommandClass(query.name(), QueryPrefix);
        Constructor<?> info = findCommandConstructor(type, parameters.getClass());
        return (QueriesCommandBase<?>) info.newInstance(parameters);
    } catch (Exception e) {
        log.errorFormat("Command Factory: Failed to create command {0} using reflection\n. {1}", type, e);
        throw new RuntimeException(e);
    }
}
#method_after
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters, EngineContext engineContext) {
    Class<?> type = null;
    try {
        type = getCommandClass(query.name(), QueryPrefix);
        QueriesCommandBase<?> result = null;
        if (engineContext == null) {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass()).newInstance(parameters);
        } else {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass(), EngineContext.class).newInstance(parameters, engineContext);
        }
        return result;
    } catch (Exception e) {
        log.errorFormat("Command Factory: Failed to create command {0} using reflection\n. {1}", type, e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    DiskProfileValidator validator = new DiskProfileValidator(getParameters().getProfile());
    return validate(validator.diskProfileIsSet()) && validate(validator.diskProfileExists()) && validate(validator.diskProfileNameNotUsed()) && validate(validator.storageDomainNotChanged()) && validate(validator.qosExistsOrNull());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getDiskProfileDao().update(getParameters().getProfile());
}
#method_after
@Override
protected void executeCommand() {
    getDiskProfileDao().update(getParameters().getProfile());
    getReturnValue().setActionReturnValue(getParameters().getProfile().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    DiskProfileValidator validator = new DiskProfileValidator(getProfile());
    return validate(validator.diskProfileIsSet()) && validate(validator.diskProfileExists());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getDbFacade().getDiskProfileDao().remove(getParameters().getProfileId());
}
#method_after
@Override
protected void executeCommand() {
    getDbFacade().getDiskProfileDao().remove(getParameters().getProfileId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getParameters().getProfile().getStorageDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getParameters().getProfileId(), VdcObjectType.DiskProfile, getActionType().getActionGroup()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    DiskProfileValidator validator = new DiskProfileValidator(getParameters().getProfile());
    return validate(validator.diskProfileIsSet()) && validate(validator.storageDomainExists()) && validate(validator.qosExistsOrNull()) && validate(validator.diskProfileNameNotUsed());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getParameters().getProfile().getStorageDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getParameters().getProfile() != null ? getParameters().getProfile().getStorageDomainId() : null, VdcObjectType.Storage, getActionType().getActionGroup()));
}
#end_block

#method_before
public void setProfile(T Profile) {
    this.profile = Profile;
}
#method_after
public void setProfile(T profile) {
    this.profile = profile;
}
#end_block

#method_before
public void setProfileId(Guid ProfileId) {
    this.profileId = ProfileId;
}
#method_after
public void setProfileId(Guid profileId) {
    this.profileId = profileId;
}
#end_block

#method_before
private static RoleNode initTreeView() {
    RoleNode tree = new RoleNode(getConstants().rootRoleTree(), new RoleNode[] { createSystemRoleTree(), createDataCenterRoleTree(), createNetworkRoleTree(), createStorageDomainRoleTree(), createClusterRoleTree(), createGlusterRoleTree(), createHostRoleTree(), createTemplateRoleTree(), createVmRoleTree(), createVmPoolRoleTree(), createDiskRoleTree() });
    // nothing to filter
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterActionGroupTreeByApplictionMode(tree);
    }
    return tree;
}
#method_after
private static RoleNode initTreeView() {
    RoleNode tree = new RoleNode(getConstants().rootRoleTree(), new RoleNode[] { createSystemRoleTree(), createDataCenterRoleTree(), createNetworkRoleTree(), createStorageDomainRoleTree(), createClusterRoleTree(), createGlusterRoleTree(), createHostRoleTree(), createTemplateRoleTree(), createVmRoleTree(), createVmPoolRoleTree(), createDiskRoleTree(), createMacPoolRoleTree() });
    // nothing to filter
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterActionGroupTreeByApplictionMode(tree);
    }
    return tree;
}
#end_block

#method_before
public static HttpClient getClient() {
    HttpClient httpClient = new HttpClient();
    if (Config.<Boolean>GetValue(ConfigValues.SecureConnectionWithOATServers)) {
        URL trustStoreUrl;
        try {
            int port = Config.<Integer>GetValue(ConfigValues.AttestationPort);
            trustStoreUrl = new URL("file://" + Config.resolveAttestationTrustStorePath());
            String truststorePassword = Config.<String>GetValue(ConfigValues.AttestationTruststorePass);
            String attestationServer = Config.<String>GetValue(ConfigValues.AttestationServer);
            // registering the https protocol with a socket factory that
            // provides client authentication.
            ProtocolSocketFactory factory = new AuthSSLProtocolSocketFactory(getTrustStore(trustStoreUrl.getPath(), truststorePassword));
            Protocol clientAuthHTTPS = new Protocol("https", factory, port);
            httpClient.getHostConfiguration().setHost(attestationServer, port, clientAuthHTTPS);
        } catch (Exception e) {
            log.fatal("Failed to init AuthSSLProtocolSocketFactory. SSL connections will not work", e);
        }
    }
    return httpClient;
}
#method_after
public static HttpClient getClient() {
    HttpClient httpClient = new HttpClient();
    if (Config.<Boolean>getValue(ConfigValues.SecureConnectionWithOATServers)) {
        URL trustStoreUrl;
        try {
            int port = Config.<Integer>getValue(ConfigValues.AttestationPort);
            trustStoreUrl = new URL("file://" + Config.resolveAttestationTrustStorePath());
            String truststorePassword = Config.<String>getValue(ConfigValues.AttestationTruststorePass);
            String attestationServer = Config.<String>getValue(ConfigValues.AttestationServer);
            // registering the https protocol with a socket factory that
            // provides client authentication.
            ProtocolSocketFactory factory = new AuthSSLProtocolSocketFactory(getTrustStore(trustStoreUrl.getPath(), truststorePassword));
            Protocol clientAuthHTTPS = new Protocol("https", factory, port);
            httpClient.getHostConfiguration().setHost(attestationServer, port, clientAuthHTTPS);
        } catch (Exception e) {
            log.fatal("Failed to init AuthSSLProtocolSocketFactory. SSL connections will not work", e);
        }
    }
    return httpClient;
}
#end_block

#method_before
private static KeyStore getTrustStore(String filePath, String password) throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {
    InputStream in = new FileInputStream(filePath);
    KeyStore ks = KeyStore.getInstance("JKS");
    ks.load(in, password.toCharArray());
    return ks;
}
#method_after
private static KeyStore getTrustStore(String filePath, String password) throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {
    KeyStore ks;
    try (InputStream in = new FileInputStream(filePath)) {
        ks = KeyStore.getInstance("JKS");
        ks.load(in, password.toCharArray());
    }
    return ks;
}
#end_block

#method_before
public List<AttestationValue> attestHosts(List<String> hosts) {
    String pollURI = Config.<String>GetValue(ConfigValues.PollUri);
    List<AttestationValue> values = new ArrayList<AttestationValue>();
    PostMethod postMethod = new PostMethod("/" + pollURI);
    try {
        postMethod.setRequestEntity(new StringRequestEntity(writeListJson(hosts)));
        postMethod.addRequestHeader("Accept", CONTENT_TYPE);
        postMethod.addRequestHeader("Content-type", CONTENT_TYPE);
        HttpClient httpClient = getClient();
        int statusCode = httpClient.executeMethod(postMethod);
        String strResponse = postMethod.getResponseBodyAsString();
        log.debug("return attested result:" + strResponse);
        if (statusCode == 200) {
            values = parsePostedResp(strResponse);
        } else {
            log.error("attestation error:" + strResponse);
        }
    } catch (JsonParseException e) {
        log.error(String.format("Failed to parse result: [%s]", e.getMessage()), e);
    } catch (IOException e) {
        log.error(String.format("Failed to attest hosts: [%s], make sure hosts are up and reachable", e.getMessage()), e);
    } finally {
        postMethod.releaseConnection();
    }
    return values;
}
#method_after
public List<AttestationValue> attestHosts(List<String> hosts) {
    String pollURI = Config.<String>getValue(ConfigValues.PollUri);
    List<AttestationValue> values = new ArrayList<AttestationValue>();
    PostMethod postMethod = new PostMethod("/" + pollURI);
    try {
        postMethod.setRequestEntity(new StringRequestEntity(writeListJson(hosts)));
        postMethod.addRequestHeader("Accept", CONTENT_TYPE);
        postMethod.addRequestHeader("Content-type", CONTENT_TYPE);
        HttpClient httpClient = getClient();
        int statusCode = httpClient.executeMethod(postMethod);
        String strResponse = postMethod.getResponseBodyAsString();
        log.debug("return attested result:" + strResponse);
        if (statusCode == 200) {
            values = parsePostedResp(strResponse);
        } else {
            log.error("attestation error:" + strResponse);
        }
    } catch (JsonParseException e) {
        log.error(String.format("Failed to parse result: [%s]", e.getMessage()), e);
    } catch (IOException e) {
        log.error(String.format("Failed to attest hosts: [%s], make sure hosts are up and reachable", e.getMessage()), e);
    } finally {
        postMethod.releaseConnection();
    }
    return values;
}
#end_block

#method_before
public List<AttestationValue> parsePostedResp(String str) throws JsonParseException, IOException {
    JsonFactory jfactory = new JsonFactory();
    List<AttestationValue> values = new ArrayList<AttestationValue>();
    JsonParser jParser = jfactory.createJsonParser(str);
    try {
        // START_OBJECT
        jParser.nextToken();
        while (jParser.nextToken() != JsonToken.END_OBJECT) {
            if (jParser.getCurrentName().equalsIgnoreCase(HEADER_HOSTS)) {
                // START_ARRAY
                jParser.nextToken();
                // START_OBJECT
                jParser.nextToken();
                // FIELD_NAME
                jParser.nextToken();
                AttestationValue value = new AttestationValue();
                while (jParser.getCurrentToken() != JsonToken.END_ARRAY) {
                    String fieldname = jParser.getCurrentName();
                    if (fieldname.equalsIgnoreCase(HEADER_HOST_NAME)) {
                        jParser.nextToken();
                        value.setHostName(jParser.getText());
                    } else if (fieldname.equalsIgnoreCase(HEADER_RESULT)) {
                        jParser.nextToken();
                        value.setTrustLevel(AttestationResultEnum.valueOf(jParser.getText().toUpperCase()));
                    } else if (fieldname.equalsIgnoreCase(HEADER_VTIME)) {
                        jParser.nextToken();
                    } else if (!jParser.nextToken().isScalarValue()) {
                        jParser.skipChildren();
                    }
                    if (jParser.nextToken() == JsonToken.END_OBJECT) {
                        log.debug("host_name:" + value.getHostName() + ", trustLevel:" + value.getTrustLevel());
                        values.add(value);
                        value = new AttestationValue();
                        if (jParser.nextToken() == JsonToken.START_OBJECT) {
                            // FIELD_NAME
                            jParser.nextToken();
                        }
                    }
                }
                break;
            } else if (!jParser.nextToken().isScalarValue()) {
                jParser.skipChildren();
            }
        }
    } finally {
        jParser.close();
    }
    return values;
}
#method_after
public List<AttestationValue> parsePostedResp(String str) throws JsonProcessingException, IOException {
    List<AttestationValue> values = new ArrayList<>();
    ObjectMapper mapper = new ObjectMapper();
    JsonNode tree = mapper.readTree(str);
    JsonNode hosts = tree.get(HEADER_HOSTS);
    if (hosts != null) {
        for (JsonNode host : hosts) {
            String name = host.get(HEADER_HOST_NAME).asText();
            String level = host.get(HEADER_RESULT).asText();
            AttestationValue value = new AttestationValue();
            value.setHostName(name);
            value.setTrustLevel(AttestationResultEnum.valueOf(level.toUpperCase()));
            values.add(value);
        }
    }
    return values;
}
#end_block

#method_before
@Override
public String toString() {
    return "Request with " + this.getId() + " id to invoke " + this.getMethod() + " method with " + this.getParams().toString();
}
#method_after
@Override
public String toString() {
    return "<JsonRpcRequest id: " + this.getId() + ", method: " + this.getMethod() + ", params: " + this.getParams().toString() + ">";
}
#end_block

#method_before
public JsonRpcClient register(ReactorClient client) {
    final JsonRpcClient jsonRpcClient = new JsonRpcClient(client);
    client.addEventListener(new MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(new MessageContext(jsonRpcClient, message));
        }
    });
    return jsonRpcClient;
}
#method_after
public JsonRpcClient register(ReactorClient client) {
    final JsonRpcClient jsonRpcClient = new JsonRpcClient(client, this.tracker);
    client.addEventListener(new MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(new MessageContext(jsonRpcClient, message));
        }
    });
    return jsonRpcClient;
}
#end_block

#method_before
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            log.debug("Message received :" + new String(context.getMessage(), UTF8));
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing", e);
            continue;
        }
    }
}
#method_after
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            if (log.isDebugEnabled()) {
                log.debug("Message received: " + new String(context.getMessage(), UTF8));
            }
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing", e);
            continue;
        }
    }
}
#end_block

#method_before
public void close() {
    this.queue.add(new MessageContext(null, null));
}
#method_after
public void close() {
    this.queue.add(new MessageContext(null, null));
    this.tracker.close();
}
#end_block

#method_before
public byte[] toByteArray() {
    ObjectNode node = MAPPER.createObjectNode();
    node.put("jsonrpc", "2.0");
    if (getError() != null) {
        node.put("error", getError());
    }
    if (getResult() != null) {
        node.put("result", getResult());
    }
    if (getId() == null) {
        node.putNull("id");
    } else {
        node.put("id", getId());
    }
    return jsonToByteArray(node, MAPPER);
}
#method_after
public byte[] toByteArray() {
    ObjectNode node = MAPPER.createObjectNode();
    node.put("jsonrpc", "2.0");
    if (getError() != null) {
        node.put("error", getError());
    }
    if (getResult() != null) {
        node.put("result", getResult());
    }
    if (getId() == null) {
        node.putNull("id");
    } else {
        node.put("id", getId());
    }
    return jsonToByteArray(node);
}
#end_block

#method_before
@Override
public String toString() {
    String response = this.getResult() != null ? "result " + this.getResult().toString() : "error " + this.getError().toString();
    return "Response with " + this.getId() + " id containing " + response;
}
#method_after
@Override
public String toString() {
    String response = this.getResult() != null ? " result: " + this.getResult().toString() : " error: " + this.getError().toString();
    return "<JsonRpcResponse id: " + this.getId() + response + ">";
}
#end_block

#method_before
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    LOG.debug("Message sent: " + new String(message, UTF8));
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#method_after
public void send(byte[] message) {
    outbox.addFirst(ByteBuffer.wrap(message));
    if (LOG.isDebugEnabled()) {
        LOG.debug("Message sent: " + new String(message, UTF8));
    }
    final ReactorClient client = this;
    scheduleTask(new Callable<Void>() {

        @Override
        public Void call() throws ClientConnectionException {
            client.updateInterestedOps();
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void processIncoming() throws IOException, ClientConnectionException {
    if (this.ibuff == null) {
        int read = readBuffer(headerBuffer);
        if (read <= 0) {
            return;
        }
        updateLastHeartbeat();
        this.message = getMessage(headerBuffer, read);
        if (this.message == null) {
            clean();
            return;
        }
        int contentLength = this.message.getContentLength();
        if (contentLength == -1) {
            // only for control messages, all other have the header
            emitOnMessageReceived(this.message);
            return;
        }
        int length = this.message.getContent().length;
        if (contentLength == length - 1) {
            emitOnMessageReceived(this.message);
            return;
        } else if (contentLength > length) {
            this.ibuff = ByteBuffer.allocate(contentLength - length + 1);
        } else {
            byte[] content = this.message.getContent();
            this.message.withContent(Arrays.copyOfRange(content, 0, contentLength));
            emitOnMessageReceived(this.message);
            headerBuffer.put(Arrays.copyOfRange(content, contentLength, content.length));
        }
    }
    readBuffer(this.ibuff);
    byte[] additionalContent = this.ibuff.array();
    int length = this.message.getContent().length + additionalContent.length;
    if (this.message.getContentLength() != length - 1) {
        return;
    }
    this.message.withAdditionalContent(additionalContent);
    emitOnMessageReceived(this.message);
}
#method_after
@Override
protected void processIncoming() throws IOException, ClientConnectionException {
    if (this.ibuff == null) {
        int read = readBuffer(headerBuffer);
        if (read <= 0) {
            return;
        }
        updateLastHeartbeat();
        this.message = getMessage(headerBuffer, read);
        if (this.message == null) {
            clean();
            return;
        }
        int contentLength = this.message.getContentLength();
        if (contentLength == -1) {
            // only for control messages, all other have the header
            emitOnMessageReceived(this.message);
            return;
        }
        int length = this.message.getContent().length;
        if (contentLength == length - 1) {
            emitOnMessageReceived(this.message);
            return;
        } else if (contentLength > length) {
            this.ibuff = ByteBuffer.allocate(contentLength - length + 1);
        } else {
            byte[] content = this.message.getContent();
            this.message.withContent(Arrays.copyOfRange(content, 0, contentLength));
            emitOnMessageReceived(this.message);
            headerBuffer.put(Arrays.copyOfRange(content, contentLength, content.length));
        }
    }
    readBuffer(this.ibuff);
    int length = this.message.getContent().length + this.ibuff.position();
    if (this.message.getContentLength() != length - 1) {
        return;
    }
    this.message.withAdditionalContent(this.ibuff.array());
    emitOnMessageReceived(this.message);
}
#end_block

#method_before
public void close() {
    this.queue.add(new MessageContext(null, null));
}
#method_after
public void close() {
    this.queue.add(new MessageContext(null, null));
    this.tracker.close();
}
#end_block

#method_before
public XsrfToken getNewXsrfToken() {
    return new XsrfToken(generateTokenValueResponse());
}
#method_after
@Override
public XsrfToken getNewXsrfToken() {
    return new XsrfToken(generateTokenValueResponse());
}
#end_block

#method_before
private String generateTokenValueResponse() {
    byte[] cookieBytes = getThreadLocalRequest().getSession().getId().getBytes();
    return StringUtils.toHexString(Md5Utils.getMd5Digest(cookieBytes));
}
#method_after
private String generateTokenValueResponse() {
    byte[] tokenBytes = getThreadLocalRequest().getSession().getId().getBytes(// $NON-NLS-1$
    Charset.forName("UTF-8"));
    return StringUtils.toHexString(Md5Utils.getMd5Digest(tokenBytes));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    if (!isStorageFormatSupportedByStoragePool() || !isStorageFormatCompatibleWithDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST);
        getReturnValue().getCanDoActionMessages().add(String.format("$storageFormat %1$s", getStorageDomain().getStorageFormat().toString()));
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType() == StorageType.LOCALFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    if (!isStorageFormatSupportedByStoragePool() || !isStorageFormatCompatibleWithDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST);
        getReturnValue().getCanDoActionMessages().add(String.format("$storageFormat %1$s", getStorageDomain().getStorageFormat()));
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            sd.setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(getTargetStoragePool().getcompatibility_version(), sd.getStorageType()));
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#method_after
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            StoragePool sp = getTargetStoragePool();
            if (sp != null) {
                sd.setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), sd.getStorageType()));
            }
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    Guid vdsId = Guid.newGuid();
    spId = Guid.newGuid();
    connId = Guid.newGuid();
    sd = new StorageDomainStatic();
    sd.setId(Guid.newGuid());
    sd.setStorageType(StorageType.NFS);
    sd.setStorageDomainType(StorageDomainType.Data);
    sd.setStorageName("newStorage");
    sd.setStorageFormat(StorageFormatType.V3);
    sd.setStorage(connId.toString());
    VDS vds = new VDS();
    vds.setId(vdsId);
    vds.setStatus(VDSStatus.Up);
    vds.setStoragePoolId(spId);
    when(vdsDao.get(vdsId)).thenReturn(vds);
    sp = new StoragePool();
    sp.setId(spId);
    sp.setcompatibility_version(Version.v3_5);
    when(spDao.get(spId)).thenReturn(sp);
    StorageServerConnections conn = new StorageServerConnections();
    conn.setid(connId.toString());
    conn.setstorage_type(StorageType.NFS);
    when(sscDao.get(connId.toString())).thenReturn(conn);
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sd);
    params.setVdsId(vdsId);
    cmd = spy(new AddStorageDomainCommon<>(params));
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(sdDao).when(cmd).getStorageDomainDAO();
    doReturn(sdsDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sscDao).when(cmd).getStorageServerConnectionDAO();
}
#method_after
@Before
public void setUp() {
    Guid vdsId = Guid.newGuid();
    spId = Guid.newGuid();
    connId = Guid.newGuid();
    sd = new StorageDomainStatic();
    sd.setId(Guid.newGuid());
    sd.setStorageType(StorageType.NFS);
    sd.setStorageDomainType(StorageDomainType.Data);
    sd.setStorageName("newStorage");
    sd.setStorageFormat(StorageFormatType.V3);
    sd.setStorage(connId.toString());
    vds = new VDS();
    vds.setId(vdsId);
    vds.setStatus(VDSStatus.Up);
    vds.setStoragePoolId(spId);
    when(vdsDao.get(vdsId)).thenReturn(vds);
    sp = new StoragePool();
    sp.setId(spId);
    sp.setcompatibility_version(Version.v3_5);
    when(spDao.get(spId)).thenReturn(sp);
    StorageServerConnections conn = new StorageServerConnections();
    conn.setid(connId.toString());
    conn.setstorage_type(StorageType.NFS);
    when(sscDao.get(connId.toString())).thenReturn(conn);
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sd);
    params.setVdsId(vdsId);
    cmd = spy(new AddStorageDomainCommon<>(params));
    doReturn(vdsDao).when(cmd).getVdsDAO();
    doReturn(sdDao).when(cmd).getStorageDomainDAO();
    doReturn(sdsDao).when(cmd).getStorageDomainStaticDAO();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(sscDao).when(cmd).getStorageServerConnectionDAO();
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} or one of the groups he is member of, have the following permissions: {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.infoFormat("No permission found for user {0} or one of the groups he is member of," + " when running action {1}, Required permissions are: Action type: {2} Action group: {3}" + " Object type: {4}  Object ID: {5}.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        if (exceptionOccurred) {
            clearChildAsyncTasksWithOutVdsmId();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (log.isDebugEnabled()) {
        logInfo.append(getParameters() != null ? "(" + getCommandParamatersString(getParameters()) + ")" : StringUtils.EMPTY);
    }
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = getPermissionSubjectsAsStringBuilder(permissionSubjectList);
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                log.infoFormat("Command {0} persisting async task placeholder for child command {1}", getCommandId(), command.getCommandId());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
protected VdcActionType getActionType() {
    try {
        if (actionType == null) {
            String name = getClass().getName();
            name = name.substring(0, name.length() - 7);
            name = name.substring(name.lastIndexOf('.') + 1);
            actionType = VdcActionType.valueOf(name);
        }
        return actionType;
    } catch (Exception e) {
        return VdcActionType.Unknown;
    }
}
#method_after
public VdcActionType getActionType() {
    try {
        if (actionType == null) {
            String name = getClass().getName();
            name = name.substring(0, name.length() - 7);
            name = name.substring(name.lastIndexOf('.') + 1);
            actionType = VdcActionType.valueOf(name);
        }
        return actionType;
    } catch (Exception e) {
        return VdcActionType.Unknown;
    }
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand) {
    persistCommand(parentCommand, getContext(), false);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallBack), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.updateCommandExecuted(getCommandId());
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = TaskManagerUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            TaskManagerUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallBackEnabled()), getContext());
            TaskManagerUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected void updateDeviceProperties() {
    oldVmDevice.setIsPlugged(false);
    oldVmDevice.setAddress("");
    getVmDeviceDao().update(oldVmDevice);
}
#method_after
@Override
protected void updateDeviceProperties() {
    oldVmDevice.setIsPlugged(false);
    oldVmDevice.setAddress("");
    getVmDeviceDao().update(oldVmDevice);
}
#end_block

#method_before
@Before
public void setUp() {
    validation = new LinuxMountPointValidation() {

        /**
         * Stubbed away to avoid GWT dependencies
         */
        @Override
        protected String composeMessage() {
            return null;
        }
    };
}
#method_after
@Before
public void setUp() {
    validation = new LinuxMountPointValidation();
}
#end_block

#method_before
public static void init(final EventBus eventBus) {
    commonModel = CommonModel.newInstance();
    ModelInitializedEvent.fire(eventBus);
    commonModel.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            MainModelSelectionChangeEvent.fire(eventBus, commonModel.getSelectedItem());
        }
    });
    commonModel.getSignedOutEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Clear CommonModel reference after the user signs out,
            // use deferred command to ensure the reference is cleared
            // only after all UiCommon-related processing is over
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    commonModel = null;
                }
            });
        }
    });
}
#method_after
public static void init(final EventBus eventBus) {
    commonModel = CommonModel.newInstance();
    commonModel.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            MainModelSelectionChangeEvent.fire(eventBus, commonModel.getSelectedItem());
        }
    });
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl(), ReportInit.getInstance().getSsoToken());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    instanceTypeListModel = new InstanceTypeListModel();
    list.add(instanceTypeListModel);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl(), ReportInit.getInstance().getSsoToken());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    instanceTypeListModel = new InstanceTypeListModel();
    list.add(instanceTypeListModel);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    sharedMacPoolListModel = new SharedMacPoolListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { roleListModel, systemPermissionListModel, clusterPolicyListModel });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#method_after
public void configure() {
    if (getWindow() != null) {
        return;
    }
    EntityModel model = new EntityModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().ConfigureTitle());
    model.setHelpTag(HelpTag.configure);
    // $NON-NLS-1$
    model.setHashName("configure");
    model.setEntity(new Model[] { roleListModel, systemPermissionListModel, clusterPolicyListModel, sharedMacPoolListModel });
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("Cancel", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
    tempVar.setIsDefault(true);
    tempVar.setIsCancel(true);
    model.getCommands().add(tempVar);
}
#end_block

#method_before
@Override
protected void beforeLogin(LoginModel loginModel) {
    CommonModelManager.init(eventBus);
}
#method_after
@Override
protected void beforeLogin(LoginModel loginModel) {
    CommonModelManager.init(eventBus);
    ModelInitializedEvent.fire(eventBus);
}
#end_block

#method_before
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            Window.Location.reload();
        }
    };
    frontend.logoffAsync(frontend.getLoggedInUser(), query);
}
#method_after
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // Reload entire application after the user has logged out successfully on backend.
            Window.Location.reload();
        }
    };
    frontend.logoffAsync(frontend.getLoggedInUser(), query);
}
#end_block

#method_before
public Mocks getMocks() {
    if (env == null) {
        // $NON-NLS-1$
        throw new RuntimeException("getMocks() can be called only from a JUnit test/lifecycle method");
    }
    return env.mocks;
}
#method_after
public Mocks getMocks() {
    if (env == null) {
        // $NON-NLS-1$
        throw new IllegalStateException("getMocks() is scoped to test rule execution context");
    }
    return env.mocks;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getNetworkClusterDAO().remove(getParameters().getVdsGroupId(), getParameters().getNetworkCluster().getNetworkId());
            return null;
        }
    });
    if (!getPersistedNetwork().isExternal() && NetworkUtils.isLabeled(getPersistedNetwork()) && NetworkHelper.setupNetworkSupported(getVdsGroup().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getNetworkClusterDAO().remove(getParameters().getVdsGroupId(), getParameters().getNetworkCluster().getNetworkId());
            return null;
        }
    });
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getPersistedNetwork(), getVdsGroup().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeNetworkFromHosts() {
    NetworkHelper.removeNetworkFromHostsInCluster(getPersistedNetwork(), getParameters().getVdsGroupId(), getContext(), getDbFacade().getInterfaceDao());
}
#method_after
private void removeNetworkFromHosts() {
    NetworkHelper.removeNetworkFromHostsInCluster(getPersistedNetwork(), getParameters().getVdsGroupId(), cloneContextAndDetachFromParent());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDAO().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    } else {
        if (NetworkUtils.isLabeled(getNetwork()) && NetworkHelper.setupNetworkSupported(getStoragePool().getcompatibility_version())) {
            removeNetworkFromHosts();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDAO().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork(), getStoragePool().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeNetworkFromHosts() {
    NetworkHelper.removeNetworkFromHostsInDataCenter(getNetwork(), getStoragePoolId(), getContext(), getDbFacade().getInterfaceDao());
}
#method_after
private void removeNetworkFromHosts() {
    NetworkHelper.removeNetworkFromHostsInDataCenter(getNetwork(), getStoragePoolId(), cloneContextAndDetachFromParent());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    NetworkValidator validator = new NetworkValidator(getNetworkDAO().get(getNetwork().getId()));
    return validate(validator.networkIsSet()) && validate(validator.notManagementNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates());
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkValidator validator = new NetworkValidator(getNetworkDAO().get(getNetwork().getId()));
    return validate(validator.networkIsSet()) && validate(validator.notManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates());
}
#end_block

#method_before
public static void addPermissionsOnNetwork(Guid userId, Guid networkId) {
    addPermission(userId, networkId, PredefinedRoles.NETWORK_ADMIN, VdcObjectType.Network);
}
#method_after
public static void addPermissionsOnNetwork(Guid userId, Guid networkId) {
    MultiLevelAdministrationHandler.addPermission(userId, networkId, PredefinedRoles.NETWORK_ADMIN, VdcObjectType.Network);
}
#end_block

#method_before
public static void addPermissionsOnVnicProfile(Guid userId, Guid vnicProfileId, boolean publicUse) {
    addPermission(userId, vnicProfileId, PredefinedRoles.NETWORK_ADMIN, VdcObjectType.VnicProfile);
    // if the profile is for public use, set EVERYONE as a VNICProfileUser on the profile
    if (publicUse) {
        addPermission(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, vnicProfileId, PredefinedRoles.VNIC_PROFILE_USER, VdcObjectType.VnicProfile);
    }
}
#method_after
public static void addPermissionsOnVnicProfile(Guid userId, Guid vnicProfileId, boolean publicUse) {
    MultiLevelAdministrationHandler.addPermission(userId, vnicProfileId, PredefinedRoles.NETWORK_ADMIN, VdcObjectType.VnicProfile);
    // if the profile is for public use, set EVERYONE as a VNICProfileUser on the profile
    if (publicUse) {
        MultiLevelAdministrationHandler.addPermission(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, vnicProfileId, PredefinedRoles.VNIC_PROFILE_USER, VdcObjectType.VnicProfile);
    }
}
#end_block

#method_before
public static void removeNetworkFromHostsInCluster(Network network, Guid clusterId, CommandContext context, InterfaceDao interfaceDao) {
    List<VdsNetworkInterface> nics = interfaceDao.getAllInterfacesByLabelForCluster(clusterId, network.getLabel());
    removeNetworkFromHosts(network, context, nics);
}
#method_after
public static void removeNetworkFromHostsInCluster(Network network, Guid clusterId, CommandContext context) {
    List<VdsNetworkInterface> nics = DbFacade.getInstance().getInterfaceDao().getAllInterfacesByLabelForCluster(clusterId, network.getLabel());
    removeNetworkFromHosts(network, context, nics);
}
#end_block

#method_before
public static void removeNetworkFromHostsInDataCenter(Network network, Guid dataCenterId, CommandContext context, InterfaceDao interfaceDao) {
    List<VdsNetworkInterface> nics = interfaceDao.getAllInterfacesByLabelForDataCenter(dataCenterId, network.getLabel());
    removeNetworkFromHosts(network, context, nics);
}
#method_after
public static void removeNetworkFromHostsInDataCenter(Network network, Guid dataCenterId, CommandContext context) {
    List<VdsNetworkInterface> nics = DbFacade.getInstance().getInterfaceDao().getAllInterfacesByLabelForDataCenter(dataCenterId, network.getLabel());
    removeNetworkFromHosts(network, context, nics);
}
#end_block

#method_before
protected static void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(network, context);
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(nics);
    if (!parameters.isEmpty()) {
        NetworkParametersBuilder.updateParametersSequencing(parameters);
        Backend.getInstance().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters, context);
    }
}
#method_after
private static void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(network, context);
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(nics);
    if (!parameters.isEmpty()) {
        NetworkParametersBuilder.updateParametersSequencing(parameters);
        Backend.getInstance().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters, context);
    }
}
#end_block

#method_before
@Override
public List<VdsNetworkInterface> getAllInterfacesByLabelForDataCenter(Guid dataCenterId, String label) {
    List<VdsNetworkInterface> result = new ArrayList<>();
    for (VdsNetworkInterface vdsNetworkInterface : getAllInterfacesByDataCenterId(dataCenterId)) {
        final Set<String> labels = vdsNetworkInterface.getLabels();
        if (labels != null && labels.contains(label)) {
            result.add(vdsNetworkInterface);
        }
    }
    return result;
}
#method_after
@Override
public List<VdsNetworkInterface> getAllInterfacesByLabelForDataCenter(Guid dataCenterId, String label) {
    return nicsContainingLabel(getAllInterfacesByDataCenterId(dataCenterId), label);
}
#end_block

#method_before
@Override
public List<VdsNetworkInterface> getAllInterfacesByLabelForCluster(Guid clusterId, String label) {
    List<VdsNetworkInterface> labelledNics = new ArrayList<>();
    for (VdsNetworkInterface nic : getAllInterfacesByClusterId(clusterId)) {
        if (nic.getLabels() != null && nic.getLabels().contains(label)) {
            labelledNics.add(nic);
        }
    }
    return labelledNics;
}
#method_after
@Override
public List<VdsNetworkInterface> getAllInterfacesByLabelForCluster(Guid clusterId, String label) {
    return nicsContainingLabel(getAllInterfacesByClusterId(clusterId), label);
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} has permission on {1} groups with {2} action group on {3} object with {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, HashSet<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debugFormat("Checking whether user {0} or groups {1} have action group {3} on object type {4}", userId, StringUtils.join(groupIds, ","), actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} has permission on {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debugFormat("Checking whether user {0} or one of the groups he is member of, have the following permissions: {1}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.infoFormat("No permission found for user {0} or one of the groups he is member of," + " when running action {1}, Required permissions are: Action type: {2} Action group: {3}" + " Object type: {4}  Object ID: {5}.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public ValidationResult vmQualifiedForSnapshotMerge() {
    for (VM vm : vms) {
        if (!vm.isQualifiedForSnapshotMerge()) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmQualifiedForSnapshotMerge() {
    for (VM vm : vms) {
        if (!vm.isQualifiedForSnapshotMerge()) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP, String.format("$VmName %s", vm.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult vmHostCanLiveMerge() {
    for (VM vm : vms) {
        if (!vm.isDown() && ((vm.getRunOnVds() == null || !DbFacade.getInstance().getVdsDao().get(vm.getRunOnVds()).getLiveMergeSupport()))) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_HOST_CANNOT_LIVE_MERGE);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmHostCanLiveMerge() {
    for (VM vm : vms) {
        if (!vm.isDown() && ((vm.getRunOnVds() == null || !DbFacade.getInstance().getVdsDao().get(vm.getRunOnVds()).getLiveMergeSupport()))) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_HOST_CANNOT_LIVE_MERGE, String.format("$VmName %s", vm.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(Boolean.FALSE);
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#end_block

#method_before
private void updateIsLiveMergeSupported(Object entity) {
    if (entity == null) {
        return;
    }
    VM vm = (VM) entity;
    if (vm.getRunOnVds() == null || !AsyncDataProvider.getInstance().isLiveMergeSupported(vm)) {
        setLiveMergeSupported(false);
        return;
    }
    // TODO GP
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VmSnapshotListModel target = (VmSnapshotListModel) model;
            VDS vds = (VDS) returnValue;
            target.setLiveMergeSupported(vds.getLiveMergeSupport());
        }
    });
    AsyncDataProvider.getInstance().getHostById(query, vm.getRunOnVds());
}
#method_after
private void updateIsLiveMergeSupported(Object entity) {
    if (entity == null) {
        return;
    }
    VM vm = (VM) entity;
    if (vm.getRunOnVds() == null || !AsyncDataProvider.getInstance().isLiveMergeSupported(vm)) {
        setLiveMergeSupported(false);
        return;
    }
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) model;
            VDS vds = (VDS) returnValue;
            vmSnapshotListModel.setLiveMergeSupported(vds.getLiveMergeSupport());
        }
    });
    AsyncDataProvider.getInstance().getHostById(query, vm.getRunOnVds());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (FeatureSupported.liveMerge(getVm().getVdsGroupCompatibilityVersion())) {
            if (!getVm().isQualifiedForSnapshotMerge() || getVm().getRunOnVds() == null || !getVdsDAO().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
                log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused," + " or is running on a host that does not support Live Merge");
                throw new VdcBLLException(VdcBllErrors.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
            }
        } else {
            log.error("Cannot remove VM snapshot. Vm is not Down and cluster version does not support Live Merge");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (FeatureSupported.liveMerge(getVm().getVdsGroupCompatibilityVersion())) {
            if (!getVm().isQualifiedForSnapshotMerge()) {
                log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
                throw new VdcBLLException(VdcBllErrors.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
            } else if (getVm().getRunOnVds() == null || !getVdsDAO().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
                log.error("Cannot remove VM snapshot. The host on which VM is running does not support Live Merge");
                throw new VdcBLLException(VdcBllErrors.VM_HOST_CANNOT_LIVE_MERGE);
            }
        } else {
            log.error("Cannot remove VM snapshot. Vm is not Down and cluster version does not support Live Merge");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
    }
    setSucceeded(true);
}
#end_block

#method_before
public void setLiveMergeSupport(Boolean value) {
    this.mVdsDynamic.setLiveMergeSupport(value);
}
#method_after
public void setLiveMergeSupport(boolean value) {
    this.mVdsDynamic.setLiveMergeSupport(value);
}
#end_block

#method_before
public Boolean getLiveMergeSupport() {
    return this.mVdsDynamic.getLiveMergeSupport();
}
#method_after
public boolean getLiveMergeSupport() {
    return this.mVdsDynamic.getLiveMergeSupport();
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval) * 1000;
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.debug(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        if (fencingPolicy.isSkipFencingIfSDActive()) {
            // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
            // so we need to be sure not to execute fencing before host is non responsive for longer time
            long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
            long difference = System.currentTimeMillis() - getParameters().getLastUpdate();
            if (difference < interval) {
                int sleepMs = (int) (interval - difference);
                log.info(String.format("Sleeping %s ms before proceeding with fence execution", sleepMs));
                ThreadUtils.sleep(sleepMs);
            }
        }
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#end_block

#method_before
private void handleSingleAgent(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence();
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            executor = createFenceExecutor(FenceActionType.Status);
            if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Primary)) {
                handleSpecificCommandActions();
            } else {
                handleWaitFailure(lastStatus, FenceAgentOrder.Primary);
            }
        } else {
            handleError(lastStatus, vdsReturnValue, FenceAgentOrder.Primary);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void handleSingleAgent(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence();
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            if (wasSkippedDueToPolicy(vdsReturnValue.getReturnValue())) {
                // fencing execution was skipped due to fencing policy
                handleFencingSkippedDueToPolicy(vdsReturnValue);
                return;
            } else {
                executor = createFenceExecutor(FenceActionType.Status);
                if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Primary)) {
                    handleSpecificCommandActions();
                } else {
                    handleWaitFailure(lastStatus, FenceAgentOrder.Primary);
                }
            }
        } else {
            handleError(lastStatus, vdsReturnValue, FenceAgentOrder.Primary);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
private void handleMultipleSequentialAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence(FenceAgentOrder.Primary);
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            executor = createFenceExecutor(FenceActionType.Status);
            if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Primary)) {
                handleSpecificCommandActions();
            } else {
                // set the executor to perform the action
                executor = createFenceExecutor(getParameters().getAction());
                tryOtherSequentialAgent(lastStatus, vdsReturnValue);
            }
        } else {
            tryOtherSequentialAgent(lastStatus, vdsReturnValue);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void handleMultipleSequentialAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence(FenceAgentOrder.Primary);
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            if (wasSkippedDueToPolicy(vdsReturnValue.getReturnValue())) {
                // fencing execution was skipped due to fencing policy
                handleFencingSkippedDueToPolicy(vdsReturnValue);
                return;
            } else {
                executor = createFenceExecutor(FenceActionType.Status);
                if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Primary)) {
                    handleSpecificCommandActions();
                } else {
                    // set the executor to perform the action
                    executor = createFenceExecutor(getParameters().getAction());
                    tryOtherSequentialAgent(lastStatus, vdsReturnValue);
                }
            }
        } else {
            tryOtherSequentialAgent(lastStatus, vdsReturnValue);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
private void tryOtherSequentialAgent(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence(FenceAgentOrder.Secondary);
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            executor = createFenceExecutor(FenceActionType.Status);
            if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Secondary)) {
                // raise an alert that secondary agent was used
                AuditLogableBase logable = new AuditLogableBase();
                logable.setVdsId(getVds().getId());
                logable.addCustomValue("Operation", getParameters().getAction().name());
                AuditLogDirector.log(logable, AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION);
                handleSpecificCommandActions();
            } else {
                handleWaitFailure(lastStatus, FenceAgentOrder.Secondary);
            }
        } else {
            handleError(lastStatus, vdsReturnValue, FenceAgentOrder.Secondary);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void tryOtherSequentialAgent(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    executor = createFenceExecutor(getParameters().getAction());
    if (executor.findProxyHost()) {
        vdsReturnValue = executor.fence(FenceAgentOrder.Secondary);
        setFenceSucceeded(vdsReturnValue.getSucceeded());
        if (getFenceSucceeded()) {
            if (wasSkippedDueToPolicy(vdsReturnValue.getReturnValue())) {
                // fencing execution was skipped due to fencing policy
                handleFencingSkippedDueToPolicy(vdsReturnValue);
                return;
            } else {
                executor = createFenceExecutor(FenceActionType.Status);
                if (waitForStatus(getVds().getName(), getParameters().getAction(), FenceAgentOrder.Secondary)) {
                    // raise an alert that secondary agent was used
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsId(getVds().getId());
                    logable.addCustomValue("Operation", getParameters().getAction().name());
                    AuditLogDirector.log(logable, AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION);
                    handleSpecificCommandActions();
                } else {
                    handleWaitFailure(lastStatus, FenceAgentOrder.Secondary);
                }
            }
        } else {
            handleError(lastStatus, vdsReturnValue, FenceAgentOrder.Secondary);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = createFenceExecutor(getParameters().getAction());
    secondaryExecutor = createFenceExecutor(getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        handleSpecificCommandActions();
                        setFenceSucceeded(true);
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error(e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = createFenceExecutor(getParameters().getAction());
    secondaryExecutor = createFenceExecutor(getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        boolean primarySkipped = wasSkippedDueToPolicy(primaryResult.getValue());
                        boolean secondarySkipped = wasSkippedDueToPolicy(secondaryResult.getValue());
                        if (primarySkipped && secondarySkipped) {
                            // fencing execution was skipped due to fencing policy
                            handleFencingSkippedDueToPolicy(vdsReturnValue);
                            return;
                        } else if (primarySkipped || secondarySkipped) {
                            // fence execution on one agents was skipped and on the other executed
                            handleError(lastStatus, primarySkipped ? primaryResult.getValue() : secondaryResult.getValue(), primarySkipped ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                        } else {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        }
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error(e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
private FenceInvocationResult run(FenceExecutor fenceExecutor, FenceAgentOrder order) {
    FenceInvocationResult fenceInvocationResult = new FenceInvocationResult();
    fenceInvocationResult.setOrder(order);
    fenceInvocationResult.setValue(fenceExecutor.fence(order));
    if (fenceInvocationResult.getValue().getSucceeded()) {
        this.executor = createFenceExecutor(FenceActionType.Status);
        fenceInvocationResult.setSucceeded(waitForStatus(getVds().getName(), getParameters().getAction(), order));
    }
    return fenceInvocationResult;
}
#method_after
private FenceInvocationResult run(FenceExecutor fenceExecutor, FenceAgentOrder order) {
    FenceInvocationResult fenceInvocationResult = new FenceInvocationResult();
    fenceInvocationResult.setOrder(order);
    fenceInvocationResult.setValue(fenceExecutor.fence(order));
    if (fenceInvocationResult.getValue().getSucceeded()) {
        if (!wasSkippedDueToPolicy(fenceInvocationResult.getValue().getReturnValue())) {
            // execution was not skipped due to policy, get status
            this.executor = createFenceExecutor(FenceActionType.Status);
            fenceInvocationResult.setSucceeded(waitForStatus(getVds().getName(), getParameters().getAction(), order));
        }
    }
    return fenceInvocationResult;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // We have to pass here the proxy host cluster compatibility version
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getVdsId());
    VdsFenceOptions vdsFencingOptions = new VdsFenceOptions(getParameters().getType(), getParameters().getOptions(), vds.getVdsGroupCompatibilityVersion().toString());
    String options = vdsFencingOptions.ToInternalString();
    // ignore starting already started host or stopping already stopped host.
    if (!isAlreadyInRequestedStatus(options)) {
        _result = getBroker().fenceNode(getParameters().getIp(), "", getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), getActualActionName(), "", options, convertFencingPolicy(getParameters().getFencingPolicy()));
        proceedProxyReturnValue();
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.Status && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            setReturnValue((_result.mStatus.mMessage != null) ? _result.mStatus.mMessage : "");
            getVDSReturnValue().setSucceeded(true);
        }
    } else {
        handleSkippedOperation();
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // We have to pass here the proxy host cluster compatibility version
    VDS vds = getProxyVds();
    VdsFenceOptions vdsFencingOptions = new VdsFenceOptions(getParameters().getType(), getParameters().getOptions(), vds.getVdsGroupCompatibilityVersion().toString());
    String options = vdsFencingOptions.ToInternalString();
    // ignore starting already started host or stopping already stopped host.
    if (!isAlreadyInRequestedStatus(options)) {
        _result = getBroker().fenceNode(getParameters().getIp(), "", getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), getActualActionName(), "", options, convertFencingPolicy());
        proceedProxyReturnValue();
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.Status && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(_result.operationStatus, _result.mStatus.mMessage != null ? _result.mStatus.mMessage : "");
            setReturnValue(fenceStatusReturnValue);
            getVDSReturnValue().setSucceeded(true);
        }
    } else {
        handleSkippedOperation();
    }
}
#end_block

#method_before
private boolean isAlreadyInRequestedStatus(String options) {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = getBroker().fenceNode(getParameters().getIp(), "", getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), "status", "", options, convertFencingPolicy(getParameters().getFencingPolicy()));
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.Start && powerStatus.equals("on")) || action == FenceActionType.Stop && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#method_after
private boolean isAlreadyInRequestedStatus(String options) {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = getBroker().fenceNode(getParameters().getIp(), "", getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), "status", "", options, null);
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.Start && powerStatus.equals("on")) || action == FenceActionType.Stop && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#end_block

#method_before
private Map<String, Object> convertFencingPolicy(FencingPolicy fencingPolicy) {
    Map<String, Object> map = new HashMap<>();
    if (fencingPolicy != null) {
        map.put(VdsProperties.SKIP_FENCING_IF_SD_ACTIVE, fencingPolicy.isSkipFencingIfSDActive());
    }
    return map;
}
#method_after
private Map<String, Object> convertFencingPolicy() {
    Map<String, Object> map = null;
    if (getParameters().getFencingPolicy() != null && FencingPolicyHelper.isFencingPolicySupported(getProxyVds().getSupportedClusterVersionsSet())) {
        // fencing policy is entered and proxy supports passing fencing policy parameters
        map = new HashMap<>();
        if (getParameters().getFencingPolicy().isSkipFencingIfSDActive()) {
            // create map STORAGE_DOMAIN_GUID -> HOST_SPM_ID to pass to fence proxy
            map.put(VdsProperties.STORAGE_DOMAIN_HOST_ID_MAP, createStorageDomainHostIdMap());
        }
    }
    return map;
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options, fencingPolicy);
        FenceStatusReturnForXmlRpc wrapper = new FenceStatusReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    try {
        Map<String, Object> xmlRpcReturnValue;
        if (fencingPolicy == null) {
            // if fencing policy is null, fence proxy does not support fencing policy parameter
            xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options);
        } else {
            xmlRpcReturnValue = vdsServer.fenceNode(ip, port, type, user, password, action, secured, options, fencingPolicy);
        }
        FenceStatusReturnForXmlRpc wrapper = new FenceStatusReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private VDSReturnValue runFenceAction(FenceActionType actionType, FenceAgentOrder order) {
    String managementIp = getManagementIp(order);
    String managementPort = getManagementPort(order);
    String managementAgent = getManagementAgent(order);
    String managementUser = getManagementUser(order);
    String managementPassword = getManagementPassword(order);
    String managementOptions = getManagementOptions(order);
    log.infoFormat("Executing <{0}> Power Management command, Proxy Host:{1}, " + "Agent:{2}, Target Host:{3}, Management IP:{4}, User:{5}, Options:{6}", actionType, proxyHostName, managementAgent, _vds.getName(), managementIp, managementUser, managementOptions);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHostId, _vds.getId(), managementIp, managementPort, managementAgent, managementUser, managementPassword, managementOptions, actionType, fencingPolicy));
}
#method_after
private VDSReturnValue runFenceAction(FenceActionType actionType, FenceAgentOrder order) {
    String managementIp = getManagementIp(order);
    String managementPort = getManagementPort(order);
    String managementAgent = getManagementAgent(order);
    String managementUser = getManagementUser(order);
    String managementPassword = getManagementPassword(order);
    String managementOptions = getManagementOptions(order);
    log.infoFormat("Executing <{0}> Power Management command, Proxy Host:{1}, " + "Agent:{2}, Target Host:{3}, Management IP:{4}, User:{5}, Options:{6}, Fencing policy:{7}", actionType, proxyHostName, managementAgent, _vds.getName(), managementIp, managementUser, managementOptions, fencingPolicy);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHostId, _vds.getId(), managementIp, managementPort, managementAgent, managementUser, managementPassword, managementOptions, actionType, fencingPolicy));
}
#end_block

#method_before
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    synchronized (this) {
        // If a skippedProxyHostId was given, try to use another proxy
        if (skippedProxyHostId != null) {
            Iterator<VDS> iter = hosts.iterator();
            while (iter.hasNext()) {
                if (iter.next().getId().equals(skippedProxyHostId)) {
                    iter.remove();
                    break;
                }
            }
        }
    }
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHER_DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#method_after
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    synchronized (this) {
        // If a skippedProxyHostId was given, try to use another proxy
        if (skippedProxyHostId != null) {
            Iterator<VDS> iter = hosts.iterator();
            while (iter.hasNext()) {
                if (iter.next().getId().equals(skippedProxyHostId)) {
                    iter.remove();
                    break;
                }
            }
        }
    }
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHER_DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            // check if host supports minimal cluster level needed by fencing policy
            ret = ret && _vds.getSupportedClusterVersionsSet().contains(minVersionSupportingFencingPol);
            return ret;
        }
    });
    return proxyHost;
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s, targetVdsId = %s, action = %s, ip = %s, port = %s, type = %s, user = %s, " + "password = %s, options = '%s'", super.toString(), getTargetVdsID(), getAction(), getIp(), getPort(), getType(), getUser(), (getPassword() == null ? null : "******"), getOptions());
}
#method_after
@Override
public String toString() {
    return String.format("%s, targetVdsId = %s, action = %s, ip = %s, port = %s, type = %s, user = %s, " + "password = %s, options = '%s', policy = '%s'", super.toString(), getTargetVdsID(), getAction(), getIp(), getPort(), getType(), getUser(), (getPassword() == null ? null : "******"), getOptions(), getFencingPolicy());
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withParameter("fencingPolicy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("power").withResponseType(String.class);
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    RequestBuilder rb = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options);
    if (fencingPolicy != null) {
        // if fencing policy is null, fence proxy does not support fencing policy parameter
        rb.withParameter("fencingPolicy", fencingPolicy);
    }
    return new FenceStatusReturnForXmlRpc(new FutureMap(this.client, rb.build()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (isPmReportsStatusDown()) {
        returnValueBase.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    }
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
        setSucceeded(returnValueBase.getSucceeded());
        setFenceSucceeded(getSucceeded());
    } else {
        super.handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warnFormat("Restart host action failed, updating host {0} to {1}", vdsId, VDSStatus.NonResponsive.name());
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vdsId, VDSStatus.NonResponsive));
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (isPmReportsStatusDown()) {
        returnValueBase.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    }
    if (returnValueBase.getSucceeded()) {
        if (wasSkippedDueToPolicy(returnValueBase.getActionReturnValue())) {
            // fence execution was skipped due to fencing policy, host should be alive
            setSucceeded(true);
            setFenceSucceeded(true);
            skippedDueToFencingPolicy = true;
            return;
        } else {
            executeFenceVdsManuallyAction(vdsId, sessionId);
            // execute StartVds action
            returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
            setSucceeded(returnValueBase.getSucceeded());
            setFenceSucceeded(getSucceeded());
        }
    } else {
        super.handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warnFormat("Restart host action failed, updating host {0} to {1}", vdsId, VDSStatus.NonResponsive.name());
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vdsId, VDSStatus.NonResponsive));
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return isInternalExecution() ? SYSTEM_VDS_RESTART : USER_VDS_RESTART;
    } else {
        return isInternalExecution() ? SYSTEM_FAILED_VDS_RESTART : USER_FAILED_VDS_RESTART;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        if (skippedDueToFencingPolicy) {
            return VDS_NOT_RESTARTED_DUE_TO_POLICY;
        } else {
            return isInternalExecution() ? SYSTEM_VDS_RESTART : USER_VDS_RESTART;
        }
    } else {
        return isInternalExecution() ? SYSTEM_FAILED_VDS_RESTART : USER_FAILED_VDS_RESTART;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), ExecutionHandler.createInternalJobContext(getContext()));
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), getContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    if (model.getSkipFencingIfSDActiveEnabled().getEntity()) {
        cluster.setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    }
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
public void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAAAProfilesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesList(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fenceSettingsTab.setLabel(constants.fenceSettingsTabLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("300px");
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
    StringEntityModelLabel skipFencingIfSDActiveLabel = new StringEntityModelLabel();
    skipFencingIfSDActiveLabel.setText(constants.skipFencingIfSDActive());
    // $NON-NLS-1$
    skipFencingIfSDActiveLabel.setWidth("250px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxOnlyEditor();
    skipFencingIfSDActiveCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(skipFencingIfSDActiveLabel, skipFencingIfSDActiveCheckBox);
    skipFencingIfSDActiveCheckboxWithInfoIcon.setExplanation(templates.italicText(constants.skipFencingIfSDActiveInfo()));
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML, resources);
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.clusterSpiceProxyEnable());
    // $NON-NLS-1$
    label.setWidth("250px");
    spiceProxyOverrideEnabled = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabled);
    skipFencingIfSDActiveInfo = new InfoIcon(// $NON-NLS-1$
    templates.italicFixedWidth("400px", constants.skipFencingIfSDActiveInfo()), resources);
}
#end_block

#method_before
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        consoleTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#method_after
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        consoleTab.setVisible(false);
        fencingPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.getInstance().isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                fenceSettingsTab.setVisible(AsyncDataProvider.getInstance().isSkipFencingIfSDActiveSupported(clusterVersion));
            }
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.getInstance().isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
    object.getSkipFencingIfSDActiveEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateFencingPolicyTabVisibility(object);
        }
    });
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(false);
    getSkipFencingIfSDActiveEnabled().getEntityChangedEvent().addListener(this);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().isSkipFencingIfSDActive());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    updateFenceSettings(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsChangable(rngSupported);
    getRngHwrngSourceRequired().setIsChangable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.toString()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
        getRngRandomSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
        getRngHwrngSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
    }
}
#method_after
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsChangable(rngSupported);
    getRngHwrngSourceRequired().setIsChangable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
        getRngRandomSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
        getRngHwrngSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
                return null;
            }
        });
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.infoFormat("Domain {0} will remain in {1} status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.infoFormat("Domain {0} will remain in {1} status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getLunDao().getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUN_id())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedBySDs) {
            formattedIds.add(getFormattedLunId(lun, lun.getStorageDomainName()));
        }
        addCanDoActionMessage(String.format("$lunIds %1$s", StringUtils.join(formattedIds, ", ")));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedByDisks) {
            formattedIds.add(getFormattedLunId(lun, lun.getDiskAlias()));
        }
        addCanDoActionMessage(String.format("$lunIds %1$s", StringUtils.join(formattedIds, ", ")));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#method_after
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getLunDao().getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUN_id())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedBySDs) {
            formattedIds.add(getFormattedLunId(lun, lun.getStorageDomainName()));
        }
        addCanDoActionMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedByDisks) {
            formattedIds.add(getFormattedLunId(lun, lun.getDiskAlias()));
        }
        addCanDoActionMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warnFormat("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    if (storageDomains.isEmpty()) {
        log.warnFormat("Cannot elect new master: storage domains not found");
        return null;
    }
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warnFormat("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warnFormat("Cannot elect new master, no storage domains found for pool {0}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessage(String.format("$status %1$s", getStorageDomainStatus()));
}
#method_after
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessageVariable("status", getStorageDomainStatus());
}
#end_block

#method_before
protected void addInvalidSDStatusMessage(StorageDomainStatus status) {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessage(String.format("$status %1$s", status));
}
#method_after
protected void addInvalidSDStatusMessage(StorageDomainStatus status) {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessageVariable("status", status);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#end_block

#method_before
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#method_after
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = runVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warnFormat("skipping connect and refresh for all hosts, last master: {0}, command status: {1}", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warnFormat("");
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warnFormat("skipping connect and refresh for all hosts, last master: {0}, command status: {1}", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warnFormat("failed to connect vds {0} to the new master {1}", vds.getId(), _newMasterStorageDomainId);
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
@Override
public void formatValue(String fieldName, Pair<String, String> pair, boolean caseSensitive) {
    if (APPS.equals(fieldName)) {
        pair.setSecond(StringFormat.format(BaseConditionFieldAutoCompleter.getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(pair.getSecond(), '\'').replace("N'", "")));
        if ("=".equals(pair.getFirst())) {
            pair.setFirst(BaseConditionFieldAutoCompleter.getLikeSyntax(caseSensitive));
        } else if ("!=".equals(pair.getFirst())) {
            pair.setFirst("NOT " + BaseConditionFieldAutoCompleter.getLikeSyntax(caseSensitive));
        }
    } else if (UPTIME.equals(fieldName)) {
        int milisecond = 1000;
        pair.setSecond(StringHelper.trim(pair.getSecond(), '\''));
        TimeSpan ts = TimeSpan.parse(pair.getSecond());
        pair.setSecond(StringFormat.format("'%1$s'", ts.TotalMilliseconds < milisecond ? 0 : ts.TotalMilliseconds / milisecond));
    } else if (CREATIONDATE.equals(fieldName)) {
        Date tmp = new Date(Date.parse(StringHelper.trim(pair.getSecond(), '\'')));
        pair.setSecond(StringFormat.format("'%1$s'", tmp));
    } else {
        super.formatValue(fieldName, pair, caseSensitive);
    }
}
#method_after
@Override
public void formatValue(String fieldName, Pair<String, String> pair, boolean caseSensitive) {
    if (APPS.equals(fieldName)) {
        pair.setSecond(StringFormat.format(BaseConditionFieldAutoCompleter.getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(pair.getSecond(), '\'').replace("N'", "")));
        if ("=".equals(pair.getFirst())) {
            pair.setFirst(BaseConditionFieldAutoCompleter.getLikeSyntax(caseSensitive));
        } else if ("!=".equals(pair.getFirst())) {
            pair.setFirst("NOT " + BaseConditionFieldAutoCompleter.getLikeSyntax(caseSensitive));
        }
    } else if (UPTIME.equals(fieldName)) {
        pair.setSecond(StringHelper.trim(pair.getSecond(), '\''));
        TimeSpan ts = TimeSpan.parse(pair.getSecond());
        pair.setSecond(StringFormat.format("'%1$s'", ts.TotalMilliseconds < MILISECOND ? 0 : ts.TotalMilliseconds / MILISECOND));
    } else if (CREATIONDATE.equals(fieldName)) {
        Date tmp = new Date(Date.parse(StringHelper.trim(pair.getSecond(), '\'')));
        pair.setSecond(StringFormat.format("'%1$s'", tmp));
    } else {
        super.formatValue(fieldName, pair, caseSensitive);
    }
}
#end_block

#method_before
private void handleEndedTask() {
    // last access time to now.
    if (getState() != AsyncTaskState.Ended) {
        setState(AsyncTaskState.Ended);
        setLastStatusAccessTime();
    }
    // A zombie task that has been stopped and cleared needs to failed
    if (isZombieTask()) {
        getParameters().getDbAsyncTask().getTaskParameters().setTaskGroupSuccess(false);
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    }
    // failed no matter what the status of the task is.
    if (isPartiallyCompletedCommandTask()) {
        getParameters().getDbAsyncTask().getTaskParameters().setTaskGroupSuccess(false);
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    }
    if (hasTaskEndedSuccessfully()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FINISHED);
        onTaskEndSuccess();
    } else if (hasTaskEndedInFailure()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    } else if (!doesTaskExist()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.UNKNOWN);
        onTaskDoesNotExist();
    }
}
#method_after
private void handleEndedTask() {
    // last access time to now.
    if (getState() != AsyncTaskState.Ended) {
        setState(AsyncTaskState.Ended);
        setLastStatusAccessTime();
    }
    // Fail zombie task and task that belongs to a partially submitted command
    if (isZombieTask() || isPartiallyCompletedCommandTask()) {
        getParameters().getDbAsyncTask().getTaskParameters().setTaskGroupSuccess(false);
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    }
    if (hasTaskEndedSuccessfully()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FINISHED);
        onTaskEndSuccess();
    } else if (hasTaskEndedInFailure()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    } else if (!doesTaskExist()) {
        ExecutionHandler.endTaskStep(privateParameters.getDbAsyncTask().getStepId(), JobExecutionStatus.UNKNOWN);
        onTaskDoesNotExist();
    }
}
#end_block

#method_before
protected void connectAllHostsToStorage(List<String> connectionIds) {
    List<Callable<Void>> tasks = new ArrayList<>();
    final List<StorageServerConnections> connections = getDbFacade().getStorageServerConnectionDao().getByIds(connectionIds);
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getIscsiBond().getStoragePoolId(), VDSStatus.Up);
    for (final VDS host : hosts) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    final List<StorageServerConnections> conns = ISCSIStorageHelper.updateIfaces(connections, host.getId());
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(host.getId(), Guid.Empty, StorageType.ISCSI, conns));
                    final Map<String, String> iscsiMap = (Map<String, String>) returnValue.getReturnValue();
                    List<String> failedConnectionsList = LinqUtils.filter(iscsiMap.keySet(), new Predicate<String>() {

                        @Override
                        public boolean eval(String a) {
                            return !"0".equals(iscsiMap.get(a));
                        }
                    });
                    if (!failedConnectionsList.isEmpty()) {
                        log.errorFormat("Host {0} - {1} encounter problems to connect to the Iscsi Storage Server. The following connections were problematic (connectionid=vdsm result): {2}", host.getName(), host.getId(), iscsiMap.toString());
                        encounterConnectionProblems = true;
                    }
                } catch (VdcBLLException e) {
                    log.errorFormat("Could not connect Host {0} - {1} to Iscsi Storage Server. The exception is: {2}", host.getName(), host.getId(), e);
                    encounterConnectionProblems = true;
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
protected void connectAllHostsToStorage(List<String> connectionIds) {
    List<Callable<Void>> tasks = new ArrayList<>();
    final List<StorageServerConnections> connections = getDbFacade().getStorageServerConnectionDao().getByIds(connectionIds);
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getIscsiBond().getStoragePoolId(), VDSStatus.Up);
    for (final VDS host : hosts) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    final List<StorageServerConnections> conns = ISCSIStorageHelper.updateIfaces(connections, host.getId());
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(host.getId(), Guid.Empty, StorageType.ISCSI, conns));
                    final Map<String, String> iscsiMap = (Map<String, String>) returnValue.getReturnValue();
                    List<String> failedConnectionsList = LinqUtils.filter(iscsiMap.keySet(), new Predicate<String>() {

                        @Override
                        public boolean eval(String a) {
                            return !"0".equals(iscsiMap.get(a));
                        }
                    });
                    if (!failedConnectionsList.isEmpty()) {
                        log.errorFormat("Host {0} - {1} encounter problems to connect to the iSCSI Storage Server. The following connections were problematic (connectionid=vdsm result): {2}", host.getName(), host.getId(), iscsiMap.toString());
                        encounterConnectionProblems = true;
                    }
                } catch (VdcBLLException e) {
                    log.errorFormat("Could not connect Host {0} - {1} to Iscsi Storage Server. The exception is: {2}", host.getName(), host.getId(), e);
                    encounterConnectionProblems = true;
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

