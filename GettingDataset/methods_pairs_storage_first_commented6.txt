857
#method_before
@Override
protected void run() throws UnloggedFailure {
    if (localDiskRepositoryManager == null) {
        throw new UnloggedFailure(1, "Command only works with disk based repository managers");
    }
    Project.NameKey nameKey = new Project.NameKey(projectName);
    if (projectCache.get(nameKey) != null) {
        stdout.print(localDiskRepositoryManager.getBasePath(nameKey) + "/" + nameKey.get() + ".git" + "\n");
    } else {
        throw new UnloggedFailure(1, "Repository not found");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (localDiskRepositoryManager == null) {
        throw new UnloggedFailure(1, "Command only works with disk based repository managers");
    }
    Project.NameKey nameKey = new Project.NameKey(projectName);
    if (projectCache.get(nameKey) != null) {
        stdout.println(localDiskRepositoryManager.getBasePath(nameKey).resolve(nameKey.get().concat(Constants.DOT_GIT_EXT)));
    } else {
        throw new UnloggedFailure(1, "Repository not found");
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (!ok) {
        reject(cmd, "prohibited by Gerrit: 'create' permission missing on " + cmd.getRefName());
        return;
    }
    String rejectReason = ctl.canCreate(rp.getRepository(), obj);
    if (rejectReason != null) {
        reject(cmd, "prohibited by Gerrit: " + rejectReason);
        return;
    }
    if (!validRefOperation(cmd)) {
        return;
    }
    validateNewCommits(ctl, cmd);
    actualCommands.add(cmd);
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    String rejectReason = ctl.canCreate(rp.getRepository(), obj);
    if (rejectReason != null) {
        reject(cmd, "prohibited by Gerrit: " + rejectReason);
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(ctl, cmd);
    actualCommands.add(cmd);
}
#end_block

#method_before
public String canCreate(Repository repo, RevObject object) {
    if (!isProjectStatePermittingWrite()) {
        return "project state does not permit write";
    }
    if (object instanceof RevCommit) {
        if (!canPerform(Permission.CREATE)) {
            return "no create permission";
        }
        return canCreateCommit(repo, (RevCommit) object);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            return "I/O exception for revwalk";
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !canForgeCommitter()) {
                return "no 'Forge Committer' permission";
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            String rejectReason = canCreateCommit(repo, (RevCommit) tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        } else {
            String rejectReason = canCreate(repo, tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return canPerform(Permission.CREATE_SIGNED_TAG) ? null : "'create signed tag' permission missing";
        }
        return canPerform(Permission.CREATE_TAG) ? null : "'create tag' permission missing";
    }
    return null;
}
#method_after
@Nullable
public String canCreate(Repository repo, RevObject object) {
    if (!isProjectStatePermittingWrite()) {
        return "project state does not permit write";
    }
    if (object instanceof RevCommit) {
        if (!canPerform(Permission.CREATE)) {
            return "lacks permission: " + Permission.CREATE;
        }
        return canCreateCommit(repo, (RevCommit) object);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            String msg = String.format("RevWalk(%s) for pushing tag %s:", projectControl.getProject().getNameKey(), tag.name());
            log.error(msg, e);
            return "I/O exception for revwalk";
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !canForgeCommitter()) {
                return "lacks permission: " + Permission.FORGE_COMMITTER;
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            String rejectReason = canCreateCommit(repo, (RevCommit) tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        } else {
            String rejectReason = canCreate(repo, tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return canPerform(Permission.CREATE_SIGNED_TAG) ? null : "lacks permission: " + Permission.CREATE_SIGNED_TAG;
        }
        return canPerform(Permission.CREATE_TAG) ? null : "lacks permission " + Permission.CREATE_TAG;
    }
    return null;
}
#end_block

#method_before
@Nullable
private String canCreateCommit(Repository repo, RevCommit commit) {
    if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return null;
    } else if (isMergedIntoBranchOrTag(repo, commit)) {
        // even if they don't have push permission.
        return null;
    }
    return "creating new commit object requires 'push' permission";
}
#method_after
@Nullable
private String canCreateCommit(Repository repo, RevCommit commit) {
    if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return null;
    } else if (isMergedIntoBranchOrTag(repo, commit)) {
        // even if they don't have push permission.
        return null;
    }
    return "lacks permission " + Permission.PUSH + " for creating new commit object";
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : batch.getCommands()) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : actualCommands) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : actualCommands) {
        // involve kicking off an additional BatchUpdate.
        if (c.getResult() != OK) {
            continue;
        }
        if (isHead(c) || isConfig(c)) {
            switch(c.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    autoCloseChanges(c);
                    branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                    break;
                case DELETE:
                    break;
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects(batchUpdateFactory);
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s; got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Deleting {}", cmd);
    if (cmd.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, cmd.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (canDelete(cmd)) {
        if (validRefOperation(cmd)) {
            batch.addCommand(cmd);
        }
    } else if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
        reject(cmd, "cannot delete project configuration");
    } else {
        errors.put(Error.DELETE, cmd.getRefName());
        reject(cmd, "cannot delete references");
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Deleting {}", cmd);
    if (cmd.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, cmd.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (canDelete(cmd)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
        reject(cmd, "cannot delete project configuration");
    } else {
        errors.put(Error.DELETE, cmd.getRefName());
        reject(cmd, "cannot delete references");
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpFactory.create(batchUpdateFactory)) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws Exception {
                // return pseudo dirty state to trigger reindexing
                return true;
            }
        });
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            permissions.ref(cmd.getRefName()).check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            permissions.ref(cmd.getRefName()).check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(@Nullable ReceiveCommand cmd, String why) {
    if (cmd != null) {
        cmd.setResult(REJECTED_OTHER_REASON, why);
        commandProgress.update(1);
    }
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    // clone with user to avoid inherited tag permissions of admin user
    testRepo = cloneProject(project, user);
    initialHead = getRemoteHead();
}
#method_after
@Before
public void setup() throws Exception {
    // clone with user to avoid inherited tag permissions of admin user
    testRepo = cloneProject(project, user);
    initialHead = getRemoteHead();
    tagType = getTagType();
}
#end_block

#method_before
@Test
public void createTagForExistingCommit() throws Exception {
    TagType tagType = getTagType();
    pushTagForExistingCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowTagCreation(tagType);
    pushTagForExistingCommit(tagType, Status.OK);
    allowPushOnRefsTags();
    pushTagForExistingCommit(tagType, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void createTagForExistingCommit() throws Exception {
    pushTagForExistingCommit(Status.REJECTED_OTHER_REASON);
    allowTagCreation();
    pushTagForExistingCommit(Status.OK);
    allowPushOnRefsTags();
    pushTagForExistingCommit(Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void createTagForNewCommit() throws Exception {
    TagType tagType = getTagType();
    pushTagForNewCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowTagCreation(tagType);
    pushTagForNewCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagForNewCommit(tagType, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void createTagForNewCommit() throws Exception {
    pushTagForNewCommit(Status.REJECTED_OTHER_REASON);
    allowTagCreation();
    pushTagForNewCommit(Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagForNewCommit(Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void fastForward() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    Status expectedStatus = tagType == ANNOTATED ? Status.REJECTED_OTHER_REASON : Status.OK;
    fastForwardTagToExistingCommit(tagType, tagName, expectedStatus);
    fastForwardTagToNewCommit(tagType, tagName, expectedStatus);
    allowForcePushOnRefsTags();
    fastForwardTagToExistingCommit(tagType, tagName, Status.OK);
    fastForwardTagToNewCommit(tagType, tagName, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void fastForward() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    fastForwardTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    fastForwardTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    Status expectedStatus = tagType == ANNOTATED ? Status.REJECTED_OTHER_REASON : Status.OK;
    fastForwardTagToExistingCommit(tagName, expectedStatus);
    fastForwardTagToNewCommit(tagName, expectedStatus);
    allowForcePushOnRefsTags();
    fastForwardTagToExistingCommit(tagName, Status.OK);
    fastForwardTagToNewCommit(tagName, Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void forceUpdate() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.OK);
    forceUpdateTagToNewCommit(tagType, tagName, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void forceUpdate() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    forceUpdateTagToExistingCommit(tagName, Status.OK);
    forceUpdateTagToNewCommit(tagName, Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void delete() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.OK);
    removePushFromRefsTags();
    allowTagDeletion();
    tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.OK);
}
#method_after
@Test
public void delete() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagDeletion(tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.OK);
    removePushFromRefsTags();
    allowTagDeletion();
    tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.OK);
}
#end_block

#method_before
private String pushTagForExistingCommit(TagType tagType, Status expectedStatus) throws Exception {
    return pushTag(tagType, null, false, false, expectedStatus);
}
#method_after
private String pushTagForExistingCommit(Status expectedStatus) throws Exception {
    return pushTag(null, false, false, expectedStatus);
}
#end_block

#method_before
private String pushTagForNewCommit(TagType tagType, Status expectedStatus) throws Exception {
    return pushTag(tagType, null, true, false, expectedStatus);
}
#method_after
private String pushTagForNewCommit(Status expectedStatus) throws Exception {
    return pushTag(null, true, false, expectedStatus);
}
#end_block

#method_before
private void fastForwardTagToExistingCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, false, false, expectedStatus);
}
#method_after
private void fastForwardTagToExistingCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, false, false, expectedStatus);
}
#end_block

#method_before
private void fastForwardTagToNewCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, true, false, expectedStatus);
}
#method_after
private void fastForwardTagToNewCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, true, false, expectedStatus);
}
#end_block

#method_before
private void forceUpdateTagToExistingCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, false, true, expectedStatus);
}
#method_after
private void forceUpdateTagToExistingCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, false, true, expectedStatus);
}
#end_block

#method_before
private void forceUpdateTagToNewCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, true, true, expectedStatus);
}
#method_after
private void forceUpdateTagToNewCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, true, true, expectedStatus);
}
#end_block

#method_before
private String pushTag(TagType tagType, String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(project, "refs/for/refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#method_after
private String pushTag(String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(project, "refs/for/refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#end_block

#method_before
private void pushTagDeletion(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    String tagRef = tagRef(tagName);
    PushResult r = deleteRef(testRepo, tagRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#method_after
private void pushTagDeletion(String tagName, Status expectedStatus) throws Exception {
    String tagRef = tagRef(tagName);
    PushResult r = deleteRef(testRepo, tagRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#end_block

#method_before
private void allowTagCreation(TagType tagType) throws Exception {
    grant(project, "refs/tags/*", tagType.createPermission, false, REGISTERED_USERS);
}
#method_after
private void allowTagCreation() throws Exception {
    grant(project, "refs/tags/*", tagType.createPermission, false, REGISTERED_USERS);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    ScheduledThreadPoolExecutor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.setAttribute(TASK, task);
        Future f = getExecutor().submit(task);
        cont.addContinuationListener(new Listener(f));
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
private ScheduledThreadPoolExecutor getExecutor() {
    return queue.getQueue(user.get().getCapabilities().getQueueType());
}
#method_after
private ScheduledThreadPoolExecutor getExecutor() {
    QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#end_block

#method_before
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    assertMigrationException("Sequence gap must be non-negative", b -> b.setSequenceGap(-1), m -> {
    });
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#method_after
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#end_block

#method_before
@Test
public void enableSequencesNoGap() throws Exception {
    testEnableSequences(0, 3, "13");
}
#method_after
@Test
public void enableSequencesNoGap() throws Exception {
    testEnableSequences(0, 2, "12");
}
#end_block

#method_before
@Test
public void enableSequencesWithGap() throws Exception {
    testEnableSequences(null, 503, "513");
}
#method_after
@Test
public void enableSequencesWithGap() throws Exception {
    testEnableSequences(-1, 502, "512");
}
#end_block

#method_before
private void testEnableSequences(Integer builderOption, int expectedFirstId, String expectedRefValue) throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    assertThat(id.get()).isEqualTo(1);
    migrate(b -> b.setSequenceGap(builderOption).setStopAtStateForTesting(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY));
    // Implementation always discards 1 ID in addition to the gap.
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId);
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId + 1);
    try (Repository repo = repoManager.openRepository(allProjects);
        ObjectReader reader = repo.newObjectReader()) {
        Ref ref = repo.exactRef("refs/sequences/changes");
        assertThat(ref).isNotNull();
        ObjectLoader loader = reader.open(ref.getObjectId());
        assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB);
        // Acquired a block of 10 to serve the first nextChangeId call after migration.
        assertThat(new String(loader.getCachedBytes(), UTF_8)).isEqualTo(expectedRefValue);
    }
    try (ReviewDb db = schemaFactory.open()) {
        // Underlying, unused ReviewDb is still on its own sequence.
        @SuppressWarnings("deprecation")
        int nextFromReviewDb = db.nextChangeId();
        assertThat(nextFromReviewDb).isEqualTo(3);
    }
}
#method_after
private void testEnableSequences(int builderOption, int expectedFirstId, String expectedRefValue) throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    assertThat(id.get()).isEqualTo(1);
    migrate(b -> b.setSequenceGap(builderOption).setStopAtStateForTesting(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY));
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId);
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId + 1);
    try (Repository repo = repoManager.openRepository(allProjects);
        ObjectReader reader = repo.newObjectReader()) {
        Ref ref = repo.exactRef("refs/sequences/changes");
        assertThat(ref).isNotNull();
        ObjectLoader loader = reader.open(ref.getObjectId());
        assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB);
        // Acquired a block of 10 to serve the first nextChangeId call after migration.
        assertThat(new String(loader.getCachedBytes(), UTF_8)).isEqualTo(expectedRefValue);
    }
    try (ReviewDb db = schemaFactory.open()) {
        // Underlying, unused ReviewDb is still on its own sequence.
        @SuppressWarnings("deprecation")
        int nextFromReviewDb = db.nextChangeId();
        assertThat(nextFromReviewDb).isEqualTo(3);
    }
}
#end_block

#method_before
public Builder setSequenceGap(Integer sequenceGap) {
    this.sequenceGap = sequenceGap;
    return this;
}
#method_after
public Builder setSequenceGap(int sequenceGap) {
    this.sequenceGap = sequenceGap;
    return this;
}
#end_block

#method_before
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, rebuilder, globalNotesMigration, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap != null ? sequenceGap : Sequences.getChangeSequenceGap(cfg));
}
#method_after
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, rebuilder, globalNotesMigration, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap >= 0 ? sequenceGap : Sequences.getChangeSequenceGap(cfg));
}
#end_block

#method_before
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, allProjects, Sequences.CHANGES, () -> db.nextChangeId() + sequenceGap, 1);
        // Throw away one ID to ensure the ref is populated.
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#method_after
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, allProjects, Sequences.CHANGES, // would be a problem, but we just discard it, so this is safe.
        () -> db.nextChangeId() + sequenceGap - 1, 1);
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#end_block

#method_before
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    matchAuthorToCommitterDate(project, mergeCommit);
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setControl(n.getControl());
    return mergeResult;
}
#method_after
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setControl(n.getControl());
    return mergeResult;
}
#end_block

#method_before
private NotifyHandling defaultNotify(Change c, ReviewInput in) {
    if (in.tag != null && in.tag.startsWith("autogenerated:")) {
        // Autogenerated comments default to lower notify levels.
        return c.isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.OWNER_REVIEWERS;
    }
    if (c.isWorkInProgress() && !c.hasReviewStarted()) {
        // the author is.
        return NotifyHandling.OWNER;
    }
    return NotifyHandling.ALL;
}
#method_after
private NotifyHandling defaultNotify(Change c, ReviewInput in) {
    if (ChangeMessagesUtil.isAutogenerated(in.tag)) {
        // Autogenerated comments default to lower notify levels.
        return c.isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.OWNER_REVIEWERS;
    }
    if (c.isWorkInProgress() && !c.hasReviewStarted()) {
        // the author is.
        return NotifyHandling.OWNER;
    }
    return NotifyHandling.ALL;
}
#end_block

#method_before
public PersonIdent newRefLogIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|account-" + ua.getId().toString();
    return new PersonIdent(name, user + "@" + guessHost(), when, tz);
}
#method_after
public PersonIdent newRefLogIdent(Date when, TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|account-" + ua.getId().toString();
    return new PersonIdent(name, user + "@" + guessHost(), when, tz);
}
#end_block

#method_before
public PersonIdent newCommitterIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    String email = ua.getPreferredEmail();
    if (email == null || email.isEmpty()) {
        // No preferred email is configured. Use a generic identity so we
        // don't leak an address the user may have given us, but doesn't
        // necessarily want to publish through Git records.
        // 
        String user = getUserName();
        if (user == null || user.isEmpty()) {
            user = "account-" + ua.getId().toString();
        }
        String host;
        if (canonicalUrl.get() != null) {
            try {
                host = new URL(canonicalUrl.get()).getHost();
            } catch (MalformedURLException e) {
                host = SystemReader.getInstance().getHostname();
            }
        } else {
            host = SystemReader.getInstance().getHostname();
        }
        email = user + "@" + host;
    }
    if (name == null || name.isEmpty()) {
        final int at = email.indexOf('@');
        if (0 < at) {
            name = email.substring(0, at);
        } else {
            name = anonymousCowardName;
        }
    }
    return new PersonIdent(name, email, when, tz);
}
#method_after
public PersonIdent newCommitterIdent(Date when, TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    String email = ua.getPreferredEmail();
    if (email == null || email.isEmpty()) {
        // No preferred email is configured. Use a generic identity so we
        // don't leak an address the user may have given us, but doesn't
        // necessarily want to publish through Git records.
        // 
        String user = getUserName();
        if (user == null || user.isEmpty()) {
            user = "account-" + ua.getId().toString();
        }
        String host;
        if (canonicalUrl.get() != null) {
            try {
                host = new URL(canonicalUrl.get()).getHost();
            } catch (MalformedURLException e) {
                host = SystemReader.getInstance().getHostname();
            }
        } else {
            host = SystemReader.getInstance().getHostname();
        }
        email = user + "@" + host;
    }
    if (name == null || name.isEmpty()) {
        final int at = email.indexOf('@');
        if (0 < at) {
            name = email.substring(0, at);
        } else {
            name = anonymousCowardName;
        }
    }
    return new PersonIdent(name, email, when, tz);
}
#end_block

#method_before
private String getHost(final InetAddress in) {
    if (Boolean.FALSE.equals(disableReverseDnsLookup)) {
        return in.getCanonicalHostName();
    }
    return in.getHostAddress();
}
#method_after
private String getHost(InetAddress in) {
    if (Boolean.FALSE.equals(disableReverseDnsLookup)) {
        return in.getCanonicalHostName();
    }
    return in.getHostAddress();
}
#end_block

#method_before
public boolean doCanForDefaultPermissionBackend(GlobalOrPluginPermission perm) throws PermissionBackendException {
    if (perm instanceof GlobalPermission) {
        return can((GlobalPermission) perm);
    } else if (perm instanceof PluginPermission) {
        return canPerform(perm.permissionName()) || isAdmin();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
public boolean doCanForDefaultPermissionBackend(GlobalOrPluginPermission perm) throws PermissionBackendException {
    if (perm instanceof GlobalPermission) {
        return can((GlobalPermission) perm);
    } else if (perm instanceof PluginPermission) {
        PluginPermission pluginPermission = (PluginPermission) perm;
        return canPerform(pluginPermission.permissionName()) || (pluginPermission.fallBackToAdmin() && isAdmin());
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser();
}
#method_after
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
            // Tests don't support ReviewDb at all, but bindings are required via NoteDbModule.
            bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
            }).toInstance(() -> {
                throw new UnsupportedOperationException();
            });
            bind(ChangeBundleReader.class).toInstance((db, id) -> {
                throw new UnsupportedOperationException();
            });
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser();
}
#end_block

#method_before
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange(boolean workInProgress) throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.setWorkInProgress(workInProgress);
    u.commit();
    return c;
}
#end_block

#method_before
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange() throws Exception {
    return newChange(false);
}
#end_block

#method_before
public void setPatchSet(final PatchSet ps) {
    patchSet = ps;
}
#method_after
public void setPatchSet(PatchSet ps) {
    patchSet = ps;
}
#end_block

#method_before
public void setPatchSet(final PatchSet ps, final PatchSetInfo psi) {
    patchSet = ps;
    patchSetInfo = psi;
}
#method_after
public void setPatchSet(PatchSet ps, PatchSetInfo psi) {
    patchSet = ps;
    patchSetInfo = psi;
}
#end_block

#method_before
@Deprecated
public void setChangeMessage(final ChangeMessage cm) {
    setChangeMessage(cm.getMessage(), cm.getWrittenOn());
}
#method_after
@Deprecated
public void setChangeMessage(ChangeMessage cm) {
    setChangeMessage(cm.getMessage(), cm.getWrittenOn());
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.TO, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#end_block

#method_before
protected void rcptToAuthors(final RecipientType rt) {
    for (final Account.Id id : authors) {
        add(rt, id);
    }
}
#method_after
protected void rcptToAuthors(RecipientType rt) {
    for (Account.Id id : authors) {
        add(rt, id);
    }
}
#end_block

#method_before
@Override
protected void add(final RecipientType rt, final Account.Id to) {
    if (!emailOnlyAuthors || authors.contains(to)) {
        super.add(rt, to);
    }
}
#method_after
@Override
protected void add(RecipientType rt, Account.Id to) {
    if (!emailOnlyAuthors || authors.contains(to)) {
        super.add(rt, to);
    }
}
#end_block

#method_before
@Override
protected boolean isVisibleTo(final Account.Id to) throws OrmException {
    return projectState == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(args.db.get(), change).isVisible(args.db.get());
}
#method_after
@Override
protected boolean isVisibleTo(Account.Id to) throws OrmException {
    return projectState == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(args.db.get(), change).isVisible(args.db.get());
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 73) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 69) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
public boolean canSee(final Account.Id otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser;
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#method_after
public boolean canSee(Account.Id otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser;
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#end_block

#method_before
public boolean canSee(final AccountState otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser.getAccount().getId();
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#method_after
public boolean canSee(AccountState otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser.getAccount().getId();
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(MergeOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    return queues.getQueue(capabilityFactory.create(user).getQueueType());
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    return queues.getQueue(capabilityFactory.create(user).getQueueType());
}
#end_block

#method_before
public ProjectControl controlFor(final Project.NameKey nameKey) throws NoSuchProjectException {
    return userCache.get().get(nameKey);
}
#method_after
public ProjectControl controlFor(Project.NameKey nameKey) throws NoSuchProjectException {
    return userCache.get().get(nameKey);
}
#end_block

#method_before
private static Set<GroupReference> getGroups(final List<SectionMatcher> sectionMatcherList) {
    final Set<GroupReference> all = new HashSet<>();
    for (final SectionMatcher matcher : sectionMatcherList) {
        final AccessSection section = matcher.section;
        for (final Permission permission : section.getPermissions()) {
            for (final PermissionRule rule : permission.getRules()) {
                all.add(rule.getGroup());
            }
        }
    }
    return all;
}
#method_after
private static Set<GroupReference> getGroups(List<SectionMatcher> sectionMatcherList) {
    final Set<GroupReference> all = new HashSet<>();
    for (SectionMatcher matcher : sectionMatcherList) {
        final AccessSection section = matcher.section;
        for (Permission permission : section.getPermissions()) {
            for (PermissionRule rule : permission.getRules()) {
                all.add(rule.getGroup());
            }
        }
    }
    return all;
}
#end_block

#method_before
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#method_after
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    WorkQueue.Executor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    ScheduledThreadPoolExecutor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
private WorkQueue.Executor getExecutor() {
    QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#method_after
private ScheduledThreadPoolExecutor getExecutor() {
    QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(GroupDescriptions.forAccountGroup(group));
}
#method_after
public GroupControl controlFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(GroupDescriptions.forAccountGroup(group));
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(group);
}
#method_after
public GroupControl controlFor(AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(group);
}
#end_block

#method_before
public GroupControl validateFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupId);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupId);
    }
    return c;
}
#method_after
public GroupControl validateFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupId);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupId);
    }
    return c;
}
#end_block

#method_before
public GroupControl validateFor(final AccountGroup.UUID groupUUID) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupUUID);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupUUID);
    }
    return c;
}
#method_after
public GroupControl validateFor(AccountGroup.UUID groupUUID) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupUUID);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupUUID);
    }
    return c;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC);
}
#method_after
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    return new AuthorPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    return new CommitterPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        Set<Account.Id> accounts = parseAccount(who);
        if (!forDefaultField || accounts.size() <= MAX_ACCOUNTS_PER_DEFAULT_FIELD) {
            reviewerPredicate = Predicate.or(accounts.stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
        }
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else if (reviewerByEmailPredicate != null) {
        return reviewerByEmailPredicate;
    } else {
        return Predicate.any();
    }
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#method_after
public ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#method_after
public boolean canPublish(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, null, null, true, input));
        bu.execute();
        return Response.ok("");
    }
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, email, psUtil, false, input));
        bu.execute();
        return Response.ok("");
    }
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    notes = ctx.getNotes();
    if (psUtil != null) {
        ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId());
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId());
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (email == null || ps == null) {
        return;
    }
    email.create(NotifyHandling.ALL, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (workInProgress) {
        return;
    }
    email.create(NotifyHandling.ALL, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#end_block

#method_before
public void create(int expectedKeys) throws Exception {
    TestAccount foo = accountCreator.create("foo");
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo("foo");
    accountIndexedCounter.assertReindexOf(foo, expectedKeys);
    // check user branch
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsUsers(foo.getId()));
        assertThat(ref).isNotNull();
        RevCommit c = rw.parseCommit(ref.getObjectId());
        long timestampDiffMs = Math.abs(c.getCommitTime() * 1000L - accountCache.get(foo.getId()).getAccount().getRegisteredOn().getTime());
        assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS);
    }
}
#method_after
public void create(int expectedAccountReindexCalls) throws Exception {
    TestAccount foo = accountCreator.create("foo");
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo("foo");
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    // check user branch
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsUsers(foo.getId()));
        assertThat(ref).isNotNull();
        RevCommit c = rw.parseCommit(ref.getObjectId());
        long timestampDiffMs = Math.abs(c.getCommitTime() * 1000L - accountCache.get(foo.getId()).getAccount().getRegisteredOn().getTime());
        assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS);
    }
}
#end_block

#method_before
@Test
public void testClassic() throws Exception {
    expectNoConfig("OWNERS");
    expectConfig("classic/OWNERS", createConfig(false, owners(USER_A_EMAIL_COM, USER_B_EMAIL_COM)));
    creatingPatchList(Arrays.asList("classic/file.txt"));
    replayAll();
    PathOwners owners = new PathOwners(accounts, repository, patchList);
    Set<Account.Id> ownersSet = owners.get().get("classic/OWNERS");
    assertEquals(2, ownersSet.size());
    assertTrue(ownersSet.contains(USER_A_ID));
    assertTrue(ownersSet.contains(USER_B_ID));
}
#method_after
@Test
public void testClassic() throws Exception {
    expectNoConfig("OWNERS");
    expectConfig("classic/OWNERS", createConfig(false, owners(USER_A_EMAIL_COM, USER_B_EMAIL_COM)));
    creatingPatchList(Arrays.asList("classic/file.txt"));
    replayAll();
    PathOwners owners = new PathOwners(accounts, repository, branch, patchList);
    Set<Account.Id> ownersSet = owners.get().get("classic/OWNERS");
    assertEquals(2, ownersSet.size());
    assertTrue(ownersSet.contains(USER_A_ID));
    assertTrue(ownersSet.contains(USER_B_ID));
}
#end_block

#method_before
@Test
public void testClassicWithInheritance() throws Exception {
    expectConfig("OWNERS", createConfig(true, owners(USER_C_EMAIL_COM)));
    expectConfig("classic/OWNERS", createConfig(true, owners(USER_A_EMAIL_COM, USER_B_EMAIL_COM)));
    creatingPatchList(Arrays.asList("classic/file.txt"));
    replayAll();
    PathOwners owners2 = new PathOwners(accounts, repository, patchList);
    Set<Account.Id> ownersSet2 = owners2.get().get("classic/OWNERS");
    // in this case we are inheriting the acct3 from /OWNERS
    assertEquals(3, ownersSet2.size());
    assertTrue(ownersSet2.contains(USER_A_ID));
    assertTrue(ownersSet2.contains(USER_B_ID));
    assertTrue(ownersSet2.contains(USER_C_ID));
}
#method_after
@Test
public void testClassicWithInheritance() throws Exception {
    expectConfig("OWNERS", createConfig(true, owners(USER_C_EMAIL_COM)));
    expectConfig("classic/OWNERS", createConfig(true, owners(USER_A_EMAIL_COM, USER_B_EMAIL_COM)));
    creatingPatchList(Arrays.asList("classic/file.txt"));
    replayAll();
    PathOwners owners2 = new PathOwners(accounts, repository, branch, patchList);
    Set<Account.Id> ownersSet2 = owners2.get().get("classic/OWNERS");
    // in this case we are inheriting the acct3 from /OWNERS
    assertEquals(3, ownersSet2.size());
    assertTrue(ownersSet2.contains(USER_A_ID));
    assertTrue(ownersSet2.contains(USER_B_ID));
    assertTrue(ownersSet2.contains(USER_C_ID));
}
#end_block

#method_before
@Test
public void testParsingYaml() {
    String yamlString = ("inherited: true\n" + "owners:\n" + "- " + USER_C_EMAIL_COM);
    Optional<OwnersConfig> config = getOwnersConfig(yamlString);
    assertTrue(config.isPresent());
    assertEquals(1, config.get().getOwners().size());
    assertTrue(config.get().getOwners().contains(USER_C_EMAIL_COM));
}
#method_after
@Test
public void testParsingYaml() {
    String yamlString = ("inherited: true\nowners:\n- " + USER_C_EMAIL_COM);
    Optional<OwnersConfig> config = getOwnersConfig(yamlString);
    assertTrue(config.isPresent());
    assertTrue(config.get().isInherited());
    assertEquals(1, config.get().getOwners().size());
    assertTrue(config.get().getOwners().contains(USER_C_EMAIL_COM));
}
#end_block

#method_before
private OwnersMap fetchOwners() {
    OwnersMap ownersMap = new OwnersMap();
    try {
        String rootPath = "OWNERS";
        PathOwnersEntry rootEntry = getOwnersConfig(rootPath).map(conf -> new PathOwnersEntry(rootPath, conf, accounts, Collections.emptySet())).orElse(new PathOwnersEntry());
        Set<String> modifiedPaths = getModifiedPaths();
        Map<String, PathOwnersEntry> entries = new HashMap<>();
        PathOwnersEntry currentEntry = null;
        for (String path : modifiedPaths) {
            currentEntry = resolvePathEntry(path, rootEntry, entries);
            // add owners to file for matcher predicates
            ownersMap.addFileOwners(path, currentEntry.getOwners());
            // entries in the result
            if (currentEntry.getOwnersPath() != null) {
                ownersMap.addPathOwners(currentEntry.getOwnersPath(), currentEntry.getOwners());
            }
            ownersMap.addMatchers(currentEntry.getMatchers());
        }
        // We need to only keep matchers that match files in the patchset
        Map<String, Matcher> matchers = ownersMap.getMatchers();
        if (matchers.size() > 0) {
            HashMap<String, Matcher> newMatchers = Maps.newHashMap();
            // extra loop
            for (String path : modifiedPaths) {
                processMatcherPerPath(matchers, newMatchers, path, ownersMap);
            }
            if (matchers.size() != newMatchers.size()) {
                ownersMap.setMatchers(newMatchers);
            }
        }
        return ownersMap;
    } catch (IOException e) {
        log.warn("Invalid OWNERS file", e);
        return ownersMap;
    }
}
#method_after
private OwnersMap fetchOwners(String branch) {
    OwnersMap ownersMap = new OwnersMap();
    try {
        String rootPath = "OWNERS";
        PathOwnersEntry projectEntry = getOwnersConfig(rootPath, RefNames.REFS_CONFIG).map(conf -> new PathOwnersEntry(rootPath, conf, accounts, Collections.emptySet())).orElse(new PathOwnersEntry());
        PathOwnersEntry rootEntry = getOwnersConfig(rootPath, branch).map(conf -> new PathOwnersEntry(rootPath, conf, accounts, Collections.emptySet())).orElse(new PathOwnersEntry());
        Set<String> modifiedPaths = getModifiedPaths();
        Map<String, PathOwnersEntry> entries = new HashMap<>();
        PathOwnersEntry currentEntry = null;
        for (String path : modifiedPaths) {
            currentEntry = resolvePathEntry(path, branch, projectEntry, rootEntry, entries);
            // add owners to file for matcher predicates
            ownersMap.addFileOwners(path, currentEntry.getOwners());
            // entries in the result
            if (currentEntry.getOwnersPath() != null) {
                ownersMap.addPathOwners(currentEntry.getOwnersPath(), currentEntry.getOwners());
            }
            ownersMap.addMatchers(currentEntry.getMatchers());
        }
        // We need to only keep matchers that match files in the patchset
        Map<String, Matcher> matchers = ownersMap.getMatchers();
        if (matchers.size() > 0) {
            HashMap<String, Matcher> newMatchers = Maps.newHashMap();
            // extra loop
            for (String path : modifiedPaths) {
                processMatcherPerPath(matchers, newMatchers, path, ownersMap);
            }
            if (matchers.size() != newMatchers.size()) {
                ownersMap.setMatchers(newMatchers);
            }
        }
        return ownersMap;
    } catch (IOException e) {
        log.warn("Invalid OWNERS file", e);
        return ownersMap;
    }
}
#end_block

#method_before
private PathOwnersEntry resolvePathEntry(String path, PathOwnersEntry rootEntry, Map<String, PathOwnersEntry> entries) throws IOException {
    String[] parts = path.split("/");
    PathOwnersEntry currentEntry = rootEntry;
    Set<Id> currentOwners = currentEntry.getOwners();
    StringBuilder builder = new StringBuilder();
    // itself
    for (int i = 0; i < parts.length - 1; i++) {
        String part = parts[i];
        builder.append(part).append("/");
        String partial = builder.toString();
        // Skip if we already parsed this path
        if (entries.containsKey(partial)) {
            currentEntry = entries.get(partial);
        } else {
            String ownersPath = partial + "OWNERS";
            Optional<OwnersConfig> conf = getOwnersConfig(ownersPath);
            currentEntry = conf.map(c -> new PathOwnersEntry(ownersPath, c, accounts, currentOwners)).orElse(currentEntry);
            if (conf.map(OwnersConfig::isInherited).orElse(false)) {
                for (Matcher m : currentEntry.getMatchers().values()) {
                    currentEntry.addMatcher(m);
                }
            }
            entries.put(partial, currentEntry);
        }
    }
    return currentEntry;
}
#method_after
private PathOwnersEntry resolvePathEntry(String path, String branch, PathOwnersEntry projectEntry, PathOwnersEntry rootEntry, Map<String, PathOwnersEntry> entries) throws IOException {
    String[] parts = path.split("/");
    PathOwnersEntry currentEntry = rootEntry;
    StringBuilder builder = new StringBuilder();
    if (rootEntry.isInherited()) {
        for (Matcher matcher : projectEntry.getMatchers().values()) {
            if (!currentEntry.hasMatcher(matcher.getPath())) {
                currentEntry.addMatcher(matcher);
            }
        }
        if (currentEntry.getOwners().isEmpty()) {
            currentEntry.setOwners(projectEntry.getOwners());
        }
        if (currentEntry.getOwnersPath() == null) {
            currentEntry.setOwnersPath(projectEntry.getOwnersPath());
        }
    }
    // itself
    for (int i = 0; i < parts.length - 1; i++) {
        String part = parts[i];
        builder.append(part).append("/");
        String partial = builder.toString();
        // Skip if we already parsed this path
        if (entries.containsKey(partial)) {
            currentEntry = entries.get(partial);
        } else {
            String ownersPath = partial + "OWNERS";
            Optional<OwnersConfig> conf = getOwnersConfig(ownersPath, branch);
            final Set<Id> owners = currentEntry.getOwners();
            currentEntry = conf.map(c -> new PathOwnersEntry(ownersPath, c, accounts, owners)).orElse(currentEntry);
            if (conf.map(OwnersConfig::isInherited).orElse(false)) {
                for (Matcher m : currentEntry.getMatchers().values()) {
                    currentEntry.addMatcher(m);
                }
            }
            entries.put(partial, currentEntry);
        }
    }
    return currentEntry;
}
#end_block

#method_before
private Optional<OwnersConfig> getOwnersConfig(String ownersPath) throws IOException {
    return getBlobAsBytes(repository, "master", ownersPath).flatMap(bytes -> parser.getOwnersConfig(bytes));
}
#method_after
private Optional<OwnersConfig> getOwnersConfig(String ownersPath, String branch) throws IOException {
    return getBlobAsBytes(repository, branch, ownersPath).flatMap(bytes -> parser.getOwnersConfig(bytes));
}
#end_block

#method_before
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        ReviewDb reviewDb = db.get();
        // same local thread and thus cannot be closed in this event listener.
        try {
            Change change = reviewDb.changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accounts, repository, patchList);
                Set<Account.Id> allReviewers = Sets.newHashSet();
                allReviewers.addAll(owners.get().values());
                for (Matcher matcher : owners.getMatchers().values()) {
                    allReviewers.addAll(matcher.getOwners());
                }
                logger.debug("Autoassigned reviewers are: {}", allReviewers.toString());
                reviewerManager.addReviewers(change, allReviewers);
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#method_after
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        ReviewDb reviewDb = db.get();
        // same local thread and thus cannot be closed in this event listener.
        try {
            Change change = reviewDb.changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accounts, repository, change.getDest().get(), patchList);
                Set<Account.Id> allReviewers = Sets.newHashSet();
                allReviewers.addAll(owners.get().values());
                for (Matcher matcher : owners.getMatchers().values()) {
                    allReviewers.addAll(matcher.getOwners());
                }
                logger.debug("Autoassigned reviewers are: {}", allReviewers.toString());
                reviewerManager.addReviewers(change, allReviewers);
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#end_block

#method_before
private String getSchemeRest(String scheme, String key) {
    return null != scheme ? key.substring(scheme.length() + 1) : null;
}
#method_after
private String getSchemeRest(String scheme, String key) {
    return null != scheme ? key.substring(scheme.length() + 1) : key;
}
#end_block

#method_before
public static synchronized void initialize(Accounts accounts) {
    if (PATH_OWNERS != null) {
        return;
    }
    log.info("Initializing OwnerStoredValues");
    PATH_OWNERS = new StoredValue<PathOwners>() {

        @Override
        protected PathOwners createValue(Prolog engine) {
            PatchList patchList = StoredValues.PATCH_LIST.get(engine);
            Repository repository = StoredValues.REPOSITORY.get(engine);
            return new PathOwners(accounts, repository, patchList);
        }
    };
}
#method_after
public static synchronized void initialize(Accounts accounts) {
    if (PATH_OWNERS != null) {
        return;
    }
    log.info("Initializing OwnerStoredValues");
    PATH_OWNERS = new StoredValue<PathOwners>() {

        @Override
        protected PathOwners createValue(Prolog engine) {
            PatchList patchList = StoredValues.PATCH_LIST.get(engine);
            Repository repository = StoredValues.REPOSITORY.get(engine);
            String branch = StoredValues.getChange(engine).getDest().get();
            return new PathOwners(accounts, repository, branch, patchList);
        }
    };
}
#end_block

#method_before
@Test
public void checkMatchers() throws Exception {
    String parentConfig = createConfig(true, owners(ACCOUNT_A), suffixMatcher(".sql", ACCOUNT_B, ACCOUNT_C), regexMatcher(".*/a.*", ACCOUNT_D));
    String childConfig = createConfig(true, owners(ACCOUNT_F), exactMatcher("project/file.txt", ACCOUNT_D, ACCOUNT_E), partialRegexMatcher("alfa", ACCOUNT_A));
    expectConfig("OWNERS", parentConfig);
    expectConfig("project/OWNERS", childConfig);
    creatingPatchList(Arrays.asList(// matches exact in
    "project/file.txt", // no matches so nothing for this
    "file1.txt", // matches two matchers so we have b,c,d
    "project/afile2.sql", // no matching
    "project/bfile.txt", // matches PartialRegex
    "projectalfa", // only .sql matching b,c
    "project/file.sql"));
    replayAll();
    // function under test
    PathOwners owners = new PathOwners(accounts, repository, patchList);
    // assertions on classic owners
    Set<Account.Id> ownersSet = owners.get().get("project/OWNERS");
    assertEquals(2, ownersSet.size());
    // get matchers
    Map<String, Matcher> matchers = owners.getMatchers();
    assertEquals(4, matchers.size());
    // asserts we have 1 exact matcher
    List<Entry<String, Matcher>> onlyExacts = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof ExactMatcher).collect(Collectors.toList());
    assertEquals(1, onlyExacts.size());
    assertEquals("project/file.txt", onlyExacts.get(0).getKey());
    // ... 1 regex matcher
    List<Entry<String, Matcher>> regexList = StreamUtils.iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof RegExMatcher).collect(Collectors.toList());
    assertEquals(1, regexList.size());
    assertEquals(".*/a.*", regexList.get(0).getKey());
    // ... 1 partial regex matcher
    List<Entry<String, Matcher>> partialRegexList = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof PartialRegExMatcher).collect(Collectors.toList());
    assertEquals(1, partialRegexList.size());
    assertEquals("alfa", partialRegexList.get(0).getKey());
    // .... 1 suffix matcher
    List<Entry<String, Matcher>> suffixList = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof SuffixMatcher).collect(Collectors.toList());
    assertEquals(1, suffixList.size());
    assertEquals(".sql", suffixList.get(0).getKey());
    // now checks file owners as well
    Map<String, Set<Account.Id>> fileOwners = owners.getFileOwners();
    assertEquals(6, fileOwners.size());
    Set<Account.Id> set1 = fileOwners.get("project/file.txt");
    // includes classic owners a and f
    assertEquals(4, set1.size());
    assertTrue(set1.contains(ACCOUNT_A_ID));
    assertTrue(set1.contains(ACCOUNT_D_ID));
    assertTrue(set1.contains(ACCOUNT_E_ID));
    assertTrue(set1.contains(ACCOUNT_F_ID));
    Set<Account.Id> set2 = fileOwners.get("project/afile2.sql");
    assertEquals(5, set2.size());
    assertTrue(set2.contains(ACCOUNT_A_ID));
    assertTrue(set2.contains(ACCOUNT_B_ID));
    assertTrue(set2.contains(ACCOUNT_C_ID));
    assertTrue(set2.contains(ACCOUNT_D_ID));
    assertTrue(set2.contains(ACCOUNT_F_ID));
    Set<Account.Id> set3 = fileOwners.get("project/file.sql");
    assertEquals(4, set3.size());
    assertTrue(set3.contains(ACCOUNT_A_ID));
    assertTrue(set3.contains(ACCOUNT_B_ID));
    assertTrue(set3.contains(ACCOUNT_C_ID));
    assertTrue(set3.contains(ACCOUNT_F_ID));
    Set<Account.Id> set4 = fileOwners.get("projectalfa");
    // only 1 because a is class and alfa owner
    assertEquals(1, set4.size());
    assertTrue(set4.contains(ACCOUNT_A_ID));
}
#method_after
@Test
public void checkMatchers() throws Exception {
    String parentConfig = createConfig(true, owners(ACCOUNT_A), suffixMatcher(".sql", ACCOUNT_B, ACCOUNT_C), regexMatcher(".*/a.*", ACCOUNT_D));
    String childConfig = createConfig(true, owners(ACCOUNT_F), exactMatcher("project/file.txt", ACCOUNT_D, ACCOUNT_E), partialRegexMatcher("alfa", ACCOUNT_A));
    expectConfig("OWNERS", parentConfig);
    expectConfig("project/OWNERS", childConfig);
    creatingPatchList(Arrays.asList(// matches exact in
    "project/file.txt", // no matches so nothing for this
    "file1.txt", // matches two matchers so we have b,c,d
    "project/afile2.sql", // no matching
    "project/bfile.txt", // matches PartialRegex
    "projectalfa", // only .sql matching b,c
    "project/file.sql"));
    replayAll();
    // function under test
    PathOwners owners = new PathOwners(accounts, repository, branch, patchList);
    // assertions on classic owners
    Set<Account.Id> ownersSet = owners.get().get("project/OWNERS");
    assertEquals(2, ownersSet.size());
    // get matchers
    Map<String, Matcher> matchers = owners.getMatchers();
    assertEquals(4, matchers.size());
    // asserts we have 1 exact matcher
    List<Entry<String, Matcher>> onlyExacts = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof ExactMatcher).collect(Collectors.toList());
    assertEquals(1, onlyExacts.size());
    assertEquals("project/file.txt", onlyExacts.get(0).getKey());
    // ... 1 regex matcher
    List<Entry<String, Matcher>> regexList = StreamUtils.iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof RegExMatcher).collect(Collectors.toList());
    assertEquals(1, regexList.size());
    assertEquals(".*/a.*", regexList.get(0).getKey());
    // ... 1 partial regex matcher
    List<Entry<String, Matcher>> partialRegexList = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof PartialRegExMatcher).collect(Collectors.toList());
    assertEquals(1, partialRegexList.size());
    assertEquals("alfa", partialRegexList.get(0).getKey());
    // .... 1 suffix matcher
    List<Entry<String, Matcher>> suffixList = iteratorStream(matchers.entrySet().iterator()).filter(entry -> entry.getValue() instanceof SuffixMatcher).collect(Collectors.toList());
    assertEquals(1, suffixList.size());
    assertEquals(".sql", suffixList.get(0).getKey());
    // now checks file owners as well
    Map<String, Set<Account.Id>> fileOwners = owners.getFileOwners();
    assertEquals(6, fileOwners.size());
    Set<Account.Id> set1 = fileOwners.get("project/file.txt");
    // includes classic owners a and f
    assertEquals(4, set1.size());
    assertTrue(set1.contains(ACCOUNT_A_ID));
    assertTrue(set1.contains(ACCOUNT_D_ID));
    assertTrue(set1.contains(ACCOUNT_E_ID));
    assertTrue(set1.contains(ACCOUNT_F_ID));
    Set<Account.Id> set2 = fileOwners.get("project/afile2.sql");
    assertEquals(5, set2.size());
    assertTrue(set2.contains(ACCOUNT_A_ID));
    assertTrue(set2.contains(ACCOUNT_B_ID));
    assertTrue(set2.contains(ACCOUNT_C_ID));
    assertTrue(set2.contains(ACCOUNT_D_ID));
    assertTrue(set2.contains(ACCOUNT_F_ID));
    Set<Account.Id> set3 = fileOwners.get("project/file.sql");
    assertEquals(4, set3.size());
    assertTrue(set3.contains(ACCOUNT_A_ID));
    assertTrue(set3.contains(ACCOUNT_B_ID));
    assertTrue(set3.contains(ACCOUNT_C_ID));
    assertTrue(set3.contains(ACCOUNT_F_ID));
    Set<Account.Id> set4 = fileOwners.get("projectalfa");
    // only 1 because a is class and alfa owner
    assertEquals(1, set4.size());
    assertTrue(set4.contains(ACCOUNT_A_ID));
}
#end_block

#method_before
@Test
public void testkRegexShouldMatchOnlyOnSuffix() throws Exception {
    String configString = createConfig(false, new String[0], suffixMatcher(".sql", ACCOUNT_B));
    expectConfig("OWNERS", configString);
    expectNoConfig("project/OWNERS");
    creatingPatch("project/file.sql", "another.txt");
    replayAll();
    PathOwners owners = new PathOwners(accounts, repository, patchList);
    Set<String> ownedFiles = owners.getFileOwners().keySet();
    assertThat(ownedFiles).containsExactly("project/file.sql");
}
#method_after
@Test
public void testkRegexShouldMatchOnlyOnSuffix() throws Exception {
    String configString = createConfig(false, new String[0], suffixMatcher(".sql", ACCOUNT_B));
    expectConfig("OWNERS", configString);
    expectNoConfig("project/OWNERS");
    creatingPatch("project/file.sql", "another.txt");
    replayAll();
    PathOwners owners = new PathOwners(accounts, repository, branch, patchList);
    Set<String> ownedFiles = owners.getFileOwners().keySet();
    assertThat(ownedFiles).containsExactly("project/file.sql");
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, RepositoryNotFoundException, IOException, UnprocessableEntityException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new Input();
    }
    String username = self.get().getUserName();
    ProjectLevelConfig storage = projectCache.getAllProjects().getConfig(pluginName + ".config");
    Config db = storage.get();
    boolean modified = false;
    String defaultProject = db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT);
    if (Strings.emptyToNull(input.defaultProject) != null) {
        if (projectCache.get(new Project.NameKey(input.defaultProject)) == null) {
            throw new UnprocessableEntityException("project '" + input.defaultProject + "' does not exist");
        }
        if (!input.defaultProject.equals(defaultProject)) {
            db.setString(PREFERENCE, username, KEY_DEFAULT_PROJECT, input.defaultProject);
            modified = true;
        }
    } else {
        if (defaultProject != null) {
            db.unset(PREFERENCE, username, KEY_DEFAULT_PROJECT);
            modified = true;
        }
    }
    if (input.linkDecoration != null) {
        LinkDecoration linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, LinkDecoration.NONE);
        if (!input.linkDecoration.equals(linkDecoration)) {
            db.setEnum(PREFERENCE, username, KEY_LINK_DECORATION, input.linkDecoration);
            modified = true;
        }
    } else {
        if (db.getNames(PREFERENCE, username).contains(KEY_LINK_DECORATION)) {
            db.unset(PREFERENCE, username, KEY_LINK_DECORATION);
            modified = true;
        }
    }
    boolean stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, false);
    if (input.stage != null) {
        if (input.stage != stage) {
            db.setBoolean(PREFERENCE, username, KEY_STAGE, input.stage);
            modified = true;
        }
    } else {
        if (!stage) {
            db.unset(PREFERENCE, username, KEY_STAGE);
            modified = true;
        }
    }
    if (modified) {
        MetaDataUpdate md = metaDataUpdateFactory.create(projectCache.getAllProjects().getProject().getNameKey());
        md.setMessage("Update " + pluginName + " Preferences for '" + username + "'\n");
        storage.commit(md);
    }
    return Response.<String>ok("OK");
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, RepositoryNotFoundException, IOException, UnprocessableEntityException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new Input();
    }
    String username = self.get().getUserName();
    ProjectLevelConfig storage = projectCache.getAllProjects().getConfig(pluginName + ".config");
    Config db = storage.get();
    boolean modified = false;
    String defaultProject = db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT);
    if (Strings.emptyToNull(input.defaultProject) != null) {
        if (projectCache.get(new Project.NameKey(input.defaultProject)) == null) {
            throw new UnprocessableEntityException("project '" + input.defaultProject + "' does not exist");
        }
        if (!input.defaultProject.equals(defaultProject)) {
            db.setString(PREFERENCE, username, KEY_DEFAULT_PROJECT, input.defaultProject);
            modified = true;
        }
    } else {
        if (defaultProject != null) {
            db.unset(PREFERENCE, username, KEY_DEFAULT_PROJECT);
            modified = true;
        }
    }
    if (input.linkDecoration != null) {
        LinkDecoration linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, LinkDecoration.NONE);
        if (!input.linkDecoration.equals(linkDecoration)) {
            db.setEnum(PREFERENCE, username, KEY_LINK_DECORATION, input.linkDecoration);
            modified = true;
        }
    } else {
        if (db.getNames(PREFERENCE, username).contains(KEY_LINK_DECORATION)) {
            db.unset(PREFERENCE, username, KEY_LINK_DECORATION);
            modified = true;
        }
    }
    boolean stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, false);
    if (input.stage != null) {
        if (input.stage != stage) {
            db.setBoolean(PREFERENCE, username, KEY_STAGE, input.stage);
            modified = true;
        }
    } else {
        if (!stage) {
            db.unset(PREFERENCE, username, KEY_STAGE);
            modified = true;
        }
    }
    if (modified) {
        MetaDataUpdate md = metaDataUpdateFactory.create(projectCache.getAllProjects().getProject().getNameKey());
        md.setMessage("Update " + pluginName + " Preferences for '" + username + "'\n");
        storage.commit(md);
    }
    return Response.<String>ok("OK");
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    ResourceKey key = ResourceKey.fromPath(getEncodedPath(req));
    ProjectState state = projectCache.get(key.project);
    if (state == null || key.file == null) {
        notFound(res);
        return;
    }
    MimeType mimeType = fileTypeRegistry.getMimeType(key.file, null);
    if (!("image".equals(mimeType.getMediaType()) && fileTypeRegistry.isSafeInline(mimeType))) {
        notFound(res);
        return;
    }
    try {
        ProjectControl projectControl = projectControlFactory.validateFor(key.project);
        String rev = key.revision;
        if (rev == null || Constants.HEAD.equals(rev)) {
            rev = getHead.get().apply(new ProjectResource(projectControl));
        } else {
            if (!ObjectId.isId(rev)) {
                if (!rev.startsWith(Constants.R_REFS)) {
                    rev = Constants.R_HEADS + rev;
                }
                if (!projectControl.controlForRef(rev).isVisible()) {
                    notFound(res);
                    return;
                }
            }
        }
        try (Repository repo = repoManager.openRepository(key.project)) {
            ObjectId revId = repo.resolve(rev != null ? rev : Constants.HEAD);
            if (revId == null) {
                notFound(res);
                return;
            }
            if (ObjectId.isId(rev)) {
                try (RevWalk rw = new RevWalk(repo)) {
                    RevCommit commit = rw.parseCommit(repo.resolve(rev));
                    if (!projectControl.canReadCommit(db.get(), repo, commit)) {
                        notFound(res);
                        return;
                    }
                }
            }
            String eTag = null;
            String receivedETag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
            if (receivedETag != null) {
                eTag = computeETag(key.project, revId, key.file);
                if (eTag.equals(receivedETag)) {
                    res.sendError(SC_NOT_MODIFIED);
                    return;
                }
            }
            if (!"image".equals(mimeType.getMediaType())) {
                notFound(res);
                return;
            }
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(revId);
                RevTree tree = commit.getTree();
                try (TreeWalk tw = new TreeWalk(repo)) {
                    tw.addTree(tree);
                    tw.setRecursive(true);
                    tw.setFilter(PathFilter.create(key.file));
                    if (!tw.next()) {
                        notFound(res);
                        return;
                    }
                    ObjectId objectId = tw.getObjectId(0);
                    ObjectLoader loader = repo.open(objectId);
                    byte[] content = loader.getBytes(Integer.MAX_VALUE);
                    mimeType = fileTypeRegistry.getMimeType(key.file, content);
                    if (!"image".equals(mimeType.getMediaType()) || !fileTypeRegistry.isSafeInline(mimeType)) {
                        notFound(res);
                        return;
                    }
                    res.setHeader(HttpHeaders.ETAG, eTag != null ? eTag : computeETag(key.project, revId, key.file));
                    CacheHeaders.setCacheablePrivate(res, 7, TimeUnit.DAYS, false);
                    send(req, res, content, mimeType.toString(), commit.getCommitTime());
                    return;
                }
            } catch (IOException e) {
                notFound(res);
                return;
            }
        }
    } catch (RepositoryNotFoundException | NoSuchProjectException | ResourceNotFoundException | AuthException | RevisionSyntaxException e) {
        notFound(res);
        return;
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    ResourceKey key = ResourceKey.fromPath(getEncodedPath(req));
    ProjectState state = projectCache.get(key.project);
    if (state == null || key.file == null) {
        notFound(res);
        return;
    }
    MimeType mimeType = fileTypeRegistry.getMimeType(key.file, (byte[]) null);
    if (!("image".equals(mimeType.getMediaType()) && fileTypeRegistry.isSafeInline(mimeType))) {
        notFound(res);
        return;
    }
    try {
        ProjectControl projectControl = projectControlFactory.controlFor(key.project);
        String rev = key.revision;
        if (rev == null || Constants.HEAD.equals(rev)) {
            rev = getHead.get().apply(new ProjectResource(projectControl));
        } else {
            if (!ObjectId.isId(rev)) {
                if (!rev.startsWith(Constants.R_REFS)) {
                    rev = Constants.R_HEADS + rev;
                }
                if (!projectControl.controlForRef(rev).isVisible()) {
                    notFound(res);
                    return;
                }
            }
        }
        try (Repository repo = repoManager.openRepository(key.project)) {
            ObjectId revId = repo.resolve(rev != null ? rev : Constants.HEAD);
            if (revId == null) {
                notFound(res);
                return;
            }
            if (ObjectId.isId(rev)) {
                try (RevWalk rw = new RevWalk(repo)) {
                    RevCommit commit = rw.parseCommit(repo.resolve(rev));
                    if (!projectControl.canReadCommit(db.get(), repo, commit)) {
                        notFound(res);
                        return;
                    }
                }
            }
            String eTag = null;
            String receivedETag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
            if (receivedETag != null) {
                eTag = computeETag(key.project, revId, key.file);
                if (eTag.equals(receivedETag)) {
                    res.sendError(SC_NOT_MODIFIED);
                    return;
                }
            }
            if (!"image".equals(mimeType.getMediaType())) {
                notFound(res);
                return;
            }
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(revId);
                RevTree tree = commit.getTree();
                try (TreeWalk tw = new TreeWalk(repo)) {
                    tw.addTree(tree);
                    tw.setRecursive(true);
                    tw.setFilter(PathFilter.create(key.file));
                    if (!tw.next()) {
                        notFound(res);
                        return;
                    }
                    ObjectId objectId = tw.getObjectId(0);
                    ObjectLoader loader = repo.open(objectId);
                    byte[] content = loader.getBytes(Integer.MAX_VALUE);
                    mimeType = fileTypeRegistry.getMimeType(key.file, content);
                    if (!"image".equals(mimeType.getMediaType()) || !fileTypeRegistry.isSafeInline(mimeType)) {
                        notFound(res);
                        return;
                    }
                    res.setHeader(HttpHeaders.ETAG, eTag != null ? eTag : computeETag(key.project, revId, key.file));
                    CacheHeaders.setCacheablePrivate(res, 7, TimeUnit.DAYS, false);
                    send(req, res, content, mimeType.toString(), commit.getCommitTime());
                    return;
                }
            } catch (IOException e) {
                notFound(res);
                return;
            }
        }
    } catch (RepositoryNotFoundException | NoSuchProjectException | ResourceNotFoundException | AuthException | RevisionSyntaxException e) {
        notFound(res);
        return;
    }
}
#end_block

#method_before
@Override
public ConfigInfo apply(AccountResource rsrc) throws AuthException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    String username = self.get().getUserName();
    ConfigInfo globalCfg = getConfig.get().apply(new ConfigResource());
    Config db = projectCache.getAllProjects().getConfig(pluginName + ".config").get();
    ConfigInfo info = new ConfigInfo();
    info.defaultProject = MoreObjects.firstNonNull(db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT), globalCfg.defaultProject);
    info.linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, MoreObjects.firstNonNull(globalCfg.linkDecoration, LinkDecoration.NONE));
    if (LinkDecoration.NONE.equals(info.linkDecoration)) {
        info.linkDecoration = null;
    }
    info.stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, (globalCfg.stage != null ? globalCfg.stage : false));
    if (!info.stage) {
        info.stage = null;
    }
    info.pattern = globalCfg.pattern;
    return info;
}
#method_after
@Override
public ConfigInfo apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    String username = self.get().getUserName();
    ConfigInfo globalCfg = getConfig.get().apply(new ConfigResource());
    Config db = projectCache.getAllProjects().getConfig(pluginName + ".config").get();
    ConfigInfo info = new ConfigInfo();
    info.defaultProject = MoreObjects.firstNonNull(db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT), globalCfg.defaultProject);
    info.linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, MoreObjects.firstNonNull(globalCfg.linkDecoration, LinkDecoration.NONE));
    if (LinkDecoration.NONE.equals(info.linkDecoration)) {
        info.linkDecoration = null;
    }
    info.stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, (globalCfg.stage != null ? globalCfg.stage : false));
    if (!info.stage) {
        info.stage = null;
    }
    info.pattern = globalCfg.pattern;
    return info;
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("N", maybeNextVimSearch(cm)).on("P", diffChunkNav(cm, true)).on("Shift-O", openClosePublished(cm)).on("Shift-Left", flipCursorSide(cm, true)).on("Shift-Right", flipCursorSide(cm, false)));
    CodeMirror.mapVimKey("j", "gj");
    CodeMirror.mapVimKey("k", "gk");
    CodeMirror.mapVimKey("Down", "gj");
    CodeMirror.mapVimKey("Up", "gk");
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("N", maybeNextVimSearch(cm)).on("P", diffChunkNav(cm, true)).on("Shift-O", openClosePublished(cm)).on("Shift-Left", flipCursorSide(cm, true)).on("Shift-Right", flipCursorSide(cm, false)));
}
#end_block

#method_before
private static void initVimKeys() {
    // TODO: Better custom keybindings, remove temporary navigation hacks.
    KeyMap km = CodeMirror.cloneKeyMap("vim");
    for (String s : new String[] { "A", "C", "O", "R", "U", "Ctrl-C" }) {
        km.remove(s);
    }
    CodeMirror.addKeyMap("vim_ro", km);
}
#method_after
private static void initVimKeys() {
    // TODO: Better custom keybindings, remove temporary navigation hacks.
    KeyMap km = CodeMirror.cloneKeyMap("vim");
    for (String s : new String[] { "A", "C", "O", "R", "U", "Ctrl-C" }) {
        km.remove(s);
    }
    CodeMirror.addKeyMap("vim_ro", km);
    CodeMirror.mapVimKey("j", "gj");
    CodeMirror.mapVimKey("k", "gk");
    CodeMirror.mapVimKey("Down", "gj");
    CodeMirror.mapVimKey("Up", "gk");
}
#end_block

#method_before
public synchronized Executor getDefaultQueue() {
    if (defaultQueue == null) {
        defaultQueue = createQueue(defaultQueueSize, "WorkQueue");
    }
    return defaultQueue;
}
#method_after
public synchronized ScheduledThreadPoolExecutor getDefaultQueue() {
    if (defaultQueue == null) {
        defaultQueue = createQueue(defaultQueueSize, "WorkQueue");
    }
    return defaultQueue;
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix) {
    return createQueue(poolsize, prefix, Thread.NORM_PRIORITY);
}
#method_after
public ScheduledThreadPoolExecutor createQueue(int poolsize, String prefix) {
    return createQueue(poolsize, prefix, Thread.NORM_PRIORITY);
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix, int threadPriority) {
    final Executor r = new Executor(poolsize, prefix);
    if (threadPriority != Thread.NORM_PRIORITY) {
        final ThreadFactory parent = r.getThreadFactory();
        r.setThreadFactory(task -> {
            final Thread t = parent.newThread(task);
            t.setPriority(threadPriority);
            return t;
        });
    }
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(r);
    return r;
}
#method_after
public ScheduledThreadPoolExecutor createQueue(int poolsize, String prefix, int threadPriority) {
    Executor executor = new Executor(poolsize, prefix);
    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(executor);
    if (threadPriority != Thread.NORM_PRIORITY) {
        ThreadFactory parent = executor.getThreadFactory();
        executor.setThreadFactory(task -> {
            Thread t = parent.newThread(task);
            t.setPriority(threadPriority);
            return t;
        });
    }
    return executor;
}
#end_block

#method_before
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (final Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#method_after
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#method_after
public Task<?> getTask(int id) {
    Task<?> result = null;
    for (Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
public Executor getExecutor(String queueName) {
    for (Executor e : queues) {
        if (e.queueName.equals(queueName)) {
            return e;
        }
    }
    return null;
}
#method_after
public ScheduledThreadPoolExecutor getExecutor(String queueName) {
    for (Executor e : queues) {
        if (e.queueName.equals(queueName)) {
            return e;
        }
    }
    return null;
}
#end_block

#method_before
private void stop() {
    for (final Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#method_after
private void stop() {
    for (Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Callable<V> callable, final RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#end_block

#method_before
void remove(final Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#method_after
void remove(Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#end_block

#method_before
Task<?> getTask(final int id) {
    return all.get(id);
}
#method_after
Task<?> getTask(int id) {
    return all.get(id);
}
#end_block

#method_before
void addAllTo(final List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#method_after
void addAllTo(List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#end_block

#method_before
@Override
public WorkQueue.Executor getQueue(QueueType type) {
    switch(type) {
        case INTERACTIVE:
            return interactiveExecutor;
        case BATCH:
        default:
            return batchExecutor;
    }
}
#method_after
@Override
public ScheduledThreadPoolExecutor getQueue(QueueType type) {
    switch(type) {
        case INTERACTIVE:
            return interactiveExecutor;
        case BATCH:
        default:
            return batchExecutor;
    }
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    return queues.createQueue(poolSize, "SSH-Stream-Worker", Thread.MIN_PRIORITY);
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    return queues.createQueue(poolSize, "SSH-Stream-Worker", Thread.MIN_PRIORITY);
}
#end_block

#method_before
public static boolean isGroupReference(String configValue) {
    return configValue.startsWith(PREFIX);
}
#method_after
public static boolean isGroupReference(String configValue) {
    return configValue != null && configValue.startsWith(PREFIX);
}
#end_block

#method_before
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId.equals(patchSetId.getId())) {
            return res.files;
        }
        PatchSetWithReviewedFiles reviewed = o.get();
        try {
            return copy(Sets.newHashSet(reviewed.files), reviewed.patchSetId, resource, userId);
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#method_after
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId().equals(patchSetId.getId())) {
            return res.files();
        }
        try {
            return copy(res.files(), res.patchSetId(), resource, userId);
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS ACCOUNT_PATCH_REVIEWS (" + "ACCOUNT_ID INTEGER DEFAULT 0 NOT NULL, " + "CHANGE_ID INTEGER DEFAULT 0 NOT NULL, " + "PATCH_SET_ID INTEGER DEFAULT 0 NOT NULL, " + "FILE_NAME VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT PRIMARY_KEY_ACCOUNT_PATCH_REVIEWS " + "PRIMARY KEY (ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME)" + ")");
}
#method_after
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (account_id, change_id, patch_set_id, file_name)" + ")");
}
#end_block

#method_before
public static void dropTableIfExists(String url) throws OrmException {
    try (Connection con = DriverManager.getConnection(url);
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS ACCOUNT_PATCH_REVIEWS");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#method_after
public static void dropTableIfExists(String url) throws OrmException {
    try (Connection con = DriverManager.getConnection(url);
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS account_patch_reviews");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#end_block

#method_before
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#method_after
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#method_after
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID + ? AND " + "PATCH_SET_ID = ? AND FILE_NAME = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE account_id = ? AND change_id = ? AND " + "patch_set_id = ? AND file_name = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID + ? AND PATCH_SET_ID = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE change_id = ? AND patch_set_id = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT PATCH_SET_ID, FILE_NAME FROM ACCOUNT_PATCH_REVIEWS APR1 " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND PATCH_SET_ID = " + "(SELECT MAX(PATCH_SET_ID) FROM ACCOUNT_PATCH_REVIEWS APR2 WHERE " + "APR1.ACCOUNT_ID = APR2.ACCOUNT_ID " + "AND APR1.CHANGE_ID = APR2.CHANGE_ID " + "AND PATCH_SET_ID <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSetWithReviewedFiles r = new PatchSetWithReviewedFiles();
                r.files = new ArrayList<>();
                r.patchSetId = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                do {
                    r.files.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(r);
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#method_after
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#end_block

#method_before
public static OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("ACCOUNT_PATCH_REVIEWS", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
    }
}
#method_after
public static OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("account_patch_reviews", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on account_patch_reviews", err);
    }
}
#end_block

#method_before
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    res.setHeader(VARY, Joiner.on(", ").join(ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD)));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!isAllowedCorsRequestHeader(reqHdr)) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#method_after
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    setHeaderList(res, VARY, ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD, ACCESS_CONTROL_REQUEST_HEADERS));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String method = req.getHeader(ACCESS_CONTROL_REQUEST_METHOD);
    if (!ALLOWED_CORS_METHODS.contains(method)) {
        throw new BadRequestException(method + " not allowed in CORS");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!ALLOWED_CORS_REQUEST_HEADERS.contains(reqHdr.toLowerCase(Locale.US))) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#end_block

#method_before
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    res.setHeader(ACCESS_CONTROL_ALLOW_METHODS, "GET, OPTIONS, PUT, DELETE, POST");
    res.setHeader(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(", ").join(ALLOWED_CORS_REQUEST_HEADERS));
}
#method_after
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    setHeaderList(res, ACCESS_CONTROL_ALLOW_METHODS, Iterables.concat(ALLOWED_CORS_METHODS, ImmutableList.of("OPTIONS")));
    setHeaderList(res, ACCESS_CONTROL_ALLOW_HEADERS, ALLOWED_CORS_REQUEST_HEADERS);
}
#end_block

#method_before
@Override
public List<ValidationMessage> onRefOperation(RefReceivedEvent refEvent) throws ValidationException {
    if (refEvent.project.getNameKey().equals(allUsersName) && (refEvent.command.getRefName().startsWith(RefNames.REFS_USERS) && !refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))) {
        if (refEvent.command.getType().equals(ReceiveCommand.Type.CREATE)) {
            if (!perm.testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
                throw new ValidationException("Not allowed to create user branch.");
            }
            if (Account.Id.fromRef(refEvent.command.getRefName()) == null) {
                throw new ValidationException(String.format("Not allowed to create non-user branch under %s.", RefNames.REFS_USERS));
            }
        } else if (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE)) {
            if (!perm.testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
                throw new ValidationException("Not allowed to delete user branch.");
            }
        }
    }
    return ImmutableList.of();
}
#method_after
@Override
public List<ValidationMessage> onRefOperation(RefReceivedEvent refEvent) throws ValidationException {
    if (refEvent.project.getNameKey().equals(allUsersName) && (refEvent.command.getRefName().startsWith(RefNames.REFS_USERS) && !refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))) {
        if (refEvent.command.getType().equals(ReceiveCommand.Type.CREATE)) {
            try {
                perm.check(GlobalPermission.ACCESS_DATABASE);
            } catch (AuthException | PermissionBackendException e) {
                throw new ValidationException("Not allowed to create user branch.");
            }
            if (Account.Id.fromRef(refEvent.command.getRefName()) == null) {
                throw new ValidationException(String.format("Not allowed to create non-user branch under %s.", RefNames.REFS_USERS));
            }
        } else if (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE)) {
            try {
                perm.check(GlobalPermission.ACCESS_DATABASE);
            } catch (AuthException | PermissionBackendException e) {
                throw new ValidationException("Not allowed to delete user branch.");
            }
        }
    }
    return ImmutableList.of();
}
#end_block

#method_before
@Test
public void getExternalIdsOfOtherUserNotAllowed() throws Exception {
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get external IDs");
    gApi.accounts().id(admin.id.get()).getExternalIds();
}
#method_after
@Test
public void getExternalIdsOfOtherUserNotAllowed() throws Exception {
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("access database not permitted");
    gApi.accounts().id(admin.id.get()).getExternalIds();
}
#end_block

#method_before
@Test
public void deleteExternalIdsOfOtherUserNotAllowed() throws Exception {
    List<AccountExternalIdInfo> extIds = gApi.accounts().self().getExternalIds();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to delete external IDs");
    gApi.accounts().id(admin.id.get()).deleteExternalIds(extIds.stream().map(e -> e.identity).collect(toList()));
}
#method_after
@Test
public void deleteExternalIdsOfOtherUserNotAllowed() throws Exception {
    List<AccountExternalIdInfo> extIds = gApi.accounts().self().getExternalIds();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("access database not permitted");
    gApi.accounts().id(admin.id.get()).deleteExternalIds(extIds.stream().map(e -> e.identity).collect(toList()));
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    projectCtl = projectState.controlFor(user.get());
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        try {
            permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE);
            viewMetadata = true;
        } catch (AuthException | PermissionBackendException no) {
            viewMetadata = false;
        }
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getProject().getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    projectCtl = projectState.controlFor(user.get());
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        viewMetadata = permissionBackend.user(user).testOrFalse(GlobalPermission.ACCESS_DATABASE);
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getProject().getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource resource, List<String> extIds) throws RestApiException, IOException, OrmException, ConfigInvalidException {
    if (self.get() != resource.getUser() && !permissionBackend.user(self).testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
        throw new AuthException("not allowed to delete external IDs");
    }
    if (extIds == null || extIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Map<ExternalId.Key, ExternalId> externalIdMap = externalIds.byAccount(resource.getUser().getAccountId()).stream().collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : extIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    try {
        for (ExternalId extId : toDelete) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(extId.email());
            accountManager.unlink(extId.accountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource resource, List<String> extIds) throws RestApiException, IOException, OrmException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != resource.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    if (extIds == null || extIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Map<ExternalId.Key, ExternalId> externalIdMap = externalIds.byAccount(resource.getUser().getAccountId()).stream().collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : extIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    try {
        for (ExternalId extId : toDelete) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(extId.email());
            accountManager.unlink(extId.accountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, IOException, OrmException {
    if (self.get() != resource.getUser() && !permissionBackend.user(self).testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
        throw new AuthException("not allowed to get external IDs");
    }
    Collection<ExternalId> ids = externalIds.byAccount(resource.getUser().getAccountId());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#method_after
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, IOException, OrmException, PermissionBackendException {
    if (self.get() != resource.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    Collection<ExternalId> ids = externalIds.byAccount(resource.getUser().getAccountId());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(TagResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    /* if (!rsrc.getControl().controlForRef(rsrc.getTagKey()).canDelete()) {
      throw new AuthException("Cannot delete tag");
    } */
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getTagKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getTagKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current tag");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getTagKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete tag: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(TagResource resource, Input input) throws OrmException, RestApiException, IOException {
    String tag = RefUtil.normalizeTagRef(resource.getTagInfo().ref);
    RefControl refControl = resource.getControl().controlForRef(tag);
    if (!refControl.canDelete()) {
        throw new AuthException("Cannot delete tag");
    }
    deleteRefFactory.create(resource).ref(tag).delete();
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public static Key parse(final String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#method_after
public static Key parse(String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setKey(final Change.Key k) {
    changeKey = k;
}
#method_after
public void setKey(Change.Key k) {
    changeKey = k;
}
#end_block

#method_before
public void setCurrentPatchSet(final PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#method_after
public void setCurrentPatchSet(PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
            if (state == ReviewerStateInternal.REMOVED) {
                continue;
            }
            Collection<AccountInfo> reviewers = toAccountInfo(cd.reviewers().byState(state));
            reviewers.addAll(toAccountInfoByEmail(cd.reviewersByEmail().byState(state)));
            if (!reviewers.isEmpty()) {
                out.reviewers.put(state.asReviewerState(), reviewers);
            }
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#method_after
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        // TODO(dborowitz): Merge email templates so we only have to send one.
        Runnable e = new ReplaceEmailTask(ctx);
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(e));
        } else {
            e.run();
        }
    }
    NotifyHandling notify = magicBranch != null ? magicBranch.getNotify(notes) : NotifyHandling.ALL;
    if (shouldPublishComments()) {
        emailCommentsFactory.create(notify, magicBranch != null ? magicBranch.getAccountsToNotify() : ImmutableListMultimap.of(), notes, newPatchSet, ctx.getUser().asIdentifiedUser(), msg, comments, msg.getMessage(), // TODO(dborowitz): Include labels.
        ImmutableList.of()).sendAsync();
    }
    revisionCreated.fire(notes.getChange(), newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        // TODO(dborowitz): Merge email templates so we only have to send one.
        Runnable e = new ReplaceEmailTask(ctx);
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(e));
        } else {
            e.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    if (shouldPublishComments()) {
        emailCommentsFactory.create(notify, magicBranch != null ? magicBranch.getAccountsToNotify() : ImmutableListMultimap.of(), notes, newPatchSet, ctx.getUser().asIdentifiedUser(), msg, comments, msg.getMessage(), // TODO(dborowitz): Include labels.
        ImmutableList.of()).sendAsync();
    }
    revisionCreated.fire(notes.getChange(), newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.getNotify(notes));
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#method_after
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.notify);
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return Predicate.and(new BooleanPredicate(ChangeField.STARTED, args.fillArgs), ReviewerPredicate.reviewer(args, self()));
        }
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.STARTED)) {
        return Predicate.and(new BooleanPredicate(ChangeField.STARTED, args.fillArgs), byState);
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in == null ? null : in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in == null ? null : in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null, true);
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null, true);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress, boolean hasReviewStarted) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress, hasReviewStarted), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress, hasReviewStarted);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, ReviewerSet pendingReviewers, ReviewerByEmailSet pendingReviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress, boolean hasReviewStarted) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress, hasReviewStarted), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, pendingReviewers, pendingReviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress, hasReviewStarted);
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = accounts.get(db, userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    accountsUpdate.create().update(db, userAccount);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = accounts.get(db, id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        accountsUpdate.create().update(db, a);
        return id;
    }
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#method_after
/*
   * AbandonedSender tests.
   */
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#end_block

#method_before
private void addReviewerToReviewableChangeInReviewDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
/*
   * AddReviewerSender tests.
   */
private void addReviewerToReviewableChangeInReviewDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
/*
   * CommentSender tests.
   */
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
}
#method_after
/*
   * CreateChangeSender tests.
   */
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
/*
   * DeleteReviewerSender tests.
   */
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraCcer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setApiUser(sc.owner);
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(sc.reviewer, sc.ccer, extraReviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setApiUser(sc.owner);
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
/*
   * DeleteVoteSender tests.
   */
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setApiUser(sc.owner);
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
}
#method_after
/*
   * MergedSender tests.
   */
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
}
#end_block

#method_before
@Test
public void newPatchSetByOwnerOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
}
#method_after
/*
   * ReplacePatchSetSender tests.
   */
@Test
public void newPatchSetByOwnerOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
}
#end_block

#method_before
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
/*
   * RestoredSender tests.
   */
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void revertChangeByOwnerInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.ccer).noOneElse();
    assertThat(sender).sent("revert", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
/*
   * RevertedSender tests.
   */
@Test
public void revertChangeByOwnerInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.ccer, sc.watchingProjectOwner, admin).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).sent("revert", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer, admin).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void revertChangeByOwnerCcingSelfInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.ccer).cc(sc.owner).noOneElse();
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void revertChangeByOwnerCcingSelfInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.ccer, sc.watchingProjectOwner, admin).cc(sc.owner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void revertChangeByOtherInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, other);
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).sent("revert", sc).cc(sc.owner, sc.reviewer, sc.ccer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void revertChangeByOtherInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, other);
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.ccer, sc.watchingProjectOwner, admin).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).sent("revert", sc).cc(sc.owner, sc.reviewer, sc.ccer, admin).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void revertChangeByOtherCcingSelfInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.ccer).cc(other).noOneElse();
    assertThat(sender).sent("revert", sc).to(other).cc(sc.owner, sc.reviewer, sc.ccer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void revertChangeByOtherCcingSelfInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.ccer, sc.watchingProjectOwner, admin).cc(other).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).sent("revert", sc).to(other).cc(sc.owner, sc.reviewer, sc.ccer, admin).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#method_after
/*
   * SetAssigneeSender tests.
   */
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
private void addReviewerToReviewableChangeInReviewDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeInReviewDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
private void addReviewerToReviewableChangeInNoteDb(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeInNoteDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDb(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbSingly() throws Exception {
    addReviewerToReviewableChangeInNoteDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDb(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbBatch() throws Exception {
    addReviewerToReviewableChangeInNoteDb(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDbSingly() throws Exception {
    addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDbBatch() throws Exception {
    addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOtherInNoteDb(Adder adder) throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeByOtherInNoteDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherInNoteDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOtherInNoteDb(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherInNoteDbSingly() throws Exception {
    addReviewerToReviewableChangeByOtherInNoteDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherInNoteDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOtherInNoteDb(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherInNoteDbBatch() throws Exception {
    addReviewerToReviewableChangeByOtherInNoteDb(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(Adder adder) throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDbSingly() throws Exception {
    addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDbBatch() throws Exception {
    addReviewerToReviewableChangeByOtherCcingSelfInNoteDb(batch());
}
#end_block

#method_before
private void addReviewerByEmailToReviewableChangeInReviewDb(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerByEmailToReviewableChangeInReviewDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInReviewDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    addReviewerByEmailToReviewableChangeInReviewDb(singly());
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInReviewDbSingly() throws Exception {
    addReviewerByEmailToReviewableChangeInReviewDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInReviewDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    addReviewerByEmailToReviewableChangeInReviewDb(batch());
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInReviewDbBatch() throws Exception {
    addReviewerByEmailToReviewableChangeInReviewDb(batch());
}
#end_block

#method_before
private void addReviewerByEmailToReviewableChangeInNoteDb(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerByEmailToReviewableChangeInNoteDb(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInNoteDbSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerByEmailToReviewableChangeInNoteDb(singly());
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInNoteDbSingly() throws Exception {
    addReviewerByEmailToReviewableChangeInNoteDb(singly());
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInNoteDbBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerByEmailToReviewableChangeInNoteDb(batch());
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInNoteDbBatch() throws Exception {
    addReviewerByEmailToReviewableChangeInNoteDb(batch());
}
#end_block

#method_before
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#end_block

#method_before
private void addReviewerToReviewableWipChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableWipChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#end_block

#method_before
private void addReviewerToWipChangeInNoteDbNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToWipChangeInNoteDbNotifyAll(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInNoteDbNotifyAllSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToWipChangeInNoteDbNotifyAll(singly());
}
#method_after
@Test
public void addReviewerToWipChangeInNoteDbNotifyAllSingly() throws Exception {
    addReviewerToWipChangeInNoteDbNotifyAll(singly());
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInNoteDbNotifyAllBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToWipChangeInNoteDbNotifyAll(batch());
}
#method_after
@Test
public void addReviewerToWipChangeInNoteDbNotifyAllBatch() throws Exception {
    addReviewerToWipChangeInNoteDbNotifyAll(batch());
}
#end_block

#method_before
private void addReviewerToWipChangeInReviewDbNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToWipChangeInReviewDbNotifyAll(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInReviewDbNotifyAllSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    addReviewerToWipChangeInReviewDbNotifyAll(singly());
}
#method_after
@Test
public void addReviewerToWipChangeInReviewDbNotifyAllSingly() throws Exception {
    addReviewerToWipChangeInReviewDbNotifyAll(singly());
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInReviewDbNotifyAllBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    addReviewerToWipChangeInReviewDbNotifyAll(batch());
}
#method_after
@Test
public void addReviewerToWipChangeInReviewDbNotifyAllBatch() throws Exception {
    addReviewerToWipChangeInReviewDbNotifyAll(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
private void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewersSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewersSingly() throws Exception {
    addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewersBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewersBatch() throws Exception {
    addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwnerSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwnerSingly() throws Exception {
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwnerBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwnerBatch() throws Exception {
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner(batch());
}
#end_block

#method_before
private void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accounts.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNoneSingly() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(singly());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNoneSingly() throws Exception {
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(singly());
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNoneBatch() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(batch());
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNoneBatch() throws Exception {
    addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone(batch());
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    voter = accounts.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    voter = accountCreator.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#end_block

#method_before
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#method_after
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // recipients.
    return named(recipientMapToString(recipients));
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // recipients.
    return named(recipientMapToString(recipients, e -> users.emailToName(e)));
}
#end_block

#method_before
private static String recipientMapToString(Map<RecipientType, List<String>> recipients) {
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return buf.toString();
}
#method_after
private static String recipientMapToString(Map<RecipientType, List<String>> recipients, Function<String, String> emailToName) {
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(emailToName.apply(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return buf.toString();
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
    if (expected) {
        accountedFor.add(email);
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
    if (expected) {
        accountedFor.add(email);
    }
}
#end_block

#method_before
public FakeEmailSenderSubject noOneElse() {
    for (Map.Entry<NotifyType, TestAccount> watchEntry : users.watchers.entrySet()) {
        if (!accountedFor.contains(watchEntry.getValue().email)) {
            notTo(watchEntry.getKey());
        }
    }
    Map<RecipientType, List<String>> unaccountedFor = new HashMap<>();
    boolean ok = true;
    for (Map.Entry<RecipientType, List<String>> entry : recipients.entrySet()) {
        unaccountedFor.put(entry.getKey(), new ArrayList<>());
        for (String address : entry.getValue()) {
            if (!accountedFor.contains(address)) {
                unaccountedFor.get(entry.getKey()).add(address);
                ok = false;
            }
        }
    }
    if (!ok) {
        fail("was fully tested, missing assertions for: " + recipientMapToString(unaccountedFor));
    }
    return this;
}
#method_after
public FakeEmailSenderSubject noOneElse() {
    for (Map.Entry<NotifyType, TestAccount> watchEntry : users.watchers.entrySet()) {
        if (!accountedFor.contains(watchEntry.getValue().email)) {
            notTo(watchEntry.getKey());
        }
    }
    Map<RecipientType, List<String>> unaccountedFor = new HashMap<>();
    boolean ok = true;
    for (Map.Entry<RecipientType, List<String>> entry : recipients.entrySet()) {
        unaccountedFor.put(entry.getKey(), new ArrayList<>());
        for (String address : entry.getValue()) {
            if (!accountedFor.contains(address)) {
                unaccountedFor.get(entry.getKey()).add(address);
                ok = false;
            }
        }
    }
    if (!ok) {
        fail("was fully tested, missing assertions for: " + recipientMapToString(unaccountedFor, e -> users.emailToName(e)));
    }
    return this;
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accounts.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accounts.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accountCreator.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accountCreator.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(extraReviewer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(extraReviewer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    setApiUser(extraReviewer);
    gApi.changes().id(sc.changeId).revision("current").review(ReviewInput.recommend());
    sender.clear();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    setApiUser(extraReviewer);
    gApi.changes().id(sc.changeId).revision("current").review(ReviewInput.recommend());
    sender.clear();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerByEmailFromWipChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageWipChange();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerByEmailFromWipChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageReviewableWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageReviewableWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInNoteDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isTrue();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToWipChangeInNoteDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isTrue();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInReviewDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToWipChangeInReviewDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(final String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    magicBranch.perm = permissions.ref(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.perm, magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    ChangeControl changeCtl = projectControl.controlFor(notes);
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    RefControl refctl = projectControl.controlForRef(change.getDest());
    if (!validCommit(rp.getRevWalk(), perm, refctl, inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(ctl.getRefName());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            perm.check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(ctl) : commitValidatorsFactory.forReceiveCommits(ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(perm, ctl) : commitValidatorsFactory.forReceiveCommits(perm, ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee);
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee);
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer, other).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer, other).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            comments = publishComments(ctx);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            change.setReviewStarted(true);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            comments = publishComments(ctx);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#method_after
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(sc.owner).to(sc.reviewer, other).to(sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).to(sc.reviewer, other).to(sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(sc.owner).to(sc.reviewer, sc.ccer, other).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).to(sc.reviewer, sc.ccer, other).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewersInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, sc.ccer).notTo(sc.starrer, other).notTo(// TODO(logan): Why?
    sc.owner).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewersInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, sc.ccer).notTo(sc.starrer, other).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // Although owner would be CCed, there's no one else to send the email to.
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=NONE", other);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(final String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    magicBranch.perm = permissions.ref(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.perm, magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    ChangeControl changeCtl = projectControl.controlFor(notes);
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    RefControl refctl = projectControl.controlForRef(change.getDest());
    if (!validCommit(rp.getRevWalk(), perm, refctl, inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(ctl.getRefName());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            perm.check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(ctl) : commitValidatorsFactory.forReceiveCommits(ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(perm, ctl) : commitValidatorsFactory.forReceiveCommits(perm, ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public void addReviewers(final Collection<Account.Id> cc) {
    reviewers.addAll(cc);
}
#method_after
public void addReviewers(Collection<Account.Id> cc) {
    reviewers.addAll(cc);
}
#end_block

#method_before
public void addExtraCC(final Collection<Account.Id> cc) {
    extraCC.addAll(cc);
}
#method_after
public void addExtraCC(Collection<Account.Id> cc) {
    extraCC.addAll(cc);
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify.equals(NotifyHandling.ALL) || notify.equals(NotifyHandling.OWNER_REVIEWERS)) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify == NotifyHandling.ALL || notify == NotifyHandling.OWNER_REVIEWERS) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#end_block

#method_before
@Before
public void createAssignee() throws Exception {
    assignee = accounts.create("assignee", "assignee@example.com", "assignee");
}
#method_after
@Before
public void createAssignee() throws Exception {
    assignee = accountCreator.create("assignee", "assignee@example.com", "assignee");
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(assignee);
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(assignee);
}
#end_block

#method_before
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#method_after
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    voter = accounts.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    voter = accountCreator.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#end_block

#method_before
private void setEmailStrategy(EmailStrategy strategy) throws Exception {
    setApiUser(voter);
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
}
#method_after
private void setEmailStrategy(EmailStrategy strategy) throws Exception {
    setEmailStrategy(voter, strategy);
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accounts.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accounts.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accountCreator.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accountCreator.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).notTo(extraCcer, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(ALL_COMMENTS);
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).notTo(extraCcer, sc.owner, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).to(// TODO(logan): This should probably be CC.
    sc.reviewerByEmail).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    // TODO(logan): This should behave like notify=OWNER
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).to(// TODO(logan): This should probably be CC.
    sc.reviewerByEmail).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master%r=reviewer,cc=ccer", NEW_CHANGES, NEW_PATCHSETS);
    assertThat(sender).sent("newchange", spc).notTo(spc.owner).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS);
}
#method_after
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    // TODO(logan): Support reviewers/CCs-by-email via push option.
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=" + users.reviewer.username, "cc=" + users.ccer.username), NEW_CHANGES, NEW_PATCHSETS);
    assertThat(sender).sent("newchange", spc).notTo(spc.owner).to(spc.reviewer, spc.watchingProjectOwner).cc(spc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    restore(sc.changeId);
    assertThat(sender).sent("restore", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange(ALL_COMMENTS);
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    restore(sc.changeId);
    assertThat(sender).sent("restore", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange(ALL_COMMENTS);
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
private void restore(String changeId) throws Exception {
    gApi.changes().id(changeId).restore();
}
#method_after
private void restore(String changeId, TestAccount by) throws Exception {
    restore(changeId, by, EmailStrategy.ENABLED);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    setApiUser(sc.owner);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    setApiUser(sc.owner);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    setApiUser(sc.reviewer);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.reviewer).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    setApiUser(sc.reviewer);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.reviewer).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
private void review(String changeId, EmailStrategy strategy) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    gApi.changes().id(changeId).revision("current").review(ReviewInput.recommend());
}
#method_after
private void review(String changeId, EmailStrategy strategy) throws Exception {
    review(changeId, strategy, null);
}
#end_block

#method_before
private void review(String changeId, EmailStrategy strategy) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    gApi.changes().id(changeId).revision("current").review(ReviewInput.recommend());
}
#method_after
private void review(String changeId, EmailStrategy strategy, @Nullable NotifyHandling notify) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    ReviewInput in = ReviewInput.recommend();
    in.notify = notify;
    gApi.changes().id(changeId).revision("current").review(in);
}
#end_block

#method_before
private Adder singly() {
    return (String changeId, String reviewer) -> gApi.changes().id(changeId).addReviewer(reviewer);
}
#method_after
private Adder singly() {
    return (String changeId, String reviewer, @Nullable NotifyHandling notify) -> {
        AddReviewerInput in = new AddReviewerInput();
        in.reviewer = reviewer;
        if (notify != null) {
            in.notify = notify;
        }
        gApi.changes().id(changeId).addReviewer(in);
    };
}
#end_block

#method_before
private Adder batch() {
    return (String changeId, String reviewer) -> {
        ReviewInput in = ReviewInput.noScore();
        in.reviewer(reviewer);
        gApi.changes().id(changeId).revision("current").review(in);
    };
}
#method_after
private Adder batch() {
    return (String changeId, String reviewer, @Nullable NotifyHandling notify) -> {
        ReviewInput in = ReviewInput.noScore();
        in.reviewer(reviewer);
        if (notify != null) {
            in.notify = notify;
        }
        gApi.changes().id(changeId).revision("current").review(in);
    };
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.enabled()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        adder.addReviewer(sc.changeId, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(singly(), sc.changeId, reviewer.email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).to(sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).to(sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(singly(), sc.changeId, email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(adder, sc.changeId, sc.owner, email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(singly(), sc.changeId, email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(email, sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(adder, sc.changeId, sc.owner, email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(email, sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
private void addReviewer(Adder adder, String changeId, String reviewer) throws Exception {
    adder.addReviewer(changeId, reviewer);
}
#method_after
private void addReviewer(Adder adder, String changeId, TestAccount by, String reviewer) throws Exception {
    addReviewer(adder, changeId, by, reviewer, EmailStrategy.ENABLED, null);
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner, sc.starrer).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).notTo(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner, sc.starrer).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).notTo(ABANDONED_CHANGES);
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES);
}
#end_block

#method_before
private void abandon(String changeId, NotifyHandling notify) throws Exception {
    AbandonInput in = new AbandonInput();
    in.notify = notify;
    gApi.changes().id(changeId).abandon(in);
}
#method_after
private void abandon(String changeId, TestAccount by) throws Exception {
    abandon(changeId, by, EmailStrategy.ENABLED);
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
public void notSent() {
    if (messages.hasNext()) {
        fail("a message wasn't sent");
    }
}
#method_after
public FakeEmailSenderSubject notSent() {
    if (actual().peekMessage() != null) {
        fail("a message wasn't sent");
    }
    return this;
}
#end_block

#method_before
public NotificationsSubject sent(String messageType, StagedUsers users) {
    if (!messages.hasNext()) {
        fail("a message was sent");
    }
    Message msg = messages.next();
    if (!msg.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = msg.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    return assertThat(new Notifications(msg, users));
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
TestAccount testAccount(String name) throws Exception {
    return accounts.create(name, name + "@example.com", name);
}
#method_after
TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
TestAccount testAccount(String name, String groupName) throws Exception {
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
protected StagedPreChange stagePreChange(String ref, NotifyType... watches) throws Exception {
    return new StagedPreChange(ref, ImmutableList.copyOf(watches));
}
#method_after
protected StagedPreChange stagePreChange(String ref, @Nullable PushOptionGenerator pushOptionGenerator, NotifyType... watches) throws Exception {
    return new StagedPreChange(ref, pushOptionGenerator, ImmutableList.copyOf(watches));
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accountCreator.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchFileAllProjects() throws Exception {
    String anyProject = createProject("anyProject").get();
    setApiUser(user);
    // watch file in All-Projects project as user to watch the file in all
    // projects
    watch(allProjects.get(), "file:a.txt");
    // push a change to watched file in any project -> should trigger email
    // notification for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> anyRepo = cloneProject(new Project.NameKey(anyProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(anyProject);
    // push a change to non-watched file in any project -> should not trigger
    // email notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFileAllProjects() throws Exception {
    String anyProject = createProject("anyProject").get();
    setApiUser(user);
    // watch file in All-Projects project as user to watch the file in all
    // projects
    watch(allProjects.get(), "file:a.txt");
    // push a change to watched file in any project -> should trigger email
    // notification for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> anyRepo = cloneProject(new Project.NameKey(anyProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accountCreator.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(anyProject);
    // push a change to non-watched file in any project -> should not trigger
    // email notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchProjectNotifyOnDraftChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all drafts
    GroupInfo groupThatCanViewDrafts = gApi.groups().create("groupThatCanViewDrafts").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_DRAFTS, false, new AccountGroup.UUID(groupThatCanViewDrafts.id));
    // watch project as user that can't view drafts
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all drafts
    TestAccount userThatCanViewDrafts = accounts.create("user2", "user2@test.com", "User2", groupThatCanViewDrafts.name);
    setApiUser(userThatCanViewDrafts);
    watch(watchedProject);
    // push a draft change to watched project -> should trigger email notification for
    // userThatCanViewDrafts, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%draft");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewDrafts.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProjectNotifyOnDraftChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all drafts
    GroupInfo groupThatCanViewDrafts = gApi.groups().create("groupThatCanViewDrafts").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_DRAFTS, false, new AccountGroup.UUID(groupThatCanViewDrafts.id));
    // watch project as user that can't view drafts
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all drafts
    TestAccount userThatCanViewDrafts = accountCreator.create("user2", "user2@test.com", "User2", groupThatCanViewDrafts.name);
    setApiUser(userThatCanViewDrafts);
    watch(watchedProject);
    // push a draft change to watched project -> should trigger email notification for
    // userThatCanViewDrafts, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%draft");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewDrafts.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void deleteAllProjectWatchesIfWatchConfigIsTheOnlyFileInUserBranch() throws Exception {
    // Create account that has no files in its refs/users/ branch.
    Account.Id id = accounts.create().id;
    // Add a project watch so that a watch.config file in the refs/users/ branch is created.
    Map<ProjectWatchKey, Set<NotifyType>> watches = new HashMap<>();
    watches.put(ProjectWatchKey.create(project, "*"), ImmutableSet.of(NotifyType.ALL));
    watchConfig.upsertProjectWatches(id, watches);
    assertThat(watchConfig.getProjectWatches(id)).isNotEmpty();
    // Delete all project watches so that the watch.config file in the refs/users/ branch is
    // deleted.
    watchConfig.deleteAllProjectWatches(id);
    assertThat(watchConfig.getProjectWatches(id)).isEmpty();
}
#method_after
@Test
public void deleteAllProjectWatchesIfWatchConfigIsTheOnlyFileInUserBranch() throws Exception {
    // Create account that has no files in its refs/users/ branch.
    Account.Id id = accountCreator.create().id;
    // Add a project watch so that a watch.config file in the refs/users/ branch is created.
    Map<ProjectWatchKey, Set<NotifyType>> watches = new HashMap<>();
    watches.put(ProjectWatchKey.create(project, "*"), ImmutableSet.of(NotifyType.ALL));
    watchConfig.upsertProjectWatches(id, watches);
    assertThat(watchConfig.getProjectWatches(id)).isNotEmpty();
    // Delete all project watches so that the watch.config file in the refs/users/ branch is
    // deleted.
    watchConfig.deleteAllProjectWatches(id);
    assertThat(watchConfig.getProjectWatches(id)).isEmpty();
}
#end_block

#method_before
@Test
public void watchProjectNotifyOnPrivateChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all private changes
    GroupInfo groupThatCanViewPrivateChanges = gApi.groups().create("groupThatCanViewPrivateChanges").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_PRIVATE_CHANGES, false, new AccountGroup.UUID(groupThatCanViewPrivateChanges.id));
    // watch project as user that can't view private changes
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all private change
    TestAccount userThatCanViewPrivateChanges = accounts.create("user2", "user2@test.com", "User2", groupThatCanViewPrivateChanges.name);
    setApiUser(userThatCanViewPrivateChanges);
    watch(watchedProject);
    // push a private change to watched project -> should trigger email notification for
    // userThatCanViewPrivateChanges, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%private");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewPrivateChanges.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProjectNotifyOnPrivateChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all private changes
    GroupInfo groupThatCanViewPrivateChanges = gApi.groups().create("groupThatCanViewPrivateChanges").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_PRIVATE_CHANGES, false, new AccountGroup.UUID(groupThatCanViewPrivateChanges.id));
    // watch project as user that can't view private changes
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all private change
    TestAccount userThatCanViewPrivateChanges = accountCreator.create("user2", "user2@test.com", "User2", groupThatCanViewPrivateChanges.name);
    setApiUser(userThatCanViewPrivateChanges);
    watch(watchedProject);
    // push a private change to watched project -> should trigger email notification for
    // userThatCanViewPrivateChanges, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%private");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewPrivateChanges.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void createChangeOnInvisibleBranchFails() throws Exception {
    changeInTwoBranches("invisible-branch", "a.txt", "branchB", "b.txt");
    block(project, "refs/heads/invisible-branch", READ, REGISTERED_USERS);
    ChangeInput in = newChangeInput(ChangeStatus.NEW);
    in.branch = "invisible-branch";
    assertCreateFails(in, AuthException.class, "cannot upload review");
}
#method_after
@Test
public void createChangeOnInvisibleBranchFails() throws Exception {
    changeInTwoBranches("invisible-branch", "a.txt", "branchB", "b.txt");
    block(project, "refs/heads/invisible-branch", READ, REGISTERED_USERS);
    ChangeInput in = newChangeInput(ChangeStatus.NEW);
    in.branch = "invisible-branch";
    assertCreateFails(in, ResourceNotFoundException.class, "");
}
#end_block

#method_before
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId();
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#method_after
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId("refs/heads/master", "a.txt", "content");
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = revision.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = revision.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true, null);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false, null);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#method_after
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#end_block

#method_before
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#method_after
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#end_block

#method_before
@Test
public void rebaseAllowedWithPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(Permission.REBASE, project, "refs/heads/master", false, REGISTERED_USERS);
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).rebase();
}
#method_after
@Test
public void rebaseAllowedWithPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(project, "refs/heads/master", Permission.REBASE, false, REGISTERED_USERS);
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).rebase();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        int id = changeResult.getChange().getId().id;
        RevCommit commit = changeResult.getCommit();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
        String ref = new Change.Id(id).toRefPrefix() + "1";
        eventRecorder.assertRefUpdatedEvents(project.get(), ref, null, commit, commit, null);
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        int id = changeResult.getChange().getId().id;
        RevCommit commit = changeResult.getCommit();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
        String ref = new Change.Id(id).toRefPrefix() + "1";
        eventRecorder.assertRefUpdatedEvents(project.get(), ref, null, commit, commit, null);
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
@Test
public void editTopicWithPermissionAllowed() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("");
    grant(Permission.EDIT_TOPIC_NAME, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).topic("mytopic");
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("mytopic");
}
#method_after
@Test
public void editTopicWithPermissionAllowed() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("");
    grant(project, "refs/heads/master", Permission.EDIT_TOPIC_NAME, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).topic("mytopic");
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("mytopic");
}
#end_block

#method_before
@Test
public void submitAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    grant(Permission.SUBMIT, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void submitAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    grant(project, "refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#method_after
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#end_block

#method_before
@Test
public void createNewDraftPatchSetOnDraftChange() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet4");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(p, admin);
    TestRepository<?> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/drafts/master");
    r1.assertOkStatus();
    // Add user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r1.getChangeId()).addReviewer(in);
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/drafts/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewDraftPatchSetOnDraftChange() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet4");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(p, admin);
    TestRepository<?> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/drafts/master");
    r1.assertOkStatus();
    // Add user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r1.getChangeId()).addReviewer(in);
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/drafts/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
public static DiffSummaryKey fromPatchListKey(PatchListKey plk) {
    Preconditions.checkState(plk.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF);
    return new DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace());
}
#method_after
public static DiffSummaryKey fromPatchListKey(PatchListKey plk) {
    Preconditions.checkArgument(plk.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF);
    return new DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace());
}
#end_block

#method_before
private Multimap<String, Edit> getEditsDueToRebasePerFilePath(RevCommit commitA, RevCommit commitB) throws PatchListNotAvailableException {
    if (!arePatchSetCommitsWithRebaseInBetween(commitA, commitB)) {
        return ImmutableMultimap.of();
    }
    PatchListKey parentDiffKey = PatchListKey.againstCommitWithPureTreeDiff(commitA.getParent(0), commitB.getParent(0), key.getWhitespace());
    PatchList parentPatchList = patchListCache.get(parentDiffKey, project);
    PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
    PatchList oldPatchList = patchListCache.get(oldKey, project);
    PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
    PatchList newPatchList = patchListCache.get(newKey, project);
    EditTransformer editTransformer = new EditTransformer(parentPatchList.getPatches());
    editTransformer.transformReferencesOfSideA(oldPatchList.getPatches());
    editTransformer.transformReferencesOfSideB(newPatchList.getPatches());
    return editTransformer.getEditsPerFilePath();
}
#method_after
private Multimap<String, Edit> getEditsDueToRebasePerFilePath(RevCommit commitA, RevCommit commitB) throws PatchListNotAvailableException {
    if (commitA == null || isRootOrMergeCommit(commitA) || isRootOrMergeCommit(commitB) || areParentChild(commitA, commitB) || haveCommonParent(commitA, commitB)) {
        return ImmutableMultimap.of();
    }
    PatchListKey parentDiffKey = PatchListKey.againstCommitWithPureTreeDiff(commitA.getParent(0), commitB.getParent(0), key.getWhitespace());
    PatchList parentPatchList = patchListCache.get(parentDiffKey, project);
    PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
    PatchList oldPatchList = patchListCache.get(oldKey, project);
    PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
    PatchList newPatchList = patchListCache.get(newKey, project);
    EditTransformer editTransformer = new EditTransformer(parentPatchList.getPatches());
    editTransformer.transformReferencesOfSideA(oldPatchList.getPatches());
    editTransformer.transformReferencesOfSideB(newPatchList.getPatches());
    return editTransformer.getEditsPerFilePath();
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isOwnerAnyRef());
}
#method_after
private boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isOwnerAnyRef());
}
#end_block

#method_before
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case CREATE_REF:
            return canAddRefs();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && getRefControl().canUpload() && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
private boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#method_after
private boolean canRestore(ReviewDb db) throws OrmException {
    // Anyone who can abandon the change can restore it, as long as they can create changes.
    return canAbandon(db) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE);
}
#end_block

#method_before
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!getRefControl().canUpload() || isPatchSetLocked(db) || !isPatchVisible(patchSetUtil.current(db, notes), db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#method_after
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db) || !isPatchVisible(patchSetUtil.current(db, notes), db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
public CommitValidators forReceiveCommits(RefControl refControl, SshInfo sshInfo, Repository repo, RevWalk rw) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new AuthorUploaderValidator(refControl, canonicalWebUrl), new CommitterUploaderValidator(refControl, canonicalWebUrl), new SignedOffByValidator(refControl), new ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refControl, rw, allUsers), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#method_after
public CommitValidators forReceiveCommits(PermissionBackend.ForRef perm, RefControl refctl, SshInfo sshInfo, Repository repo, RevWalk rw) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    IdentifiedUser user = refctl.getUser().asIdentifiedUser();
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refctl), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refctl, rw, allUsers), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#end_block

#method_before
public CommitValidators forGerritCommits(RefControl refControl, SshInfo sshInfo, RevWalk rw) {
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new AuthorUploaderValidator(refControl, canonicalWebUrl), new SignedOffByValidator(refControl), new ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refControl, rw, allUsers), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#method_after
public CommitValidators forGerritCommits(PermissionBackend.ForRef perm, RefControl refctl, SshInfo sshInfo, RevWalk rw) {
    IdentifiedUser user = refctl.getUser().asIdentifiedUser();
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refctl), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refctl, rw, allUsers), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#end_block

#method_before
public CommitValidators forMergedCommits(RefControl refControl) {
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AuthorUploaderValidator(refControl, canonicalWebUrl), new CommitterUploaderValidator(refControl, canonicalWebUrl)));
}
#method_after
public CommitValidators forMergedCommits(PermissionBackend.ForRef perm, RefControl refControl) {
    IdentifiedUser user = refControl.getUser().asIdentifiedUser();
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl)));
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    final ProjectControl projectControl = refControl.getProjectControl();
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        boolean sboAuthor = false;
        boolean sboCommitter = false;
        boolean sboMe = false;
        for (FooterLine footer : receiveEvent.commit.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.hasEmailAddress(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !refControl.canForgeCommitter()) {
            throw new CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer");
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!state.isUseSignedOffBy()) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    PersonIdent committer = commit.getCommitterIdent();
    PersonIdent author = commit.getAuthorIdent();
    boolean sboAuthor = false;
    boolean sboCommitter = false;
    boolean sboMe = false;
    for (FooterLine footer : commit.getFooterLines()) {
        if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
            String e = footer.getEmailAddress();
            if (e != null) {
                sboAuthor |= author.getEmailAddress().equals(e);
                sboCommitter |= committer.getEmailAddress().equals(e);
                sboMe |= user.hasEmailAddress(e);
            }
        }
    }
    if (!sboAuthor && !sboCommitter && !sboMe) {
        try {
            perm.check(RefPermission.FORGE_COMMITTER);
        } catch (AuthException denied) {
            throw new CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer");
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_COMMITTER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (!currentUser.hasEmailAddress(author.getEmailAddress()) && !refControl.canForgeAuthor()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "author", author, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid author", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (user.hasEmailAddress(author.getEmailAddress())) {
        return Collections.emptyList();
    }
    try {
        perm.check(RefPermission.FORGE_AUTHOR);
        return Collections.emptyList();
    } catch (AuthException e) {
        throw new CommitValidationException("invalid author", invalidEmail(receiveEvent.commit, "author", author, user, canonicalWebUrl));
    } catch (PermissionBackendException e) {
        log.error("cannot check FORGE_AUTHOR", e);
        throw new CommitValidationException("internal auth error");
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (!currentUser.hasEmailAddress(committer.getEmailAddress()) && !refControl.canForgeCommitter()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "committer", committer, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid committer", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (user.hasEmailAddress(committer.getEmailAddress())) {
        return Collections.emptyList();
    }
    try {
        perm.check(RefPermission.FORGE_COMMITTER);
        return Collections.emptyList();
    } catch (AuthException e) {
        throw new CommitValidationException("invalid committer", invalidEmail(receiveEvent.commit, "committer", committer, user, canonicalWebUrl));
    } catch (PermissionBackendException e) {
        log.error("cannot check FORGE_COMMITTER", e);
        throw new CommitValidationException("internal auth error");
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !refControl.canForgeGerritServerIdentity()) {
        throw new CommitValidationException("do not amend merges not made by you");
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException("do not amend merges not made by you");
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    ListMultimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    int projects = 0;
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            BranchBatch bb = validateChangeList(or, cbb.get(branch));
            toSubmit.put(branch, bb);
            if (!bb.commits().isEmpty()) {
                projects++;
            }
        }
    }
    if (projects > 1) {
        topicMetrics.topicSubmissions.increment();
    }
    // Done checks that don't involve running submit strategies.
    commitStatus.maybeFailVerbose();
    try {
        SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        batchUpdateFactory.execute(orm.batchUpdates(batchUpdateFactory, allProjects), new SubmitStrategyListener(submitInput, strategies, commitStatus), submissionId, dryrun);
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (IOException | SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    if (projects > 1) {
        topicMetrics.topicSubmissionsCompleted.increment();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    ListMultimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    int projects = 0;
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            BranchBatch bb = validateChangeList(or, cbb.get(branch));
            toSubmit.put(branch, bb);
            if (!bb.commits().isEmpty()) {
                projects++;
            }
        }
    }
    // Done checks that don't involve running submit strategies.
    commitStatus.maybeFailVerbose();
    if (projects > 1) {
        topicMetrics.topicSubmissions.increment();
    }
    try {
        SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        batchUpdateFactory.execute(orm.batchUpdates(batchUpdateFactory, allProjects), new SubmitStrategyListener(submitInput, strategies, commitStatus), submissionId, dryrun);
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (IOException | SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    if (projects > 1) {
        topicMetrics.topicSubmissionsCompleted.increment();
    }
}
#end_block

#method_before
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser.isPresent()).isTrue();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser).isPresent();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void setDescriptionAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    grant(Permission.OWNER, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
}
#method_after
@Test
public void setDescriptionAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    grant(project, "refs/heads/master", Permission.OWNER, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
}
#end_block

#method_before
public Change.Id cherryPick(@Nullable Change.Id sourceChangeId, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, ObjectId sourceObjectId, String message, ProjectControl projectControl, CherryPickDestination destination, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        // ensure the cherry-picked commit is flushed before patch sets are updated.
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        CodeReviewCommit sourceCommit = revWalk.parseCommit(sourceObjectId);
        if (parent <= 0 || parent > sourceCommit.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, sourceCommit.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = userProvider.get().newCommitterIdent(now, serverTimeZone);
        CodeReviewCommit mergeTip = revWalk.parseCommit(destination.mergeTip());
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(sourceCommit.getTree(), mergeTip, sourceCommit.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit commit;
        try {
            commit = mergeUtilFactory.create(projectControl.getProjectState()).createCherryPickFromCommit(oi, repo.getConfig(), mergeTip, sourceCommit, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            String targetRef = destination.targetRef();
            Branch.NameKey newDest = new Branch.NameKey(project, targetRef);
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destination.targetAtChange()) {
                if (destChanges.size() > 0) {
                    throw new ResourceConflictException("target branch contains a change with key " + changeKey);
                }
            } else if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("target branch contains several changes with key " + changeKey + ". Cannot create a new patch set.");
            }
            try (BatchUpdate bu = updateFactory.create(dbProvider.get(), project, userProvider.get(), now)) {
                bu.setRepository(repo, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick will be added as a
                    // new patch set.
                    ChangeControl destCtl = projectControl.controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, repo, destCtl, commit);
                } else {
                    // Change key not found on destination branch. We can create a new change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, commit, targetRef, newTopic, sourceBranch, sourceObjectId);
                    if (sourceChangeId != null && sourcePatchId != null) {
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, newDest.getShortName(), commit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    return cherryPick(batchUpdateFactory, change.getId(), patch.getId(), change.getDest(), change.getTopic(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit) throws IOException, OrmException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    bu.addOp(destChange.getId(), inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setNotify(NotifyHandling.NONE));
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch, ObjectId sourceCommit) throws OrmException, IOException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit));
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    if (input == null) {
        input = new CherryPickInput();
    }
    String message = Strings.nullToEmpty(input.message).trim();
    if (message.isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    }
    String destination = Strings.nullToEmpty(input.destination).trim();
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    ChangeControl control = revision.getControl();
    if (!control.isVisible(dbProvider.get())) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    CherryPickDestination dest = cherryPickUtil.parseDestination(projectControl, destination);
    RefControl refControl = projectControl.controlForRef(dest.targetRef());
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + destination);
    }
    int parent = input.parent == null ? 1 : input.parent;
    try {
        Change.Id cherryPickedChangeId = // TODO(dborowitz): Pass updateFactory here.
        cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), message, projectControl, dest, parent);
        return json.noOptions().format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    input.parent = input.parent == null ? 1 : input.parent;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    if (!control.isVisible(dbProvider.get())) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    RefControl refControl = projectControl.controlForRef(RefNames.fullName(input.destination));
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, revision.getChange(), revision.getPatchSet(), input, refControl);
        return json.noOptions().format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId();
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#method_after
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId("refs/heads/master", "a.txt", "content");
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private Map<String, Result> changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
    return ImmutableMap.of("master", initialCommit, branchA, changeA, branchB, changeB);
}
#end_block

#method_before
static AllExternalIds create(Multimap<Account.Id, ExternalId> byAccount) {
    Multimap<String, ExternalId> byEmail = MultimapBuilder.hashKeys().arrayListValues().build();
    byAccount.values().stream().forEach(e -> {
        if (!Strings.isNullOrEmpty(e.email())) {
            byEmail.put(e.email(), e);
        }
    });
    return new AutoValue_ExternalIdCacheImpl_AllExternalIds(ImmutableSetMultimap.copyOf(byAccount), ImmutableSetMultimap.copyOf(byEmail));
}
#method_after
static AllExternalIds create(Multimap<Account.Id, ExternalId> byAccount) {
    ImmutableSetMultimap<String, ExternalId> byEmail = byAccount.values().stream().filter(e -> !Strings.isNullOrEmpty(e.email())).collect(toImmutableSetMultimap(ExternalId::email, e -> e));
    return new AutoValue_ExternalIdCacheImpl_AllExternalIds(ImmutableSetMultimap.copyOf(byAccount), byEmail);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, extraCC);
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    assertChange(expectedStatus, expectedTopic, false, Arrays.asList(expectedReviewers), ImmutableList.of());
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    assertChange(expectedStatus, expectedTopic, Arrays.asList(expectedReviewers), ImmutableList.of());
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, boolean legacyCcs, List<TestAccount> expectedReviewers, List<TestAccount> expectedCcs) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    if (legacyCcs) {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, Stream.concat(expectedReviewers.stream(), expectedCcs.stream()).collect(toList()));
    } else {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, expectedReviewers);
        assertReviewers(c, ReviewerStateInternal.CC, expectedCcs);
    }
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, List<TestAccount> expectedReviewers, List<TestAccount> expectedCcs) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    if (notesMigration.readChanges()) {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, expectedReviewers);
        assertReviewers(c, ReviewerStateInternal.CC, expectedCcs);
    } else {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, Stream.concat(expectedReviewers.stream(), expectedCcs.stream()).collect(toList()));
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, !notesMigration.readChanges(), ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accounts.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, !notesMigration.readChanges(), ImmutableList.of(), ImmutableList.of(user, accounts.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accounts.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user, accounts.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void revertPreservesReviewersAndCcs() throws Exception {
    PushOneCommit.Result r = createChange();
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email);
    in.reviewer(accounts.user2().email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    // expect both the original reviewers and CCs to be preserved
    // original owner should be added as reviewer, user requesting the revert (new owner) removed
    setApiUser(accounts.admin2());
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revert().get().reviewers;
    assertThat(result.containsKey(ReviewerState.REVIEWER)).isTrue();
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    assertThat(reviewers).containsAllOf(user.id.get(), admin.id.get());
    if (notesMigration.readChanges()) {
        assertThat(result.containsKey(ReviewerState.CC)).isTrue();
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(accounts.user2().id.get());
    } else {
        assertThat(reviewers).contains(accounts.user2().id.get());
    }
}
#method_after
@Test
public void revertPreservesReviewersAndCcs() throws Exception {
    PushOneCommit.Result r = createChange();
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email);
    in.reviewer(accounts.user2().email, ReviewerState.CC, true);
    // Add user as reviewer that will create the revert
    in.reviewer(accounts.admin2().email);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    // expect both the original reviewers and CCs to be preserved
    // original owner should be added as reviewer, user requesting the revert (new owner) removed
    setApiUser(accounts.admin2());
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revert().get().reviewers;
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(accounts.user2().id.get());
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accounts.user2().id.get());
    }
}
#end_block

#method_before
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(db.get(), ctl.getNotes());
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        Set<Account.Id> ccs = new HashSet<>();
        ccs.addAll(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setCcs(ccs);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(db.get(), ctl.getNotes());
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setExtraCC(ccs);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
@Test
@UseLocalDisk
@GlobalPluginConfig(pluginName = "high-availability", name = "peerInfo.url", value = URL)
@GlobalPluginConfig(pluginName = "high-availability", name = "http.user", value = "admin")
@GlobalPluginConfig(pluginName = "high-availability", name = "cache.cacheThreadPoolSize", value = "10")
@GlobalPluginConfig(pluginName = "high-availability", name = "main.sharedDirectory", value = "directory")
public void flushAndSendPost() throws Exception {
    final String flushRequest = "/plugins/high-availability/cache/" + Constants.PROJECT_LIST;
    final CyclicBarrier checkPoint = new CyclicBarrier(2);
    wireMockRule.addMockServiceRequestListener(new RequestListener() {

        @Override
        public void requestReceived(Request request, Response response) {
            if (request.getAbsoluteUrl().contains(flushRequest)) {
                try {
                    checkPoint.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    fail();
                }
            }
        }
    });
    givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_NO_CONTENT)));
    adminSshSession.exec("gerrit flush-caches --cache " + Constants.PROJECT_LIST);
    checkPoint.await(5, TimeUnit.SECONDS);
    verify(postRequestedFor(urlEqualTo(flushRequest)));
}
#method_after
@Test
@UseLocalDisk
@GlobalPluginConfig(pluginName = "high-availability", name = "peerInfo.url", value = URL)
@GlobalPluginConfig(pluginName = "high-availability", name = "http.user", value = "admin")
@GlobalPluginConfig(pluginName = "high-availability", name = "cache.threadPoolSize", value = "10")
@GlobalPluginConfig(pluginName = "high-availability", name = "main.sharedDirectory", value = "directory")
public void flushAndSendPost() throws Exception {
    final String flushRequest = "/plugins/high-availability/cache/" + Constants.PROJECT_LIST;
    final CyclicBarrier checkPoint = new CyclicBarrier(2);
    wireMockRule.addMockServiceRequestListener(new RequestListener() {

        @Override
        public void requestReceived(Request request, Response response) {
            if (request.getAbsoluteUrl().contains(flushRequest)) {
                try {
                    checkPoint.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    fail();
                }
            }
        }
    });
    givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_NO_CONTENT)));
    adminSshSession.exec("gerrit flush-caches --cache " + Constants.PROJECT_LIST);
    checkPoint.await(5, TimeUnit.SECONDS);
    verify(postRequestedFor(urlEqualTo(flushRequest)));
}
#end_block

#method_before
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
    install(LfsLocksHandler.module());
}
#end_block

#method_before
LfsLockResponse createLock(String project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#method_after
LfsLockResponse createLock(Project.NameKey project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#end_block

#method_before
LfsLockResponse deleteLock(String project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#method_after
LfsLockResponse deleteLock(Project.NameKey project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#end_block

#method_before
LfsVerifyLocksResponse verifyLocks(String project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#method_after
LfsVerifyLocksResponse verifyLocks(Project.NameKey project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#end_block

#method_before
LfsGetLocksResponse listLocksByPath(String project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#method_after
LfsGetLocksResponse listLocksByPath(Project.NameKey project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#end_block

#method_before
LfsGetLocksResponse listLocksById(String project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? Lists.newArrayList(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#method_after
LfsGetLocksResponse listLocksById(Project.NameKey project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? ImmutableList.of(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#end_block

#method_before
LfsGetLocksResponse listLocks(String project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projects.getUnchecked(project).getLocks(), null);
}
#method_after
LfsGetLocksResponse listLocks(Project.NameKey project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projectLocks.getUnchecked(project).getLocks(), null);
}
#end_block

#method_before
@Override
public LfsProjectLocks load(String project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#method_after
@Override
public LfsProjectLocks load(Project.NameKey project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#end_block

#method_before
Optional<LfsLock> getLock(String lockId) {
    return Optional.fromNullable(locks.getIfPresent(lockId));
}
#method_after
Optional<LfsLock> getLock(String lockId) {
    return Optional.ofNullable(locks.getIfPresent(lockId));
}
#end_block

#method_before
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing locking to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
    } finally {
        fileLock.unlock();
    }
    locks.put(lockId, lock);
    return lock;
}
#method_after
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing lock to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
        // put lock object to cache while file lock is being hold so that
        // there is no chance that other process performs lock operation
        // in the meantime (either cache returns with existing object or
        // LockFile.lock fails on locking attempt)
        locks.put(lockId, lock);
    } finally {
        fileLock.unlock();
    }
    return lock;
}
#end_block

#method_before
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        return matcher.group(1);
    }
    throw new LfsException("no repository at " + context.path);
}
#method_after
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        return matcher.group(1);
    }
    throw new LfsException("no repository at " + context.path);
}
#end_block

#method_before
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    if (!control.isReadable()) {
        throwUnauthroizedOp("list locks", control, log);
    }
}
#method_after
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    if (!control.isReadable()) {
        throwUnauthorizedOp("list locks", control);
    }
}
#end_block

#method_before
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            action = new CreateLock();
        } else {
            action = new DeleteLock(lockId);
        }
        return project;
    }
    matcher = LFS_VERIFICATION_URL.matcher(context.path);
    if (matcher.matches()) {
        action = new VerifyLock();
        return matcher.group(1);
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#method_after
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            action = new CreateLock();
        } else {
            action = new DeleteLock(lockId);
        }
        return project;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        action = new VerifyLock();
        return matcher.group(1);
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#end_block

#method_before
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    // all operations require push permission
    if (Capable.OK != control.canPushToAtLeastOneRef()) {
        throwUnauthroizedOp(action.getName(), control, log);
    }
}
#method_after
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    // all operations require push permission
    if (Capable.OK != control.canPushToAtLeastOneRef()) {
        throwUnauthorizedOp(action.getName(), control);
    }
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL.matcher(action.path);
    if (!matcher.matches()) {
        action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
        return;
    }
    String project = matcher.group(1);
    listLocks(project, action);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project, action);
        return;
    }
    action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, action);
        } else {
            deleteLock(project, lockId, action);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL.matcher(action.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), action);
    } else {
        action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, action);
        } else {
            deleteLock(project, lockId, action);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), action);
        return;
    }
    action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
}
#end_block

#method_before
private void listLocks(String project, Action action) throws IOException {
    LfsListLocksInput input = action.input(LfsListLocksInput.class);
    log.debug("Get list of locks for {} project", project);
    // TODO method stub for getting project's locks list
    action.sendResponse(new LfsGetLocksResponse(Collections.emptyList(), input.cursor));
}
#method_after
private void listLocks(String project, Action action) throws IOException {
    log.debug("Get list of locks for {} project", project);
    // TODO method stub for getting project's locks list
    // stub for searching lock by path
    String path = action.getParam("path");
    if (!Strings.isNullOrEmpty(path)) {
        action.sendResponse(new LfsGetLocksResponse(ImmutableList.<LfsLock>builder().add(new LfsLock("random_id", path, now(), new LfsLockOwner("Lock Owner <lock_owner@example.com>"))).build(), null));
        return;
    }
    // stub for searching lock by id
    String id = action.getParam("id");
    if (!Strings.isNullOrEmpty(id)) {
        action.sendResponse(new LfsGetLocksResponse(ImmutableList.<LfsLock>builder().add(new LfsLock(id, "path/to/file", now(), new LfsLockOwner("Lock Owner <lock_owner@example.com>"))).build(), null));
        return;
    }
    // stub for returning all locks
    action.sendResponse(new LfsGetLocksResponse(Collections.emptyList(), null));
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(LFS_OBJECTS_REST).with(LfsApiServlet.class);
    serveRegex(LFS_LOCKS_REST).with(LfsLocksServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("lfs-project-info.js"));
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(LFS_OBJECTS_REGEX_REST).with(LfsApiServlet.class);
    serveRegex(LFS_LOCKS_REGEX_REST).with(LfsLocksServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("lfs-project-info.js"));
}
#end_block

#method_before
@Test
public void renderTemplate() throws URISyntaxException {
    final String TEST_CANONICAL_URL = "foo-url";
    final String TEST_CDN_PATH = "bar-cdn";
    TestIndexServlet servlet = new TestIndexServlet(TEST_CANONICAL_URL, TEST_CDN_PATH);
    String output = servlet.getIndexSource();
    assertThat(output).contains("<!DOCTYPE html>");
    assertThat(output).contains("window.CANONICAL_PATH = '" + TEST_CANONICAL_URL);
    assertThat(output).contains("<link rel=\"preload\" href=\"" + TEST_CDN_PATH);
}
#method_after
@Test
public void renderTemplate() throws URISyntaxException {
    String testCanonicalUrl = "foo-url";
    String testCdnPath = "bar-cdn";
    TestIndexServlet servlet = new TestIndexServlet(testCanonicalUrl, testCdnPath);
    String output = servlet.getIndexSource();
    assertThat(output).contains("<!DOCTYPE html>");
    assertThat(output).contains("window.CANONICAL_PATH = '" + testCanonicalUrl);
    assertThat(output).contains("<link rel=\"preload\" href=\"" + testCdnPath);
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new DatabaseModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new SchemaModule());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class), sysInjector.getInstance(LfsPluginAuthCommand.Module.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
static Map<String, Config> parse(GerritPluginConfigs annotation) {
    if (annotation == null || annotation.value().length < 1) {
        return null;
    }
    HashMap<String, Config> result = new HashMap<>();
    for (GerritPluginConfig c : annotation.value()) {
        String pluginName = c.pluginName();
        Config config;
        if (result.containsKey(pluginName)) {
            config = result.get(pluginName);
        } else {
            config = new Config();
            result.put(pluginName, config);
        }
        parseAnnotation(config, new GerritPluginConfigToGerritConfig(c));
    }
    return result;
}
#method_after
static Map<String, Config> parse(GlobalPluginConfig annotation) {
    if (annotation == null) {
        return null;
    }
    Map<String, Config> result = new HashMap<>();
    Config cfg = new Config();
    parseAnnotation(cfg, new GlobalPluginConfigToGerritConfig(annotation));
    result.put(annotation.pluginName(), cfg);
    return result;
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GerritPluginConfig is only valid on methods.
    null, // @GerritPluginConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GlobalPluginConfig is only valid on methods.
    null, // @GlobalPluginConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GerritPluginConfig.class), testDesc.getAnnotation(GerritPluginConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GlobalPluginConfig.class), testDesc.getAnnotation(GlobalPluginConfigs.class));
}
#end_block

#method_before
private Config buildConfig(Config baseConfig) {
    if (configs() != null && config() != null) {
        throw new IllegalStateException("Use either @GerritConfigs or @GerritConfig not both");
    }
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#method_after
private Config buildConfig(Config baseConfig) {
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#end_block

#method_before
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null && pluginConfig() != null) {
        throw new IllegalStateException("Use either @GerritPluginConfig or @GerritPluginConfigs not both");
    }
    if ((pluginConfigs() != null || pluginConfig() != null) && memory()) {
        throw new IllegalStateException("Must use @UseLocalDisk with @GerritPluginConfig(s)");
    }
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#method_after
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#end_block

#method_before
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#method_after
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    desc.checkValidAnnotations();
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    String path = req.getPathInfo();
    String accountGroupId = path.substring(path.lastIndexOf('/') + 1);
    AccountGroup.UUID uuid = AccountGroup.UUID.parse(accountGroupId);
    try {
        Context.setForwardedEvent(true);
        index(uuid);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        sendError(rsp, SC_CONFLICT, e.getMessage());
        logger.error("Unable to update account index", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding(UTF_8.name());
    String path = req.getPathInfo();
    String accountGroupId = path.substring(path.lastIndexOf('/') + 1);
    AccountGroup.UUID uuid = AccountGroup.UUID.parse(accountGroupId);
    try {
        Context.setForwardedEvent(true);
        index(uuid);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (IOException e) {
        sendError(rsp, SC_CONFLICT, e.getMessage());
        logger.error("Unable to update account index", e);
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
@Test
public void testIndexGroupTaskHashCodeAndEquals() {
    IndexGroupTask task = indexEventHandler.new IndexGroupTask(UUID);
    assertThat(task.equals(task)).isTrue();
    assertThat(task.hashCode()).isEqualTo(task.hashCode());
    IndexGroupTask identicalTask = indexEventHandler.new IndexGroupTask(UUID);
    assertThat(task.equals(identicalTask)).isTrue();
    assertThat(task.hashCode()).isEqualTo(identicalTask.hashCode());
    assertThat(task.equals(null)).isFalse();
    assertThat(task.equals("test")).isFalse();
    assertThat(task.hashCode()).isNotEqualTo("test".hashCode());
    IndexGroupTask differentGroupIdTask = indexEventHandler.new IndexGroupTask("123");
    assertThat(task.equals(differentGroupIdTask)).isFalse();
    assertThat(task.hashCode()).isNotEqualTo(differentGroupIdTask.hashCode());
}
#method_after
@Test
public void testIndexGroupTaskHashCodeAndEquals() {
    IndexGroupTask task = indexEventHandler.new IndexGroupTask(UUID);
    IndexGroupTask sameTask = task;
    assertThat(task.equals(sameTask)).isTrue();
    assertThat(task.hashCode()).isEqualTo(sameTask.hashCode());
    IndexGroupTask identicalTask = indexEventHandler.new IndexGroupTask(UUID);
    assertThat(task.equals(identicalTask)).isTrue();
    assertThat(task.hashCode()).isEqualTo(identicalTask.hashCode());
    assertThat(task.equals(null)).isFalse();
    assertThat(task.equals("test")).isFalse();
    assertThat(task.hashCode()).isNotEqualTo("test".hashCode());
    IndexGroupTask differentGroupIdTask = indexEventHandler.new IndexGroupTask("123");
    assertThat(task.equals(differentGroupIdTask)).isFalse();
    assertThat(task.hashCode()).isNotEqualTo(differentGroupIdTask.hashCode());
}
#end_block

#method_before
@Override
public boolean indexGroup(String uuid) {
    return new Request("index group " + uuid) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "index/group", uuid));
        }
    }.execute();
}
#method_after
@Override
public boolean indexGroup(final String uuid) {
    return new Request("index group " + uuid) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "index/group", uuid));
        }
    }.execute();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    List<AccountGroup> accountGroups = db.accountGroups().all().toList();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp createdOn = firstTimeMentioned.orElseGet(() -> Timestamp.from(AccountGroup.AUDIT_CREATION_INSTANT));
        accountGroup.setCreatedOn(createdOn);
    }
    db.accountGroups().update(accountGroups);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    List<AccountGroup> accountGroups = db.accountGroups().all().toList();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp createdOn = firstTimeMentioned.orElseGet(() -> AccountGroup.auditCreationInstantTs());
        accountGroup.setCreatedOn(createdOn);
    }
    db.accountGroups().update(accountGroups);
}
#end_block

#method_before
public Timestamp getCreatedOn() {
    return createdOn != null ? createdOn : Timestamp.from(AUDIT_CREATION_INSTANT);
}
#method_after
public Timestamp getCreatedOn() {
    return createdOn != null ? createdOn : auditCreationInstantTs();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    ResultSet<AccountGroup> accountGroups = db.accountGroups().all();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp auditAddedOn = Timestamp.from(LocalDateTime.of(2009, Month.JUNE, 8, 19, 31).toInstant(ZoneOffset.UTC));
        Timestamp createdOn = firstTimeMentioned.orElse(auditAddedOn);
        accountGroup.setCreatedOn(createdOn);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    List<AccountGroup> accountGroups = db.accountGroups().all().toList();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp createdOn = firstTimeMentioned.orElseGet(() -> Timestamp.from(AUDIT_CREATION_INSTANT));
        accountGroup.setCreatedOn(createdOn);
    }
    db.accountGroups().update(accountGroups);
}
#end_block

#method_before
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Method configMap = getConfigMap(clazz);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : callConfigMapMethod(configMap).entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#method_after
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Map<String, org.eclipse.jgit.lib.Config> configMap = callConfigMapMethod(getConfigMap(clazz), configs);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : configMap.entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.getTypeName().equals(types[0].getTypeName()), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.getTypeName().equals(types[1].getTypeName()), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m, List<Method> configs) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.isAssignableFrom((Class<?>) types[0]), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.isAssignableFrom((Class<?>) types[1]), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        checkArgument(!configMap.containsKey(DEFAULT), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, DEFAULT);
        for (String name : configs.stream().map(cm -> cm.getName()).collect(toSet())) {
            checkArgument(!configMap.containsKey(name), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, name);
        }
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
    }
    return reviewerByState(who, ReviewerStateInternal.REVIEWER);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
    }
    return reviewerByState(who, ReviewerStateInternal.REVIEWER);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (byState == Predicate.<ChangeData>any()) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC);
}
#method_after
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC, false);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        Set<Account.Id> accounts = parseAccount(who);
        if (!forDefaultField || accounts.size() <= MAX_ACCOUNTS_PER_DEFAULT_FIELD) {
            reviewerPredicate = Predicate.or(accounts.stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
        }
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else if (reviewerByEmailPredicate != null) {
        return reviewerByEmailPredicate;
    } else {
        return Predicate.any();
    }
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@Test
public void byPrivate() throws Exception {
    @SuppressWarnings("deprecation")
    int v40 = ChangeSchemaDefinitions.V40.getVersion();
    if (getSchemaVersion() < v40) {
        assertMissingField(ChangeField.PRIVATE);
        assertFailingQuery("is:private", "'is:private' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#method_after
@Test
public void byPrivate() throws Exception {
    if (getSchemaVersion() < 40) {
        assertMissingField(ChangeField.PRIVATE);
        assertFailingQuery("is:private", "'is:private' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true, null);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#method_after
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < 42) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= ChangeSchemaDefinitions.V42.getVersion()) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 42) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#end_block

#method_before
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "un.registered@reviewer.com";
    String userByEmailWithName = "John Doe <" + userByEmail + ">";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    @SuppressWarnings("deprecation")
    int v41 = ChangeSchemaDefinitions.V41.getVersion();
    if (getSchemaVersion() >= v41) {
        assertQuery("reviewer:\"" + userByEmailWithName + "\"", change1);
        assertQuery("cc:\"" + userByEmailWithName + "\"", change2);
        // Omitting the name:
        assertQuery("reviewer:\"" + userByEmail + "\"", change1);
        assertQuery("cc:\"" + userByEmail + "\"", change2);
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        assertFailingQuery("reviewer:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        assertFailingQuery("cc:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        // Omitting the name:
        assertFailingQuery("reviewer:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
        assertFailingQuery("cc:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
    }
}
#method_after
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "un.registered@reviewer.com";
    String userByEmailWithName = "John Doe <" + userByEmail + ">";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 41) {
        assertQuery("reviewer:\"" + userByEmailWithName + "\"", change1);
        assertQuery("cc:\"" + userByEmailWithName + "\"", change2);
        // Omitting the name:
        assertQuery("reviewer:\"" + userByEmail + "\"", change1);
        assertQuery("cc:\"" + userByEmail + "\"", change2);
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        assertFailingQuery("reviewer:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        assertFailingQuery("cc:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        // Omitting the name:
        assertFailingQuery("reviewer:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
        assertFailingQuery("cc:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
    }
}
#end_block

#method_before
@Test
public void reviewerAndCcByEmailWithQueryForDifferentUser() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "John Doe <un.registered@reviewer.com>";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    @SuppressWarnings("deprecation")
    int v41 = ChangeSchemaDefinitions.V41.getVersion();
    if (getSchemaVersion() >= v41) {
        assertQuery("reviewer:\"someone@example.com\"");
        assertQuery("cc:\"someone@example.com\"");
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        String someoneEmail = "someone@example.com";
        assertFailingQuery("reviewer:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
        assertFailingQuery("cc:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
    }
}
#method_after
@Test
public void reviewerAndCcByEmailWithQueryForDifferentUser() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "John Doe <un.registered@reviewer.com>";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 41) {
        assertQuery("reviewer:\"someone@example.com\"");
        assertQuery("cc:\"someone@example.com\"");
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        String someoneEmail = "someone@example.com";
        assertFailingQuery("reviewer:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
        assertFailingQuery("cc:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
    }
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#method_after
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true, null);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#method_after
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < 42) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= ChangeSchemaDefinitions.V42.getVersion()) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 42) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#end_block

#method_before
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "un.registered@reviewer.com";
    String userByEmailWithName = "John Doe <" + userByEmail + ">";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    @SuppressWarnings("deprecation")
    int v41 = ChangeSchemaDefinitions.V41.getVersion();
    if (getSchemaVersion() >= v41) {
        assertQuery("reviewer:\"" + userByEmailWithName + "\"", change1);
        assertQuery("cc:\"" + userByEmailWithName + "\"", change2);
        // Omitting the name:
        assertQuery("reviewer:\"" + userByEmail + "\"", change1);
        assertQuery("cc:\"" + userByEmail + "\"", change2);
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        assertFailingQuery("reviewer:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        assertFailingQuery("cc:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        // Omitting the name:
        assertFailingQuery("reviewer:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
        assertFailingQuery("cc:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
    }
}
#method_after
@Test
public void reviewerAndCcByEmail() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "un.registered@reviewer.com";
    String userByEmailWithName = "John Doe <" + userByEmail + ">";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmailWithName;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 41) {
        assertQuery("reviewer:\"" + userByEmailWithName + "\"", change1);
        assertQuery("cc:\"" + userByEmailWithName + "\"", change2);
        // Omitting the name:
        assertQuery("reviewer:\"" + userByEmail + "\"", change1);
        assertQuery("cc:\"" + userByEmail + "\"", change2);
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        assertFailingQuery("reviewer:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        assertFailingQuery("cc:\"" + userByEmailWithName + "\"", "User " + userByEmailWithName + " not found");
        // Omitting the name:
        assertFailingQuery("reviewer:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
        assertFailingQuery("cc:\"" + userByEmail + "\"", "User " + userByEmail + " not found");
    }
}
#end_block

#method_before
@Test
public void reviewerAndCcByEmailWithQueryForDifferentUser() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "John Doe <un.registered@reviewer.com>";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    @SuppressWarnings("deprecation")
    int v41 = ChangeSchemaDefinitions.V41.getVersion();
    if (getSchemaVersion() >= v41) {
        assertQuery("reviewer:\"someone@example.com\"");
        assertQuery("cc:\"someone@example.com\"");
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        String someoneEmail = "someone@example.com";
        assertFailingQuery("reviewer:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
        assertFailingQuery("cc:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
    }
}
#method_after
@Test
public void reviewerAndCcByEmailWithQueryForDifferentUser() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    String userByEmail = "John Doe <un.registered@reviewer.com>";
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = userByEmail;
    rin.state = ReviewerState.CC;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 41) {
        assertQuery("reviewer:\"someone@example.com\"");
        assertQuery("cc:\"someone@example.com\"");
    } else {
        assertMissingField(ChangeField.REVIEWER_BY_EMAIL);
        String someoneEmail = "someone@example.com";
        assertFailingQuery("reviewer:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
        assertFailingQuery("cc:\"" + someoneEmail + "\"", "User " + someoneEmail + " not found");
    }
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountState>> schemas = SchemaUtil.schemasFromClass(AccountSchemaDefinitions.class, AccountState.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountState> prevSchema = AccountSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<ChangeData>> schemas = SchemaUtil.schemasFromClass(ChangeSchemaDefinitions.class, ChangeData.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<ChangeData> prevSchema = ChangeSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byInname() throws Exception {
    String namePart = testName.getMethodName();
    namePart = namePart.replaceAll("[\\[\\]]", "");
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#method_after
@Test
public void byInname() throws Exception {
    String namePart = getSanitizedMethodName();
    namePart = CharMatcher.is('_').removeFrom(namePart);
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    return name + "_" + getSanitizedMethodName();
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountGroup>> schemas = SchemaUtil.schemasFromClass(GroupSchemaDefinitions.class, AccountGroup.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountGroup> prevSchema = GroupSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#method_after
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("me", currentUserInfo);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = getSanitizedMethodName();
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#method_after
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true, null);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#method_after
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < 42) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    assertQuery("reviewer:" + user1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 42) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, Arrays.asList(config.getStringList("gitiles", null, "customTemplates")).stream().map(fileUrlMapper()).collect(toList()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#method_after
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, Arrays.stream(config.getStringList("gitiles", null, "customTemplates")).map(fileUrlMapper()).collect(toList()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && (!exists(site.ssh_rsa) || !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa_256) || !exists(site.ssh_ecdsa_384) || !exists(site.ssh_ecdsa_521))) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        // Generate the SSH daemon host key using ssh-keygen.
        // 
        final String comment = "gerrit-code-review@" + hostname();
        // Workaround for JDK-6518827 - zero-length argument ignored on Win32
        String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
        if (!exists(site.ssh_rsa)) {
            System.err.print(" rsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_dsa)) {
            System.err.print(" dsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_ed25519)) {
            System.err.print(" ed25519...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ed25519 keys.
                System.err.print(" Failed to generate ed25519 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_256)) {
            System.err.print(" ecdsa 256...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "256", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_256.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_384)) {
            System.err.print(" ecdsa 384...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "384", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_384.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_521)) {
            System.err.print(" ecdsa 521...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "521", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_521.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && (!exists(site.ssh_rsa) || !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa_256) || !exists(site.ssh_ecdsa_384) || !exists(site.ssh_ecdsa_521))) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        // Generate the SSH daemon host key using ssh-keygen.
        // 
        final String comment = "gerrit-code-review@" + hostname();
        // Workaround for JDK-6518827 - zero-length argument ignored on Win32
        String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
        if (!exists(site.ssh_rsa)) {
            System.err.print(" rsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_dsa)) {
            System.err.print(" dsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_ed25519)) {
            System.err.print(" ed25519...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ed25519 keys.
                System.err.print(" Failed to generate ed25519 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_256)) {
            System.err.print(" ecdsa 256...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "256", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_256.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 256 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_384)) {
            System.err.print(" ecdsa 384...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "384", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_384.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 384 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_521)) {
            System.err.print(" ecdsa 521...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "521", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_521.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 521 key, continuing...");
                System.err.flush();
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Before
public void setUpMocks() {
    id = Change.Id.parse(Integer.toString(CHANGE_ID));
    indexEventHandler = new IndexEventHandler(MoreExecutors.directExecutor(), PLUGIN_NAME, forwarder);
}
#method_after
@Before
public void setUpMocks() {
    changeId = Change.Id.parse(Integer.toString(CHANGE_ID));
    accountId = Account.Id.parse(Integer.toString(ACCOUNT_ID));
    indexEventHandler = new IndexEventHandler(MoreExecutors.directExecutor(), PLUGIN_NAME, forwarder);
}
#end_block

#method_before
@Test
public void shouldIndexInRemoteOnChangeIndexedEvent() throws Exception {
    indexEventHandler.onChangeIndexed(id.get());
    verify(forwarder).indexChange(CHANGE_ID);
}
#method_after
@Test
public void shouldIndexInRemoteOnChangeIndexedEvent() throws Exception {
    indexEventHandler.onChangeIndexed(changeId.get());
    verify(forwarder).indexChange(CHANGE_ID);
}
#end_block

#method_before
@Test
public void shouldDeleteFromIndexInRemoteOnChangeDeletedEvent() throws Exception {
    indexEventHandler.onChangeDeleted(id.get());
    verify(forwarder).deleteChangeFromIndex(CHANGE_ID);
}
#method_after
@Test
public void shouldDeleteFromIndexInRemoteOnChangeDeletedEvent() throws Exception {
    indexEventHandler.onChangeDeleted(changeId.get());
    verify(forwarder).deleteChangeFromIndex(CHANGE_ID);
}
#end_block

#method_before
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(project + "/+/" + id);
}
#method_after
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(Joiner.on('~').join(ImmutableList.of(Url.encode(project), Url.encode(String.valueOf(id)))));
}
#end_block

#method_before
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try project/+/numericChangeId
    if (id.contains(PROJECT_CHANGE_DELIMITER)) {
        int lastDel = id.lastIndexOf(PROJECT_CHANGE_DELIMITER);
        if (lastDel > 0) {
            String project = id.substring(0, lastDel);
            Integer n = Ints.tryParse(id.substring(lastDel + PROJECT_CHANGE_DELIMITER.length()));
            if (n != null) {
                try {
                    return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), new Change.Id(n), user));
                } catch (NoSuchChangeException e) {
                    return Collections.emptyList();
                } catch (IllegalArgumentException e) {
                    // Change or Project unknown. This exception is thrown in checkArgument calls in NoteDb.
                    return Collections.emptyList();
                } catch (OrmException e) {
                    // other OrmExceptions (failure in the persistence layer).
                    if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                        return Collections.emptyList();
                    }
                    throw e;
                }
            }
        }
    }
    // Try legacy id
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    if (!id.contains("~")) {
        return asChangeControls(query.byKeyPrefix(id), user);
    }
    // Try change triplet
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
    if (triplet.isPresent()) {
        return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
    }
    return Collections.emptyList();
}
#method_after
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    int numTwiddles = 0;
    for (char c : id.toCharArray()) {
        if (c == '~') {
            numTwiddles++;
        }
    }
    if (numTwiddles == 1) {
        // Try project~numericChangeId
        String project = id.substring(0, id.indexOf('~'));
        Integer n = Ints.tryParse(id.substring(project.length() + 1));
        if (n != null) {
            Change.Id changeId = new Change.Id(n);
            try {
                return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), changeId, user));
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            } catch (IllegalArgumentException e) {
                String changeNotFound = String.format("change %s not found in ReviewDb", changeId);
                String projectNotFound = String.format("passed project %s when creating ChangeNotes for %s, but actual project is", project, changeId);
                if (e.getMessage().equals(changeNotFound) || e.getMessage().startsWith(projectNotFound)) {
                    return Collections.emptyList();
                }
                throw e;
            } catch (OrmException e) {
                // other OrmExceptions (failure in the persistence layer).
                if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                    return Collections.emptyList();
                }
                throw e;
            }
        }
    } else if (numTwiddles == 2) {
        // Try change triplet
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
        if (triplet.isPresent()) {
            return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
        }
    }
    // Try numeric changeId
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    return asChangeControls(query.byKeyPrefix(id), user);
}
#end_block

#method_before
@Test
public void deleteOneCommentMultipleTimes() throws Exception {
    PushOneCommit.Result result = createChange();
    Change.Id id = result.getChange().getId();
    String changeId = result.getChangeId();
    String ps1 = result.getCommit().name();
    CommentInput c1 = newComment(FILE_NAME, "comment 1");
    CommentInput c2 = newComment(FILE_NAME, "comment 2");
    CommentInput c3 = newComment(FILE_NAME, "comment 3");
    addComments(changeId, ps1, c1);
    addComments(changeId, ps1, c2);
    addComments(changeId, ps1, c3);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(3);
    Optional<CommentInfo> targetComment = commentsBeforeDelete.stream().filter(c -> c.message.equals("comment 2")).findFirst();
    assertThat(targetComment.isPresent()).isTrue();
    String uuid = targetComment.get().id;
    setApiUser(admin);
    for (int i = 0; i < 3; i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo oldComment = gApi.changes().id(changeId).revision(1).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment 2: " + i);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(1).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        assertThat(getChangeSortedComments(changeId)).hasSize(3);
    }
    CommentInput c4 = newComment(FILE_NAME, "comment 4");
    addComments(changeId, ps1, c4);
    assertThat(getChangeSortedComments(changeId)).hasSize(4);
}
#method_after
@Test
public void deleteOneCommentMultipleTimes() throws Exception {
    PushOneCommit.Result result = createChange();
    Change.Id id = result.getChange().getId();
    String changeId = result.getChangeId();
    String ps1 = result.getCommit().name();
    CommentInput c1 = newComment(FILE_NAME, "comment 1");
    CommentInput c2 = newComment(FILE_NAME, "comment 2");
    CommentInput c3 = newComment(FILE_NAME, "comment 3");
    addComments(changeId, ps1, c1);
    addComments(changeId, ps1, c2);
    addComments(changeId, ps1, c3);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(3);
    Optional<CommentInfo> targetComment = commentsBeforeDelete.stream().filter(c -> c.message.equals("comment 2")).findFirst();
    assertThat(targetComment).isPresent();
    String uuid = targetComment.get().id;
    CommentInfo oldComment = gApi.changes().id(changeId).revision(ps1).comment(uuid).get();
    List<RevCommit> commitsBeforeDelete = new ArrayList<>();
    if (notesMigration.commitChangeWrites()) {
        commitsBeforeDelete = getCommits(id);
    }
    setApiUser(admin);
    for (int i = 0; i < 3; i++) {
        DeleteCommentInput input = new DeleteCommentInput("delete comment 2, iteration: " + i);
        gApi.changes().id(changeId).revision(ps1).comment(uuid).delete(input);
    }
    CommentInfo updatedComment = gApi.changes().id(changeId).revision(ps1).comment(uuid).get();
    String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, "delete comment 2, iteration: 2");
    assertThat(updatedComment.message).isEqualTo(expectedMsg);
    oldComment.message = expectedMsg;
    assertThat(updatedComment).isEqualTo(oldComment);
    if (notesMigration.commitChangeWrites()) {
        assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
    }
    assertThat(getChangeSortedComments(changeId)).hasSize(3);
}
#end_block

#method_before
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve commit", e);
    }
}
#end_block

#method_before
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#method_after
@Option(name = "--links", usage = "Include weblinks")
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#end_block

#method_before
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#method_after
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    PushOneCommit.Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
private static void assertIteratorSize(int size, Iterator it) {
    List lst = ImmutableList.copyOf(it);
    assertThat(lst).hasSize(size);
}
#method_after
private static void assertIteratorSize(int size, Iterator<?> it) {
    List<?> lst = ImmutableList.copyOf(it);
    assertThat(lst).hasSize(size);
}
#end_block

#method_before
@Override
public void onRevisionCreated(com.google.gerrit.extensions.events.RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    Config pluginConfig = cfgFactory.getGlobalPluginConfig(pluginName);
    boolean ignoreDrafts = pluginConfig.getBoolean(pluginName, null, "ignoreDrafts", false);
    if (ignoreDrafts && c.status == ChangeStatus.DRAFT) {
        log.debug("Ignoring draft change");
        return;
    }
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    if (ignoreDrafts && c.status == ChangeStatus.DRAFT) {
        log.debug("Ignoring draft change");
        return;
    }
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#end_block

#method_before
@Override
public void onDraftPublished(com.google.gerrit.extensions.events.DraftPublishedListener.Event event) {
    ChangeInfo c = event.getChange();
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo c = event.getChange();
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException, PermissionBackendException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (byState == Predicate.<ChangeData>any()) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new AuthorPredicate(who);
    }
    return Predicate.or(Arrays.asList(new AuthorPredicate(email), new AuthorPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new CommitterPredicate(who);
    }
    return Predicate.or(Arrays.asList(new CommitterPredicate(email), new CommitterPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#method_after
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB && !notesMigration.disableChangeReviewDb()) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
@Override
public Optional<Id> load(String username) throws Exception {
    try (ReviewDb db = dbProvider.get()) {
        return Optional.ofNullable(db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME + ":" + username))).map(AccountExternalId::getAccountId);
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    ReviewDb db = dbProvider.get();
    return Optional.ofNullable(db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME + ":" + username))).map(AccountExternalId::getAccountId);
}
#end_block

#method_before
@Test
public void deleteCommentByRewritingCommitHistory() throws Exception {
    // Creates the following commit history on the meta branch of the test change. Then try to
    // delete the comments one by one, which will rewrite most of the commits on the 'meta' branch.
    // Commits will be rewritten N times if it puts in N comments. After each deletion, the meta
    // branch should keep its previous state except that the target comment's message should be
    // updated.
    // 1st commit: Create PS1.
    PushOneCommit.Result result1 = createChange(SUBJECT, "a.txt", "a");
    Change.Id id = result1.getChange().getId();
    String changeId = result1.getChangeId();
    String ps1 = result1.getCommit().name();
    // 2nd commit: Add (c1) to PS1.
    CommentInput c1 = newComment("a.txt", "comment 1");
    addComments(changeId, ps1, c1);
    // 3rd commit: Add (c2, c3) to PS1.
    CommentInput c2 = newComment("a.txt", "comment 2");
    CommentInput c3 = newComment("a.txt", "comment 3");
    addComments(changeId, ps1, c2, c3);
    // 4th commit: Add (c4) to PS1.
    CommentInput c4 = newComment("a.txt", "comment 4");
    addComments(changeId, ps1, c4);
    // 5th commit: Create PS2.
    PushOneCommit.Result result2 = amendChange(changeId, "refs/for/master", "b.txt", "b");
    String ps2 = result2.getCommit().name();
    // 6th commit: Add (c5) to PS1.
    CommentInput c5 = newComment("a.txt", "comment 5");
    addComments(changeId, ps1, c5);
    // 7th commit: Add (c6) to PS2.
    CommentInput c6 = newComment("b.txt", "comment 6");
    addComments(changeId, ps2, c6);
    // 8th commit: Create PS3.
    PushOneCommit.Result result3 = amendChange(changeId);
    String ps3 = result3.getCommit().name();
    // 9th commit: Create PS4.
    PushOneCommit.Result result4 = amendChange(changeId, "refs/for/master", "c.txt", "c");
    String ps4 = result4.getCommit().name();
    // 10th commit: Add (c7, c8) to PS4.
    CommentInput c7 = newComment("c.txt", "comment 7");
    CommentInput c8 = newComment("b.txt", "comment 8");
    addComments(changeId, ps4, c7, c8);
    // 11th commit: Add (c4) to PS2.
    CommentInput c9 = newComment("b.txt", "comment 9");
    addComments(changeId, ps2, c9);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(9);
    // PS1 has comments [c1, c2, c3, c4, c5].
    assertThat(getRevisionComments(changeId, ps1)).hasSize(5);
    // PS2 has comments [c6, c9].
    assertThat(getRevisionComments(changeId, ps2)).hasSize(2);
    // PS3 has no comment.
    assertThat(getRevisionComments(changeId, ps3)).hasSize(0);
    // PS4 has comments [c7, c8].
    assertThat(getRevisionComments(changeId, ps4)).hasSize(2);
    setApiUser(admin);
    for (int i = 0; i < commentsBeforeDelete.size(); i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo comment = commentsBeforeDelete.get(i);
        String uuid = comment.id;
        int patchSet = comment.patchSet;
        // 'oldComment' has some fields unset compared with 'comment'.
        CommentInfo oldComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment " + uuid);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        // Check the NoteDb state after the deletion.
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        comment.message = expectedMsg;
        commentsBeforeDelete.set(i, comment);
        List<CommentInfo> commentsAfterDelete = getChangeSortedComments(changeId);
        assertThat(commentsAfterDelete).isEqualTo(commentsBeforeDelete);
    }
    // Make sure that comments can still be added correctly.
    CommentInput c10 = newComment("a.txt", "comment 10");
    CommentInput c11 = newComment("b.txt", "comment 11");
    CommentInput c12 = newComment("a.txt", "comment 12");
    CommentInput c13 = newComment("c.txt", "comment 13");
    addComments(changeId, ps1, c10);
    addComments(changeId, ps2, c11);
    addComments(changeId, ps3, c12);
    addComments(changeId, ps4, c13);
    assertThat(getChangeSortedComments(changeId)).hasSize(13);
    assertThat(getRevisionComments(changeId, ps1)).hasSize(6);
    assertThat(getRevisionComments(changeId, ps2)).hasSize(3);
    assertThat(getRevisionComments(changeId, ps3)).hasSize(1);
    assertThat(getRevisionComments(changeId, ps4)).hasSize(3);
}
#method_after
@Test
public void deleteCommentByRewritingCommitHistory() throws Exception {
    // Creates the following commit history on the meta branch of the test change. Then tries to
    // delete the comments one by one, which will rewrite most of the commits on the 'meta' branch.
    // Commits will be rewritten N times for N added comments. After each deletion, the meta branch
    // should keep its previous state except that the target comment's message should be updated.
    // 1st commit: Create PS1.
    PushOneCommit.Result result1 = createChange(SUBJECT, "a.txt", "a");
    Change.Id id = result1.getChange().getId();
    String changeId = result1.getChangeId();
    String ps1 = result1.getCommit().name();
    // 2nd commit: Add (c1) to PS1.
    CommentInput c1 = newComment("a.txt", "comment 1");
    addComments(changeId, ps1, c1);
    // 3rd commit: Add (c2, c3) to PS1.
    CommentInput c2 = newComment("a.txt", "comment 2");
    CommentInput c3 = newComment("a.txt", "comment 3");
    addComments(changeId, ps1, c2, c3);
    // 4th commit: Add (c4) to PS1.
    CommentInput c4 = newComment("a.txt", "comment 4");
    addComments(changeId, ps1, c4);
    // 5th commit: Create PS2.
    PushOneCommit.Result result2 = amendChange(changeId, "refs/for/master", "b.txt", "b");
    String ps2 = result2.getCommit().name();
    // 6th commit: Add (c5) to PS1.
    CommentInput c5 = newComment("a.txt", "comment 5");
    addComments(changeId, ps1, c5);
    // 7th commit: Add (c6) to PS2.
    CommentInput c6 = newComment("b.txt", "comment 6");
    addComments(changeId, ps2, c6);
    // 8th commit: Create PS3.
    PushOneCommit.Result result3 = amendChange(changeId);
    String ps3 = result3.getCommit().name();
    // 9th commit: Create PS4.
    PushOneCommit.Result result4 = amendChange(changeId, "refs/for/master", "c.txt", "c");
    String ps4 = result4.getCommit().name();
    // 10th commit: Add (c7, c8) to PS4.
    CommentInput c7 = newComment("c.txt", "comment 7");
    CommentInput c8 = newComment("b.txt", "comment 8");
    addComments(changeId, ps4, c7, c8);
    // 11th commit: Add (c9) to PS2.
    CommentInput c9 = newComment("b.txt", "comment 9");
    addComments(changeId, ps2, c9);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(9);
    // PS1 has comments [c1, c2, c3, c4, c5].
    assertThat(getRevisionComments(changeId, ps1)).hasSize(5);
    // PS2 has comments [c6, c9].
    assertThat(getRevisionComments(changeId, ps2)).hasSize(2);
    // PS3 has no comment.
    assertThat(getRevisionComments(changeId, ps3)).hasSize(0);
    // PS4 has comments [c7, c8].
    assertThat(getRevisionComments(changeId, ps4)).hasSize(2);
    setApiUser(admin);
    for (int i = 0; i < commentsBeforeDelete.size(); i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo comment = commentsBeforeDelete.get(i);
        String uuid = comment.id;
        int patchSet = comment.patchSet;
        // 'oldComment' has some fields unset compared with 'comment'.
        CommentInfo oldComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment " + uuid);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        // Check the NoteDb state after the deletion.
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        comment.message = expectedMsg;
        commentsBeforeDelete.set(i, comment);
        List<CommentInfo> commentsAfterDelete = getChangeSortedComments(changeId);
        assertThat(commentsAfterDelete).isEqualTo(commentsBeforeDelete);
    }
    // Make sure that comments can still be added correctly.
    CommentInput c10 = newComment("a.txt", "comment 10");
    CommentInput c11 = newComment("b.txt", "comment 11");
    CommentInput c12 = newComment("a.txt", "comment 12");
    CommentInput c13 = newComment("c.txt", "comment 13");
    addComments(changeId, ps1, c10);
    addComments(changeId, ps2, c11);
    addComments(changeId, ps3, c12);
    addComments(changeId, ps4, c13);
    assertThat(getChangeSortedComments(changeId)).hasSize(13);
    assertThat(getRevisionComments(changeId, ps1)).hasSize(6);
    assertThat(getRevisionComments(changeId, ps2)).hasSize(3);
    assertThat(getRevisionComments(changeId, ps3)).hasSize(1);
    assertThat(getRevisionComments(changeId, ps4)).hasSize(3);
}
#end_block

#method_before
private List<CommentInfo> getChangeSortedComments(String changeId) throws Exception {
    List<CommentInfo> comments = new ArrayList<>();
    Map<String, List<CommentInfo>> commentsMap = getPublishedComments(changeId);
    for (Entry<String, List<CommentInfo>> e : commentsMap.entrySet()) {
        for (CommentInfo c : e.getValue()) {
            // Set the comment's path field.
            c.path = e.getKey();
            comments.add(c);
        }
    }
    Collections.sort(comments, (c1, c2) -> c1.id.compareTo(c2.id));
    return comments;
}
#method_after
private List<CommentInfo> getChangeSortedComments(String changeId) throws Exception {
    List<CommentInfo> comments = new ArrayList<>();
    Map<String, List<CommentInfo>> commentsMap = getPublishedComments(changeId);
    for (Entry<String, List<CommentInfo>> e : commentsMap.entrySet()) {
        for (CommentInfo c : e.getValue()) {
            // Set the comment's path field.
            c.path = e.getKey();
            comments.add(c);
        }
    }
    comments.sort(Comparator.comparing(c -> c.id));
    return comments;
}
#end_block

#method_before
private List<CommentInfo> getRevisionComments(String changeId, String revId) throws Exception {
    return getPublishedComments(changeId, revId).values().stream().flatMap(t -> t.stream()).collect(Collectors.toList());
}
#method_after
private List<CommentInfo> getRevisionComments(String changeId, String revId) throws Exception {
    return getPublishedComments(changeId, revId).values().stream().flatMap(List::stream).collect(Collectors.toList());
}
#end_block

#method_before
private void addComments(String changeId, String revision, CommentInput... commentInputs) throws Exception {
    ReviewInput input = new ReviewInput();
    input.comments = new HashMap<>();
    for (int i = 0; i < commentInputs.length; i++) {
        CommentInput c = commentInputs[i];
        if (!input.comments.containsKey(c.path)) {
            input.comments.put(c.path, Lists.newArrayList(c));
        } else {
            input.comments.get(c.path).add(c);
        }
    }
    input.label("Code-Review", 1);
    gApi.changes().id(changeId).revision(revision).review(input);
}
#method_after
private void addComments(String changeId, String revision, CommentInput... commentInputs) throws Exception {
    ReviewInput input = new ReviewInput();
    input.comments = Arrays.stream(commentInputs).collect(Collectors.groupingBy(c -> c.path));
    gApi.changes().id(changeId).revision(revision).review(input);
}
#end_block

#method_before
public ImmutableList<T> getComments() {
    checkParsed();
    return comments != null ? comments : ImmutableList.of();
}
#method_after
public ImmutableList<T> getComments() {
    checkParsed();
    return comments;
}
#end_block

#method_before
public void parse() throws IOException, ConfigInvalidException {
    raw = reader.open(noteId, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
    MutableInteger p = new MutableInteger();
    trimLeadingEmptyLines(raw, p);
    if (p.value >= raw.length) {
        comments = null;
        return;
    }
    comments = ImmutableList.copyOf(parse(raw, p.value));
}
#method_after
public void parse() throws IOException, ConfigInvalidException {
    raw = reader.open(noteId, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
    MutableInteger p = new MutableInteger();
    trimLeadingEmptyLines(raw, p);
    if (p.value >= raw.length) {
        comments = ImmutableList.of();
        return;
    }
    comments = ImmutableList.copyOf(parse(raw, p.value));
}
#end_block

#method_before
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    return account.getAccount().getFullName().trim().equalsIgnoreCase(nameOrEmail) || account.getExternalIds().stream().anyMatch(extId -> {
        String schemeRest = getSchemeRest(extId.key().scheme(), extId.key().get());
        return null != schemeRest && schemeRest.trim().equalsIgnoreCase(nameOrEmail);
    });
}
#method_after
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    return account.getAccount().getFullName().trim().equalsIgnoreCase(nameOrEmail) || account.getExternalIds().stream().anyMatch(extId -> getSchemeRest(extId.key().scheme(), extId.key().get()).trim().equalsIgnoreCase(nameOrEmail));
}
#end_block

#method_before
private String getSchemeRest(String scheme, String key) {
    return null != scheme ? key.substring(scheme.length() + 1) : null;
}
#method_after
private String getSchemeRest(String scheme, String key) {
    return null != scheme ? key.substring(scheme.length() + 1) : key;
}
#end_block

#method_before
protected void deny(NameKey p, String ref, String permission, UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(String ref, String permission, AccountGroup.UUID id) throws Exception {
    deny(project, ref, permission, id);
}
#end_block

#method_before
protected PermissionRule block(NameKey project, String ref, String permission, UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(String ref, String permission, AccountGroup.UUID id) throws Exception {
    return block(project, ref, permission, id);
}
#end_block

#method_before
protected void grant(NameKey project, String ref, String permission, boolean force, UUID groupUUID) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    grant(project, ref, permission, false);
}
#end_block

#method_before
protected void removePermission(NameKey project, String ref, String permission) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void removePermission(Project.NameKey project, String ref, String permission) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
        if (!children.isEmpty()) {
            String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

                @Override
                public String apply(ProjectInfo info) {
                    return info.name;
                }
            }));
            throw new CannotDeleteProjectException("Cannot delete project because " + "it has children: " + childrenString);
        }
    } catch (PermissionBackendException e) {
        throw new CannotDeleteProjectException("Cannot delete project because " + "of failure in permission backend.");
    }
}
#method_after
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
        if (!children.isEmpty()) {
            String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

                @Override
                public String apply(ProjectInfo info) {
                    return info.name;
                }
            }));
            throw new CannotDeleteProjectException("Cannot delete project because it has children: " + childrenString);
        }
    } catch (PermissionBackendException e) {
        throw new CannotDeleteProjectException("Cannot delete project because of failure in permission backend.");
    }
}
#end_block

#method_before
protected boolean canDelete(ProjectResource rsrc) {
    WithUser userPermission = permissionBackend.user(userProvider.get());
    return userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER) || userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_PROJECT)) || (userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_OWN_PROJECT)) && rsrc.getControl().isOwner());
}
#method_after
protected boolean canDelete(ProjectResource rsrc) {
    PermissionBackend.WithUser userPermission = permissionBackend.user(userProvider);
    return userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER) || userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_PROJECT)) || (userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_OWN_PROJECT)) && rsrc.getControl().isOwner());
}
#end_block

#method_before
private void processImpl(BatchUpdate.Factory buf, MailMessage message) throws OrmException {
    for (DynamicMap.Entry<MailFilter> filter : mailFilters) {
        if (!filter.getProvider().get().shouldProcessMessage(message)) {
            log.warn(String.format("Message %s filtered by plugin %s %s. Will delete message.", message.id(), filter.getPluginName(), filter.getExportName()));
            return;
        }
    }
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error(String.format("Message %s is missing required metadata, have %s. Will delete message.", message.id(), metadata));
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error(String.format("Address %s could not be matched to a unique account. It was matched to %s. Will delete message.", metadata.author, accounts));
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!accountCache.get(account).getAccount().isActive()) {
        log.warn(String.format("Mail: Account %s is inactive. Will delete message.", account));
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        List<ChangeData> changeDataList = queryProvider.get().byKey(Change.Key.parse(metadata.changeId));
        if (changeDataList.size() != 1) {
            log.error(String.format("Message %s references unique change %s, but there are %d matching changes in the index. Will delete message.", message.id(), metadata.changeId, changeDataList.size()));
            return;
        }
        ChangeData cd = changeDataList.get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            throw new OrmException(e);
        }
    }
}
#method_after
private void processImpl(BatchUpdate.Factory buf, MailMessage message) throws OrmException, UpdateException, RestApiException {
    for (DynamicMap.Entry<MailFilter> filter : mailFilters) {
        if (!filter.getProvider().get().shouldProcessMessage(message)) {
            log.warn(String.format("Message %s filtered by plugin %s %s. Will delete message.", message.id(), filter.getPluginName(), filter.getExportName()));
            return;
        }
    }
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error(String.format("Message %s is missing required metadata, have %s. Will delete message.", message.id(), metadata));
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error(String.format("Address %s could not be matched to a unique account. It was matched to %s. Will delete message.", metadata.author, accounts));
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!accountCache.get(account).getAccount().isActive()) {
        log.warn(String.format("Mail: Account %s is inactive. Will delete message.", account));
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        List<ChangeData> changeDataList = queryProvider.get().byKey(Change.Key.parse(metadata.changeId));
        if (changeDataList.size() != 1) {
            log.error(String.format("Message %s references unique change %s, but there are %d matching changes in the index. Will delete message.", message.id(), metadata.changeId, changeDataList.size()));
            return;
        }
        ChangeData cd = changeDataList.get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        batchUpdate.execute();
    }
}
#end_block

#method_before
public void publish(BatchUpdate.Factory updateFactory, ChangeControl ctl, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        } catch (UpdateException e) {
            if (e.getCause() instanceof IOException && e.getMessage().equals(String.format("%s: Failed to delete ref %s: %s", IOException.class.getName(), edit.getRefName(), RefUpdate.Result.LOCK_FAILURE.name()))) {
                throw new ResourceConflictException("edit ref was updated");
            }
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#method_after
public void publish(BatchUpdate.Factory updateFactory, ChangeControl ctl, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : batch.getCommands()) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : actualCommands) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : actualCommands) {
        // involve kicking off an additional BatchUpdate.
        if (c.getResult() != OK) {
            continue;
        }
        if (isHead(c) || isConfig(c)) {
            switch(c.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    autoCloseChanges(c);
                    branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                    break;
                case DELETE:
                    break;
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s; got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    logDebug("Deleting {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws Exception {
                // return pseudo dirty state to trigger reindexing
                return true;
            }
        });
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(@Nullable ReceiveCommand cmd, String why) {
    if (cmd != null) {
        cmd.setResult(REJECTED_OTHER_REASON, why);
        commandProgress.update(1);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && getRefControl().canUpload() && !isPatchSetLocked(db);
}
#end_block

#method_before
private List<String> copy(Set<String> paths, PatchSet.Id old, RevisionResource resource, Account.Id userId) throws IOException, PatchListNotAvailableException, OrmException {
    Project.NameKey project = resource.getChange().getProject();
    try (Repository git = gitManager.openRepository(project);
        ObjectReader reader = git.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        TreeWalk tw = new TreeWalk(reader)) {
        PatchSet patchSet = psUtil.get(db.get(), resource.getNotes(), old);
        if (patchSet == null) {
            throw new PatchListNotAvailableException(String.format("patch set %s of change %s not found", old.get(), resource.getChange().getId().get()));
        }
        PatchList oldList = patchListCache.get(resource.getChange(), patchSet);
        PatchList curList = patchListCache.get(resource.getChange(), resource.getPatchSet());
        int sz = paths.size();
        List<String> pathList = Lists.newArrayListWithCapacity(sz);
        tw.setFilter(PathFilterGroup.createFromStrings(paths));
        tw.setRecursive(true);
        int o = tw.addTree(rw.parseCommit(oldList.getNewId()).getTree());
        int c = tw.addTree(rw.parseCommit(curList.getNewId()).getTree());
        int op = -1;
        if (oldList.getOldId() != null) {
            op = tw.addTree(rw.parseTree(oldList.getOldId()));
        }
        int cp = -1;
        if (curList.getOldId() != null) {
            cp = tw.addTree(rw.parseTree(curList.getOldId()));
        }
        while (tw.next()) {
            String path = tw.getPathString();
            if (tw.getRawMode(o) != 0 && tw.getRawMode(c) != 0 && tw.idEqual(o, c) && paths.contains(path)) {
                // File exists in previously reviewed oldList and in curList.
                // File content is identical.
                pathList.add(path);
            } else if (op >= 0 && cp >= 0 && tw.getRawMode(o) == 0 && tw.getRawMode(c) == 0 && tw.getRawMode(op) != 0 && tw.getRawMode(cp) != 0 && tw.idEqual(op, cp) && paths.contains(path)) {
                // File was deleted in previously reviewed oldList and curList.
                // File exists in ancestor of oldList and curList.
                // File content is identical in ancestors.
                pathList.add(path);
            }
        }
        accountPatchReviewStore.get().markReviewed(resource.getPatchSet().getId(), userId, pathList);
        return pathList;
    }
}
#method_after
private List<String> copy(Set<String> paths, PatchSet.Id old, RevisionResource resource, Account.Id userId) throws IOException, PatchListNotAvailableException, OrmException {
    Project.NameKey project = resource.getChange().getProject();
    try (Repository git = gitManager.openRepository(project);
        ObjectReader reader = git.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        TreeWalk tw = new TreeWalk(reader)) {
        Change change = resource.getChange();
        PatchSet patchSet = psUtil.get(db.get(), resource.getNotes(), old);
        if (patchSet == null) {
            throw new PatchListNotAvailableException(String.format("patch set %s of change %s not found", old.get(), change.getId().get()));
        }
        PatchList oldList = patchListCache.get(change, patchSet);
        PatchList curList = patchListCache.get(change, resource.getPatchSet());
        int sz = paths.size();
        List<String> pathList = Lists.newArrayListWithCapacity(sz);
        tw.setFilter(PathFilterGroup.createFromStrings(paths));
        tw.setRecursive(true);
        int o = tw.addTree(rw.parseCommit(oldList.getNewId()).getTree());
        int c = tw.addTree(rw.parseCommit(curList.getNewId()).getTree());
        int op = -1;
        if (oldList.getOldId() != null) {
            op = tw.addTree(rw.parseTree(oldList.getOldId()));
        }
        int cp = -1;
        if (curList.getOldId() != null) {
            cp = tw.addTree(rw.parseTree(curList.getOldId()));
        }
        while (tw.next()) {
            String path = tw.getPathString();
            if (tw.getRawMode(o) != 0 && tw.getRawMode(c) != 0 && tw.idEqual(o, c) && paths.contains(path)) {
                // File exists in previously reviewed oldList and in curList.
                // File content is identical.
                pathList.add(path);
            } else if (op >= 0 && cp >= 0 && tw.getRawMode(o) == 0 && tw.getRawMode(c) == 0 && tw.getRawMode(op) != 0 && tw.getRawMode(cp) != 0 && tw.idEqual(op, cp) && paths.contains(path)) {
                // File was deleted in previously reviewed oldList and curList.
                // File exists in ancestor of oldList and curList.
                // File content is identical in ancestors.
                pathList.add(path);
            }
        }
        accountPatchReviewStore.get().markReviewed(resource.getPatchSet().getId(), userId, pathList);
        return pathList;
    }
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        c.setIdleTimeout(cfg.getTimeUnit("httpd", null, "idleTimeout", 30000L, TimeUnit.MILLISECONDS));
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = cfg.getEnum("auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final Path keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.toAbsolutePath().toString());
            ssl.setTrustStorePath(keystore.toAbsolutePath().toString());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                Path crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (Files.exists(crl)) {
                    ssl.setCrlPath(crl.toAbsolutePath().toString());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false));
        c.setReuseAddress(reuseAddress);
        c.setIdleTimeout(cfg.getTimeUnit("httpd", null, "idleTimeout", 30000L, MILLISECONDS));
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true, null);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false, null);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#method_after
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#end_block

#method_before
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#method_after
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#end_block

#method_before
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#method_after
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#end_block

#method_before
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#method_after
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(batchUpdateFactory, controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#end_block

#method_before
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(new Project.NameKey(project1Name), user, list);
}
#method_after
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(batchUpdateFactory, new Project.NameKey(project1Name), user, list);
}
#end_block

#method_before
@Test
public void rebaseNotAllowedWithoutPushPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(Permission.REBASE, project, "refs/heads/master", false, REGISTERED_USERS);
    block(Permission.PUSH, REGISTERED_USERS, "refs/for/*").setForce(true);
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("rebase not permitted");
    gApi.changes().id(changeId).rebase();
}
#method_after
@Test
public void rebaseNotAllowedWithoutPushPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(Permission.REBASE, project, "refs/heads/master", false, REGISTERED_USERS);
    block(Permission.PUSH, REGISTERED_USERS, "refs/for/*");
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("rebase not permitted");
    gApi.changes().id(changeId).rebase();
}
#end_block

#method_before
@Test
public void rebaseNotAllowedForOwnerWithoutPushPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    block(Permission.PUSH, REGISTERED_USERS, "refs/for/*").setForce(true);
    // Rebase the second
    String changeId = r2.getChangeId();
    exception.expect(AuthException.class);
    exception.expectMessage("rebase not permitted");
    gApi.changes().id(changeId).rebase();
}
#method_after
@Test
public void rebaseNotAllowedForOwnerWithoutPushPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    block(Permission.PUSH, REGISTERED_USERS, "refs/for/*");
    // Rebase the second
    String changeId = r2.getChangeId();
    exception.expect(AuthException.class);
    exception.expectMessage("rebase not permitted");
    gApi.changes().id(changeId).rebase();
}
#end_block

#method_before
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#method_after
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = batchUpdateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#end_block

#method_before
@Override
public void setPrivate(boolean value, String message) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setPrivate(boolean value, @Nullable String message) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains(msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains(msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true, null);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false, null);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#method_after
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isNull();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
}
#end_block

#method_before
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#method_after
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#end_block

#method_before
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#method_after
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#end_block

#method_before
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#method_after
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#end_block

#method_before
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#method_after
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange();
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    changeAbandoner.batchAbandon(batchUpdateFactory, controlA.get(0).getProject().getNameKey(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#end_block

#method_before
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(new Project.NameKey(project1Name), user, list);
}
#method_after
@Test
public void batchAbandonChangeProject() throws Exception {
    String project1Name = name("Project1");
    String project2Name = name("Project2");
    gApi.projects().create(project1Name);
    gApi.projects().create(project2Name);
    TestRepository<InMemoryRepository> project1 = cloneProject(new Project.NameKey(project1Name));
    TestRepository<InMemoryRepository> project2 = cloneProject(new Project.NameKey(project2Name));
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange(project1, "master", "x", "x", "x", "");
    List<ChangeControl> controlA = changeFinder.find(a.getChangeId(), user);
    assertThat(controlA).hasSize(1);
    PushOneCommit.Result b = createChange(project2, "master", "x", "x", "x", "");
    List<ChangeControl> controlB = changeFinder.find(b.getChangeId(), user);
    assertThat(controlB).hasSize(1);
    List<ChangeControl> list = ImmutableList.of(controlA.get(0), controlB.get(0));
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Project name \"%s\" doesn't match \"%s\"", project2Name, project1Name));
    changeAbandoner.batchAbandon(batchUpdateFactory, new Project.NameKey(project1Name), user, list);
}
#end_block

#method_before
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#method_after
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = batchUpdateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PutPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public void setPrivate(boolean value, String message) throws RestApiException {
    try {
        SetPrivateOp.Input input = new SetPrivateOp.Input(message);
        if (value) {
            putPrivate.apply(change, input);
        } else {
            deletePrivate.apply(change, input);
        }
    } catch (UpdateException e) {
        throw new RestApiException("Cannot change private status", e);
    }
}
#method_after
@Override
public void setPrivate(boolean value, @Nullable String message) throws RestApiException {
    try {
        SetPrivateOp.Input input = new SetPrivateOp.Input(message);
        if (value) {
            postPrivate.apply(change, input);
        } else {
            deletePrivate.apply(change, input);
        }
    } catch (Exception e) {
        throw asRestApiException("Cannot change private status", e);
    }
}
#end_block

#method_before
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set work in progress state", e);
    }
}
#method_after
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set work in progress state", e);
    }
}
#end_block

#method_before
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set ready for review state", e);
    }
}
#method_after
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set ready for review state", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot publish change", e);
    }
}
#method_after
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#end_block

#method_before
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (EmailException | OrmException | UpdateException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot rebase change", e);
    }
}
#method_after
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase change", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Could not extract IncludedIn data", e);
    }
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Could not extract IncludedIn data", e);
    }
}
#end_block

#method_before
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get hashtags", e);
    }
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get drafts", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Override
public void ignore(boolean ignore) throws RestApiException {
    if (ignore) {
        this.ignore.apply(change, new Ignore.Input());
    } else {
        unignore.apply(change, new Unignore.Input());
    }
}
#method_after
@Override
public void ignore(boolean ignore) throws RestApiException {
    // StarredChangesUtil.
    if (ignore) {
        this.ignore.apply(change, new Ignore.Input());
    } else {
        unignore.apply(change, new Unignore.Input());
    }
}
#end_block

#method_before
@Override
public void mute(boolean mute) throws RestApiException {
    if (mute) {
        this.mute.apply(change, new Mute.Input());
    } else {
        unmute.apply(change, new Unmute.Input());
    }
}
#method_after
@Override
public void mute(boolean mute) throws RestApiException {
    // StarredChangesUtil.
    if (mute) {
        this.mute.apply(change, new Mute.Input());
    } else {
        unmute.apply(change, new Unmute.Input());
    }
}
#end_block

#method_before
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
    if (!children.isEmpty()) {
        String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

            @Override
            public String apply(ProjectInfo info) {
                return info.name;
            }
        }));
        throw new CannotDeleteProjectException("Cannot delete project because " + "it has children: " + childrenString);
    }
}
#method_after
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
    if (!children.isEmpty()) {
        String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

            @Override
            public String apply(ProjectInfo info) {
                return info.name;
            }
        }));
        throw new CannotDeleteProjectException("Cannot delete project because it has children: " + childrenString);
    }
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            // Workaround for JDK-6518827 - zero-length argument ignored on Win32
            String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
            if (!exists(site.ssh_rsa)) {
                System.err.print(" rsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_dsa)) {
                System.err.print(" dsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_ed25519)) {
                System.err.print(" ed25519...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue as since older hosts wont be able to generate ed25519 keys.
                    System.err.print(" Failed to generate ed25519 key, continuing...");
                    System.err.flush();
                }
            }
            if (!exists(site.ssh_ecdsa)) {
                System.err.print(" ecdsa...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ecdsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue as since older hosts wont be able to generate ecdsa keys.
                    System.err.print(" Failed to generate ecdsa key, continuing...");
                    System.err.flush();
                }
            }
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && !exists(site.ssh_rsa) && !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            // Workaround for JDK-6518827 - zero-length argument ignored on Win32
            String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
            if (!exists(site.ssh_rsa)) {
                System.err.print(" rsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_dsa)) {
                System.err.print(" dsa...");
                System.err.flush();
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            }
            if (!exists(site.ssh_ed25519)) {
                System.err.print(" ed25519...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue since older hosts won't be able to generate ed25519 keys.
                    System.err.print(" Failed to generate ed25519 key, continuing...");
                    System.err.flush();
                }
            }
            if (!exists(site.ssh_ecdsa)) {
                System.err.print(" ecdsa...");
                System.err.flush();
                try {
                    new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                    "-t", "ecdsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
                } catch (Exception e) {
                    // continue since older hosts won't be able to generate ecdsa keys.
                    System.err.print(" Failed to generate ecdsa key, continuing...");
                    System.err.flush();
                }
            }
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Override
public KeyPairProvider get() {
    Path objKey = site.ssh_key;
    Path rsaKey = site.ssh_rsa;
    Path dsaKey = site.ssh_dsa;
    Path ecdsaKey = site.ssh_ecdsa;
    Path ed25519Key = site.ssh_ed25519;
    final List<File> stdKeys = new ArrayList<>(2);
    if (Files.exists(rsaKey)) {
        stdKeys.add(rsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(dsaKey)) {
        stdKeys.add(dsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ecdsaKey)) {
        stdKeys.add(ecdsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ed25519Key)) {
        stdKeys.add(ed25519Key.toAbsolutePath().toFile());
    }
    if (Files.exists(objKey)) {
        if (stdKeys.isEmpty()) {
            SimpleGeneratorHostKeyProvider p = new SimpleGeneratorHostKeyProvider();
            p.setPath(objKey.toAbsolutePath());
            return p;
        }
        // Both formats of host key exist, we don't know which format
        // should be authoritative. Complain and abort.
        // 
        stdKeys.add(objKey.toAbsolutePath().toFile());
        throw new ProvisionException("Multiple host keys exist: " + stdKeys);
    }
    if (stdKeys.isEmpty()) {
        throw new ProvisionException("No SSH keys under " + site.etc_dir);
    }
    if (!SecurityUtils.isBouncyCastleRegistered()) {
        throw new ProvisionException("Bouncy Castle Crypto not installed;" + " needed to read server host keys: " + stdKeys + "");
    }
    FileKeyPairProvider kp = new FileKeyPairProvider();
    kp.setFiles(stdKeys);
    return kp;
}
#method_after
@Override
public KeyPairProvider get() {
    Path objKey = site.ssh_key;
    Path rsaKey = site.ssh_rsa;
    Path dsaKey = site.ssh_dsa;
    Path ecdsaKey = site.ssh_ecdsa;
    Path ed25519Key = site.ssh_ed25519;
    final List<File> stdKeys = new ArrayList<>(4);
    if (Files.exists(rsaKey)) {
        stdKeys.add(rsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(dsaKey)) {
        stdKeys.add(dsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ecdsaKey)) {
        stdKeys.add(ecdsaKey.toAbsolutePath().toFile());
    }
    if (Files.exists(ed25519Key)) {
        stdKeys.add(ed25519Key.toAbsolutePath().toFile());
    }
    if (Files.exists(objKey)) {
        if (stdKeys.isEmpty()) {
            SimpleGeneratorHostKeyProvider p = new SimpleGeneratorHostKeyProvider();
            p.setPath(objKey.toAbsolutePath());
            return p;
        }
        // Both formats of host key exist, we don't know which format
        // should be authoritative. Complain and abort.
        // 
        stdKeys.add(objKey.toAbsolutePath().toFile());
        throw new ProvisionException("Multiple host keys exist: " + stdKeys);
    }
    if (stdKeys.isEmpty()) {
        throw new ProvisionException("No SSH keys under " + site.etc_dir);
    }
    if (!SecurityUtils.isBouncyCastleRegistered()) {
        throw new ProvisionException("Bouncy Castle Crypto not installed;" + " needed to read server host keys: " + stdKeys + "");
    }
    FileKeyPairProvider kp = new FileKeyPairProvider();
    kp.setFiles(stdKeys);
    return kp;
}
#end_block

#method_before
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, NoSuchChangeException, OrmException {
    String path = rsrc.getPatchKey().get();
    if (Patch.COMMIT_MSG.equals(path)) {
        String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64();
    } else if (Patch.MERGE_LIST.equals(path)) {
        byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64();
    }
    return fileContentUtil.getContent(rsrc.getRevision().getControl().getProjectControl().getProjectState(), ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent);
}
#method_after
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, BadRequestException, OrmException {
    String path = rsrc.getPatchKey().get();
    if (Patch.COMMIT_MSG.equals(path)) {
        String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64();
    } else if (Patch.MERGE_LIST.equals(path)) {
        byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64();
    }
    return fileContentUtil.getContent(rsrc.getRevision().getControl().getProjectControl().getProjectState(), ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent);
}
#end_block

#method_before
@Override
public Response<BinaryResult> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : edit.getEditCommit(), rsrc.getPath(), null));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<BinaryResult> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : edit.getEditCommit(), rsrc.getPath(), null));
    } catch (ResourceNotFoundException | BadRequestException e) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException {
    return fileContentUtil.getContent(rsrc.getProject().getProjectState(), rsrc.getRev(), rsrc.getPath(), null);
}
#method_after
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, BadRequestException, IOException {
    return fileContentUtil.getContent(rsrc.getProject().getProjectState(), rsrc.getRev(), rsrc.getPath(), null);
}
#end_block

#method_before
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path, @Nullable Integer parent) throws ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        if (parent != null) {
            RevCommit revCommit = rw.parseCommit(revstr);
            if (revCommit == null || parent < 0 || parent > revCommit.getParentCount()) {
                throw new ResourceNotFoundException("invalid parent");
            }
            revstr = rw.parseCommit(revstr).getParent(parent - 1).toObjectId();
        }
        return getContent(repo, project, revstr, path);
    }
}
#method_after
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path, @Nullable Integer parent) throws BadRequestException, ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        if (parent != null) {
            RevCommit revCommit = rw.parseCommit(revstr);
            if (revCommit == null) {
                throw new ResourceNotFoundException("commit not found");
            }
            if (parent > revCommit.getParentCount()) {
                throw new BadRequestException("invalid parent");
            }
            revstr = rw.parseCommit(revstr).getParent(Integer.max(0, parent - 1)).toObjectId();
        }
        return getContent(repo, project, revstr, path);
    }
}
#end_block

#method_before
private List<PublicKey> myHostKeys() {
    final KeyPairProvider p = getKeyPairProvider();
    final List<PublicKey> keys = new ArrayList<>(2);
    addPublicKey(keys, p, KeyPairProvider.SSH_ED25519);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP256);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP384);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP521);
    addPublicKey(keys, p, KeyPairProvider.SSH_RSA);
    addPublicKey(keys, p, KeyPairProvider.SSH_DSS);
    return keys;
}
#method_after
private List<PublicKey> myHostKeys() {
    final KeyPairProvider p = getKeyPairProvider();
    final List<PublicKey> keys = new ArrayList<>(6);
    addPublicKey(keys, p, KeyPairProvider.SSH_ED25519);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP256);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP384);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP521);
    addPublicKey(keys, p, KeyPairProvider.SSH_RSA);
    addPublicKey(keys, p, KeyPairProvider.SSH_DSS);
    return keys;
}
#end_block

#method_before
private static Set<PublicKey> myHostKeys(KeyPairProvider p) {
    final Set<PublicKey> keys = new HashSet<>(2);
    addPublicKey(keys, p, KeyPairProvider.SSH_ED25519);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP256);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP384);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP521);
    addPublicKey(keys, p, KeyPairProvider.SSH_RSA);
    addPublicKey(keys, p, KeyPairProvider.SSH_DSS);
    return keys;
}
#method_after
private static Set<PublicKey> myHostKeys(KeyPairProvider p) {
    final Set<PublicKey> keys = new HashSet<>(6);
    addPublicKey(keys, p, KeyPairProvider.SSH_ED25519);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP256);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP384);
    addPublicKey(keys, p, KeyPairProvider.ECDSA_SHA2_NISTP521);
    addPublicKey(keys, p, KeyPairProvider.SSH_RSA);
    addPublicKey(keys, p, KeyPairProvider.SSH_DSS);
    return keys;
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate != null && input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        // Nothing to do.
        return false;
    }
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), Change.Status.DRAFT)) {
        throw new AuthException("Not permitted to delete this draft patch set");
    }
    patchSetsBeforeDeletion = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    deleteDraftPatchSet(patchSet, ctx);
    deleteOrUpdateDraftChange(ctx);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    Map<PatchSet.Id, PatchSet> patchSets = psUtil.byChangeAsMap(db.get(), ctx.getNotes());
    patchSet = patchSets.get(psId);
    if (patchSet == null) {
        // Nothing to do.
        return false;
    }
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), Change.Status.DRAFT)) {
        throw new AuthException("Not permitted to delete this draft patch set");
    }
    patchSetsBeforeDeletion = patchSets.values();
    deleteDraftPatchSet(patchSet, ctx);
    deleteOrUpdateDraftChange(ctx, patchSets);
    return true;
}
#end_block

#method_before
private void deleteOrUpdateDraftChange(ChangeContext ctx) throws OrmException, RestApiException, IOException, NoSuchChangeException {
    Change c = ctx.getChange();
    if (deletedOnlyPatchSet()) {
        deleteChangeOp = deleteChangeOpProvider.get();
        deleteChangeOp.updateChange(ctx);
        return;
    }
    if (c.currentPatchSetId().equals(psId)) {
        c.setCurrentPatchSet(previousPatchSetInfo(ctx));
    }
}
#method_after
private void deleteOrUpdateDraftChange(ChangeContext ctx, Map<PatchSet.Id, PatchSet> patchSets) throws OrmException, RestApiException, IOException, NoSuchChangeException {
    Change c = ctx.getChange();
    if (deletedOnlyPatchSet()) {
        deleteChangeOp = deleteChangeOpProvider.get();
        deleteChangeOp.updateChange(ctx);
        return;
    }
    if (c.currentPatchSetId().equals(psId)) {
        c.setCurrentPatchSet(previousPatchSetInfo(ctx, patchSets));
    }
}
#end_block

#method_before
private PatchSetInfo previousPatchSetInfo(ChangeContext ctx) throws OrmException {
    try {
        // the repo after the updateRepo phase.
        return patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(psId.getParentKey(), psId.get() - 1));
    } catch (PatchSetInfoNotAvailableException e) {
        throw new OrmException(e);
    }
}
#method_after
private PatchSetInfo previousPatchSetInfo(ChangeContext ctx, Map<PatchSet.Id, PatchSet> patchSets) throws OrmException {
    PatchSet.Id prevPsId = null;
    for (PatchSet.Id id : patchSets.keySet()) {
        if (id.get() < psId.get() && (prevPsId == null || id.get() > prevPsId.get())) {
            prevPsId = id;
        }
    }
    try {
        // the repo after the updateRepo phase.
        return patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(psId.getParentKey(), checkNotNull(prevPsId).get()));
    } catch (PatchSetInfoNotAvailableException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.apply(revision, in);
    } catch (Exception e) {
        throwRestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        // TODO(dborowitz): Convert to RetryingRestModifyHandler. Requires converting MergeOp to a
        // Factory that takes BatchUpdate.Factory. (Enough Factories yet?)
        submit.apply(revision, in);
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        // TODO(dborowitz): Convert to RetryingRestModifyHandler. Requires converting MergeOp to a
        // Factory that takes BatchUpdate.Factory. (Enough Factories yet?)
        submit.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot submit change", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        // TODO(dborowitz): Convert to RetryingRestModifyHandler. Requires converting MergeOp to a
        // Factory that takes BatchUpdate.Factory.
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit preview", e);
    }
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        // TODO(dborowitz): Convert to RetryingRestModifyHandler. Requires converting MergeOp to a
        // Factory that takes BatchUpdate.Factory.
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publish.apply(revision, new PublishDraftPatchSet.Input());
    } catch (Exception e) {
        throwRestApiException("Cannot publish draft patch set", e);
    }
}
#method_after
@Override
public void publish() throws RestApiException {
    try {
        publish.apply(revision, new PublishDraftPatchSet.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot publish draft patch set", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteDraft.apply(revision, null);
    } catch (Exception e) {
        throwRestApiException("Cannot delete draft ps", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteDraft.apply(revision, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete draft ps", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (IOException e) {
        throw new RestApiException("Cannot check if rebase is possible", e);
    }
}
#method_after
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (Exception e) {
        throw asRestApiException("Cannot check if rebase is possible", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (Exception e) {
        throw asRestApiException("Cannot list reviewed files", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public EditInfo applyFix(String fixId) throws RestApiException {
    try {
        return applyFix.apply(fixes.parse(revision, IdString.fromDecoded(fixId)), null).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot apply fix", e);
    }
}
#method_after
@Override
public EditInfo applyFix(String fixId) throws RestApiException {
    try {
        return applyFix.apply(fixes.parse(revision, IdString.fromDecoded(fixId)), null).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot apply fix", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve draft", e);
    }
}
#method_after
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve draft", e);
    }
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot create draft", e);
    }
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (Exception e) {
        throw asRestApiException("Cannot create draft", e);
    }
}
#end_block

#method_before
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comment", e);
    }
}
#method_after
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comment", e);
    }
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comment", e);
    }
}
#method_after
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comment", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get actions", e);
    }
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get actions", e);
    }
}
#end_block

#method_before
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit type", e);
    }
}
#method_after
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit type", e);
    }
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot test submit type", e);
    }
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot test submit type", e);
    }
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (IOException e) {
                throw new RestApiException("Cannot get merge list", e);
            }
        }
    };
}
#method_after
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (Exception e) {
                throw asRestApiException("Cannot get merge list", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throwRestApiException("Cannot set description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set description", e);
    }
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throwRestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throwRestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throwRestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public void setPrivate(boolean value) throws RestApiException {
    try {
        if (value) {
            putPrivate.apply(change, null);
        } else {
            deletePrivate.apply(change, null);
        }
    } catch (Exception e) {
        throwRestApiException("Cannot change private status", e);
    }
}
#method_after
@Override
public void setPrivate(boolean value) throws RestApiException {
    try {
        if (value) {
            putPrivate.apply(change, null);
        } else {
            deletePrivate.apply(change, null);
        }
    } catch (Exception e) {
        throw asRestApiException("Cannot change private status", e);
    }
}
#end_block

#method_before
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throwRestApiException("Cannot set work in progress state", e);
    }
}
#method_after
@Override
public void setWorkInProgress(String message) throws RestApiException {
    try {
        setWip.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set work in progress state", e);
    }
}
#end_block

#method_before
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throwRestApiException("Cannot set ready for review state", e);
    }
}
#method_after
@Override
public void setReadyForReview(String message) throws RestApiException {
    try {
        setReady.apply(change, new WorkInProgressOp.Input(message));
    } catch (Exception e) {
        throw asRestApiException("Cannot set ready for review state", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throwRestApiException("Cannot publish change", e);
    }
}
#method_after
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#end_block

#method_before
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (Exception e) {
        throwRestApiException("Cannot rebase change", e);
    }
}
#method_after
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase change", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throwRestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Could not extract IncludedIn data", e);
    }
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Could not extract IncludedIn data", e);
    }
}
#end_block

#method_before
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throwRestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot get hashtags", e);
    }
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throwIfPossible(e);
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get drafts", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throwRestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isFalse();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#method_after
@Test
public void setPrivateByOtherUser() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isNull();
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to mark private");
    gApi.changes().id(result.getChangeId()).setPrivate(true);
}
#end_block

#method_before
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#method_after
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#end_block

#method_before
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        oi.flush();
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(approvalsUtil.getReviewers(db.get(), ctl.getNotes()).all());
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(approvalsUtil.getReviewers(db.get(), ctl.getNotes()).all());
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
@Test
@UseSsh
public void create() throws Exception {
    TestAccount foo = accounts.create("foo");
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo("foo");
    // account creation + adding SSH keys
    accountIndexedCounter.assertReindexOf(foo, 2);
    // check user branch
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsUsers(foo.getId()));
        assertThat(ref).isNotNull();
        RevCommit c = rw.parseCommit(ref.getObjectId());
        long timestampDiffMs = Math.abs(c.getCommitTime() * 1000L - accountCache.get(foo.getId()).getAccount().getRegisteredOn().getTime());
        assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS);
    }
}
#method_after
@Test
public void create() throws Exception {
    TestAccount foo = accounts.create("foo");
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo("foo");
    if (SshMode.useSsh()) {
        // account creation + adding SSH keys
        accountIndexedCounter.assertReindexOf(foo, 2);
    } else {
        // account creation
        accountIndexedCounter.assertReindexOf(foo, 1);
    }
    // check user branch
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsUsers(foo.getId()));
        assertThat(ref).isNotNull();
        RevCommit c = rw.parseCommit(ref.getObjectId());
        long timestampDiffMs = Math.abs(c.getCommitTime() * 1000L - accountCache.get(foo.getId()).getAccount().getRegisteredOn().getTime());
        assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS);
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    assignee.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        Status s = info.revision(revision).draft() ? Status.DRAFT : info.status();
        statusText.setInnerText(Util.toLongString(s));
    }
    if (info.isPrivate()) {
        privateText.setInnerText(Util.C.isPrivate());
    }
    if (info.isWip()) {
        wipText.setInnerText(Util.C.isPrivate());
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    assignee.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        Status s = info.revision(revision).draft() ? Status.DRAFT : info.status();
        statusText.setInnerText(Util.toLongString(s));
    }
    if (info.isPrivate()) {
        privateText.setInnerText(Util.C.isPrivate());
    }
    if (info.isWorkInProgress()) {
        wipText.setInnerText(Util.C.isWorkInProgress());
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
private String getUrl(@GerritServerConfig Config cfg, SitePaths sitePaths) {
    String url = cfg.getString("accountPatchReviewDb", null, "url");
    if (url == null) {
        return H2.createUrl(sitePaths.db_dir.resolve("account_patch_reviews"));
    }
    return url;
}
#method_after
private static String getUrl(@GerritServerConfig Config cfg, SitePaths sitePaths) {
    String url = cfg.getString("accountPatchReviewDb", null, "url");
    if (url == null) {
        return H2.createUrl(sitePaths.db_dir.resolve("account_patch_reviews"));
    }
    return url;
}
#end_block

#method_before
private static DataSource createDataSource(String url) {
    BasicDataSource datasource = new BasicDataSource();
    if (url.contains("postgresql")) {
        datasource.setDriverClassName("org.postgresql.Driver");
    } else if (url.contains("h2")) {
        datasource.setDriverClassName("org.h2.Driver");
    } else if (url.contains("mysql")) {
        datasource.setDriverClassName("com.mysql.jdbc.Driver");
    }
    datasource.setUrl(url);
    datasource.setMaxActive(50);
    datasource.setMinIdle(4);
    datasource.setMaxIdle(16);
    long evictIdleTimeMs = 1000 * 60;
    datasource.setMinEvictableIdleTimeMillis(evictIdleTimeMs);
    datasource.setTimeBetweenEvictionRunsMillis(evictIdleTimeMs / 2);
    return datasource;
}
#method_after
protected static DataSource createDataSource(String url) {
    BasicDataSource datasource = new BasicDataSource();
    if (url.contains("postgresql")) {
        datasource.setDriverClassName("org.postgresql.Driver");
    } else if (url.contains("h2")) {
        datasource.setDriverClassName("org.h2.Driver");
    } else if (url.contains("mysql")) {
        datasource.setDriverClassName("com.mysql.jdbc.Driver");
    }
    datasource.setUrl(url);
    datasource.setMaxActive(50);
    datasource.setMinIdle(4);
    datasource.setMaxIdle(16);
    long evictIdleTimeMs = 1000 * 60;
    datasource.setMinEvictableIdleTimeMillis(evictIdleTimeMs);
    datasource.setTimeBetweenEvictionRunsMillis(evictIdleTimeMs / 2);
    return datasource;
}
#end_block

#method_before
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS ACCOUNT_PATCH_REVIEWS (" + "ACCOUNT_ID INTEGER DEFAULT 0 NOT NULL, " + "CHANGE_ID INTEGER DEFAULT 0 NOT NULL, " + "PATCH_SET_ID INTEGER DEFAULT 0 NOT NULL, " + "FILE_NAME VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT PRIMARY_KEY_ACCOUNT_PATCH_REVIEWS " + "PRIMARY KEY (ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME)" + ")");
}
#method_after
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(4096) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (account_id, change_id, patch_set_id, file_name)" + ")");
}
#end_block

#method_before
public void dropTableIfExists() throws OrmException {
    try (Connection con = ds.getConnection();
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS ACCOUNT_PATCH_REVIEWS");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#method_after
public void dropTableIfExists() throws OrmException {
    try (Connection con = ds.getConnection();
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS account_patch_reviews");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#end_block

#method_before
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#method_after
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#method_after
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND " + "PATCH_SET_ID = ? AND FILE_NAME = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE account_id = ? AND change_id = ? AND " + "patch_set_id = ? AND file_name = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID = ? AND PATCH_SET_ID = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE change_id = ? AND patch_set_id = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT PATCH_SET_ID, FILE_NAME FROM ACCOUNT_PATCH_REVIEWS APR1 " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND PATCH_SET_ID = " + "(SELECT MAX(PATCH_SET_ID) FROM ACCOUNT_PATCH_REVIEWS APR2 WHERE " + "APR1.ACCOUNT_ID = APR2.ACCOUNT_ID " + "AND APR1.CHANGE_ID = APR2.CHANGE_ID " + "AND PATCH_SET_ID <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSetWithReviewedFiles r = new PatchSetWithReviewedFiles();
                r.files = new ArrayList<>();
                r.patchSetId = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                do {
                    r.files.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(r);
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#method_after
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("patch_set_id"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("file_name"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#end_block

#method_before
public OrmException convertError(String op, SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
}
#method_after
public OrmException convertError(String op, SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return new OrmException(op + " failure on account_patch_reviews", err);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    JdbcAccountPatchReviewStore jdbcAccountPatchReviewStore = new JdbcAccountPatchReviewStore(cfg, sitePaths);
    jdbcAccountPatchReviewStore.dropTableIfExists();
    jdbcAccountPatchReviewStore.createTableIfNotExists();
    try (Connection con = jdbcAccountPatchReviewStore.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        int batchCount = 0;
        try (Statement s = newStatement(db);
            ResultSet rs = s.executeQuery("SELECT * from account_patch_reviews")) {
            while (rs.next()) {
                stmt.setInt(1, rs.getInt("account_id"));
                stmt.setInt(2, rs.getInt("change_id"));
                stmt.setInt(3, rs.getInt("patch_set_id"));
                stmt.setString(4, rs.getString("file_name"));
                stmt.addBatch();
                batchCount++;
                if (batchCount >= MAX_BATCH_SIZE) {
                    stmt.executeBatch();
                    batchCount = 0;
                }
            }
        }
        if (batchCount > 0) {
            stmt.executeBatch();
        }
    } catch (SQLException e) {
        throw jdbcAccountPatchReviewStore.convertError("insert", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    JdbcAccountPatchReviewStore jdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(cfg, sitePaths);
    jdbcAccountPatchReviewStore.dropTableIfExists();
    jdbcAccountPatchReviewStore.createTableIfNotExists();
    try (Connection con = jdbcAccountPatchReviewStore.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        int batchCount = 0;
        try (Statement s = newStatement(db);
            ResultSet rs = s.executeQuery("SELECT * from account_patch_reviews")) {
            while (rs.next()) {
                stmt.setInt(1, rs.getInt("account_id"));
                stmt.setInt(2, rs.getInt("change_id"));
                stmt.setInt(3, rs.getInt("patch_set_id"));
                stmt.setString(4, rs.getString("file_name"));
                stmt.addBatch();
                batchCount++;
                if (batchCount >= MAX_BATCH_SIZE) {
                    stmt.executeBatch();
                    batchCount = 0;
                }
            }
        }
        if (batchCount > 0) {
            stmt.executeBatch();
        }
    } catch (SQLException e) {
        throw jdbcAccountPatchReviewStore.convertError("insert", e);
    }
}
#end_block

#method_before
@Override
public OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("ACCOUNT_PATCH_REVIEWS", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
    }
}
#method_after
@Override
public OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("account_patch_reviews", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on account_patch_reviews", err);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new JdbcAccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new H2AccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (EmailException | OrmException | UpdateException | RestApiException | IOException e) {
        throw new RestApiException("Cannot rebase change", e);
    }
}
#method_after
@Override
public void rebase(RebaseInput in) throws RestApiException {
    try {
        rebase.apply(change, in);
    } catch (EmailException | OrmException | UpdateException | IOException | PermissionBackendException e) {
        throw new RestApiException("Cannot rebase change", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    addReviewer(in);
}
#method_after
@Override
public AddReviewerResult addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(in);
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (UpdateException | PermissionBackendException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException | IOException | OrmException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (UpdateException | IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException | PermissionBackendException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.DRAFT);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress(null);
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview(null);
    assertQuery("is:private");
}
#method_after
@Test
public void byWip() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
    gApi.changes().id(change1.getChangeId()).setWorkInProgress(null);
    assertQuery("is:wip", change1);
    assertQuery("reviewer:" + user1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview(null);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    assertQuery("reviewer:" + user1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(String in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(String in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    assertThat(gApi.changes().id(changeId).get().isPrivate).isTrue();
    gApi.changes().id(changeId).setPrivate(false);
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
}
#method_after
@Test
public void toggleWorkInProgressState() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // With message
    gApi.changes().id(changeId).setWorkInProgress("Needs some refactoring");
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).contains("Needs some refactoring");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview("PTAL");
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).contains("PTAL");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
    // No message
    gApi.changes().id(changeId).setWorkInProgress();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Work In Progress");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_WIP);
    gApi.changes().id(changeId).setReadyForReview();
    info = gApi.changes().id(changeId).get();
    assertThat(info.workInProgress).isFalse();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set Ready For Review");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_READY);
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        int id = changeResult.getChange().getId().id;
        RevCommit commit = changeResult.getCommit();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
        String ref = new Change.Id(id).toRefPrefix() + "1";
        eventRecorder.assertRefUpdatedEvents(project.get(), ref, null, commit, commit, null);
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#end_block

#method_before
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        Change.Id id = changeResult.getChange().getId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage(String.format("Deleting change %s is not permitted", id));
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        Change.Id id = changeResult.getChange().getId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Change not visible to " + user.email);
    gApi.changes().id(result.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result r = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Account of " + username + " is inactive.");
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result result = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).contains("identifies an inactive account");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
public static PatchSet.Id nextPatchSetId(Repository git, PatchSet.Id id) throws IOException {
    return nextPatchSetId(git.getRefDatabase().getRefs(RefDatabase.ALL), id);
}
#method_after
public static PatchSet.Id nextPatchSetId(Repository git, PatchSet.Id id) throws IOException {
    return nextPatchSetIdFromChangeRefsMap(Maps.transformValues(git.getRefDatabase().getRefs(id.getParentKey().toRefPrefix()), Ref::getObjectId), id);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    put(CHANGE_KIND, "private").to(PutPrivate.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(PostReviewersOp.Factory.class);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        info.wip = c.isWip();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate();
        info.workInProgress = c.isWorkInProgress();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.wip = in.isWip();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate();
    out.workInProgress = in.isWorkInProgress();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
            if (state == ReviewerStateInternal.REMOVED) {
                continue;
            }
            Collection<AccountInfo> reviewers = toAccountInfo(cd.reviewers().byState(state));
            reviewers.addAll(toAccountInfoByEmail(cd.reviewersByEmail().byState(state)));
            if (!reviewers.isEmpty()) {
                out.reviewers.put(state.asReviewerState(), reviewers);
            }
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(perm, cd, labelTypes, standard, detailed) : labelsForClosedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForOpenChange(ChangeControl ctl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Map<String, LabelWithStatus> labels = initLabels(cd, labelTypes, standard);
    if (detailed) {
        setAllApprovals(ctl, cd, labels);
    }
    for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
        LabelType type = labelTypes.byLabel(e.getKey());
        if (type == null) {
            continue;
        }
        if (standard) {
            for (PatchSetApproval psa : cd.currentApprovals()) {
                if (type.matches(psa)) {
                    short val = psa.getValue();
                    Account.Id accountId = psa.getAccountId();
                    setLabelScores(type, e.getValue(), val, accountId);
                }
            }
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForOpenChange(PermissionBackend.ForChange perm, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    Map<String, LabelWithStatus> labels = initLabels(cd, labelTypes, standard);
    if (detailed) {
        setAllApprovals(perm, cd, labels);
    }
    for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
        LabelType type = labelTypes.byLabel(e.getKey());
        if (type == null) {
            continue;
        }
        if (standard) {
            for (PatchSetApproval psa : cd.currentApprovals()) {
                if (type.matches(psa)) {
                    short val = psa.getValue();
                    Account.Id accountId = psa.getAccountId();
                    setLabelScores(type, e.getValue(), val, accountId);
                }
            }
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(PermissionBackend.ForChange basePerm, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException, PermissionBackendException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), cd.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    for (Account.Id accountId : allUsers) {
        PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = labelTypes.byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = perm.test(new LabelPermission(lt)) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = perm.test(new LabelPermission(lt)) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(PermissionBackend.ForChange basePerm, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    boolean isMerged = cd.change().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelType> toCheck = new HashMap<>();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels != null) {
            for (SubmitRecord.Label r : rec.labels) {
                LabelType type = labelTypes.byLabel(r.label);
                if (type != null && (!isMerged || type.allowPostSubmit())) {
                    toCheck.put(type.getName(), type);
                }
            }
        }
    }
    Map<String, Short> labels = null;
    Set<LabelPermission.WithValue> can = perm.testLabels(toCheck.values());
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            for (LabelValue v : type.getValues()) {
                boolean ok = can.contains(new LabelPermission.WithValue(type, v));
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(perm, cd);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, Short> currentLabels(ChangeControl ctl) throws OrmException {
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, ctl.getChange().currentPatchSetId(), ctl.getUser().getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    ChangeControl ctl = cd.changeControl().forUser(user);
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, cd.change().currentPatchSetId(), user.getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isPatchVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (ctl.canRemoveReviewer(id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(ctl.getChange().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWip(wip);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWip(wip);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWip() ? "Ready For Review" : "Work In Progress");
    String m = Strings.nullToEmpty(in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), !m.isEmpty() ? null : c.isWip() ? ChangeMessagesUtil.TAG_SET_READY : ChangeMessagesUtil.TAG_SET_WIP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
public static ChangeMessage newMessage(PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUuid()), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#method_after
public static ChangeMessage newMessage(ChangeContext ctx, String body, @Nullable String tag) {
    return newMessage(ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWip()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, false, input));
        bu.execute();
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, false, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("Ready").setTitle("Set Ready For Review").setVisible(rsrc.getControl().isOwner() && rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWip());
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("Ready").setTitle("Set Ready For Review").setVisible(rsrc.isUserOwner() && rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWorkInProgress());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWip()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, true, input));
        bu.execute();
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, true, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(rsrc.getControl().isOwner() && rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWip());
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(rsrc.isUserOwner() && rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWorkInProgress());
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, notesMigration);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("wip".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#end_block

#method_before
public static Change readOneReviewDbChange(ReviewDb db, Change.Id id) throws OrmException {
    return ReviewDbUtil.unwrapDb(db).changes().get(id);
}
#method_after
@Nullable
public static Change readOneReviewDbChange(ReviewDb db, Change.Id id) throws OrmException {
    return ReviewDbUtil.unwrapDb(db).changes().get(id);
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.test(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null);
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean wip) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, wip), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, wip);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWip(c.isWip() == null ? false : c.isWip());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    if (isPrivate != null) {
        addFooter(msg, FOOTER_PRIVATE, isPrivate);
    }
    if (wip != null) {
        addFooter(msg, FOOTER_WIP, wip);
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Map.Entry<Address, ReviewerStateInternal> e : reviewersByEmail.entrySet()) {
        addFooter(msg, e.getValue().getByEmailFooterKey(), e.getKey().toString());
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        // Label names/values are safe to append without sanitizing.
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    // Label names/values are safe to append without sanitizing.
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    if (readOnlyUntil != null) {
        addFooter(msg, FOOTER_READ_ONLY_UNTIL, ChangeNoteUtil.formatTime(serverIdent, readOnlyUntil));
    }
    if (isPrivate != null) {
        addFooter(msg, FOOTER_PRIVATE, isPrivate);
    }
    if (workInProgress != null) {
        addFooter(msg, FOOTER_WORK_IN_PROGRESS, workInProgress);
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null && wip == null;
}
#method_after
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && reviewersByEmail.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null && workInProgress == null;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWip(wip);
    return change;
}
#method_after
@Override
public Change createChange(Context ctx) throws IOException {
    change = new Change(getChangeKey(ctx.getRevWalk(), commitId), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWorkInProgress(workInProgress);
    return change;
}
#end_block

#method_before
private static Change.Key getChangeKey(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeId = new StringBuilder();
    changeId.append("I").append(ObjectId.toString(id));
    return new Change.Key(changeId.toString());
}
#method_after
private static Change.Key getChangeKey(RevWalk rw, ObjectId id) throws IOException {
    RevCommit commit = rw.parseCommit(id);
    rw.parseBody(commit);
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId changeId = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeIdStr = new StringBuilder();
    changeIdStr.append("I").append(ObjectId.toString(changeId));
    return new Change.Key(changeIdStr.toString());
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(ObjectId.zeroId(), commitId, psId.toRefName());
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    if (isPrivate) {
        update.setPrivate(isPrivate);
    }
    if (wip) {
        update.setWip(wip);
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getIdentifiedUser());
        commitValidatorsFactory.create(validatePolicy, refControl, new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName), refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#method_after
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneReviewersByEmail();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, wip);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (wip == null) {
        parseWip(commit);
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
        for (String line : commit.getFooterLineValues(state.getByEmailFooterKey())) {
            parseReviewerByEmail(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (workInProgress == null) {
        parseWorkInProgress(commit);
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#method_after
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    boolean workInProgress = magicBranch != null && magicBranch.workInProgress;
    msg = ChangeMessagesUtil.newMessage(patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    boolean workInProgress = magicBranch != null && magicBranch.workInProgress;
    msg = ChangeMessagesUtil.newMessage(patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    change.setStatus(Change.Status.NEW);
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#method_after
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
    // Leave in draft status.
    } else {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#end_block

#method_before
@Test
public void noNotificationForWipChangesForWatchersInNotifyConfig() throws Exception {
    Address addr = new Address("Watcher", "watcher@example.com");
    NotifyConfig nc = new NotifyConfig();
    nc.addEmail(addr);
    nc.setName("team");
    nc.setHeader(NotifyConfig.Header.TO);
    nc.setTypes(EnumSet.of(NotifyType.NEW_CHANGES));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.putNotifyConfig("team", nc);
    saveProjectConfig(project, cfg);
    sender.clear();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), testRepo, "wip change", "a", "a1").to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void noNotificationForWipChangesForWatchersInNotifyConfig() throws Exception {
    Address addr = new Address("Watcher", "watcher@example.com");
    NotifyConfig nc = new NotifyConfig();
    nc.addEmail(addr);
    nc.setName("team");
    nc.setHeader(NotifyConfig.Header.TO);
    nc.setTypes(EnumSet.of(NotifyType.NEW_CHANGES, NotifyType.ALL_COMMENTS));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.putNotifyConfig("team", nc);
    saveProjectConfig(project, cfg);
    sender.clear();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), testRepo, "wip change", "a", "a1").to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    setApiUser(admin);
    ReviewInput in = new ReviewInput();
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).current().review(in);
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : batch.getCommands()) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s; got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s; got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) {
    logDebug("Updating {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate).setWorkInProgress(magicBranch.workInProgress).setValidatePolicy(CommitValidators.Policy.NONE);
    if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins);
        bu.setRequestId(receiveId);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#method_after
void insertPatchSetWithoutBatchUpdate() throws IOException, UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins);
        bu.setRequestId(receiveId);
        addOps(bu, replaceProgress);
        bu.execute();
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitValidators.Policy policy;
    if (magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged) {
        policy = CommitValidators.Policy.MERGED;
    } else {
        policy = CommitValidators.Policy.RECEIVE_COMMITS;
    }
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(ctl) : commitValidatorsFactory.forReceiveCommits(ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    commit = ctx.getRevWalk().parseCommit(commitId);
    ctx.getRevWalk().parseBody(commit);
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), ctx.getRevWalk(), priorCommitId, commitId);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commitId, patchSetId.toRefName()));
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    commit = ctx.getRevWalk().parseCommit(commitId);
    ctx.getRevWalk().parseBody(commit);
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRevWalk(), ctx.getRepoView().getConfig(), priorCommitId, commitId);
    if (checkMergedInto) {
        String mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto);
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(ObjectId.zeroId(), commitId, patchSetId.toRefName());
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
    }
    update.setStatus(Change.Status.NEW);
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    change.setStatus(Change.Status.NEW);
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#method_after
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
    // Leave in draft status.
    } else {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#end_block

#method_before
private static Ref findMergedInto(Context ctx, String first, RevCommit commit) {
    try {
        RefDatabase refDatabase = ctx.getRepository().getRefDatabase();
        Ref firstRef = refDatabase.exactRef(first);
        if (firstRef != null && isMergedInto(ctx.getRevWalk(), commit, firstRef)) {
            return firstRef;
        }
        for (Ref ref : refDatabase.getRefs(Constants.R_HEADS).values()) {
            if (isMergedInto(ctx.getRevWalk(), commit, ref)) {
                return ref;
            }
        }
        return null;
    } catch (IOException e) {
        log.warn("Can't check for already submitted change", e);
        return null;
    }
}
#method_after
private static String findMergedInto(Context ctx, String first, RevCommit commit) {
    try {
        RevWalk rw = ctx.getRevWalk();
        Optional<ObjectId> firstId = ctx.getRepoView().getRef(first);
        if (firstId.isPresent() && rw.isMergedInto(commit, rw.parseCommit(firstId.get()))) {
            return first;
        }
        for (Map.Entry<String, ObjectId> e : ctx.getRepoView().getRefs(R_HEADS).entrySet()) {
            if (rw.isMergedInto(commit, rw.parseCommit(e.getValue()))) {
                return R_HEADS + e.getKey();
            }
        }
        return null;
    } catch (IOException e) {
        log.warn("Can't check for already submitted change", e);
        return null;
    }
}
#end_block

#method_before
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#method_after
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    if (notesMigration.fuseUpdates()) {
        // InMemoryRepository's atomic BatchRefUpdate implementation doesn't update the progress
        // monitor. That's fine, we just care that there was at least one new change and no errors.
        assertThat(pr.getMessages()).contains("changes: new: 1, done");
    } else {
        assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    }
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
public void mute(Account.Id accountId, Project.NameKey project, Change change) throws OrmException {
    star(accountId, project, change.getId(), ImmutableSet.of(MUTE_LABEL + "/" + change.currentPatchSetId().get()), ImmutableSet.of());
}
#method_after
public void mute(Account.Id accountId, Project.NameKey project, Change change) throws OrmException {
    star(accountId, project, change.getId(), ImmutableSet.of(getMuteLabel(change)), ImmutableSet.of());
}
#end_block

#method_before
public void unmute(Account.Id accountId, Project.NameKey project, Change change) throws OrmException {
    star(accountId, project, change.getId(), ImmutableSet.of(), ImmutableSet.of(MUTE_LABEL + "/" + change.currentPatchSetId().get()));
}
#method_after
public void unmute(Account.Id accountId, Project.NameKey project, Change change) throws OrmException {
    star(accountId, project, change.getId(), ImmutableSet.of(), ImmutableSet.of(getMuteLabel(change)));
}
#end_block

#method_before
public boolean isMutedBy(Change change, Account.Id accountId) throws OrmException {
    return byChange(change.getId(), MUTE_LABEL + "/" + change.currentPatchSetId().get()).contains(accountId);
}
#method_after
public boolean isMutedBy(Change change, Account.Id accountId) throws OrmException {
    return byChange(change.getId(), getMuteLabel(change)).contains(accountId);
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || isMuted(rsrc.getChange())) {
            // early exit for own changes and already muted changes
            return Response.ok("");
        }
        stars.mute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange());
    } catch (OrmException e) {
        throw new RestApiException("failed to mute change", e);
    }
    return Response.ok("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || isMuted(rsrc.getChange())) {
            // early exit for own changes and already muted changes
            return Response.ok("");
        }
        stars.mute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange());
    } catch (OrmException e) {
        throw new RestApiException("failed to mute change", e);
    }
    return Response.ok("");
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || !isMuted(rsrc.getChange())) {
            // early exit for own changes and not muted changes
            return Response.ok("");
        }
        stars.unmute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange());
    } catch (OrmException e) {
        throw new RestApiException("failed to unmute change", e);
    }
    return Response.ok("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || !isMuted(rsrc.getChange())) {
            // early exit for own changes and not muted changes
            return Response.ok("");
        }
        stars.unmute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange());
    } catch (OrmException e) {
        throw new RestApiException("failed to unmute change", e);
    }
    return Response.ok("");
}
#end_block

#method_before
static void executeRemoteSsh(CredentialsProvider credentialsProvider, ReplicationSshSessionFactory sshSessionFactory, URIish uri, String cmd, OutputStream errStream) throws IOException {
    RemoteSession ssh = connect(credentialsProvider, sshSessionFactory, uri);
    Process proc = ssh.exec(cmd, 0);
    proc.getOutputStream().close();
    StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
    StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
    out.start();
    err.start();
    try {
        proc.waitFor();
        out.halt();
        err.halt();
    } catch (InterruptedException interrupted) {
    // Don't wait, drop out immediately.
    }
    ssh.disconnect();
}
#method_after
int executeRemoteSsh(URIish uri, String cmd, OutputStream errStream) throws IOException {
    RemoteSession ssh = connect(uri);
    Process proc = ssh.exec(cmd, 0);
    proc.getOutputStream().close();
    StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
    StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
    out.start();
    err.start();
    try {
        proc.waitFor();
        out.halt();
        err.halt();
    } catch (InterruptedException interrupted) {
    // Don't wait, drop out immediately.
    }
    ssh.disconnect();
    return proc.exitValue();
}
#end_block

#method_before
static OutputStream newErrorBufferStream() {
    return new OutputStream() {

        private final StringBuilder out = new StringBuilder();

        private final StringBuilder line = new StringBuilder();

        @Override
        public synchronized String toString() {
            while (out.length() > 0 && out.charAt(out.length() - 1) == '\n') {
                out.setLength(out.length() - 1);
            }
            return out.toString();
        }

        @Override
        public synchronized void write(final int b) {
            if (b == '\r') {
                return;
            }
            line.append((char) b);
            if (b == '\n') {
                out.append(line);
                line.setLength(0);
            }
        }
    };
}
#method_after
OutputStream newErrorBufferStream() {
    return new OutputStream() {

        private final StringBuilder out = new StringBuilder();

        private final StringBuilder line = new StringBuilder();

        @Override
        public synchronized String toString() {
            while (out.length() > 0 && out.charAt(out.length() - 1) == '\n') {
                out.setLength(out.length() - 1);
            }
            return out.toString();
        }

        @Override
        public synchronized void write(final int b) {
            if (b == '\r') {
                return;
            }
            line.append((char) b);
            if (b == '\n') {
                out.append(line);
                line.setLength(0);
            }
        }
    };
}
#end_block

#method_before
private static RemoteSession connect(CredentialsProvider credentialsProvider, ReplicationSshSessionFactory sshSessionFactory, URIish uri) throws TransportException {
    return sshSessionFactory.create().getSession(uri, credentialsProvider, FS.DETECTED, ReplicationQueue.SSH_REMOTE_TIMEOUT);
}
#method_after
RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT);
}
#end_block

#method_before
public void createProject(CredentialsProvider credentialsProvider, URIish uri, String projectName, String head) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "gerrit create-project --branch " + head + " " + projectName;
    try {
        execute(credentialsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
protected boolean createProject(URIish uri, Project.NameKey projectName, String head) {
    OutputStream errStream = sshHelper.newErrorBufferStream();
    String cmd = "gerrit create-project --branch " + head + " " + projectName.get();
    try {
        execute(uri, cmd, errStream);
    } catch (IOException e) {
        logError("creating", uri, errStream, cmd, e);
        return false;
    }
    return true;
}
#end_block

#method_before
public void deleteProject(SecureCredentialsProvider credsProvider, URIish uri, String projectName) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "deleteproject delete --yes-really-delete --force " + projectName;
    try {
        execute(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
protected boolean deleteProject(URIish uri, Project.NameKey projectName) {
    if (!withoutDeleteProjectPlugin.contains(uri)) {
        OutputStream errStream = sshHelper.newErrorBufferStream();
        String cmd = "deleteproject delete --yes-really-delete --force " + projectName.get();
        int exitCode = -1;
        try {
            exitCode = execute(uri, cmd, errStream);
        } catch (IOException e) {
            logError("deleting", uri, errStream, cmd, e);
            return false;
        }
        if (exitCode == 1) {
            log.info("DeleteProject plugin is not installed on {}; will not try to forward this operation to that host");
            withoutDeleteProjectPlugin.add(uri);
            return true;
        }
    }
    return true;
}
#end_block

#method_before
public void updateHead(CredentialsProvider credsProvider, URIish uri, String projectName, String newHead) {
    OutputStream errStream = newErrorBufferStream();
    String cmd = "gerrit set-head " + projectName + " --new-head " + newHead;
    try {
        execute(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#method_after
protected boolean updateHead(URIish uri, Project.NameKey projectName, String newHead) {
    OutputStream errStream = sshHelper.newErrorBufferStream();
    String cmd = "gerrit set-head " + projectName.get() + " --new-head " + newHead;
    try {
        execute(uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n  Command: %s\n  Output: %s", uri, newHead, e, cmd, errStream), e);
        return false;
    }
    return true;
}
#end_block

#method_before
private URIish toSshUri(URIish uri) throws URISyntaxException {
    if (uri.getHost() != null) {
        return new URIish(uri.toString().replace("gerrit://", "ssh://"));
    } else {
        String rawPath = uri.getRawPath();
        if (!rawPath.endsWith("/")) {
            rawPath = rawPath + "/";
        }
        URIish sshUri = new URIish("ssh://" + rawPath);
        if (sshUri.getPort() < 0) {
            sshUri = sshUri.setPort(29418);
        }
        return sshUri;
    }
}
#method_after
private URIish toSshUri(URIish uri) throws URISyntaxException {
    String uriStr = uri.toString();
    if (uri.getHost() != null && uriStr.startsWith(GERRIT_ADMIN_PROTOCOL_PREFIX)) {
        return new URIish(uriStr.substring(0, GERRIT_ADMIN_PROTOCOL_PREFIX.length()));
    }
    String rawPath = uri.getRawPath();
    if (!rawPath.endsWith("/")) {
        rawPath = rawPath + "/";
    }
    URIish sshUri = new URIish("ssh://" + rawPath);
    if (sshUri.getPort() < 0) {
        sshUri = sshUri.setPort(SshAddressesModule.DEFAULT_PORT);
    }
    return sshUri;
}
#end_block

#method_before
private void execute(CredentialsProvider credentialsProvider, URIish uri, String cmd, OutputStream errStream) throws IOException {
    try {
        URIish sshUri = toSshUri(uri);
        executeRemoteSsh(credentialsProvider, sessionFactory, sshUri, cmd, errStream);
    } catch (URISyntaxException e) {
        log.error(String.format("Cannot convert %s to SSH uri", uri), e);
    }
}
#method_after
private int execute(URIish uri, String cmd, OutputStream errStream) throws IOException {
    try {
        URIish sshUri = toSshUri(uri);
        return sshHelper.executeRemoteSsh(sshUri, cmd, errStream);
    } catch (URISyntaxException e) {
        log.error(String.format("Cannot convert %s to SSH uri", uri), e);
    }
    return SSH_COMMAND_FAILED;
}
#end_block

#method_before
@Override
public void stop() {
    running = false;
    int discarded = config.shutdown();
    if (discarded > 0) {
        repLog.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#method_after
@Override
public void stop() {
    running = false;
    int discarded = config.shutdown();
    if (discarded > 0) {
        repLog.warn(String.format("Canceled %d replication events during shutdown", discarded));
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(Project.NameKey project, String urlMatch, ReplicationState state) {
    scheduleFullSync(project, urlMatch, state, false);
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(Project.NameKey project, String urlMatch, ReplicationState state, boolean now) {
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state, now);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher, database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher.get()));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.PROJECT_CREATION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            createProject(credsProvider, uri, projectName, event.getHeadName());
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(projectName, FilterType.PROJECT_CREATION)) {
        createProject(uri, projectName, event.getHeadName());
    }
}
#end_block

#method_before
@Override
public void onProjectDeleted(ProjectDeletedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.PROJECT_DELETION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            deleteProject(credsProvider, uri, projectName);
        }
    }
}
#method_after
@Override
public void onProjectDeleted(ProjectDeletedListener.Event event) {
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(projectName, FilterType.PROJECT_DELETION)) {
        deleteProject(uri, projectName);
    }
}
#end_block

#method_before
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    String projectName = event.getProjectName();
    for (Map.Entry<String, Set<URIish>> entry : getURIs(new Project.NameKey(projectName), FilterType.ALL).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            updateHead(credsProvider, uri, projectName, event.getNewHeadName());
        }
    }
}
#method_after
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (URIish uri : getURIs(project, FilterType.ALL)) {
        updateHead(uri, project, event.getNewHeadName());
    }
}
#end_block

#method_before
private Map<String, Set<URIish>> getURIs(Project.NameKey projectName, FilterType filterType) {
    if (config.getDestinations(filterType).isEmpty()) {
        return Collections.emptyMap();
    }
    if (!running) {
        repLog.error("Replication plugin did not finish startup before event");
        return Collections.emptyMap();
    }
    Map<String, Set<URIish>> result = new HashMap<>();
    for (Destination config : this.config.getDestinations(filterType)) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        Set<URIish> uris = new HashSet<>();
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                repLog.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            if (!isGerrit(uri)) {
                String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
                if (path == null) {
                    repLog.warn(String.format("adminURL %s does not contain ${name}", uri));
                    continue;
                }
                uri = uri.setPath(path);
                if (!isSSH(uri)) {
                    repLog.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                    continue;
                }
            }
            uris.add(uri);
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                uris.add(uri);
            }
        }
        result.put(config.getName(), uris);
    }
    return result;
}
#method_after
private Set<URIish> getURIs(Project.NameKey projectName, FilterType filterType) {
    if (config.getDestinations(filterType).isEmpty()) {
        return Collections.emptySet();
    }
    if (!running) {
        repLog.error("Replication plugin did not finish startup before event");
        return Collections.emptySet();
    }
    Set<URIish> uris = new HashSet<>();
    for (Destination config : this.config.getDestinations(filterType)) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        boolean adminURLUsed = false;
        for (String url : config.getAdminUrls()) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                repLog.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            if (!isGerrit(uri)) {
                String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
                if (path == null) {
                    repLog.warn(String.format("adminURL %s does not contain ${name}", uri));
                    continue;
                }
                uri = uri.setPath(path);
                if (!isSSH(uri)) {
                    repLog.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                    continue;
                }
            }
            uris.add(uri);
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : config.getURIs(projectName, "*")) {
                uris.add(uri);
            }
        }
    }
    return uris;
}
#end_block

#method_before
public boolean createProject(Project.NameKey project, String head) {
    boolean success = false;
    for (Map.Entry<String, Set<URIish>> entry : getURIs(project, FilterType.PROJECT_CREATION).entrySet()) {
        SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey());
        for (URIish uri : entry.getValue()) {
            success &= createProject(credsProvider, uri, project.get(), head);
        }
    }
    return success;
}
#method_after
public boolean createProject(Project.NameKey project, String head) {
    boolean success = true;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, project, head);
    }
    return success;
}
#end_block

#method_before
private boolean createProject(CredentialsProvider credsProvider, URIish replicateURI, String projectName, String head) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.createProject(credsProvider, replicateURI, projectName, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        createLocally(replicateURI, head);
        repLog.info("Created local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        createRemoteSsh(credsProvider, replicateURI, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot create new project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository creation", replicateURI));
        return false;
    }
    return true;
}
#method_after
private boolean createProject(URIish replicateURI, Project.NameKey projectName, String head) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.createProject(replicateURI, projectName, head);
    } else if (!replicateURI.isRemote()) {
        createLocally(replicateURI, head);
        repLog.info("Created local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        createRemoteSsh(replicateURI, head);
        repLog.info("Created remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot create new project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository creation", replicateURI));
        return false;
    }
    return true;
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        repo.create(true);
        if (head != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#end_block

#method_before
private void createRemoteSsh(CredentialsProvider credsProvider, URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private void deleteProject(SecureCredentialsProvider credsProvider, URIish replicateURI, String projectName) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.deleteProject(credsProvider, replicateURI, projectName);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        deleteLocally(replicateURI);
        repLog.info("Deleted local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        deleteRemoteSsh(credsProvider, replicateURI);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot delete project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository deletion", replicateURI));
    }
}
#method_after
private void deleteProject(URIish replicateURI, Project.NameKey projectName) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.deleteProject(replicateURI, projectName);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else if (!replicateURI.isRemote()) {
        deleteLocally(replicateURI);
        repLog.info("Deleted local repository: " + replicateURI);
    } else if (isSSH(replicateURI)) {
        deleteRemoteSsh(replicateURI);
        repLog.info("Deleted remote repository: " + replicateURI);
    } else {
        repLog.warn(String.format("Cannot delete project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote repository deletion", replicateURI));
    }
}
#end_block

#method_before
public static void recursivelyDelete(File dir) throws IOException {
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                if (!d.delete()) {
                    throw new IOException("Failed to delete: " + d.getAbsolutePath());
                }
            }
        }
    }
    if (!dir.delete()) {
        throw new IOException("Failed to delete: " + dir.getAbsolutePath());
    }
}
#method_after
private static void recursivelyDelete(File dir) throws IOException {
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                if (!d.delete()) {
                    throw new IOException("Failed to delete: " + d.getAbsolutePath());
                }
            }
        }
    }
    if (!dir.delete()) {
        throw new IOException("Failed to delete: " + dir.getAbsolutePath());
    }
}
#end_block

#method_before
private void deleteRemoteSsh(CredentialsProvider credsProvider, URIish uri) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "rm -rf " + quotedPath;
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private void deleteRemoteSsh(URIish uri) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "rm -rf " + quotedPath;
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error deleting remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private void updateHead(CredentialsProvider credsProvider, URIish replicateURI, String projectName, String newHead) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.updateHead(credsProvider, replicateURI, projectName, newHead);
    } else if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(credsProvider, replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#method_after
private void updateHead(URIish replicateURI, Project.NameKey projectName, String newHead) {
    if (isGerrit(replicateURI)) {
        gerritAdmin.updateHead(replicateURI, projectName, newHead);
    } else if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#end_block

#method_before
private void updateHeadRemoteSsh(CredentialsProvider credsProvider, URIish uri, String newHead) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "cd " + quotedPath + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(newHead);
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemoteSsh(credsProvider, uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#method_after
private void updateHeadRemoteSsh(URIish uri, String newHead) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "cd " + quotedPath + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(newHead);
    OutputStream errStream = sshHelper.newErrorBufferStream();
    try {
        sshHelper.executeRemoteSsh(uri, cmd, errStream);
    } catch (IOException e) {
        repLog.error(String.format("Error updating HEAD of remote repository at %s to %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, newHead, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private static void updateHeadLocally(URIish uri, String newHead) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            if (newHead != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.link(newHead);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#method_after
private static void updateHeadLocally(URIish uri, String newHead) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        if (newHead != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.link(newHead);
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#end_block

#method_before
private static boolean isGerrit(URIish uri) {
    String scheme = uri.getScheme();
    return scheme != null && scheme.toLowerCase().equals("gerrit");
}
#method_after
private static boolean isGerrit(URIish uri) {
    String scheme = uri.getScheme();
    return scheme != null && scheme.toLowerCase().equals("gerrit+ssh");
}
#end_block

#method_before
private void post(final String url, final ProjectEvent projectEvent) {
    executor.execute(new Runnable() {

        @Override
        public void run() {
            String serializedEvent = new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).create().toJson(projectEvent);
            try {
                session.post(url, serializedEvent);
            } catch (IOException e) {
                log.error("Coulnd't post event: " + projectEvent, e);
            }
        }
    });
}
#method_after
private void post(final String url, final ProjectEvent projectEvent) {
    executor.execute(new Runnable() {

        @Override
        public void run() {
            String serializedEvent = gson.toJson(projectEvent);
            try {
                session.post(url, serializedEvent);
            } catch (IOException e) {
                log.error("Coulnd't post event: " + projectEvent, e);
            }
        }

        @Override
        public String toString() {
            return String.format("%s:%s > %s", projectEvent.type, projectEvent.getProjectNameKey().get(), url);
        }
    });
}
#end_block

#method_before
private String parseResponse(HttpResponse response) {
    HttpEntity entity = response.getEntity();
    String asString = "";
    if (entity != null) {
        try {
            asString = EntityUtils.toString(entity);
        } catch (IOException e) {
            log.error("Error parsing entity", e);
        }
    }
    return asString;
}
#method_after
private String parseResponse(HttpResponse response) {
    HttpEntity entity = response.getEntity();
    if (entity != null) {
        try {
            return EntityUtils.toString(entity);
        } catch (IOException e) {
            log.error("Error parsing entity", e);
        }
    }
    return "";
}
#end_block

#method_before
HttpResult post(String endpoint, String content) throws IOException {
    PeerInfo info = getPeerInfo();
    HttpPost post = new HttpPost(info.getDirectUrl() + endpoint);
    if (!Strings.isNullOrEmpty(content)) {
        post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
        post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    }
    return httpClient.execute(post, new HttpResponseHandler());
}
#method_after
HttpResult post(String endpoint, String content) throws IOException {
    HttpPost post = new HttpPost(getPeerInfo().getDirectUrl() + endpoint);
    if (!Strings.isNullOrEmpty(content)) {
        post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
        post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    }
    return httpClient.execute(post, new HttpResponseHandler());
}
#end_block

#method_before
HttpResult delete(String endpoint) throws IOException {
    PeerInfo info = getPeerInfo();
    return httpClient.execute(new HttpDelete(info.getDirectUrl() + endpoint), new HttpResponseHandler());
}
#method_after
HttpResult delete(String endpoint) throws IOException {
    return httpClient.execute(new HttpDelete(getPeerInfo().getDirectUrl() + endpoint), new HttpResponseHandler());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    cfg = mock(Configuration.class);
    when(cfg.getUser()).thenReturn("user");
    when(cfg.getPassword()).thenReturn("pass");
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(cfg.getConnectionTimeout()).thenReturn(TIMEOUT);
    when(cfg.getSocketTimeout()).thenReturn(TIMEOUT);
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    PeerInfo peerInfo = mock(PeerInfo.class);
    when(peerInfo.getDirectUrl()).thenReturn(url);
    httpSession = new HttpSession(new HttpClientProvider(cfg).get(), Providers.of(Optional.of(peerInfo)));
    wireMockRule.resetRequests();
}
#method_after
@Before
public void setUp() throws Exception {
    String url = "http://localhost:" + wireMockRule.port();
    cfg = mock(Configuration.class);
    when(cfg.getUser()).thenReturn("user");
    when(cfg.getPassword()).thenReturn("pass");
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(cfg.getConnectionTimeout()).thenReturn(TIMEOUT);
    when(cfg.getSocketTimeout()).thenReturn(TIMEOUT);
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    PeerInfo peerInfo = mock(PeerInfo.class);
    when(peerInfo.getDirectUrl()).thenReturn(url);
    httpSession = new HttpSession(new HttpClientProvider(cfg).get(), Providers.of(Optional.of(peerInfo)));
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            e.addRef(ref);
            scheduleTask(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            e.addRef(ref);
            postReplicationScheduledEvent(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    schedule(project, ref, uri, state, false);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            e.addRef(ref);
            scheduleTask(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            e.addRef(ref);
            postReplicationScheduledEvent(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state, boolean now) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            pool.schedule(e, now ? 0 : config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    scheduleTask(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                    pushOp.setToRetry();
                    postReplicationFailedEvent(pushOp, REJECTED_OTHER_REASON);
                    scheduleTask(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
                case REPOSITORY_MISSING:
                    pushOp.setToRetry();
                    postReplicationFailedEvent(pushOp, NON_EXISTING);
                    scheduleTask(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
                default:
                    pushOp.setToRetry();
                    scheduleTask(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON;
                    postReplicationFailedEvent(pushOp, status);
                    if (pushOp.setToRetry()) {
                        postReplicationScheduledEvent(pushOp);
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private void postReplicationScheduledEvent(PushOne pushOp, String inputRef) {
    Set<String> refs = inputRef == null ? pushOp.getRefs() : ImmutableSet.of(inputRef);
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : refs) {
        ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
        eventDispatcher.postEvent(new Branch.NameKey(project, ref), event);
    }
}
#method_after
private void postReplicationScheduledEvent(PushOne pushOp, String inputRef) {
    Set<String> refs = inputRef == null ? pushOp.getRefs() : ImmutableSet.of(inputRef);
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : refs) {
        ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
        eventDispatcher.get().postEvent(new Branch.NameKey(project, ref), event);
    }
}
#end_block

#method_before
private void postReplicationFailedEvent(PushOne pushOp, RemoteRefUpdate.Status status) {
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : pushOp.getRefs()) {
        RefReplicatedEvent event = new RefReplicatedEvent(project.get(), ref, targetNode, RefPushResult.FAILED, status);
        eventDispatcher.postEvent(new Branch.NameKey(project, ref), event);
    }
}
#method_after
private void postReplicationFailedEvent(PushOne pushOp, RemoteRefUpdate.Status status) {
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : pushOp.getRefs()) {
        RefReplicatedEvent event = new RefReplicatedEvent(project.get(), ref, targetNode, RefPushResult.FAILED, status);
        eventDispatcher.get().postEvent(new Branch.NameKey(project, ref), event);
    }
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            commentsUtil.publish(ctx, psId, drafts.values(), in.tag);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            commentsUtil.publish(ctx, psId, drafts.values(), in.tag);
            comments.addAll(drafts.values());
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException {
    String reviewer = input.reviewer;
    ReviewerState state = input.state();
    NotifyHandling notify = input.notify;
    ListMultimap<RecipientType, Account.Id> accountsToNotify = null;
    try {
        accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    } catch (BadRequestException e) {
        return fail(reviewer, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail();
    Addition byAccountId = addByAccountId(reviewer, rsrc, state, notify, accountsToNotify, allowGroup, allowByEmail);
    if (byAccountId != null) {
        return byAccountId;
    }
    Addition wholeGroup = addWholeGroup(reviewer, rsrc, state, notify, accountsToNotify, confirmed, allowGroup, allowByEmail);
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(reviewer, rsrc, state, notify, accountsToNotify);
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException {
    String reviewer = input.reviewer;
    ReviewerState state = input.state();
    NotifyHandling notify = input.notify;
    ListMultimap<RecipientType, Account.Id> accountsToNotify = null;
    try {
        accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    } catch (BadRequestException e) {
        return fail(reviewer, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail();
    Addition byAccountId = addByAccountId(reviewer, rsrc, state, notify, accountsToNotify, allowGroup, allowByEmail);
    if (byAccountId != null) {
        return byAccountId;
    }
    Addition wholeGroup = addWholeGroup(reviewer, rsrc, state, notify, accountsToNotify, confirmed, allowGroup, allowByEmail);
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(reviewer, rsrc, state, notify, accountsToNotify);
}
#end_block

#method_before
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), null, CC, NotifyHandling.NONE, ImmutableListMultimap.of());
}
#method_after
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableSet.of(user.getAccountId()), null, CC, NotifyHandling.NONE, ImmutableListMultimap.of());
}
#end_block

#method_before
@Nullable
private Addition addByAccountId(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean allowGroup, boolean allowByEmail) throws OrmException {
    Account.Id accountId = null;
    try {
        accountId = accounts.parse(reviewer).getAccountId();
    } catch (UnprocessableEntityException | AuthException e) {
        // AuthException won't occur since the user is authenticated at this point.
        if (!allowGroup && !allowByEmail) {
            // Only return failure if we aren't going to try other interpretations.
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, reviewer));
        }
    }
    if (accountId == null) {
        return null;
    }
    ReviewerResource rrsrc = reviewerFactory.create(rsrc, accountId);
    Account member = rrsrc.getReviewerUser().getAccount();
    ChangeControl control = rrsrc.getReviewerControl();
    if (isValidReviewer(member, control)) {
        return new Addition(reviewer, rsrc, ImmutableMap.of(member.getId(), control), null, state, notify, accountsToNotify);
    }
    if (!member.isActive()) {
        if (allowByEmail && state == CC) {
            return null;
        }
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerInactive, reviewer));
    }
    return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, reviewer));
}
#method_after
@Nullable
private Addition addByAccountId(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean allowGroup, boolean allowByEmail) throws OrmException, PermissionBackendException {
    Account.Id accountId = null;
    try {
        accountId = accounts.parse(reviewer).getAccountId();
    } catch (UnprocessableEntityException | AuthException e) {
        // AuthException won't occur since the user is authenticated at this point.
        if (!allowGroup && !allowByEmail) {
            // Only return failure if we aren't going to try other interpretations.
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, reviewer));
        }
        return null;
    }
    ReviewerResource rrsrc = reviewerFactory.create(rsrc, accountId);
    Account member = rrsrc.getReviewerUser().getAccount();
    PermissionBackend.ForRef perm = permissionBackend.user(rrsrc.getReviewerUser()).ref(rrsrc.getChange().getDest());
    if (isValidReviewer(member, perm)) {
        return new Addition(reviewer, rsrc, ImmutableSet.of(member.getId()), null, state, notify, accountsToNotify);
    }
    if (!member.isActive()) {
        if (allowByEmail && state == CC) {
            return null;
        }
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerInactive, reviewer));
    }
    return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, reviewer));
}
#end_block

#method_before
@Nullable
private Addition addWholeGroup(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean confirmed, boolean allowGroup, boolean allowByEmail) throws OrmException, IOException {
    if (!allowGroup) {
        return null;
    }
    GroupDescription.Basic group = null;
    try {
        group = groupsCollection.parseInternal(reviewer);
    } catch (UnprocessableEntityException e) {
        if (!allowByEmail) {
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, reviewer));
        }
    }
    if (group == null) {
        return null;
    }
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, group.getName()));
    } catch (NoSuchProjectException e) {
        return fail(reviewer, e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(reviewer, rsrc, reviewers, null, state, notify, accountsToNotify);
}
#method_after
@Nullable
private Addition addWholeGroup(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean confirmed, boolean allowGroup, boolean allowByEmail) throws OrmException, IOException, PermissionBackendException {
    if (!allowGroup) {
        return null;
    }
    GroupDescription.Basic group = null;
    try {
        group = groupsCollection.parseInternal(reviewer);
    } catch (UnprocessableEntityException e) {
        if (!allowByEmail) {
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, reviewer));
        }
        return null;
    }
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Set<Account.Id> reviewers = new HashSet<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, group.getName()));
    } catch (NoSuchProjectException e) {
        return fail(reviewer, e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    PermissionBackend.ForRef perm = permissionBackend.user(rsrc.getUser()).ref(rsrc.getChange().getDest());
    for (Account member : members) {
        if (isValidReviewer(member, perm)) {
            reviewers.add(member.getId());
        }
    }
    return new Addition(reviewer, rsrc, reviewers, null, state, notify, accountsToNotify);
}
#end_block

#method_before
@Nullable
private Addition addByEmail(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws OrmException {
    if (!rsrc.getControl().forUser(anonymousProvider.get()).isVisible(dbProvider.get())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, reviewer));
    }
    if (!migration.readChanges()) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, reviewer));
    }
    Address adr = Address.tryParse(reviewer);
    if (adr == null || !OutgoingEmailValidator.isValid(adr.getEmail())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerInvalid, reviewer));
    }
    return new Addition(reviewer, rsrc, null, ImmutableList.of(adr), state, notify, accountsToNotify);
}
#method_after
@Nullable
private Addition addByEmail(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws OrmException {
    if (!rsrc.getControl().forUser(anonymousProvider.get()).isVisible(dbProvider.get())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, reviewer));
    }
    if (!migration.readChanges()) {
        // addByEmail depends on NoteDb.
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, reviewer));
    }
    Address adr = Address.tryParse(reviewer);
    if (adr == null || !validator.isValid(adr.getEmail())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerInvalid, reviewer));
    }
    return new Addition(reviewer, rsrc, null, ImmutableList.of(adr), state, notify, accountsToNotify);
}
#end_block

#method_before
private boolean isValidReviewer(Account member, ChangeControl control) {
    if (member.isActive()) {
        IdentifiedUser user = identifiedUserFactory.create(member.getId());
        // reviewer see a draft.
        return control.forUser(user).isRefVisible();
    }
    return false;
}
#method_after
private boolean isValidReviewer(Account member, PermissionBackend.ForRef perm) throws PermissionBackendException {
    if (member.isActive()) {
        IdentifiedUser user = identifiedUserFactory.create(member.getId());
        // reviewer see a draft.
        try {
            perm.user(user).check(RefPermission.READ);
            return true;
        } catch (AuthException e) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
void gatherResults() throws OrmException, PermissionBackendException {
    // Generate result details and fill AccountLoader. This occurs outside
    // the Op because the accounts are in a different table.
    PostReviewersOp.Result opResult = op.getResult();
    if (migration.readChanges() && state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(opResult.addedCCs().size());
        for (Account.Id accountId : opResult.addedCCs()) {
            ChangeControl ctl = reviewers.get(accountId);
            PermissionBackend.ForChange perm = permissionBackend.user(ctl.getUser()).database(dbProvider).change(ctl.getNotes());
            result.ccs.add(json.format(new ReviewerInfo(accountId.get()), perm, ctl));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(opResult.addedReviewers().size());
        for (PatchSetApproval psa : opResult.addedReviewers()) {
            // New reviewers have value 0, don't bother normalizing.
            ChangeControl ctl = reviewers.get(psa.getAccountId());
            PermissionBackend.ForChange perm = permissionBackend.user(ctl.getUser()).database(dbProvider).change(ctl.getNotes());
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), perm, ctl, ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#method_after
void gatherResults() throws OrmException, PermissionBackendException {
    if (notes == null || caller == null) {
        // in the contained AddReviewerResult.
        return;
    }
    ChangeData cd = changeDataFactory.create(dbProvider.get(), notes);
    PermissionBackend.ForChange perm = permissionBackend.user(caller).database(dbProvider).change(cd);
    // Generate result details and fill AccountLoader. This occurs outside
    // the Op because the accounts are in a different table.
    PostReviewersOp.Result opResult = op.getResult();
    if (migration.readChanges() && state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(opResult.addedCCs().size());
        for (Account.Id accountId : opResult.addedCCs()) {
            IdentifiedUser u = identifiedUserFactory.create(accountId);
            result.ccs.add(json.format(new ReviewerInfo(accountId.get()), perm.user(u), cd));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(opResult.addedReviewers().size());
        for (PatchSetApproval psa : opResult.addedReviewers()) {
            // New reviewers have value 0, don't bother normalizing.
            IdentifiedUser u = identifiedUserFactory.create(psa.getAccountId());
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), perm.user(u), cd, ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#end_block

#method_before
@Override
public void start() {
    try {
        for (IndexDefinition<?, ?, ?> def : defs.values()) {
            initIndex(def);
        }
    } catch (IOException e) {
        fail(e);
    }
}
#method_after
@Override
public void start() {
    try {
        for (IndexDefinition<?, ?, ?> def : defs.values()) {
            initIndex(def);
        }
    } catch (IOException e) {
        ProvisionException ex = new ProvisionException("Error scanning indexes");
        ex.initCause(e);
        throw ex;
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def) throws IOException {
    TreeMap<Integer, Version<V>> versions = scanVersions(def);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    int latest = write.get(0).version;
    OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#method_after
private <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def) throws IOException {
    TreeMap<Integer, Version<V>> versions = scanVersions(def);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindexMsg);
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(factory.create(v.schema));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, latest);
            reindexers.put(def.getName(), reindexer);
            if (onlineUpgrade && latest != search.version) {
                reindexer.start();
            }
        }
    }
}
#end_block

#method_before
public synchronized boolean startReindexer(String name, boolean force) throws ReindexerAlreadyRunningException {
    OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name);
    validateReindexerNotRunning(reindexer);
    if (force || !isCurrentIndexVersionLatest(name, reindexer)) {
        reindexer.start();
        return true;
    }
    return false;
}
#method_after
public synchronized boolean startReindexer(String name, boolean force) throws ReindexerAlreadyRunningException {
    OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name);
    validateReindexerNotRunning(reindexer);
    if (force || !isLatestIndexVersion(name, reindexer)) {
        reindexer.start();
        return true;
    }
    return false;
}
#end_block

#method_before
public synchronized boolean activateLatestIndex(String name) throws ReindexerAlreadyRunningException {
    OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name);
    validateReindexerNotRunning(reindexer);
    if (!isCurrentIndexVersionLatest(name, reindexer)) {
        reindexer.activateIndex();
        return true;
    }
    return false;
}
#method_after
public synchronized boolean activateLatestIndex(String name) throws ReindexerAlreadyRunningException {
    OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name);
    validateReindexerNotRunning(reindexer);
    if (!isLatestIndexVersion(name, reindexer)) {
        reindexer.activateIndex();
        return true;
    }
    return false;
}
#end_block

#method_before
@Test
public void testRetryOnErrorThenSuccess() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), any())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(true, "Success"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isTrue();
}
#method_after
@Test
public void testRetryOnErrorThenSuccess() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), anyString())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(true, "Success"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isTrue();
}
#end_block

#method_before
@Test
public void testFailureAfterMaxTries() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), any())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isFalse();
}
#method_after
@Test
public void testFailureAfterMaxTries() throws IOException {
    Configuration cfg = mock(Configuration.class);
    when(cfg.getMaxTries()).thenReturn(3);
    when(cfg.getRetryInterval()).thenReturn(10);
    HttpSession httpSession = mock(HttpSession.class);
    when(httpSession.post(anyString(), anyString())).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error")).thenReturn(new HttpResult(false, "Error"));
    RestForwarder forwarder = new RestForwarder(httpSession, PLUGIN_NAME, cfg);
    assertThat(forwarder.evict(Constants.PROJECT_LIST, new Object())).isFalse();
}
#end_block

#method_before
public boolean isRecoverable() {
    return isRecoverable;
}
#method_after
boolean isRecoverable() {
    return isRecoverable;
}
#end_block

#method_before
private String buildIndexEndpoint(int changeId) {
    return Joiner.on("/").join(pluginRelativePath, "index", changeId);
}
#method_after
private String buildIndexEndpoint(int changeId) {
    return Joiner.on("/").join(pluginRelativePath, "index/change", changeId);
}
#end_block

#method_before
boolean execute() {
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            return true;
        } catch (ForwardingException e) {
            if (!e.isRecoverable()) {
                log.error("Failed to " + name, e);
                return false;
            }
            if (execCnt >= cfg.getMaxTries()) {
                log.error("Failed to " + name + ", after " + cfg.getMaxTries() + " tries");
                return false;
            }
            logRetry(e);
            try {
                Thread.sleep(cfg.getRetryInterval());
            } catch (InterruptedException ie) {
                log.error(name + " was interrupted, giving up", ie);
            }
        }
    }
}
#method_after
boolean execute() {
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            return true;
        } catch (ForwardingException e) {
            if (!e.isRecoverable()) {
                log.error("Failed to {}", name, e);
                return false;
            }
            if (execCnt >= cfg.getMaxTries()) {
                log.error("Failed to {}, after {} tries", name, cfg.getMaxTries());
                return false;
            }
            logRetry(e);
            try {
                Thread.sleep(cfg.getRetryInterval());
            } catch (InterruptedException ie) {
                log.error("{} was interrupted, giving up", name, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#end_block

#method_before
void tryOnce() throws ForwardingException {
    try {
        HttpResult result = send();
        if (!result.isSuccessful()) {
            log.error("Unable to " + name + ": " + result.getMessage());
            throw new ForwardingException(true, "Unable to " + name + ": " + result.getMessage());
        }
    } catch (IOException e) {
        log.error("Error trying to {}", name, e);
        throw new ForwardingException(isRecoverable(e), e.getMessage());
    }
}
#method_after
void tryOnce() throws ForwardingException {
    try {
        HttpResult result = send();
        if (!result.isSuccessful()) {
            throw new ForwardingException(true, "Unable to " + name + ": " + result.getMessage());
        }
    } catch (IOException e) {
        throw new ForwardingException(isRecoverable(e), e.getMessage(), e);
    }
}
#end_block

#method_before
void logRetry(Throwable cause) {
    if (log.isDebugEnabled()) {
        log.debug("Retrying to " + name + " causeed by '" + cause + "'");
    }
}
#method_after
void logRetry(Throwable cause) {
    if (log.isDebugEnabled()) {
        log.debug("Retrying to {} caused by '{}'", name, cause);
    }
}
#end_block

