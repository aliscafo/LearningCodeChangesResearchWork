163
#method_before
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    DiskImage diskFromDb = createDiskImage();
    diskFromDb.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(diskFromDb);
    initializeCommand(parameters);
    command.executeVmCommand();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#method_after
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    command.executeVmCommand();
    assertFalse(command.shouldUpdateReadOnly());
    verify(command, atLeast(1)).shouldUpdateReadOnly();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    return result;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((brickOrder == null) ? 0 : brickOrder.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((brickOrder == null) ? 0 : brickOrder.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    return result;
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    // pinned, allow to select all hosts.
    if (vm.getRunOnVds() == null && vm.getDedicatedVmForVds() == null) {
        return hosts;
    }
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.toString());
        return new ArrayList<>();
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        // host has been specified for pin to host.
        if (vm.getDedicatedVmForVds() != null) {
            for (VDS host : hosts) {
                if (host.getId().equals(vm.getDedicatedVmForVds())) {
                    return Arrays.asList(host);
                }
            }
        } else {
            // check pin to any (the VM should be down/ no migration allowed).
            if (vm.getRunOnVds() == null) {
                return hosts;
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            // _vds = loadVDS(_vds.getId());
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void reloadVds(VDS vds) {
    DbFacade.getInstance().getVdsDao().reloadVDS(vds);
}
#method_after
private void reloadVds(VDS vds) {
    DbFacade.getInstance().getVdsDao().reloadPartial(vds);
}
#end_block

#method_before
private boolean devicePluggable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getDevice()) && VmDeviceGeneralType.DISK == device.getType()) || (VmDeviceType.BRIDGE.getName().equals(device.getDevice()) && VmDeviceGeneralType.INTERFACE == device.getType());
}
#method_after
private boolean devicePluggable(VmDevice device) {
    return VmDeviceCommonUtils.isDisk(device) || VmDeviceCommonUtils.isBridge(device);
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getStatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#end_block

#method_before
@Override
public VDS getPartial(Guid vdsId) {
    VDS vdsPartial = new VDS();
    // TODO: From cache
    vdsPartial.setStaticData(DbFacade.getInstance().getVdsStaticDao().get(vdsId));
    vdsPartial.setDynamicData(DbFacade.getInstance().getVdsDynamicDao().get(vdsId));
    // vdsPartial.setStatisticsData(DbFacade.getInstance().getVdsStatisticsDao().get(vdsId));
    // TODO: From cache
    VDSGroup group = DbFacade.getInstance().getVdsGroupDao().get(vdsPartial.getVdsGroupId());
    vdsPartial.setVdsGroupCompatibilityVersion(group.getcompatibility_version());
    vdsPartial.setVdsGroupCpuName(group.getcpu_name());
    vdsPartial.setVdsGroupDescription(group.getdescription());
    vdsPartial.setVdsGroupName(group.getName());
    vdsPartial.setStoragePoolId(group.getStoragePoolId());
    vdsPartial.setStoragePoolName(group.getStoragePoolName());
    vdsPartial.setMaxVdsMemoryOverCommit(group.getmax_vds_memory_over_commit());
    return vdsPartial;
}
#method_after
@Override
public VDS getPartial(Guid vdsId) {
    VDS vdsPartial = new VDS();
    // TODO: From cache
    vdsPartial.setStaticData(DbFacade.getInstance().getVdsStaticDao().get(vdsId));
    vdsPartial.setDynamicData(DbFacade.getInstance().getVdsDynamicDao().get(vdsId));
    // TODO: From cache
    VDSGroup group = DbFacade.getInstance().getVdsGroupDao().get(vdsPartial.getVdsGroupId());
    vdsPartial.setVdsGroupCompatibilityVersion(group.getcompatibility_version());
    vdsPartial.setVdsGroupCpuName(group.getcpu_name());
    vdsPartial.setVdsGroupDescription(group.getdescription());
    vdsPartial.setVdsGroupName(group.getName());
    vdsPartial.setStoragePoolId(group.getStoragePoolId());
    vdsPartial.setStoragePoolName(group.getStoragePoolName());
    vdsPartial.setMaxVdsMemoryOverCommit(group.getmax_vds_memory_over_commit());
    return vdsPartial;
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().getPartial(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().getPartial(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
                if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds, false);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                if (log.isDebugEnabled()) {
                    log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                }
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
                returnStatus = vds.getStatus();
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds, false);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                if (log.isDebugEnabled()) {
                    log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                }
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
                returnStatus = vds.getStatus();
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getStatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#end_block

#method_before
public static void updateDisksFromDb(VM vm) {
    List<Disk> imageList = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    vm.getDiskList().clear();
    vm.getDiskMap().clear();
    updateDisksForVm(vm, imageList);
}
#method_after
public static void updateDisksFromDb(VM vm) {
    List<Disk> imageList = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    vm.clearDisks();
    updateDisksForVm(vm, imageList);
}
#end_block

#method_before
public static void updateDisksForVm(VM vm, List<? extends Disk> diskList) {
    for (Disk disk : diskList) {
        if (disk.isAllowSnapshot()) {
            DiskImage image = (DiskImage) disk;
            if (image.getActive() != null && image.getActive()) {
                vm.getDiskMap().put(image.getId(), image);
                vm.getDiskList().add(image);
            }
        } else {
            vm.getDiskMap().put(disk.getId(), disk);
        }
    }
}
#method_after
public static void updateDisksForVm(VM vm, Collection<? extends Disk> disks) {
    for (Disk disk : disks) {
        if (disk.isAllowSnapshot() && !disk.isDiskSnapshot()) {
            DiskImage image = (DiskImage) disk;
            vm.getDiskMap().put(image.getId(), image);
            vm.getDiskList().add(image);
        } else {
            vm.getDiskMap().put(disk.getId(), disk);
        }
    }
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
@JsonIgnore
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
@Override
public HandlerRegistration addValueChangeHandler(ValueChangeHandler handler) {
    return asRadioButton().addValueChangeHandler(handler);
}
#method_after
@Override
public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler) {
    return asRadioButton().addValueChangeHandler(handler);
}
#end_block

#method_before
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            NetworkQoS none = new NetworkQoS();
            none.setName(ConstantsManager.getInstance().getConstants().unlimitedQoSTitle());
            none.setId(Guid.Empty);
            networkQoSes.add(0, none);
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#method_after
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            networkQoSes.add(0, getEmptyQos());
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#end_block

#method_before
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    setSelectedNetworkQoSId(Guid.Empty);
}
#method_after
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    getNetworkQoS().setSelectedItem(getEmptyQos());
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        VdcQueryReturnValue vdcQueryReturnValue = runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(new org.ovirt.engine.core.compat.Version(asString(v))));
        for (ServerCpu sc : (List<ServerCpu>) vdcQueryReturnValue.getReturnValue()) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
@Ignore
@Test
public void testList() throws Exception {
    HashSet<org.ovirt.engine.core.compat.Version> supportedVersions = new HashSet<org.ovirt.engine.core.compat.Version>();
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(1, 5));
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(10, 3));
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.SupportedClusterLevels }, supportedVersions);
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.PredefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.UserDefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.PredefinedVMProperties }, "foo=true|false");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.UserDefinedVMProperties }, "bar=[a-z]");
    verifyCapabilities(resource.list());
}
#method_after
@Ignore
@Test
public void testList() throws Exception {
    HashSet<org.ovirt.engine.core.compat.Version> supportedVersions = new HashSet<org.ovirt.engine.core.compat.Version>();
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(1, 5));
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(10, 3));
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.SupportedClusterLevels }, supportedVersions);
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.PredefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.UserDefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.PredefinedVMProperties }, "foo=true|false");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.UserDefinedVMProperties }, "bar=[a-z]");
    setUpGetEntityExpectations(VdcQueryType.GetAllServerCpuList, GetAllServerCpuListParameters.class, new String[] { "Version" }, new Object[] { "3.3" }, "bar=[a-z]");
    verifyCapabilities(resource.list());
}
#end_block

#method_before
private void _threadMain() {
    try {
        boolean terminate = false;
        while (!terminate) {
            Event.Base bevent = _parser.nextEvent();
            log.debugFormat("Installation of {0}: Event {1}", _vds.getHostName(), bevent);
            if (bevent instanceof Event.Terminate) {
                terminate = true;
            } else if (bevent instanceof Event.Log) {
                Event.Log event = (Event.Log) bevent;
                InstallerMessages.Severity severity;
                switch(event.severity) {
                    case INFO:
                        severity = InstallerMessages.Severity.INFO;
                        break;
                    case WARNING:
                        severity = InstallerMessages.Severity.WARNING;
                        break;
                    default:
                        severity = InstallerMessages.Severity.ERROR;
                        break;
                }
                _messages.post(severity, event.record);
            } else if (bevent instanceof Event.Confirm) {
                Event.Confirm event = (Event.Confirm) bevent;
                if (Confirms.GPG_KEY.equals(event.what)) {
                    _messages.post(InstallerMessages.Severity.WARNING, event.description);
                    event.reply = true;
                } else if (org.ovirt.ovirt_host_deploy.constants.Confirms.DEPLOY_PROCEED.equals(event.what)) {
                    event.reply = true;
                } else {
                    log.warnFormat("Installation of {0}: Not confirming {1}: ${2}", _vds.getHostName(), event.what, event.description);
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryString) {
                Event.QueryString event = (Event.QueryString) bevent;
                if (Queries.CUSTOMIZATION_COMMAND.equals(event.name)) {
                    _nextCustomizationEntry();
                } else if (Queries.TERMINATION_COMMAND.equals(event.name)) {
                    _nextTerminationEntry();
                } else {
                    throw new Exception(String.format("Unexpected query %1$s", event));
                }
            } else if (bevent instanceof Event.QueryValue) {
                Event.QueryValue event = (Event.QueryValue) bevent;
                if (Queries.TIME.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Setting time");
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmssZ");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    event.value = format.format(Calendar.getInstance().getTime());
                } else {
                    event.abort = true;
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryMultiString) {
                Event.QueryMultiString event = (Event.QueryMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Queries.CERTIFICATE_CHAIN.equals(event.name)) {
                    event.value = (_pkiResources.getAsString(PKIResources.Resource.CACertificate, PKIResources.OutputType.X509_PEM) + _certificate).split("\n");
                    _parser.sendResponse(event);
                } else {
                    event.abort = true;
                    _parser.sendResponse(event);
                }
            } else if (bevent instanceof Event.DisplayMultiString) {
                Event.DisplayMultiString event = (Event.DisplayMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Displays.CERTIFICATE_REQUEST.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Enrolling certificate");
                    _certificate = OpenSslCAWrapper.signCertificateRequest(StringUtils.join(event.value, "\n"), _vds.getHostName());
                }
            } else {
                throw new SoftError(String.format("Unexpected event '%1$s'", bevent));
            }
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during deploy dialog", e);
        _control.disconnect();
    }
}
#method_after
private void _threadMain() {
    try {
        boolean terminate = false;
        while (!terminate) {
            Event.Base bevent = _parser.nextEvent();
            log.debugFormat("Installation of {0}: Event {1}", _vds.getHostName(), bevent);
            if (bevent instanceof Event.Terminate) {
                terminate = true;
            } else if (bevent instanceof Event.Log) {
                Event.Log event = (Event.Log) bevent;
                InstallerMessages.Severity severity;
                switch(event.severity) {
                    case INFO:
                        severity = InstallerMessages.Severity.INFO;
                        break;
                    case WARNING:
                        severity = InstallerMessages.Severity.WARNING;
                        break;
                    default:
                        severity = InstallerMessages.Severity.ERROR;
                        break;
                }
                _messages.post(severity, event.record);
            } else if (bevent instanceof Event.Confirm) {
                Event.Confirm event = (Event.Confirm) bevent;
                if (Confirms.GPG_KEY.equals(event.what)) {
                    _messages.post(InstallerMessages.Severity.WARNING, event.description);
                    event.reply = true;
                } else if (org.ovirt.ovirt_host_deploy.constants.Confirms.DEPLOY_PROCEED.equals(event.what)) {
                    event.reply = true;
                } else {
                    log.warnFormat("Installation of {0}: Not confirming {1}: ${2}", _vds.getHostName(), event.what, event.description);
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryString) {
                Event.QueryString event = (Event.QueryString) bevent;
                if (Queries.CUSTOMIZATION_COMMAND.equals(event.name)) {
                    _nextCustomizationEntry();
                } else if (Queries.TERMINATION_COMMAND.equals(event.name)) {
                    _nextTerminationEntry();
                } else {
                    throw new Exception(String.format("Unexpected query %1$s", event));
                }
            } else if (bevent instanceof Event.QueryValue) {
                Event.QueryValue event = (Event.QueryValue) bevent;
                if (Queries.TIME.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Setting time");
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmssZ");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    event.value = format.format(Calendar.getInstance().getTime());
                } else {
                    event.abort = true;
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryMultiString) {
                Event.QueryMultiString event = (Event.QueryMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Queries.CERTIFICATE_CHAIN.equals(event.name)) {
                    event.value = (_pkiResources.getAsString(PKIResources.Resource.CACertificate, PKIResources.OutputType.X509_PEM) + _certificate).split("\n");
                    _parser.sendResponse(event);
                } else {
                    event.abort = true;
                    _parser.sendResponse(event);
                }
            } else if (bevent instanceof Event.DisplayMultiString) {
                Event.DisplayMultiString event = (Event.DisplayMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Displays.CERTIFICATE_REQUEST.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Enrolling certificate");
                    _certificate = OpenSslCAWrapper.signCertificateRequest(StringUtils.join(event.value, "\n"), _vds.getHostName());
                }
            } else {
                throw new SoftError(String.format("Unexpected event '%1$s'", bevent));
            }
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during deploy dialog", e);
        try {
            _control.close();
        } catch (IOException ee) {
            log.error("Error during close", e);
        }
    }
}
#end_block

#method_before
@Override
protected void finalize() {
    close();
}
#method_after
@Override
protected void finalize() {
    try {
        close();
    } catch (IOException e) {
        log.error("Exception during finalize", e);
    }
}
#end_block

#method_before
public void close() {
    stop();
    if (_dialog != null) {
        _dialog.disconnect();
        _dialog = null;
    }
}
#method_after
public void close() throws IOException {
    stop();
    if (_dialog != null) {
        _dialog.close();
        _dialog = null;
    }
}
#end_block

#method_before
public void execute() throws Exception {
    InputStream in = null;
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>GetValue(ConfigValues.BootstrapCommand);
        // in future we should set here LANG, LC_ALL
        command = command.replace(BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.infoFormat("Installation of {0}. Executing command via SSH {1} < {2}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        in = new FileInputStream(s_deployPackage.getFile());
        _dialog.executeCommand(this, command, new InputStream[] { in });
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        } else if (_goingToReboot) {
            _deployStatus = DeployStatus.Reboot;
        } else if (_installIncomplete) {
            _deployStatus = DeployStatus.Incomplete;
        } else {
            _deployStatus = DeployStatus.Complete;
        }
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during host {0} install", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during host {0} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            _messages.post(InstallerMessages.Severity.ERROR, e.getMessage());
            log.errorFormat("Error during host {0} install, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close deploy package", e);
            }
        }
    }
}
#method_after
public void execute() throws Exception {
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>GetValue(ConfigValues.BootstrapCommand);
        // in future we should set here LANG, LC_ALL
        command = command.replace(BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.infoFormat("Installation of {0}. Executing command via SSH {1} < {2}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        try (final InputStream in = new FileInputStream(s_deployPackage.getFile())) {
            _dialog.executeCommand(this, command, new InputStream[] { in });
        }
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        } else if (_goingToReboot) {
            _deployStatus = DeployStatus.Reboot;
        } else if (_installIncomplete) {
            _deployStatus = DeployStatus.Incomplete;
        } else {
            _deployStatus = DeployStatus.Complete;
        }
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during host {0} install", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during host {0} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            _messages.post(InstallerMessages.Severity.ERROR, e.getMessage());
            log.errorFormat("Error during host {0} install, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#end_block

#method_before
public static String signCertificateRequest(String request, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", hostname)));
        os.write(request.getBytes(Charset.forName("UTF-8")));
    } finally {
        if (os != null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(new File(config.getPKIDir(), "certs"), String.format("%s.cer", hostname)).getPath());
}
#method_after
public static String signCertificateRequest(String request, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    try (final OutputStream os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", hostname)))) {
        os.write(request.getBytes(Charset.forName("UTF-8")));
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(new File(config.getPKIDir(), "certs"), String.format("%s.cer", hostname)).getPath());
}
#end_block

#method_before
private boolean runCommandArray(String[] command_array, int signatureTimeout) {
    boolean returnValue = true;
    String outputString = null;
    String errorString = null;
    BufferedReader stdOutput = null;
    BufferedReader stdError = null;
    try {
        log.debug("Running Sign Certificate request script");
        Process process = getRuntime().exec(command_array);
        stdOutput = new BufferedReader(new InputStreamReader(process.getInputStream(), Charset.forName("UTF-8")));
        stdError = new BufferedReader(new InputStreamReader(process.getErrorStream(), Charset.forName("UTF-8")));
        int exitCode = 0;
        boolean completed = false;
        for (int x = 0; x < signatureTimeout; x++) {
            try {
                Thread.sleep(1000);
                exitCode = process.exitValue();
                completed = true;
                break;
            } catch (IllegalThreadStateException | InterruptedException e) {
            // keep going
            }
        }
        outputString += readAllLines(stdOutput);
        errorString += readAllLines(stdError);
        if (!completed) {
            process.destroy();
            returnValue = false;
            log.error("Sign Certificate request script killed due to timeout");
            logOutputAndErrors(outputString, errorString);
        } else if (exitCode != 0) {
            returnValue = false;
            log.error("Sign Certificate request failed with exit code " + exitCode);
            logOutputAndErrors(outputString, errorString);
        } else {
            log.debug("Successfully completed certificate signing script");
        }
    } catch (IOException e) {
        log.error("Exception signing the certificate", e);
        logOutputAndErrors(outputString, errorString);
        returnValue = false;
    } finally {
        // Close the BufferedReaders
        try {
            if (stdOutput != null) {
                stdOutput.close();
            }
            if (stdError != null) {
                stdError.close();
            }
        } catch (IOException ex) {
            log.error("Unable to close BufferedReader");
        }
    }
    return returnValue;
}
#method_after
private boolean runCommandArray(String[] command_array, int signatureTimeout) {
    boolean returnValue = true;
    String outputString = null;
    String errorString = null;
    try {
        log.debug("Running Sign Certificate request script");
        Process process = getRuntime().exec(command_array);
        try (final BufferedReader stdOutput = new BufferedReader(new InputStreamReader(process.getInputStream(), Charset.forName("UTF-8")));
            final BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream(), Charset.forName("UTF-8")))) {
            int exitCode = 0;
            boolean completed = false;
            for (int x = 0; x < signatureTimeout; x++) {
                try {
                    Thread.sleep(1000);
                    exitCode = process.exitValue();
                    completed = true;
                    break;
                } catch (IllegalThreadStateException | InterruptedException e) {
                // keep going
                }
            }
            outputString = readAllLines(stdOutput);
            errorString = readAllLines(stdError);
            if (!completed) {
                process.destroy();
                returnValue = false;
                log.error("Sign Certificate request script killed due to timeout");
                logOutputAndErrors(outputString, errorString);
            } else if (exitCode != 0) {
                returnValue = false;
                log.error("Sign Certificate request failed with exit code " + exitCode);
                logOutputAndErrors(outputString, errorString);
            } else {
                log.debug("Successfully completed certificate signing script");
            }
        }
    } catch (IOException e) {
        log.error("Exception signing the certificate", e);
        logOutputAndErrors(outputString, errorString);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
public void close() throws IOException {
    try {
        if (_session != null) {
            _session.close(true);
            _session = null;
        }
        if (_client != null) {
            _client.stop();
            _client = null;
        }
    } catch (Exception e) {
        log.error("Failed to close session", e);
    }
}
#method_after
public void close() throws IOException {
    try {
        if (_session != null) {
            _session.close(true);
            _session = null;
        }
        if (_client != null) {
            _client.stop();
            _client = null;
        }
    } catch (Exception e) {
        log.error("Failed to close session", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
public void executeCommand(String command, InputStream in, OutputStream out, OutputStream err) throws Exception {
    log.debug(String.format("Executing: '%1$s'", command));
    if (in == null) {
        in = new ByteArrayInputStream(new byte[0]);
    }
    if (out == null) {
        out = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    if (err == null) {
        err = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    /*
         * Redirect streams into indexed streams.
         */
    ProgressInputStream iin = new ProgressInputStream(in);
    ProgressOutputStream iout = new ProgressOutputStream(out);
    ProgressOutputStream ierr = new ProgressOutputStream(err);
    ClientChannel channel = _session.createExecChannel(command);
    try {
        channel.setIn(iin);
        channel.setOut(iout);
        channel.setErr(ierr);
        channel.open();
        long hardEnd = 0;
        if (_hardTimeout != 0) {
            hardEnd = System.currentTimeMillis() + _hardTimeout;
        }
        boolean hardTimeout = false;
        int stat;
        boolean activity;
        do {
            stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EOF | ClientChannel.TIMEOUT), _softTimeout);
            hardTimeout = (hardEnd != 0 && System.currentTimeMillis() >= hardEnd);
            /*
                 * Notice that we should visit all
                 * so do not cascade statement.
                 */
            activity = iin.wasProgress();
            activity = iout.wasProgress() || activity;
            activity = ierr.wasProgress() || activity;
        } while (!hardTimeout && (stat & ClientChannel.TIMEOUT) != 0 && activity);
        if (hardTimeout) {
            throw new TimeLimitExceededException(String.format("SSH session hard timeout host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout host '%1$s'", this.getDisplayHost()));
        }
        stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EXIT_STATUS | ClientChannel.EXIT_SIGNAL | ClientChannel.TIMEOUT), _softTimeout);
        if ((stat & ClientChannel.EXIT_SIGNAL) != 0) {
            throw new IOException(String.format("Signal received during SSH session host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.EXIT_STATUS) != 0 && channel.getExitStatus() != 0) {
            throw new IOException(String.format("Command returned failure code %2$d during SSH session '%1$s'", this.getDisplayHost(), channel.getExitStatus()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout waiting for status host '%1$s'", this.getDisplayHost()));
        }
    } catch (RuntimeException e) {
        log.debug("Execute failed", e);
        throw e;
    } finally {
        int stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.TIMEOUT), 1);
        if ((stat & ClientChannel.CLOSED) != 0) {
            channel.close(true);
        }
    }
    log.debug(String.format("Executed: '%1$s'", command));
}
#method_after
public void executeCommand(String command, InputStream in, OutputStream out, OutputStream err) throws Exception {
    log.debug(String.format("Executing: '%1$s'", command));
    InputStream _xin = null;
    OutputStream _xout = null;
    OutputStream _xerr = null;
    if (in == null) {
        _xin = in = new ByteArrayInputStream(new byte[0]);
    }
    if (out == null) {
        _xout = out = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    if (err == null) {
        _xerr = err = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    /*
         * Redirect streams into indexed streams.
         */
    ClientChannel channel = null;
    try (final InputStream _xxin = _xin;
        final OutputStream _xxout = _xout;
        final OutputStream _xxerr = _xerr;
        final ProgressInputStream iin = new ProgressInputStream(in);
        final ProgressOutputStream iout = new ProgressOutputStream(out);
        final ProgressOutputStream ierr = new ProgressOutputStream(err)) {
        channel = _session.createExecChannel(command);
        channel.setIn(iin);
        channel.setOut(iout);
        channel.setErr(ierr);
        channel.open();
        long hardEnd = 0;
        if (_hardTimeout != 0) {
            hardEnd = System.currentTimeMillis() + _hardTimeout;
        }
        boolean hardTimeout = false;
        int stat;
        boolean activity;
        do {
            stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EOF | ClientChannel.TIMEOUT), _softTimeout);
            hardTimeout = (hardEnd != 0 && System.currentTimeMillis() >= hardEnd);
            /*
                 * Notice that we should visit all
                 * so do not cascade statement.
                 */
            activity = iin.wasProgress();
            activity = iout.wasProgress() || activity;
            activity = ierr.wasProgress() || activity;
        } while (!hardTimeout && (stat & ClientChannel.TIMEOUT) != 0 && activity);
        if (hardTimeout) {
            throw new TimeLimitExceededException(String.format("SSH session hard timeout host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout host '%1$s'", this.getDisplayHost()));
        }
        stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EXIT_STATUS | ClientChannel.EXIT_SIGNAL | ClientChannel.TIMEOUT), _softTimeout);
        if ((stat & ClientChannel.EXIT_SIGNAL) != 0) {
            throw new IOException(String.format("Signal received during SSH session host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.EXIT_STATUS) != 0 && channel.getExitStatus() != 0) {
            throw new IOException(String.format("Command returned failure code %2$d during SSH session '%1$s'", this.getDisplayHost(), channel.getExitStatus()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout waiting for status host '%1$s'", this.getDisplayHost()));
        }
    } catch (RuntimeException e) {
        log.debug("Execute failed", e);
        throw e;
    } finally {
        if (channel != null) {
            int stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.TIMEOUT), 1);
            if ((stat & ClientChannel.CLOSED) != 0) {
                channel.close(true);
            }
        }
    }
    log.debug(String.format("Executed: '%1$s'", command));
}
#end_block

#method_before
@Test
public void testProperties() {
    try (final SSHClient ssh = new SSHClient()) {
        assertEquals(ssh.getHost(), null);
        assertEquals(ssh.getPort(), 22);
        assertEquals(ssh.getUser(), null);
        assertEquals(ssh.getDisplayHost(), "N/A");
        ssh.setHost("host1");
        assertEquals(ssh.getHost(), "host1");
        assertEquals(ssh.getDisplayHost(), "host1");
        ssh.setHost("host1", 1234);
        assertEquals(ssh.getPort(), 1234);
        assertEquals(ssh.getDisplayHost(), "host1:1234");
        ssh.setUser("user1");
        assertEquals(ssh.getUser(), "user1");
        assertEquals(ssh.getDisplayHost(), "user1@host1:1234");
        ssh.setHost("host2");
        assertEquals(ssh.getDisplayHost(), "user1@host2");
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Test
public void testProperties() throws IOException {
    try (final SSHClient ssh = new SSHClient()) {
        assertEquals(ssh.getHost(), null);
        assertEquals(ssh.getPort(), 22);
        assertEquals(ssh.getUser(), null);
        assertEquals(ssh.getDisplayHost(), "N/A");
        ssh.setHost("host1");
        assertEquals(ssh.getHost(), "host1");
        assertEquals(ssh.getDisplayHost(), "host1");
        ssh.setHost("host1", 1234);
        assertEquals(ssh.getPort(), 1234);
        assertEquals(ssh.getDisplayHost(), "host1:1234");
        ssh.setUser("user1");
        assertEquals(ssh.getUser(), "user1");
        assertEquals(ssh.getDisplayHost(), "user1@host1:1234");
        ssh.setHost("host2");
        assertEquals(ssh.getDisplayHost(), "user1@host2");
    }
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    doReturn(null).when(storageDomainDAOMock).get(storageDomain.getId());
    doReturn(Collections.emptyList()).when(storageDomainDAOMock).getAllForStorageDomain(storageDomain.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    doReturn(null).when(storageDomainDAOMock).get(storageDomain.getId());
    doReturn(Collections.emptyList()).when(storageDomainDAOMock).getAllForStorageDomain(storageDomain.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction shouldn't be possible for a non-existent storage domain", command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerException
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerException
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction shouldn't be possible for a non-existent storage domain", command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(command, message);
}
#method_after
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    return runAndAssertCanDoActionFailure("", command, message);
}
#end_block

#method_before
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(command, message);
}
#method_after
public static List<String> runAndAssertCanDoActionFailure(String assertionMessage, CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(assertionMessage, command, message);
}
#end_block

#method_before
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#method_after
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    return runAndAssertSetActionMessageParameters("", command, messages);
}
#end_block

#method_before
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#method_after
public static List<String> runAndAssertSetActionMessageParameters(String assertionMessage, CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(assertionMessage, command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#end_block

#method_before
private static List<String> assertCanDoActionMessages(CommandBase<?> command, VdcBllMessages message) {
    List<String> canDoActionMessages = command.getReturnValue().getCanDoActionMessages();
    assertTrue(MessageFormat.format("canDoAction messages doesn''t contain expected message: {0}, messages are: {1}", message.name(), canDoActionMessages), canDoActionMessages.contains(message.name()));
    return canDoActionMessages;
}
#method_after
private static List<String> assertCanDoActionMessages(String assertionMessage, CommandBase<?> command, VdcBllMessages message) {
    List<String> canDoActionMessages = command.getReturnValue().getCanDoActionMessages();
    assertTrue(MessageFormat.format("{0}canDoAction messages doesn''t contain expected message: {1}, messages are: {2}", optionalMessage(assertionMessage), message.name(), canDoActionMessages), canDoActionMessages.contains(message.name()));
    return canDoActionMessages;
}
#end_block

#method_before
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    t.setName("org.ovirt.thread." + t.getName());
    if (log.isDebugEnabled()) {
        log.debug("About to run task " + r.getClass().getName() + " from ", new Exception());
    }
    if (getQueue().size() > 0) {
        log.warn("Executing a command, but note that there are " + getQueue().size() + " tasks in the queue.");
    }
}
#method_after
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    t.setName("org.ovirt.thread." + t.getName());
    if (log.isDebugEnabled()) {
        log.debug("About to run task " + r.getClass().getName() + " from ", new Exception());
    }
    if (getQueue().size() > 0) {
        log.warn("Executing a command: " + r.getClass().getName() + " , but note that there are " + getQueue().size() + " tasks in the queue.");
    }
}
#end_block

#method_before
@Override
public void run() {
    ThreadLocalParamsContainer.setVdcUser(vdcUser);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    job.run();
}
#method_after
@Override
public void run() {
    ThreadLocalParamsContainer.setUser(user);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    job.run();
}
#end_block

#method_before
@Override
public V call() throws Exception {
    ThreadLocalParamsContainer.setVdcUser(vdcUser);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    return job.call();
}
#method_after
@Override
public V call() throws Exception {
    ThreadLocalParamsContainer.setUser(user);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    return job.call();
}
#end_block

#method_before
public static void execute(Runnable command) {
    try {
        es.submit(new InternalWrapperRunnable(command, ThreadLocalParamsContainer.getVdcUser(), ThreadLocalParamsContainer.getHttpSessionId(), ThreadLocalParamsContainer.getCorrelationId()));
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#method_after
public static void execute(Runnable command) {
    try {
        es.submit(new InternalWrapperRunnable(command, ThreadLocalParamsContainer.getUser(), ThreadLocalParamsContainer.getHttpSessionId(), ThreadLocalParamsContainer.getCorrelationId()));
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
public VmDevice readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (isManaged) {
        vmDevice.setIsManaged(true);
        vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
    return vmDevice;
}
#method_after
public VmDevice readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).InnerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    }
    if (isManaged) {
        vmDevice.setIsManaged(true);
        vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
    return vmDevice;
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#method_after
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    // Remove brick task is marked completed only if committed or aborted.
    if (JobExecutionStatus.ABORTED == task.getStatus() || (JobExecutionStatus.FINISHED == task.getStatus() && task.getType() != GlusterTaskType.REMOVE_BRICK) || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#end_block

#method_before
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    values.put("status", task.getStatus().toString());
    values.put("info", task.getMessage());
    return values;
}
#method_after
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.valueOf((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    return task;
}
#method_after
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    task.getTaskParameters().setBricks(getBrickNames(map.get(BRICK_NAMES)));
    return task;
}
#end_block

#method_before
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getconnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDAO.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDAO.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#method_after
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getconnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDAO.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDAO.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#end_block

#method_before
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#method_after
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (isReadOnly ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (isReadOnly ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    result = prime * result + (snapshotId == null ? 0 : snapshotId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && isReadOnly == other.isReadOnly && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && isReadOnly == other.isReadOnly && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties) && ObjectUtils.objectsEqual(snapshotId, other.snapshotId));
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("VmDevice {");
    sb.append("vmId=");
    sb.append(id.getVmId());
    sb.append(", deviceId=");
    sb.append(id.getDeviceId());
    sb.append(", device=");
    sb.append(getDevice());
    sb.append(", type=");
    sb.append(getType());
    sb.append(", bootOrder=");
    sb.append(getBootOrder());
    sb.append(", specParams=");
    sb.append(getSpecParams());
    sb.append(", address=");
    sb.append(getAddress());
    sb.append(", managed=");
    sb.append(getIsManaged());
    sb.append(", plugged=");
    sb.append(getIsPlugged());
    sb.append(", readOnly=");
    sb.append(getIsReadOnly());
    sb.append(", deviceAlias=");
    sb.append(getAlias());
    sb.append(", customProperties=");
    sb.append(getCustomProperties());
    sb.append("}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("VmDevice {");
    sb.append("vmId=");
    sb.append(id.getVmId());
    sb.append(", deviceId=");
    sb.append(id.getDeviceId());
    sb.append(", device=");
    sb.append(getDevice());
    sb.append(", type=");
    sb.append(getType());
    sb.append(", bootOrder=");
    sb.append(getBootOrder());
    sb.append(", specParams=");
    sb.append(getSpecParams());
    sb.append(", address=");
    sb.append(getAddress());
    sb.append(", managed=");
    sb.append(getIsManaged());
    sb.append(", plugged=");
    sb.append(getIsPlugged());
    sb.append(", readOnly=");
    sb.append(getIsReadOnly());
    sb.append(", deviceAlias=");
    sb.append(getAlias());
    sb.append(", customProperties=");
    sb.append(getCustomProperties());
    sb.append(", snapshotId=");
    sb.append(getSnapshotId());
    sb.append("}");
    return sb.toString();
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk((Guid) getParameters().getDiskId());
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk((Guid) getParameters().getDiskId(), true);
    }
    return listVms;
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDAO().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDAO().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<VMWithPlugInfo> vms = getVmsWithPlugInfo(id);
    for (VMWithPlugInfo vm : vms) {
        MultiValueMapUtils.addToMap(vm.isPlugged(), vm.getVM(), result);
    }
    return result;
}
#method_after
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    for (Pair<VM, VmDevice> pair : vms) {
        VmDevice device = pair.getSecond();
        if (includeVmsSnapshotAttachedTo || device.getSnapshotId() == null) {
            MultiValueMapUtils.addToMap(device.getIsPlugged(), pair.getFirst(), result);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public List<VM> getVmsListForDisk(Guid id) {
    List<VM> result = new ArrayList<VM>();
    List<VMWithPlugInfo> vms = getVmsWithPlugInfo(id);
    for (VMWithPlugInfo vm : vms) {
        result.add(vm.getVM());
    }
    return result;
}
#method_after
@Override
public List<VM> getVmsListForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    List<VM> result = new ArrayList<>();
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    for (Pair<VM, VmDevice> pair : vms) {
        if (includeVmsSnapshotAttachedTo || pair.getSecond().getSnapshotId() == null) {
            result.add(pair.getFirst());
        }
    }
    return result;
}
#end_block

#method_before
private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id));
}
#method_after
public List<Pair<VM, VmDevice>> getVmsWithPlugInfo(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id));
}
#end_block

#method_before
@Override
public VMWithPlugInfo mapRow(ResultSet rs, int rowNum) throws SQLException {
    @SuppressWarnings("synthetic-access")
    VMWithPlugInfo entity = new VMWithPlugInfo();
    entity.setPlugged(rs.getBoolean("is_plugged"));
    entity.setVM(VMRowMapper.instance.mapRow(rs, rowNum));
    return entity;
}
#method_after
@Override
public Pair<VM, VmDevice> mapRow(ResultSet rs, int rowNum) throws SQLException {
    @SuppressWarnings("synthetic-access")
    Pair<VM, VmDevice> entity = new Pair<>();
    entity.setFirst(VMRowMapper.instance.mapRow(rs, rowNum));
    entity.setSecond(VmDeviceDAODbFacadeImpl.VmDeviceRowMapper.instance.mapRow(rs, rowNum));
    return entity;
}
#end_block

#method_before
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessage(String.format("$domainNames %1$s", domains.get(0).getStorageName()));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessage(String.format("$domainNames %1$s", domains.get(0).getStorageName()));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, java.util.ArrayList<VDSDomainsData> vdsDomainData) {
    IrsProxyData proxy = _irsProxyData.get(storagePoolId);
    if (proxy != null) {
        proxy.UpdateVdsDomainsData(vdsId, vdsName, vdsDomainData);
    }
}
#method_after
public static void UpdateVdsDomainsData(VDS vds, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    if (vds.getStatus() == VDSStatus.Up) {
        IrsProxyData proxy = _irsProxyData.get(storagePoolId);
        if (proxy != null) {
            proxy.UpdateVdsDomainsData(vds.getId(), vds.getName(), vdsDomainData);
        }
    }
}
#end_block

#method_before
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, ImagesHandler.getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false));
    copyAllMemoryImages(getVm().getId());
}
#method_after
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false, true));
    copyAllMemoryImages(getVm().getId());
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#method_after
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#end_block

#method_before
private List<GlusterClientInfo> getClientList(int listSize) {
    ArrayList<GlusterClientInfo> list = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < listSize; i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        clientInfo.setBytesRead(RandomUtils.instance().nextInt());
        clientInfo.setBytesWritten(RandomUtils.instance().nextInt());
        clientInfo.setClientPort(RandomUtils.instance().nextInt());
        clientInfo.setHostname(RandomUtils.instance().nextString(7));
        list.add(clientInfo);
    }
    return list;
}
#method_after
private List<GlusterClientInfo> getClientList(int listSize) {
    ArrayList<GlusterClientInfo> list = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < listSize; i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        clientInfo.setBytesRead(RandomUtils.instance().nextLong());
        clientInfo.setBytesWritten(RandomUtils.instance().nextLong());
        clientInfo.setClientPort(RandomUtils.instance().nextInt());
        clientInfo.setHostname(RandomUtils.instance().nextString(7));
        list.add(clientInfo);
    }
    return list;
}
#end_block

#method_before
@Override
protected void removeNodeSpi() {
    throw new UnsupportedOperationException("Not supported for sake of simplicity, non blocking API");
}
#method_after
@Override
protected void removeNodeSpi() {
    if (parent() == null) {
        throw new IllegalArgumentException("Cannot remove root node");
    }
    parent().remove(this.name());
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.nameQuotaPopup());
    descriptionEditor.setLabel(constants.descriptionQuotaPopup());
    dataCenterEditor.setLabel(constants.dataCenterQuotaPopup());
    memAndCpuLabel.setText(constants.memAndCpuQuotaPopup());
    storageLabel.setText(constants.storageQuotaPopup());
    globalClusterQuotaRadioButtonEditor.setLabel(constants.ultQuotaForAllClustersQuotaPopup());
    specificClusterQuotaRadioButtonEditor.setLabel(constants.useQuotaSpecificClusterQuotaPopup());
    globalStorageQuotaRadioButtonEditor.setLabel(constants.utlQuotaAllStoragesQuotaPopup());
    specificStorageQuotaRadioButtonEditor.setLabel(constants.usedQuotaSpecStoragesQuotaPopup());
    clusterGraceLabel.setText(constants.quotaClusterGrace());
    clusterThresholdLabel.setText(constants.quotaClusterThreshold());
    storageGraceLabel.setText(constants.quotaStorageGrace());
    storageThresholdLabel.setText(constants.quotaStorageThreshold());
}
#method_after
void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.nameQuotaPopup());
    descriptionEditor.setLabel(constants.descriptionQuotaPopup());
    dataCenterEditor.setLabel(constants.dataCenterQuotaPopup());
    copyPermissionsEditor.setLabel(constants.copyQuotaPermissionsQuotaPopup());
    memAndCpuLabel.setText(constants.memAndCpuQuotaPopup());
    storageLabel.setText(constants.storageQuotaPopup());
    globalClusterQuotaRadioButtonEditor.setLabel(constants.ultQuotaForAllClustersQuotaPopup());
    specificClusterQuotaRadioButtonEditor.setLabel(constants.useQuotaSpecificClusterQuotaPopup());
    globalStorageQuotaRadioButtonEditor.setLabel(constants.utlQuotaAllStoragesQuotaPopup());
    specificStorageQuotaRadioButtonEditor.setLabel(constants.usedQuotaSpecStoragesQuotaPopup());
    clusterGraceLabel.setText(constants.quotaClusterGrace());
    clusterThresholdLabel.setText(constants.quotaClusterThreshold());
    storageGraceLabel.setText(constants.quotaStorageGrace());
    storageThresholdLabel.setText(constants.quotaStorageThreshold());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId());
}
#end_block

#method_before
@Override
protected RowMapper<VmDevice> createEntityRowMapper() {
    return vmDeviceRowMapper;
}
#method_after
@Override
protected RowMapper<VmDevice> createEntityRowMapper() {
    return VmDeviceRowMapper.instance;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    return vmDevice;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<VmDevice> getBatchMapper() {
    return new MapSqlParameterMapper<VmDevice>() {

        @Override
        public MapSqlParameterSource map(VmDevice entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("device_id", entity.getDeviceId()).addValue("vm_id", entity.getVmId()).addValue("address", entity.getAddress()).addValue("alias", entity.getAlias()).addValue("type", entity.getType()).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("spec_params", entity.getSpecParams()).addValue("boot_order", entity.getBootOrder()).addValue("device", entity.getDevice());
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<VmDevice> getBatchMapper() {
    return new MapSqlParameterMapper<VmDevice>() {

        @Override
        public MapSqlParameterSource map(VmDevice entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("device_id", entity.getDeviceId()).addValue("vm_id", entity.getVmId()).addValue("address", entity.getAddress()).addValue("alias", entity.getAlias()).addValue("type", entity.getType()).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("spec_params", entity.getSpecParams()).addValue("boot_order", entity.getBootOrder()).addValue("snapshot_id", entity.getSnapshotId()).addValue("device", entity.getDevice());
            return paramValue;
        }
    };
}
#end_block

#method_before
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.error("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#end_block

#method_before
@Override
protected VmDevice generateNewEntity() {
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "value1");
    return new VmDevice(new VmDeviceId(Guid.newGuid(), EXISTING_VM_ID), VmDeviceGeneralType.DISK, "floppy", "type:'drive', controller:'0', bus:'0', unit:'1'", 2, new HashMap<String, Object>(), true, false, false, "alias", customProp);
}
#method_after
@Override
protected VmDevice generateNewEntity() {
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "value1");
    return new VmDevice(new VmDeviceId(Guid.newGuid(), EXISTING_VM_ID), VmDeviceGeneralType.DISK, "floppy", "type:'drive', controller:'0', bus:'0', unit:'1'", 2, new HashMap<String, Object>(), true, false, false, "alias", customProp, null);
}
#end_block

#method_before
protected Response performAction(VdcActionType task, VdcActionParametersBase params, Action action, boolean getEntityWhenDone) {
    try {
        if (isAsync() || expectNonBlocking()) {
            getCurrent().get(MetaData.class).set("async", true);
            return performNonBlockingAction(task, params, action);
        } else {
            doAction(task, params);
            if (action == null) {
                action = new Action();
            }
            action.setStatus(StatusUtils.create(CreationStatus.COMPLETE));
            if (getEntityWhenDone) {
                setActionItem(action, getEntity());
            }
            return Response.ok().entity(action).build();
        }
    } catch (Exception e) {
        return handleError(Response.class, e, false);
    }
}
#method_after
protected Response performAction(VdcActionType task, VdcActionParametersBase params, Action action, boolean getEntityWhenDone) {
    try {
        if (isAsync() || expectNonBlocking()) {
            getCurrent().get(MetaData.class).set("async", true);
            return performNonBlockingAction(task, params, action);
        } else {
            VdcReturnValueBase actionResult = doAction(task, params);
            if (actionResult.getJobId() != null) {
                setJobLink(action, actionResult);
            }
            if (action == null) {
                action = new Action();
            }
            action.setStatus(StatusUtils.create(CreationStatus.COMPLETE));
            if (getEntityWhenDone) {
                setActionItem(action, getEntity());
            }
            return Response.ok().entity(action).build();
        }
    } catch (Exception e) {
        return handleError(Response.class, e, false);
    }
}
#end_block

#method_before
protected <E> Validator<E> getValidator(Class<E> validatedClass) {
    return (Validator<E>) getValidatorLocator().getValidator(validatedClass);
}
#method_after
protected <E> Validator<E> getValidator(Class<E> validatedClass) {
    return getValidatorLocator().getValidator(validatedClass);
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId());
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupHostTabAvailability(object);
            } else if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    // only for non local storage available
    setupHostTabAvailability(object);
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || (Boolean) object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = (Boolean) object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(constants.notAvailableWithNoUpDC());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles().getItems());
    object.getNicsWithLogicalNetworks().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles().getItems());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupHostTabAvailability(object);
            } else if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    // only for non local storage available
    setupHostTabAvailability(object);
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || (Boolean) object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = (Boolean) object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(constants.notAvailableWithNoUpDC());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles());
}
#end_block

#method_before
public String formatSize(double size) {
    String sSize = String.valueOf(size);
    // $NON-NLS-1$
    int dotIndex = sSize.indexOf(".");
    if (dotIndex != -1) {
        return sSize.substring(0, dotIndex + 3);
    } else {
        // $NON-NLS-1$
        return sSize.concat(".00");
    }
}
#method_after
public String formatSize(double size) {
    // $NON-NLS-1$
    return NumberFormat.getFormat("#.##").format(size);
}
#end_block

#method_before
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setMessage(ConstantsManager.getInstance().getConstants().removeVolumesMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Test
public void canDoActionFailsOnNull() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTaskCompleted, getBricks(volumeWithRemoveBricksTaskCompleted, 2))));
    prepareMocks(cmd);
    assertFalse(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionFailsOnNull() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(null, getBricks(volumeWithRemoveBricksTaskCompleted, 2))));
    prepareMocks(cmd);
    assertFalse(cmd.canDoAction());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED) || GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    releaseVolumeLock();
    getDbUtils().removeBricksFromVolumeInDb(volume, getParameters().getBricks(), getParameters().getReplicaCount());
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    getDbUtils().removeBricksFromVolumeInDb(volume, getParameters().getBricks(), getParameters().getReplicaCount());
    getGlusterVolumeDao().updateVolumeTask(volume.getId(), null);
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks(), getParameters().getReplicaCount());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks(), replicaCount);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getVdsGroupName());
}
#method_after
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getVdsGroupName());
}
#end_block

#method_before
private void addBricks(GlusterVolumeEntity volumeEntity) {
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#method_after
private void addBricks(GlusterVolumeEntity volumeEntity) {
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#end_block

#method_before
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#end_block

#method_before
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setWindow(removeBrickStatusModel);
    removeBrickStatusModel.startProgress(null);
    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
    // $NON-NLS-1$
    UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand RetainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    RetainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    RetainBricksFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addRetainBricksCommand(RetainBricksFromStatus);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            removeBrickStatusModel.stopProgress();
            GlusterVolumeTaskStatusEntity removeBrickStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            removeBrickStatusModel.showStatus(removeBrickStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    removeBrickStatusModel.getCommands().add(cancelCommand);
}
#method_after
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setWindow(removeBrickStatusModel);
    removeBrickStatusModel.startProgress(null);
    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
    // $NON-NLS-1$
    UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            removeBrickStatusModel.stopProgress();
            GlusterVolumeTaskStatusEntity removeBrickStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            removeBrickStatusModel.showStatus(removeBrickStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    removeBrickStatusModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeEntity getVolumeByGlusterTask(Guid taskId) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByGlusterTaskId", volumeRowMapper, getCustomMapSqlParameterSource().addValue("task_id", taskId));
    return volume;
}
#method_after
@Override
public GlusterVolumeEntity getVolumeByGlusterTask(Guid taskId) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByGlusterTaskId", volumeRowMapper, getCustomMapSqlParameterSource().addValue("task_id", taskId));
    fetchRelatedEntities(volume);
    return volume;
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getStepId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(jobId, ExecutionMessageDirector.resolveStepMessage(StepEnum.EXECUTING, null), StepEnum.EXECUTING));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid execStepId = (Guid) result.getActionReturnValue();
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        // acquire lock on volume
        acquireLock(vol.getId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks == null) {
                return;
            }
            List<GlusterBrickEntity> brickEntities = new ArrayList<>();
            for (String brick : bricks) {
                String[] brickParts = brick.split(":", -1);
                String hostnameOrIp = brickParts[0];
                String brickDir = brickParts[1];
                GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                if (server == null) {
                    log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                } else {
                    brickEntity.setServerId(server.getId());
                    brickEntity.setBrickDirectory(brickDir);
                    brickEntity.setAsyncTask(new GlusterAsyncTask());
                    brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                    brickEntities.add(brickEntity);
                }
            }
            getBrickDao().updateAllBrickTasksByHostIdBrickDir(brickEntities);
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#method_after
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        // acquire lock on volume
        acquireLock(vol.getId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks == null) {
                return;
            }
            List<GlusterBrickEntity> brickEntities = new ArrayList<>();
            for (String brick : bricks) {
                String[] brickParts = brick.split(":", -1);
                String hostnameOrIp = brickParts[0];
                String brickDir = brickParts[1];
                GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                if (server == null) {
                    log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                } else {
                    brickEntity.setServerId(server.getId());
                    brickEntity.setBrickDirectory(brickDir);
                    brickEntity.setAsyncTask(new GlusterAsyncTask());
                    brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                    brickEntities.add(brickEntity);
                }
            }
            getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    if (map.get(BRICK_NAMES) != null) {
        task.getTaskParameters().setBricks((String[]) map.get(BRICK_NAMES));
    }
    return task;
}
#method_after
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    task.getTaskParameters().setBricks(getBrickNames(map.get(BRICK_NAMES)));
    return task;
}
#end_block

#method_before
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.debug("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#end_block

#method_before
protected Object resolveCreated(VdcReturnValueBase result, EntityResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        return entityResolver.resolve((Guid) result.getActionReturnValue());
    } catch (Exception e) {
        // already succeeded
        return null;
    }
}
#method_after
protected Object resolveCreated(VdcReturnValueBase result, EntityResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        return entityResolver.resolve(result.getActionReturnValue());
    } catch (Exception e) {
        // already succeeded
        return null;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setQuotaParameter();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getQuotaDAO().save(getQuota());
            copyQuotaPermissions();
            getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
protected void executeCommand() {
    setQuotaParameter();
    if (getParameters().isCopyPermissions()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                return executeAddQutoa();
            }
        });
    } else {
        executeAddQutoa();
    }
}
#end_block

#method_before
private void copyQuotaPermissions() {
    if (!getParameters().isCopyPermissions()) {
        return;
    }
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getCurrentUser().getUserId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), VdcObjectType.Quota);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#method_after
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getCurrentUser().getId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : new ArrayList<VDS>();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#method_after
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#end_block

#method_before
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().isStoragePoolMasterUp(_storagePoolId)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool, _isSpmStartCalled);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent - ", exp);
            }
        }
    });
}
#method_after
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().isStoragePoolMasterUp(_storagePoolId)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent - ", exp);
            }
        }
    });
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = (Boolean) getIsPm().getEntity();
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable((Boolean) getIsPm().getEntity());
    Object proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    // $NON-NLS-1$
    String version = "general";
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = (String) getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    String pmSecondaryType = (String) getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = (Boolean) getIsPm().getEntity();
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable((Boolean) getIsPm().getEntity());
    Object proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    String version = AsyncDataProvider.getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = (String) getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    String pmSecondaryType = (String) getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String version = ((GetAgentFenceOptionsQueryParameters) getParameters()).getVersion();
    VdsFenceOptions options = new VdsFenceOptions(version);
    HashMap<String, HashMap<String, String>> map = options.getFencingOptionMappingMap();
    getQueryReturnValue().setReturnValue(map);
    getQueryReturnValue().setSucceeded(map.size() > 0);
}
#method_after
@Override
protected void executeQueryCommand() {
    String version = getParameters().getVersion();
    VdsFenceOptions options = new VdsFenceOptions(version);
    HashMap<String, HashMap<String, String>> map = options.getFencingOptionMappingMap();
    getQueryReturnValue().setReturnValue(map);
    getQueryReturnValue().setSucceeded(map.size() > 0);
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), (getSnapshotName() == null) ? "" : getSnapshotName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), StringUtils.defaultString(getSnapshotName()));
    }
    return jobProperties;
}
#end_block

#method_before
private GlusterVolumeTaskStatusEntity fetchRemobeBricksStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null) {
        Guid taskId = asyncTask.getTaskId();
        if (taskId != null) {
            List<Step> stepsList = getStepDao().getStepsByExternalId(taskId);
            if (stepsList != null && !stepsList.isEmpty()) {
                entity.setStartTime(stepsList.get(0).getStartTime());
            }
        }
    }
    return entity;
}
#method_after
private GlusterVolumeTaskStatusEntity fetchRemobeBricksStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            entity.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return entity;
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // through all filters -> use it
        if (vdsList != null) {
            for (VDS vds : vdsList) {
                if (vds.getId().equals(destHostId)) {
                    return destHostId;
                }
            }
        }
        if (vdsList != null && vdsList.contains(destHostId)) {
            return destHostId;
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // through all filters -> use it
        if (vdsList != null) {
            for (VDS vds : vdsList) {
                if (vds.getId().equals(destHostId)) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#end_block

#method_before
public VmTemplateStatus getStatus() {
    return status;
}
#method_after
@Override
public VmTemplateStatus getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#method_after
@Override
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#end_block

#method_before
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#method_after
public Guid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
public void setStoragePoolId(NGuid value) {
    storagePoolId = value;
}
#method_after
public void setStoragePoolId(Guid value) {
    storagePoolId = value;
}
#end_block

#method_before
@JsonIgnore
public Map<Guid, DiskImage> getDiskImageMap() {
    return diskMap;
}
#method_after
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskImageMap;
}
#end_block

#method_before
public void setDiskImageMap(Map<Guid, DiskImage> value) {
    diskMap = value;
}
#method_after
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskImageMap = value;
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && isMigrationInterfaceUp(nic, nics)) {
            return nic.getAddress();
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return nic.getAddress();
        }
    }
    return null;
}
#end_block

#method_before
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#method_after
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(new VolumeBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    setBrickListModel(new VolumeBrickListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(getBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    getBrickListModel().setEntity(provideDetailModelEntity(getSelectedItem()));
}
#end_block

#method_before
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            showRebalanceStatus();
        }
    });
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>GetValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>GetValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>GetValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>GetValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.EncryptHostCommunication));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (volume.getAsyncTask() == null || volume.getAsyncTask().getType() != GlusterTaskType.REMOVE_BRICK || volume.getAsyncTask().getStatus() != JobExecutionStatus.FINISHED) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_FINISHED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_FINISHED);
    }
    return true;
}
#end_block

#method_before
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
}
#method_after
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    boolean allowRemove = true;
    boolean allowStopRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
        allowStopRemove = false;
    } else {
        if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        List<GlusterBrickEntity> list = getSelectedItems();
        for (GlusterBrickEntity brick : list) {
            GlusterAsyncTask task = brick.getAsyncTask();
            allowStopRemove = allowStopRemove && task != null && task.getStatus() == JobExecutionStatus.STARTED;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && ((GlusterBrickEntity) getSelectedItems().get(0)).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getStopRemoveBricksCommand().setIsExecutionAllowed(allowStopRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    boolean allowRemove = true;
    boolean allowStopRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
        allowStopRemove = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        List<GlusterBrickEntity> list = getSelectedItems();
        for (GlusterBrickEntity brick : list) {
            GlusterAsyncTask task = brick.getAsyncTask();
            allowStopRemove = allowStopRemove && task != null && task.getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && ((GlusterBrickEntity) getSelectedItems().get(0)).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getStopRemoveBricksCommand().setIsExecutionAllowed(allowStopRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
}
#end_block

#method_before
private void stopRemoveBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRemoveBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VolumeRebalanceStatusPopupPresenterWidget> rebalanceStatusPopupProvider) {
    return new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRebalanceCommand()) {
                return rebalanceStatusPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
public void edit(final RemoveBrickModel object) {
    driver.edit(object);
    object.getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ArrayList<String> items = (ArrayList<String>) object.getItems();
            for (String item : items) {
                itemsPanel.add(new Label(item));
            }
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsMigrationSupported".equals(propName)) {
                // $NON-NLS-1$
                migrateEditor.setVisible(object.isMigrationSupported());
                migrateInfoIcon.setVisible(object.isMigrationSupported());
                warningLabel.setVisible(object.isMigrationSupported());
            }
        }
    });
}
#method_after
@Override
public void edit(final RemoveBrickModel object) {
    driver.edit(object);
    object.getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ArrayList<String> items = (ArrayList<String>) object.getItems();
            for (String item : items) {
                itemsPanel.add(new Label(item));
            }
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsMigrationSupported".equals(propName)) {
                // $NON-NLS-1$
                migratePanel.setVisible(object.isMigrationSupported());
            }
        }
    });
    object.getMigrateData().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            warningLabel.setVisible(!(Boolean) object.getMigrateData().getEntity());
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBrick, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), bricks, replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(bricks);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), bricks, replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(bricks);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
public int keysUsedCount() {
    return keyValueMap_used == null ? 0 : keyValueMap_used.size();
}
#method_after
public int keysUsedCount() {
    if (keyValueMap_used == null || keyValueMap_used.containsKey(NO_KEYS)) {
        return 0;
    }
    return keyValueMap_used.size();
}
#end_block

#method_before
private void setPanel(KeyValueModel object) {
    List<KeyValueLineModel> list = (List<KeyValueLineModel>) object.getKeyValueLines().getItems();
    panel.clear();
    widgetList = new ArrayList<KeyValueLineWidget>();
    // create & edit each row.
    for (KeyValueLineModel keyValueLineModel : list) {
        KeyValueLineWidget keyValueLineWidget = new KeyValueLineWidget();
        widgetList.add(keyValueLineWidget);
        panel.add(keyValueLineWidget);
        keyValueLineWidget.edit(keyValueLineModel);
        keyValueLineWidget.setEnabled(enabled);
        if (list.size() == 1 && object.keysUsedCount() == 0) {
            keyValueLineWidget.setMinusButtonEnabled(false);
        }
        if (list.size() == object.possibleKeysCount()) {
            keyValueLineWidget.setPlusButtonEnabled(false);
        }
    }
}
#method_after
private void setPanel(KeyValueModel object) {
    List<KeyValueLineModel> list = (List<KeyValueLineModel>) object.getKeyValueLines().getItems();
    panel.clear();
    widgetList = new ArrayList<KeyValueLineWidget>();
    // create & edit each row.
    for (KeyValueLineModel keyValueLineModel : list) {
        KeyValueLineWidget keyValueLineWidget = new KeyValueLineWidget();
        widgetList.add(keyValueLineWidget);
        panel.add(keyValueLineWidget);
        keyValueLineWidget.edit(keyValueLineModel);
        keyValueLineWidget.setEnabled(enabled);
        if (list.size() == 1 && object.keysUsedCount() == 0) {
            keyValueLineWidget.setMinusButtonEnabled(false);
        }
        if (list.size() >= object.possibleKeysCount()) {
            keyValueLineWidget.setPlusButtonEnabled(false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        // clears snapshot ID
        getImageDao().updateImageVmSnapshotId(((DiskImage) disk).getImageId(), Guid.Empty);
    }
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        // clears snapshot ID
        getImageDao().updateImageVmSnapshotId(((DiskImage) disk).getImageId(), null);
    }
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
private boolean shouldUpdateImageProperties() {
    if (getOldDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        return false;
    }
    Guid oldQuotaId = ((DiskImage) getOldDisk()).getQuotaId();
    return !ObjectUtils.objectsEqual(oldQuotaId, getQuotaId());
}
#method_after
private boolean shouldUpdateImageProperties() {
    if (getOldDisk().getDiskStorageType() != DiskStorageType.IMAGE) {
        return false;
    }
    Guid oldQuotaId = ((DiskImage) getOldDisk()).getQuotaId();
    return !ObjectUtils.objectsEqual(oldQuotaId, getQuotaId());
}
#end_block

#method_before
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(String.format("Invalid volume id %s", volumeId));
        }
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchRemobeBricksStatusDetails());
}
#method_after
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.GLUSTER_VOLUME_ID_INVALID.toString());
        }
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchRemobeBricksStatusDetails());
}
#end_block

#method_before
@Override
public void render(Context context, T value, SafeHtmlBuilder sb) {
    ImageResource image = imageResources.triangleDown();
    SafeHtml imageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(image).getHTML());
    sb.append(applicationTemplates.image(imageHtml));
}
#method_after
@Override
public void render(Context context, T value, SafeHtmlBuilder sb) {
    ImageResource image = resources.triangleDown();
    SafeHtml imageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(image).getHTML());
    sb.append(templates.image(imageHtml));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!volume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        addCanDoActionMessage(String.format("$volumeName %1$s", volume.getName()));
        return false;
    }
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
        if (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REBALANCE_IN_PROGRESS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!volume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ALREADY_STOPPED);
        addCanDoActionMessage(String.format("$volumeName %1$s", volume.getName()));
        return false;
    }
    if (GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REBALANCE) && GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_CANNOT_STOP_REBALANCE_IN_PROGRESS);
    }
    return true;
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
}
#method_after
public void vmTypeChanged(VmType vmType) {
    getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
}
#end_block

#method_before
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#method_after
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else if (takesXmlGregorianCalendar(method)) {
                populateXmlGregorianCalendar(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#end_block

#method_before
private static void descend(Method method, Object model, List<Class<?>> seen, int level) throws Exception {
    Class<?> type = method.getParameterTypes()[0];
    Object child;
    if (type.getName().equals(XML_GREGORIAN_CALENDAR)) {
        child = DatatypeFactory.newInstance().newXMLGregorianCalendar(new GregorianCalendar(1111, 10, 29));
    } else {
        child = type.newInstance();
    }
    method.invoke(model, child);
    if ((level == 1 || unseen(method, seen)) && (!XMLGregorianCalendar.class.isAssignableFrom(child.getClass()))) {
        populate(child, child.getClass(), seen, ++level);
    }
}
#method_after
private static void descend(Method method, Object model, List<Class<?>> seen, int level) throws Exception {
    Object child = method.getParameterTypes()[0].newInstance();
    method.invoke(model, child);
    if (level == 1 || unseen(method, seen)) {
        populate(child, child.getClass(), seen, ++level);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private static void fill(Method method, Object model, List<Class<?>> seen, int level) throws Exception {
    // List<T> type parameter removed by erasure, hence we attempt to
    // infer from method name
    String elementType = method.getName().substring(GET_ROOT.length());
    Class<?> childType = coPackaged(model, elementType);
    if (level == 1 || unseen(childType, seen)) {
        List<Object> list = (List<Object>) method.invoke(model);
        Object child = null;
        if (childType.isEnum()) {
            Object[] labels = childType.getEnumConstants();
            child = labels[rand(labels.length)];
        } else {
            child = childType.newInstance();
        }
        list.add(child);
        populate(child, child.getClass(), seen, ++level);
    }
}
#method_after
@SuppressWarnings("unchecked")
private static void fill(Method method, Object model, List<Class<?>> seen, int level) throws Exception {
    // List<T> type parameter removed by erasure, hence we attempt to
    // infer from method name
    String elementType = method.getName().substring(GET_ROOT.length());
    Class<?> childType = getChildType(model, elementType);
    if (level == 1 || unseen(childType, seen)) {
        List<Object> list = (List<Object>) method.invoke(model);
        Object child = null;
        if (childType.isEnum()) {
            Object[] labels = childType.getEnumConstants();
            child = labels[rand(labels.length)];
        } else {
            child = childType.newInstance();
        }
        list.add(child);
        populate(child, child.getClass(), seen, ++level);
    }
}
#end_block

#method_before
private static Class<?> coPackaged(Object model, String elementType) throws ClassNotFoundException {
    String packageRoot = model.getClass().getPackage().getName() + ".";
    try {
        // Consider special case: "Usages" contains a list of Strings, not 'Usage' elements.
        return elementType.equals("Usages") ? String.class : Class.forName(packageRoot + singular(elementType));
    } catch (ClassNotFoundException cnf) {
        try {
            return Class.forName(packageRoot + elementType);
        } catch (ClassNotFoundException cnfe) {
            // try inner class
            return Class.forName(model.getClass().getName() + "$" + elementType);
        }
    }
}
#method_after
private static Class<?> coPackaged(Object model, String elementType) throws ClassNotFoundException {
    String packageRoot = model.getClass().getPackage().getName() + ".";
    try {
        return Class.forName(packageRoot + singular(elementType));
    } catch (ClassNotFoundException cnf) {
        try {
            return Class.forName(packageRoot + elementType);
        } catch (ClassNotFoundException cnfe) {
            // try inner class
            return Class.forName(model.getClass().getName() + "$" + elementType);
        }
    }
}
#end_block

#method_before
private static String singular(String s) {
    // 'Slaves' is plural of 'HostNIC' (we don't have a 'Slave' entity)
    return s.equals(NICS_PLURAL) ? NIC_SINGLE : s.equals(FLOPPIES_PLURAL) ? FLOPPY_SINGLE : s.equals(SLAVES_PLURAL) ? SLAVE_SINGLE : s.endsWith("s") ? s.substring(0, s.length() - 1) : s;
}
#method_after
private static String singular(String s) {
    return isSingularSpecialCase(s) ? handleSingularSpecialCase(s) : s.endsWith("s") ? s.substring(0, s.length() - 1) : s;
}
#end_block

