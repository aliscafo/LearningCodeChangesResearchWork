599
#method_before
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count(rs.getInt("vm_count"));
    entity.setvms_cores_count(rs.getInt("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead(rs.getInt("guest_overhead"));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setbuild_name(rs.getString("build_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setlibvirt_version(new RpmVersion(rs.getString("libvirt_version")));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setgluster_version(rs.getString("gluster_version"));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    return entity;
}
#method_after
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count(rs.getInt("vm_count"));
    entity.setvms_cores_count(rs.getInt("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead(rs.getInt("guest_overhead"));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setbuild_name(rs.getString("build_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setlibvirt_version(new RpmVersion(rs.getString("libvirt_version")));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    return entity;
}
#end_block

#method_before
@Override
public void save(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getgluster_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("InsertVdsDynamic", parameterSource);
}
#method_after
@Override
public void save(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("InsertVdsDynamic", parameterSource);
}
#end_block

#method_before
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getgluster_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#method_after
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#end_block

#method_before
public String getGlusterVersion() {
    return glusterVersion;
}
#method_after
public RpmVersion getGlusterVersion() {
    return glusterVersion;
}
#end_block

#method_before
public void setGlusterVersion(String value) {
    if (this.glusterVersion == null || !this.glusterVersion.equals(value)) {
        this.glusterVersion = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("GlusterVersion"));
    }
}
#method_after
public void setGlusterVersion(RpmVersion value) {
    if (Version.OpInequality(glusterVersion, value)) {
        glusterVersion = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("glusterVersion"));
    }
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(rs.getString("gluster_version"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((cpuThreads == null) ? 0 : cpuThreads.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((libvirt_version == null) ? 0 : libvirt_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((gluster_version == null) ? 0 : gluster_version.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    result = prime * result + ((hwManufacturer == null) ? 0 : hwManufacturer.hashCode());
    result = prime * result + ((hwProductName == null) ? 0 : hwProductName.hashCode());
    result = prime * result + ((hwVersion == null) ? 0 : hwVersion.hashCode());
    result = prime * result + ((hwSerialNumber == null) ? 0 : hwSerialNumber.hashCode());
    result = prime * result + ((hwUUID == null) ? 0 : hwUUID.hashCode());
    result = prime * result + ((hwFamily == null) ? 0 : hwFamily.hashCode());
    result = prime * result + ((HBAs == null) ? 0 : HBAs.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((cpuThreads == null) ? 0 : cpuThreads.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((libvirt_version == null) ? 0 : libvirt_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((glusterVersion == null) ? 0 : glusterVersion.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    result = prime * result + ((hwManufacturer == null) ? 0 : hwManufacturer.hashCode());
    result = prime * result + ((hwProductName == null) ? 0 : hwProductName.hashCode());
    result = prime * result + ((hwVersion == null) ? 0 : hwVersion.hashCode());
    result = prime * result + ((hwSerialNumber == null) ? 0 : hwSerialNumber.hashCode());
    result = prime * result + ((hwUUID == null) ? 0 : hwUUID.hashCode());
    result = prime * result + ((hwFamily == null) ? 0 : hwFamily.hashCode());
    result = prime * result + ((HBAs == null) ? 0 : HBAs.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && anonymousHugePages == other.anonymousHugePages && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(gluster_version, other.gluster_version) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && anonymousHugePages == other.anonymousHugePages && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines));
}
#end_block

#method_before
public String getGlusterVersion() {
    return this.mVdsDynamic.getgluster_version();
}
#method_after
public RpmVersion getGlusterVersion() {
    return this.mVdsDynamic.getGlusterVersion();
}
#end_block

#method_before
public void setGlusterVersion(String value) {
    this.mVdsDynamic.setgluster_version(value);
}
#method_after
public void setGlusterVersion(RpmVersion value) {
    this.mVdsDynamic.setGlusterVersion(value);
}
#end_block

#method_before
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.glusterPackageName)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.glusterPackageName);
            vds.setGlusterVersion(getPackageVersionFormated2(gluster));
        }
    }
}
#method_after
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncDataProvider.getGlusterBricksForServer(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<GlusterBrickEntity> glusterBricks = (List<GlusterBrickEntity>) returnValue;
            Collections.sort(glusterBricks, new GlusterBrickEntity());
            setItems(glusterBricks);
        }
    }), getEntity().getId());
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncDataProvider.getGlusterBricksForServer(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<GlusterBrickEntity> glusterBricks = (List<GlusterBrickEntity>) returnValue;
            Collections.sort(glusterBricks, new Linq.ServerBricksComparer());
            setItems(glusterBricks);
        }
    }), getEntity().getId());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
@Override
public HandlerRegistration addValueChangeHandler(ValueChangeHandler handler) {
    return asRadioButton().addValueChangeHandler(handler);
}
#method_after
@Override
public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler) {
    return asRadioButton().addValueChangeHandler(handler);
}
#end_block

#method_before
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            NetworkQoS none = new NetworkQoS();
            none.setName(ConstantsManager.getInstance().getConstants().unlimitedQoSTitle());
            none.setId(Guid.Empty);
            networkQoSes.add(0, none);
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#method_after
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            networkQoSes.add(0, getEmptyQos());
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#end_block

#method_before
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    setSelectedNetworkQoSId(Guid.Empty);
}
#method_after
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    getNetworkQoS().setSelectedItem(getEmptyQos());
}
#end_block

#method_before
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            NetworkQoS none = new NetworkQoS();
            none.setName(ConstantsManager.getInstance().getConstants().unlimitedQoSTitle());
            none.setId(Guid.Empty);
            networkQoSes.add(0, none);
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#method_after
private void initNetworkQoSList() {
    if (getDcId() == null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ArrayList<NetworkQoS> networkQoSes = (ArrayList<NetworkQoS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            networkQoSes.add(0, getEmptyQos());
            getNetworkQoS().setItems(networkQoSes);
            setSelectedNetworkQoSId(defaultQosId);
        }
    };
    IdQueryParameters queryParams = new IdQueryParameters(getDcId());
    Frontend.RunQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, queryParams, _asyncQuery);
}
#end_block

#method_before
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    setSelectedNetworkQoSId(Guid.Empty);
}
#method_after
private void setSelectedNetworkQoSId(Guid networkQoSId) {
    for (Object item : getNetworkQoS().getItems()) {
        if (((NetworkQoS) item).getId().equals(networkQoSId)) {
            getNetworkQoS().setSelectedItem(item);
            return;
        }
    }
    getNetworkQoS().setSelectedItem(getEmptyQos());
}
#end_block

#method_before
@Override
protected void initProfiles() {
    Iterable<VnicProfileModel> existingProfiles = getProfiles().getItems();
    if (existingProfiles == null) {
        // first run (dialog has just been opened and default DC chosen), create default entry
        List<VnicProfileModel> profiles = new LinkedList<VnicProfileModel>();
        profiles.add(createDefaultProfile());
        getProfiles().setItems(profiles);
    } else {
        // not first run (user picked different DC), want to keep existing entries and update DC-related properties
        for (VnicProfileModel profile : existingProfiles) {
            profile.updateDc(getSelectedDc().getcompatibility_version(), getSelectedDc().getId());
        }
    }
}
#method_after
@Override
protected void initProfiles() {
    Iterable<VnicProfileModel> existingProfiles = getProfiles().getItems();
    if (existingProfiles == null) {
        // first run (dialog has just been opened and default DC chosen), create default entry
        List<VnicProfileModel> profiles = new LinkedList<VnicProfileModel>();
        profiles.add(getDefaultProfile());
        getProfiles().setItems(profiles);
    } else {
        // not first run (user picked different DC), want to keep existing entries and update DC-related properties
        for (VnicProfileModel profile : existingProfiles) {
            profile.updateDc(getSelectedDc().getcompatibility_version(), getSelectedDc().getId());
        }
    }
}
#end_block

#method_before
public String getRelativePath() {
    String path = getPath();
    if (path.startsWith("/")) {
        // $NON-NLS-1$
        path = path.substring(1);
    }
    return path;
}
#method_after
public String getRelativePath() {
    String path = getPath();
    // $NON-NLS-1$
    return path.startsWith("/") ? path.substring(1) : path;
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && StorageType.LOCALFS.equals(getModel().getSelectedDataCenter().getStorageType());
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable()) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && StorageType.LOCALFS.equals(getModel().getSelectedDataCenter().getStorageType());
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#end_block

#method_before
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartedTime().setEntity(rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
        refresh.cancel();
    } else {
        setStatusAvailable(false);
        if ((rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh.cancel();
        }
    }
    if (GlusterTaskType.REBALANCE.equals(getEntity().getAsyncTask().getType())) {
        getStopReblanceFromStatus().setIsExecutionAllowed(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.STARTED);
    }
}
#method_after
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartedTime().setEntity(rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
        refresh.cancel();
    } else {
        setStatusAvailable(false);
        if ((rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh.cancel();
        }
    }
    if (GlusterTaskType.REBALANCE == getEntity().getAsyncTask().getType()) {
        getStopReblanceFromStatus().setIsExecutionAllowed(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.STARTED);
    }
}
#end_block

#method_before
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            GlusterVolumeTaskStatusEntity rebalanceEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            showStatus(rebalanceEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if (rebalanceStatusEntity != null) {
                showStatus(rebalanceStatusEntity);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network == null ? Collections.<String>emptyList() : Collections.singletonList(networkName))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    if (!unsupportedFeatures.isEmpty()) {
        reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
    }
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    if (!unsupportedFeatures.isEmpty()) {
        reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
    }
}
#end_block

#method_before
private static boolean addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Version version, List<String> networkNames) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        if (FeatureSupported.portMirroring(version)) {
            struct.put(VdsProperties.PORT_MIRRORING, networkNames);
        } else {
            return false;
        }
    }
    return true;
}
#method_after
private static boolean addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Version version, Network network) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        if (FeatureSupported.portMirroring(version)) {
            struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
        } else {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE;
            }
            if (getParameters().getExecutionIndex() == 0 && getSucceeded()) {
                return AuditLogType.USER_EXPORT_IMAGE;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.USER_EXPORT_IMAGE : AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE;
        case END_SUCCESS:
            return AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    optimizationNoneEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForServerEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForDesktopEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationCustomEditor.setContentWidgetStyleName(style.fullWidth());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.toString());
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
protected void initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    VDS destVds = getDestinationVds();
    SchedulingManager.SchedulingResult schedulingResult = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), destVds == null ? null : destVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    Guid vdsToRunOn = schedulingResult.getVdsSelected();
    setVdsDestinationId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // make _destinationVds null in order to refresh it from db in case it
    // changed.
    _destinationVds = null;
    if (vdsDestinationId != null && vdsDestinationId.equals(Guid.Empty)) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_CANT_ALLOC_VDS_MIGRATION);
    }
    if (getDestinationVds() == null || getVds() == null) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
    }
}
#method_after
protected void initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    VDS destVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), destVds == null ? null : destVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsDestinationId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // make _destinationVds null in order to refresh it from db in case it
    // changed.
    _destinationVds = null;
    if (vdsDestinationId != null && vdsDestinationId.equals(Guid.Empty)) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_CANT_ALLOC_VDS_MIGRATION);
    }
    if (getDestinationVds() == null || getVds() == null) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
    }
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, vdsDestinationId, dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp());
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, vdsDestinationId, dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getVdsGroupCompatibilityVersion());
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (nic.getStatistics().getStatus() == InterfaceStatus.UP && migrationNetworkName.equals(nic.getNetworkName())) {
            return nic.getAddress();
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return nic.getAddress();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? AuditLogType.VM_MIGRATION_DONE : isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START : _isRerun ? AuditLogType.VM_MIGRATION_TRYING_RERUN : getVds().getStatus() == VDSStatus.PreparingForMaintenance ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : AuditLogType.VM_MIGRATION_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? AuditLogType.VM_MIGRATION_DONE : isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START : _isRerun ? AuditLogType.VM_MIGRATION_TRYING_RERUN : getVds().getStatus() == VDSStatus.PreparingForMaintenance ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : getDestinationVds() == null ? AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON : AuditLogType.VM_MIGRATION_FAILED;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    if (vm.getStatus() == VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
    }
    if (vm.getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    if (vm.getStatus() == VMStatus.Paused) {
        return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getVdsDestinationId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    if (vm.getStatus() == VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
    }
    if (vm.getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    if (vm.getStatus() == VMStatus.Paused) {
        return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getVdsDestinationId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
        discoveryThread.start();
    } else {
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
public void addReason(Guid id, String reason) {
    filteredOutReasons.put(id, reason);
}
#method_after
public void addReason(Guid id, String hostName, VdcBllMessages filterType, String filterName) {
    filteredOutReasons.put(id, new Pair<VdcBllMessages, String>(filterType, filterName));
    hostNames.put(id, hostName);
}
#end_block

#method_before
public Set<Entry<Guid, String>> getReasons() {
    return filteredOutReasons.entrySet();
}
#method_after
public Set<Entry<Guid, Pair<VdcBllMessages, String>>> getReasons() {
    return filteredOutReasons.entrySet();
}
#end_block

#method_before
public Collection<String> getReasonMessages() {
    return filteredOutReasons.values();
}
#method_after
public Collection<String> getReasonMessages() {
    List<String> lines = new ArrayList<>();
    for (Entry<Guid, Pair<VdcBllMessages, String>> line : filteredOutReasons.entrySet()) {
        lines.add(line.getValue().getFirst().name());
        lines.add(String.format("$%1$s %2$s", "hostName", hostNames.get(line.getKey())));
        lines.add(String.format("$%1$s %2$s", "filterName", line.getValue().getSecond()));
        lines.add(VdcBllMessages.SCHEDULING_HOST_FILTERED_REASON.name());
    }
    return lines;
}
#end_block

#method_before
public SchedulingResult schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        if (destHostId != null) {
            if (checkDestinationHost(vm, vdsList, destHostId, messages, policy, parameters, memoryChecker)) {
                result.setVdsSelected(destHostId);
                return result;
            } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
                result.setMessage("VM " + vm.getId().toString() + " cannot be migrated because it is pinned to host");
                log.info(result.getMessage());
                return result;
            }
        }
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, correlationId, result);
        if (vdsList == null || vdsList.size() == 0) {
            return result;
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            result.setVdsSelected(vdsList.get(0).getId());
            return result;
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        result.setVdsSelected(bestHost);
        return result;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    SchedulingResult result = new SchedulingResult();
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    if (destVdsId != null) {
        if (checkDestinationHost(vm, vdsList, destVdsId, messages, policy, parameters, noWaitingMemoryChecker)) {
            return true;
        } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            return false;
        }
    }
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, null, result);
    if (vdsList == null || vdsList.size() == 0) {
        messages.addAll(result.getReasonMessages());
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> newHostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(hostList, newHostList, "internal filter " + filterPolicyUnit.getName(), result);
            hostList = newHostList;
        }
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<VDS>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(currentHostList, toIdSet(hostList), VdcBllMessages.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getName(), result, correlationId);
        }
    }
    return hostList;
}
#end_block

#method_before
private void logFilterActions(List<VDS> oldList, List<VDS> newList, String actionName, SchedulingResult result) {
    // to get O(1) membership check
    Set<VDS> newSet = new HashSet<VDS>(newList);
    for (VDS host : oldList) {
        if (!newSet.contains(host)) {
            StringBuilder reason = new StringBuilder();
            reason.append("Candidate host ");
            reason.append(host.getName());
            reason.append(" (");
            reason.append(host.getId().toString());
            reason.append(") was filtered out by ");
            reason.append(actionName);
            result.addReason(host.getId(), reason.toString());
            log.info(reason);
        }
    }
}
#method_after
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, VdcBllMessages actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            String reason = String.format("Candidate host %s (%s) was filtered out by %s filter %s", host.getName(), host.getId().toString(), actionName.name(), filterName);
            if (!StringUtils.isEmpty(correlationId)) {
                reason = String.format("%s (correlation id: %s)", reason, correlationId);
            }
            log.info(reason);
            result.addReason(host.getId(), host.getName(), actionName, filterName);
        }
    }
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        logFilterActionsWithGuid(hostList, filteredIDs, "external filter(s)", result);
    }
    return intersectHosts(hostList, filteredIDs);
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<Guid>(filteredIDs), VdcBllMessages.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the endAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    SchedulingManager.SchedulingResult schedulingResult = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), null, destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    Guid vdsToRunOn = schedulingResult.getVdsSelected();
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    /* Prepare user readable error message */
    VdcFault fault = new VdcFault();
    fault.setError(VdcBllErrors.SCHEDULING_ALL_HOSTS_FILTERED_OUT);
    getReturnValue().setFault(fault);
    StringBuilder errorMessage = new StringBuilder();
    errorMessage.append("All hosts were filtered out, the reasons follow:\n");
    for (Map.Entry<Guid, String> vds : schedulingResult.getReasons()) {
        errorMessage.append(String.format("%s: %s\n", vds.getKey().toString(), vds.getValue()));
    }
    getReturnValue().setDescription(errorMessage.toString());
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getVdsWhiteList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        VdcQueryReturnValue vdcQueryReturnValue = runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(new org.ovirt.engine.core.compat.Version(asString(v))));
        for (ServerCpu sc : (List<ServerCpu>) vdcQueryReturnValue.getReturnValue()) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
@Ignore
@Test
public void testList() throws Exception {
    HashSet<org.ovirt.engine.core.compat.Version> supportedVersions = new HashSet<org.ovirt.engine.core.compat.Version>();
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(1, 5));
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(10, 3));
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.SupportedClusterLevels }, supportedVersions);
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.PredefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.UserDefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.PredefinedVMProperties }, "foo=true|false");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.UserDefinedVMProperties }, "bar=[a-z]");
    verifyCapabilities(resource.list());
}
#method_after
@Ignore
@Test
public void testList() throws Exception {
    HashSet<org.ovirt.engine.core.compat.Version> supportedVersions = new HashSet<org.ovirt.engine.core.compat.Version>();
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(1, 5));
    supportedVersions.add(new org.ovirt.engine.core.compat.Version(10, 3));
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.SupportedClusterLevels }, supportedVersions);
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionMapping }, "foo:one=1,two=2");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.VdsFenceOptionTypes }, "one=int,two=bool");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.PredefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "1.5", ConfigurationValues.UserDefinedVMProperties }, "");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.PredefinedVMProperties }, "foo=true|false");
    setUpGetEntityExpectations(VdcQueryType.GetConfigurationValue, GetConfigurationValueParameters.class, new String[] { "Version", "ConfigValue" }, new Object[] { "10.3", ConfigurationValues.UserDefinedVMProperties }, "bar=[a-z]");
    setUpGetEntityExpectations(VdcQueryType.GetAllServerCpuList, GetAllServerCpuListParameters.class, new String[] { "Version" }, new Object[] { "3.3" }, "bar=[a-z]");
    verifyCapabilities(resource.list());
}
#end_block

#method_before
void reloadData(File[] descriptorFiles, Map<String, PluginData> currentDataMapCopy) {
    Map<String, PluginData> entriesToUpdate = new HashMap<String, PluginData>();
    Set<String> keysToRemove = new HashSet<String>();
    // Optimization: make sure we don't check data that we already processed
    Set<String> keysToCheckForRemoval = new HashSet<String>(currentDataMapCopy.keySet());
    // Compare (possibly added or modified) files against cached data
    for (final File df : descriptorFiles) {
        final File cf = new File(pluginConfigDir, getConfigurationFileName(df));
        String descriptorFilePath = df.getAbsolutePath();
        PluginData currentData = currentDataMapCopy.get(descriptorFilePath);
        long descriptorLastModified = df.lastModified();
        long configurationLastModified = isJsonFile(cf) ? cf.lastModified() : MISSING_FILE_LAST_MODIFIED;
        // Check if data needs to be reloaded
        boolean reloadDescriptor, reloadConfiguration;
        if (currentDataMapCopy.containsKey(descriptorFilePath)) {
            reloadDescriptor = descriptorLastModified > currentData.getDescriptorLastModified();
            reloadConfiguration = configurationLastModified > currentData.getConfigurationLastModified();
            // Change in descriptor causes reload of configuration
            reloadConfiguration = reloadConfiguration || reloadDescriptor;
            // Refresh configuration if the corresponding file has gone missing
            reloadConfiguration = reloadConfiguration || (configurationLastModified == MISSING_FILE_LAST_MODIFIED && currentData.getConfigurationLastModified() != MISSING_FILE_LAST_MODIFIED);
        } else {
            reloadDescriptor = true;
            reloadConfiguration = true;
        }
        // Read descriptor data
        JsonNode descriptorNode = currentData != null ? currentData.getDescriptorNode() : null;
        if (reloadDescriptor) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin descriptor [" + df.getAbsolutePath() + "]");
            descriptorNode = readJsonNode(df);
            if (descriptorNode == null) {
                // Failed to read descriptor data, nothing we can do about it
                continue;
            }
        } else if (descriptorNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin descriptor node is null for [" + df.getAbsolutePath() + "]");
            continue;
        }
        // Read configuration data
        JsonNode configurationNode = currentData != null ? currentData.getConfigurationNode() : null;
        if (reloadConfiguration) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin configuration [" + cf.getAbsolutePath() + "]");
            configurationNode = readConfigurationNode(cf);
            if (configurationNode == null) {
                // Failed to read configuration data, use empty object
                configurationNode = createEmptyObjectNode();
            }
        } else if (configurationNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin configuration node is null for [" + cf.getAbsolutePath() + "]");
            continue;
        }
        // Update data
        if (reloadDescriptor || reloadConfiguration) {
            PluginData newData = new PluginData(descriptorNode, descriptorLastModified, configurationNode, configurationLastModified, mapper.getNodeFactory());
            // Validate data
            boolean dataValid = newData.validate(new PluginData.ValidationCallback() {

                @Override
                public void descriptorError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + df.getAbsolutePath() + "]: " + message);
                }

                @Override
                public void configurationError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + cf.getAbsolutePath() + "]: " + message);
                }
            });
            if (!dataValid) {
                // Data validation failed, nothing we can do about it
                continue;
            }
            entriesToUpdate.put(descriptorFilePath, newData);
        }
        keysToCheckForRemoval.remove(descriptorFilePath);
    }
    // Compare cached data against (possibly missing) files
    for (String descriptorFilePath : keysToCheckForRemoval) {
        File df = new File(descriptorFilePath);
        if (!df.exists()) {
            // Descriptor data file has gone missing
            keysToRemove.add(descriptorFilePath);
        }
    }
    // Perform data updates
    currentDataMapCopy.putAll(entriesToUpdate);
    currentDataMapCopy.keySet().removeAll(keysToRemove);
}
#method_after
void reloadData(File[] descriptorFiles, Map<String, PluginData> currentDataMapCopy) {
    Map<String, PluginData> entriesToUpdate = new HashMap<String, PluginData>();
    Set<String> keysToRemove = new HashSet<String>();
    // Optimization: make sure we don't check data that we already processed
    Set<String> keysToCheckForRemoval = new HashSet<String>(currentDataMapCopy.keySet());
    // Compare (possibly added or modified) files against cached data
    for (final File df : descriptorFiles) {
        final File cf = new File(pluginConfigDir, getConfigurationFileName(df));
        String descriptorFilePath = df.getAbsolutePath();
        PluginData currentData = currentDataMapCopy.get(descriptorFilePath);
        long descriptorLastModified = df.lastModified();
        long configurationLastModified = isJsonFile(cf) ? cf.lastModified() : MISSING_FILE_LAST_MODIFIED;
        // Check if data needs to be reloaded
        boolean reloadDescriptor, reloadConfiguration;
        if (currentDataMapCopy.containsKey(descriptorFilePath)) {
            reloadDescriptor = descriptorLastModified > currentData.getDescriptorLastModified();
            reloadConfiguration = configurationLastModified > currentData.getConfigurationLastModified();
            // Change in descriptor causes reload of configuration
            reloadConfiguration |= reloadDescriptor;
            // Refresh configuration if the corresponding file has gone missing
            reloadConfiguration |= (configurationLastModified == MISSING_FILE_LAST_MODIFIED && currentData.getConfigurationLastModified() != MISSING_FILE_LAST_MODIFIED);
        } else {
            reloadDescriptor = true;
            reloadConfiguration = true;
        }
        // Read descriptor data
        JsonNode descriptorNode = currentData != null ? currentData.getDescriptorNode() : null;
        if (reloadDescriptor) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin descriptor [" + df.getAbsolutePath() + "]");
            descriptorNode = readJsonNode(df);
            if (descriptorNode == null) {
                // Failed to read descriptor data, nothing we can do about it
                continue;
            }
        } else if (descriptorNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin descriptor node is null for [" + df.getAbsolutePath() + "]");
            continue;
        }
        // Read configuration data
        JsonNode configurationNode = currentData != null ? currentData.getConfigurationNode() : null;
        if (reloadConfiguration) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin configuration [" + cf.getAbsolutePath() + "]");
            configurationNode = readConfigurationNode(cf);
            if (configurationNode == null) {
                // Failed to read configuration data, use empty object
                configurationNode = createEmptyObjectNode();
            }
        } else if (configurationNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin configuration node is null for [" + cf.getAbsolutePath() + "]");
            continue;
        }
        // Update data
        if (reloadDescriptor || reloadConfiguration) {
            PluginData newData = new PluginData(descriptorNode, descriptorLastModified, configurationNode, configurationLastModified, mapper.getNodeFactory());
            // Validate data
            boolean dataValid = newData.validate(new PluginData.ValidationCallback() {

                @Override
                public void descriptorError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + df.getAbsolutePath() + "]: " + message);
                }

                @Override
                public void configurationError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + cf.getAbsolutePath() + "]: " + message);
                }
            });
            if (!dataValid) {
                // Data validation failed, nothing we can do about it
                continue;
            }
            entriesToUpdate.put(descriptorFilePath, newData);
        }
        keysToCheckForRemoval.remove(descriptorFilePath);
    }
    // Compare cached data against (possibly missing) files
    for (String descriptorFilePath : keysToCheckForRemoval) {
        File df = new File(descriptorFilePath);
        if (!df.exists()) {
            // Descriptor data file has gone missing
            keysToRemove.add(descriptorFilePath);
        }
    }
    // Perform data updates
    currentDataMapCopy.putAll(entriesToUpdate);
    currentDataMapCopy.keySet().removeAll(keysToRemove);
}
#end_block

#method_before
private void _threadMain() {
    try {
        boolean terminate = false;
        while (!terminate) {
            Event.Base bevent = _parser.nextEvent();
            log.debugFormat("Installation of {0}: Event {1}", _vds.getHostName(), bevent);
            if (bevent instanceof Event.Terminate) {
                terminate = true;
            } else if (bevent instanceof Event.Log) {
                Event.Log event = (Event.Log) bevent;
                InstallerMessages.Severity severity;
                switch(event.severity) {
                    case INFO:
                        severity = InstallerMessages.Severity.INFO;
                        break;
                    case WARNING:
                        severity = InstallerMessages.Severity.WARNING;
                        break;
                    default:
                        severity = InstallerMessages.Severity.ERROR;
                        break;
                }
                _messages.post(severity, event.record);
            } else if (bevent instanceof Event.Confirm) {
                Event.Confirm event = (Event.Confirm) bevent;
                if (Confirms.GPG_KEY.equals(event.what)) {
                    _messages.post(InstallerMessages.Severity.WARNING, event.description);
                    event.reply = true;
                } else if (org.ovirt.ovirt_host_deploy.constants.Confirms.DEPLOY_PROCEED.equals(event.what)) {
                    event.reply = true;
                } else {
                    log.warnFormat("Installation of {0}: Not confirming {1}: ${2}", _vds.getHostName(), event.what, event.description);
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryString) {
                Event.QueryString event = (Event.QueryString) bevent;
                if (Queries.CUSTOMIZATION_COMMAND.equals(event.name)) {
                    _nextCustomizationEntry();
                } else if (Queries.TERMINATION_COMMAND.equals(event.name)) {
                    _nextTerminationEntry();
                } else {
                    throw new Exception(String.format("Unexpected query %1$s", event));
                }
            } else if (bevent instanceof Event.QueryValue) {
                Event.QueryValue event = (Event.QueryValue) bevent;
                if (Queries.TIME.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Setting time");
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmssZ");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    event.value = format.format(Calendar.getInstance().getTime());
                } else {
                    event.abort = true;
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryMultiString) {
                Event.QueryMultiString event = (Event.QueryMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Queries.CERTIFICATE_CHAIN.equals(event.name)) {
                    event.value = (_pkiResources.getAsString(PKIResources.Resource.CACertificate, PKIResources.OutputType.X509_PEM) + _certificate).split("\n");
                    _parser.sendResponse(event);
                } else {
                    event.abort = true;
                    _parser.sendResponse(event);
                }
            } else if (bevent instanceof Event.DisplayMultiString) {
                Event.DisplayMultiString event = (Event.DisplayMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Displays.CERTIFICATE_REQUEST.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Enrolling certificate");
                    _certificate = OpenSslCAWrapper.signCertificateRequest(StringUtils.join(event.value, "\n"), _vds.getHostName());
                }
            } else {
                throw new SoftError(String.format("Unexpected event '%1$s'", bevent));
            }
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during deploy dialog", e);
        _control.disconnect();
    }
}
#method_after
private void _threadMain() {
    try {
        boolean terminate = false;
        while (!terminate) {
            Event.Base bevent = _parser.nextEvent();
            log.debugFormat("Installation of {0}: Event {1}", _vds.getHostName(), bevent);
            if (bevent instanceof Event.Terminate) {
                terminate = true;
            } else if (bevent instanceof Event.Log) {
                Event.Log event = (Event.Log) bevent;
                InstallerMessages.Severity severity;
                switch(event.severity) {
                    case INFO:
                        severity = InstallerMessages.Severity.INFO;
                        break;
                    case WARNING:
                        severity = InstallerMessages.Severity.WARNING;
                        break;
                    default:
                        severity = InstallerMessages.Severity.ERROR;
                        break;
                }
                _messages.post(severity, event.record);
            } else if (bevent instanceof Event.Confirm) {
                Event.Confirm event = (Event.Confirm) bevent;
                if (Confirms.GPG_KEY.equals(event.what)) {
                    _messages.post(InstallerMessages.Severity.WARNING, event.description);
                    event.reply = true;
                } else if (org.ovirt.ovirt_host_deploy.constants.Confirms.DEPLOY_PROCEED.equals(event.what)) {
                    event.reply = true;
                } else {
                    log.warnFormat("Installation of {0}: Not confirming {1}: ${2}", _vds.getHostName(), event.what, event.description);
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryString) {
                Event.QueryString event = (Event.QueryString) bevent;
                if (Queries.CUSTOMIZATION_COMMAND.equals(event.name)) {
                    _nextCustomizationEntry();
                } else if (Queries.TERMINATION_COMMAND.equals(event.name)) {
                    _nextTerminationEntry();
                } else {
                    throw new Exception(String.format("Unexpected query %1$s", event));
                }
            } else if (bevent instanceof Event.QueryValue) {
                Event.QueryValue event = (Event.QueryValue) bevent;
                if (Queries.TIME.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Setting time");
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmssZ");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    event.value = format.format(Calendar.getInstance().getTime());
                } else {
                    event.abort = true;
                }
                _parser.sendResponse(event);
            } else if (bevent instanceof Event.QueryMultiString) {
                Event.QueryMultiString event = (Event.QueryMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Queries.CERTIFICATE_CHAIN.equals(event.name)) {
                    event.value = (_pkiResources.getAsString(PKIResources.Resource.CACertificate, PKIResources.OutputType.X509_PEM) + _certificate).split("\n");
                    _parser.sendResponse(event);
                } else {
                    event.abort = true;
                    _parser.sendResponse(event);
                }
            } else if (bevent instanceof Event.DisplayMultiString) {
                Event.DisplayMultiString event = (Event.DisplayMultiString) bevent;
                if (org.ovirt.ovirt_host_deploy.constants.Displays.CERTIFICATE_REQUEST.equals(event.name)) {
                    _messages.post(InstallerMessages.Severity.INFO, "Enrolling certificate");
                    _certificate = OpenSslCAWrapper.signCertificateRequest(StringUtils.join(event.value, "\n"), _vds.getHostName());
                }
            } else {
                throw new SoftError(String.format("Unexpected event '%1$s'", bevent));
            }
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during deploy dialog", e);
        try {
            _control.close();
        } catch (IOException ee) {
            log.error("Error during close", e);
        }
    }
}
#end_block

#method_before
@Override
protected void finalize() {
    close();
}
#method_after
@Override
protected void finalize() {
    try {
        close();
    } catch (IOException e) {
        log.error("Exception during finalize", e);
    }
}
#end_block

#method_before
public void close() {
    stop();
    if (_dialog != null) {
        _dialog.disconnect();
        _dialog = null;
    }
}
#method_after
public void close() throws IOException {
    stop();
    if (_dialog != null) {
        _dialog.close();
        _dialog = null;
    }
}
#end_block

#method_before
public void execute() throws Exception {
    InputStream in = null;
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>GetValue(ConfigValues.BootstrapCommand);
        // in future we should set here LANG, LC_ALL
        command = command.replace(BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.infoFormat("Installation of {0}. Executing command via SSH {1} < {2}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        in = new FileInputStream(s_deployPackage.getFile());
        _dialog.executeCommand(this, command, new InputStream[] { in });
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        } else if (_goingToReboot) {
            _deployStatus = DeployStatus.Reboot;
        } else if (_installIncomplete) {
            _deployStatus = DeployStatus.Incomplete;
        } else {
            _deployStatus = DeployStatus.Complete;
        }
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during host {0} install", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during host {0} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            _messages.post(InstallerMessages.Severity.ERROR, e.getMessage());
            log.errorFormat("Error during host {0} install, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close deploy package", e);
            }
        }
    }
}
#method_after
public void execute() throws Exception {
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>GetValue(ConfigValues.BootstrapCommand);
        // in future we should set here LANG, LC_ALL
        command = command.replace(BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.infoFormat("Installation of {0}. Executing command via SSH {1} < {2}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        try (final InputStream in = new FileInputStream(s_deployPackage.getFile())) {
            _dialog.executeCommand(this, command, new InputStream[] { in });
        }
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        } else if (_goingToReboot) {
            _deployStatus = DeployStatus.Reboot;
        } else if (_installIncomplete) {
            _deployStatus = DeployStatus.Incomplete;
        } else {
            _deployStatus = DeployStatus.Complete;
        }
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during host {0} install", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during host {0} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            _messages.post(InstallerMessages.Severity.ERROR, e.getMessage());
            log.errorFormat("Error during host {0} install, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#end_block

#method_before
public static String signCertificateRequest(String request, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", hostname)));
        os.write(request.getBytes(Charset.forName("UTF-8")));
    } finally {
        if (os != null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(new File(config.getPKIDir(), "certs"), String.format("%s.cer", hostname)).getPath());
}
#method_after
public static String signCertificateRequest(String request, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    try (final OutputStream os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", hostname)))) {
        os.write(request.getBytes(Charset.forName("UTF-8")));
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(new File(config.getPKIDir(), "certs"), String.format("%s.cer", hostname)).getPath());
}
#end_block

#method_before
private boolean runCommandArray(String[] command_array, int signatureTimeout) {
    boolean returnValue = true;
    String outputString = null;
    String errorString = null;
    BufferedReader stdOutput = null;
    BufferedReader stdError = null;
    try {
        log.debug("Running Sign Certificate request script");
        Process process = getRuntime().exec(command_array);
        stdOutput = new BufferedReader(new InputStreamReader(process.getInputStream(), Charset.forName("UTF-8")));
        stdError = new BufferedReader(new InputStreamReader(process.getErrorStream(), Charset.forName("UTF-8")));
        int exitCode = 0;
        boolean completed = false;
        for (int x = 0; x < signatureTimeout; x++) {
            try {
                Thread.sleep(1000);
                exitCode = process.exitValue();
                completed = true;
                break;
            } catch (IllegalThreadStateException | InterruptedException e) {
            // keep going
            }
        }
        outputString += readAllLines(stdOutput);
        errorString += readAllLines(stdError);
        if (!completed) {
            process.destroy();
            returnValue = false;
            log.error("Sign Certificate request script killed due to timeout");
            logOutputAndErrors(outputString, errorString);
        } else if (exitCode != 0) {
            returnValue = false;
            log.error("Sign Certificate request failed with exit code " + exitCode);
            logOutputAndErrors(outputString, errorString);
        } else {
            log.debug("Successfully completed certificate signing script");
        }
    } catch (IOException e) {
        log.error("Exception signing the certificate", e);
        logOutputAndErrors(outputString, errorString);
        returnValue = false;
    } finally {
        // Close the BufferedReaders
        try {
            if (stdOutput != null) {
                stdOutput.close();
            }
            if (stdError != null) {
                stdError.close();
            }
        } catch (IOException ex) {
            log.error("Unable to close BufferedReader");
        }
    }
    return returnValue;
}
#method_after
private boolean runCommandArray(String[] command_array, int signatureTimeout) {
    boolean returnValue = true;
    String outputString = null;
    String errorString = null;
    try {
        log.debug("Running Sign Certificate request script");
        Process process = getRuntime().exec(command_array);
        try (final BufferedReader stdOutput = new BufferedReader(new InputStreamReader(process.getInputStream(), Charset.forName("UTF-8")));
            final BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream(), Charset.forName("UTF-8")))) {
            int exitCode = 0;
            boolean completed = false;
            for (int x = 0; x < signatureTimeout; x++) {
                try {
                    Thread.sleep(1000);
                    exitCode = process.exitValue();
                    completed = true;
                    break;
                } catch (IllegalThreadStateException | InterruptedException e) {
                // keep going
                }
            }
            outputString = readAllLines(stdOutput);
            errorString = readAllLines(stdError);
            if (!completed) {
                process.destroy();
                returnValue = false;
                log.error("Sign Certificate request script killed due to timeout");
                logOutputAndErrors(outputString, errorString);
            } else if (exitCode != 0) {
                returnValue = false;
                log.error("Sign Certificate request failed with exit code " + exitCode);
                logOutputAndErrors(outputString, errorString);
            } else {
                log.debug("Successfully completed certificate signing script");
            }
        }
    } catch (IOException e) {
        log.error("Exception signing the certificate", e);
        logOutputAndErrors(outputString, errorString);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(getDisk()) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation() && virtIoScsiDiskValidation();
}
#method_after
@Override
protected boolean canDoAction() {
    performDbLoads();
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(getDisk()) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation() && virtIoScsiDiskValidation();
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getDisk().getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#end_block

#method_before
@Test
public void canDoActionFailedGuestOsIsNotSupported() {
    VM vm = mockVmStatusUp();
    // rhel3x64
    vm.setVmOs(15);
    cretaeVirtIODisk();
    when(osRepository.getOsName(15)).thenReturn("RHEL3x64");
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<String>());
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailedGuestOsIsNotSupported() {
    VM vm = mockVmStatusUp();
    // rhel3x64
    vm.setVmOs(15);
    cretaeVirtIODisk();
    when(osRepository.getOsName(15)).thenReturn("RHEL3x64");
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(Collections.<String>emptySet());
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED.toString()));
}
#end_block

#method_before
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#method_after
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    mockVmDevice(false);
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
    doReturn(vmNetworkInterfaceDao).when(command).getVmNetworkInterfaceDao();
}
#end_block

#method_before
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class))).thenReturn(vmList);
}
#method_after
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#end_block

#method_before
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    return disk;
}
#method_after
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#end_block

#method_before
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(false);
}
#method_after
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#end_block

#method_before
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            getMacPoolManager().freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#method_after
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        removeFromExternalNetworks(interfaces);
        for (VmNic iface : interfaces) {
            getMacPoolManager().freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#end_block

#method_before
@Before
public void setupMocks() {
    MockitoAnnotations.initMocks(this);
    doReturn(macPoolManager).when(vmInterfaceManager).getMacPoolManager();
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#method_after
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    MockitoAnnotations.initMocks(this);
    doReturn(macPoolManager).when(vmInterfaceManager).getMacPoolManager();
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        retValue = canRunActionOnNonManagedVm();
    }
    if (retValue && getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        retValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (retValue) {
        disk = getDiskDao().get((Guid) getParameters().getEntityInfo().getId());
        retValue = isDiskExist(disk);
    }
    if (retValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
        if (vmDevice == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
        }
    }
    if (retValue && Boolean.TRUE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        retValue = isInterfaceSupportedForPlugUnPlug(disk);
    }
    if (retValue && Boolean.FALSE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        retValue = false;
    }
    // Check if disk has no snapshots before detaching it.
    if (retValue && DiskStorageType.IMAGE == disk.getDiskStorageType() && getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        retValue = canRunActionOnNonManagedVm();
    }
    if (retValue && getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        retValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (retValue) {
        disk = loadDisk((Guid) getParameters().getEntityInfo().getId());
        retValue = isDiskExist(disk);
    }
    if (retValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
        if (vmDevice == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
        }
        if (retValue && vmDevice.getSnapshotId() != null) {
            disk = loadDiskFromSnapshot(disk.getId(), vmDevice.getSnapshotId());
        }
    }
    if (retValue && Boolean.TRUE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        retValue = isInterfaceSupportedForPlugUnPlug(disk);
    }
    if (retValue && Boolean.FALSE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        retValue = false;
    }
    // Check if disk has no snapshots before detaching it.
    if (retValue && DiskStorageType.IMAGE == disk.getDiskStorageType()) {
        // therefore for attached disk snapshot it shouldn't be checked whether it has snapshots or not.
        if (vmDevice.getSnapshotId() == null && getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    if (!disk.isDiskSnapshot()) {
        // clears snapshot ID
        getImageDao().updateImageVmSnapshotId(((DiskImage) disk).getImageId(), null);
    }
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
    }
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
        return false;
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (disk.isAllowSnapshot()) {
        updateDiskVmSnapshotId();
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#end_block

#method_before
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null);
}
#method_after
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null, getParameters().getSnapshotId());
}
#end_block

#method_before
protected void removeVmNetwork() {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS vds = getVds();
    VDSGroup cluster = getVdsGroup();
    boolean vdsmVersionSupportedByEngine = false;
    // check that vdc support vds OR vds support vdc
    Version partialVdcVersion = new Version(new Version(Config.<String>GetValue(ConfigValues.VdcVersion)).toString(2));
    RpmVersion vdsVersion = vds.getVersion();
    Version vdsmVersion = new Version(vdsVersion.getMajor(), vdsVersion.getMinor());
    if (!StringUtils.isEmpty(vds.getSupportedEngines())) {
        vdsmVersionSupportedByEngine = vds.getSupportedENGINESVersionsSet().contains(partialVdcVersion);
    }
    // version is not supported
    if (!vdsmVersionSupportedByEngine && !Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).contains(vdsmVersion)) {
        reportNonOperationReason(NonOperationalReason.VERSION_INCOMPATIBLE_WITH_CLUSTER, Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).toString(), vdsmVersion.toString());
    } else if (!VersionSupport.checkClusterVersionSupported(cluster.getcompatibility_version(), vds)) {
        reportNonOperationReason(NonOperationalReason.CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER, cluster.getcompatibility_version().toString(), vds.getSupportedClusterLevels().toString());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VDS vds = getVds();
    VDSGroup cluster = getVdsGroup();
    boolean isEngineSupportedByVdsm = false;
    // partialVdcVersion will hold the engine's version (minor and major parts),
    // this will be compared to vdsm supported engines to see if vdsm can be added
    // to cluster
    Version partialVdcVersion = new Version(new Version(Config.<String>GetValue(ConfigValues.VdcVersion)).toString(2));
    RpmVersion vdsVersion = vds.getVersion();
    Version vdsmVersion = new Version(vdsVersion.getMajor(), vdsVersion.getMinor());
    if (!StringUtils.isEmpty(vds.getSupportedEngines())) {
        isEngineSupportedByVdsm = vds.getSupportedENGINESVersionsSet().contains(partialVdcVersion);
    }
    // and cluster supports the specific vdsm version. which is sufficient
    if (!isEngineSupportedByVdsm && !Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).contains(vdsmVersion)) {
        reportNonOperationReason(NonOperationalReason.VERSION_INCOMPATIBLE_WITH_CLUSTER, Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).toString(), vdsmVersion.toString());
    } else if (!VersionSupport.checkClusterVersionSupported(cluster.getcompatibility_version(), vds)) {
        reportNonOperationReason(NonOperationalReason.CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER, cluster.getcompatibility_version().toString(), vds.getSupportedClusterLevels().toString());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resource = getMyParameter("resource", request);
    String format = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resource == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        Details details = pkiResources.get(resource);
        if (details == null) {
            throw new IllegalArgumentException(String.format("Resource %1$s is invalid", resource));
        }
        if (format == null) {
            format = details.format;
        }
        if (alias == null) {
            alias = details.alias;
        }
        try (InputStream in = new FileInputStream(details.file)) {
            final Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(in);
            if (format.startsWith("X509-PEM")) {
                if (format.endsWith("-CA")) {
                    response.setContentType("application/x-x509-ca-cert");
                } else {
                    response.setContentType("application/x-x509-cert");
                }
                // do not let println to use platform specific new line
                response.getWriter().print(String.format(("-----BEGIN CERTIFICATE-----%1$c" + "%2$s" + "-----END CERTIFICATE-----%1$c"), '\n', new Base64(76, new byte[] { (byte) '\n' }).encodeToString(certificate.getEncoded())));
            } else if ("RFC4716".equals(format)) {
                response.setContentType("text/plain");
                // do not let println to use platform specific new line
                response.getWriter().print(OpenSSHUtils.getKeyString(certificate.getPublicKey(), alias));
            } else {
                throw new IllegalArgumentException(String.format("Unsupported output format %1$s", format));
            }
        }
    } catch (FileNotFoundException e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());
    } catch (Exception e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resource = getMyParameter("resource", request);
    String format = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resource == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        Details details = pkiResources.get(resource);
        if (details == null) {
            throw new IllegalArgumentException(String.format("Resource '%1$s' is invalid", resource));
        }
        if (format == null) {
            format = details.format;
        }
        if (alias == null) {
            alias = details.alias;
        }
        try (InputStream in = new FileInputStream(details.file)) {
            final Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(in);
            if (format.startsWith("X509-PEM")) {
                if (format.endsWith("-CA")) {
                    response.setContentType("application/x-x509-ca-cert");
                } else {
                    response.setContentType("application/x-x509-cert");
                }
                // do not let println to use platform specific new line
                response.getWriter().print(String.format(("-----BEGIN CERTIFICATE-----%1$c" + "%2$s" + "-----END CERTIFICATE-----%1$c"), '\n', new Base64(76, new byte[] { (byte) '\n' }).encodeToString(certificate.getEncoded())));
            } else if ("OPENSSH-PUBKEY".equals(format)) {
                response.setContentType("text/plain");
                // do not let println to use platform specific new line
                response.getWriter().print(OpenSSHUtils.getKeyString(certificate.getPublicKey(), alias));
            } else {
                throw new IllegalArgumentException(String.format("Unsupported output format '%1$s'", format));
            }
        }
    } catch (FileNotFoundException e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());
    } catch (Exception e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#end_block

#method_before
public void close() throws IOException {
    try {
        if (_session != null) {
            _session.close(true);
            _session = null;
        }
        if (_client != null) {
            _client.stop();
            _client = null;
        }
    } catch (Exception e) {
        log.error("Failed to close session", e);
    }
}
#method_after
public void close() throws IOException {
    try {
        if (_session != null) {
            _session.close(true);
            _session = null;
        }
        if (_client != null) {
            _client.stop();
            _client = null;
        }
    } catch (Exception e) {
        log.error("Failed to close session", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
public void executeCommand(String command, InputStream in, OutputStream out, OutputStream err) throws Exception {
    log.debug(String.format("Executing: '%1$s'", command));
    if (in == null) {
        in = new ByteArrayInputStream(new byte[0]);
    }
    if (out == null) {
        out = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    if (err == null) {
        err = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    /*
         * Redirect streams into indexed streams.
         */
    ProgressInputStream iin = new ProgressInputStream(in);
    ProgressOutputStream iout = new ProgressOutputStream(out);
    ProgressOutputStream ierr = new ProgressOutputStream(err);
    ClientChannel channel = _session.createExecChannel(command);
    try {
        channel.setIn(iin);
        channel.setOut(iout);
        channel.setErr(ierr);
        channel.open();
        long hardEnd = 0;
        if (_hardTimeout != 0) {
            hardEnd = System.currentTimeMillis() + _hardTimeout;
        }
        boolean hardTimeout = false;
        int stat;
        boolean activity;
        do {
            stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EOF | ClientChannel.TIMEOUT), _softTimeout);
            hardTimeout = (hardEnd != 0 && System.currentTimeMillis() >= hardEnd);
            /*
                 * Notice that we should visit all
                 * so do not cascade statement.
                 */
            activity = iin.wasProgress();
            activity = iout.wasProgress() || activity;
            activity = ierr.wasProgress() || activity;
        } while (!hardTimeout && (stat & ClientChannel.TIMEOUT) != 0 && activity);
        if (hardTimeout) {
            throw new TimeLimitExceededException(String.format("SSH session hard timeout host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout host '%1$s'", this.getDisplayHost()));
        }
        stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EXIT_STATUS | ClientChannel.EXIT_SIGNAL | ClientChannel.TIMEOUT), _softTimeout);
        if ((stat & ClientChannel.EXIT_SIGNAL) != 0) {
            throw new IOException(String.format("Signal received during SSH session host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.EXIT_STATUS) != 0 && channel.getExitStatus() != 0) {
            throw new IOException(String.format("Command returned failure code %2$d during SSH session '%1$s'", this.getDisplayHost(), channel.getExitStatus()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout waiting for status host '%1$s'", this.getDisplayHost()));
        }
    } catch (RuntimeException e) {
        log.debug("Execute failed", e);
        throw e;
    } finally {
        int stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.TIMEOUT), 1);
        if ((stat & ClientChannel.CLOSED) != 0) {
            channel.close(true);
        }
    }
    log.debug(String.format("Executed: '%1$s'", command));
}
#method_after
public void executeCommand(String command, InputStream in, OutputStream out, OutputStream err) throws Exception {
    log.debug(String.format("Executing: '%1$s'", command));
    InputStream _xin = null;
    OutputStream _xout = null;
    OutputStream _xerr = null;
    if (in == null) {
        _xin = in = new ByteArrayInputStream(new byte[0]);
    }
    if (out == null) {
        _xout = out = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    if (err == null) {
        _xerr = err = new ConstraintByteArrayOutputStream(CONSTRAINT_BUFFER_SIZE);
    }
    /*
         * Redirect streams into indexed streams.
         */
    ClientChannel channel = null;
    try (final InputStream _xxin = _xin;
        final OutputStream _xxout = _xout;
        final OutputStream _xxerr = _xerr;
        final ProgressInputStream iin = new ProgressInputStream(in);
        final ProgressOutputStream iout = new ProgressOutputStream(out);
        final ProgressOutputStream ierr = new ProgressOutputStream(err)) {
        channel = _session.createExecChannel(command);
        channel.setIn(iin);
        channel.setOut(iout);
        channel.setErr(ierr);
        channel.open();
        long hardEnd = 0;
        if (_hardTimeout != 0) {
            hardEnd = System.currentTimeMillis() + _hardTimeout;
        }
        boolean hardTimeout = false;
        int stat;
        boolean activity;
        do {
            stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EOF | ClientChannel.TIMEOUT), _softTimeout);
            hardTimeout = (hardEnd != 0 && System.currentTimeMillis() >= hardEnd);
            /*
                 * Notice that we should visit all
                 * so do not cascade statement.
                 */
            activity = iin.wasProgress();
            activity = iout.wasProgress() || activity;
            activity = ierr.wasProgress() || activity;
        } while (!hardTimeout && (stat & ClientChannel.TIMEOUT) != 0 && activity);
        if (hardTimeout) {
            throw new TimeLimitExceededException(String.format("SSH session hard timeout host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout host '%1$s'", this.getDisplayHost()));
        }
        stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.EXIT_STATUS | ClientChannel.EXIT_SIGNAL | ClientChannel.TIMEOUT), _softTimeout);
        if ((stat & ClientChannel.EXIT_SIGNAL) != 0) {
            throw new IOException(String.format("Signal received during SSH session host '%1$s'", this.getDisplayHost()));
        }
        if ((stat & ClientChannel.EXIT_STATUS) != 0 && channel.getExitStatus() != 0) {
            throw new IOException(String.format("Command returned failure code %2$d during SSH session '%1$s'", this.getDisplayHost(), channel.getExitStatus()));
        }
        if ((stat & ClientChannel.TIMEOUT) != 0) {
            throw new TimeLimitExceededException(String.format("SSH session timeout waiting for status host '%1$s'", this.getDisplayHost()));
        }
    } catch (RuntimeException e) {
        log.debug("Execute failed", e);
        throw e;
    } finally {
        if (channel != null) {
            int stat = channel.waitFor((ClientChannel.CLOSED | ClientChannel.TIMEOUT), 1);
            if ((stat & ClientChannel.CLOSED) != 0) {
                channel.close(true);
            }
        }
    }
    log.debug(String.format("Executed: '%1$s'", command));
}
#end_block

#method_before
@Test
public void testProperties() {
    try (final SSHClient ssh = new SSHClient()) {
        assertEquals(ssh.getHost(), null);
        assertEquals(ssh.getPort(), 22);
        assertEquals(ssh.getUser(), null);
        assertEquals(ssh.getDisplayHost(), "N/A");
        ssh.setHost("host1");
        assertEquals(ssh.getHost(), "host1");
        assertEquals(ssh.getDisplayHost(), "host1");
        ssh.setHost("host1", 1234);
        assertEquals(ssh.getPort(), 1234);
        assertEquals(ssh.getDisplayHost(), "host1:1234");
        ssh.setUser("user1");
        assertEquals(ssh.getUser(), "user1");
        assertEquals(ssh.getDisplayHost(), "user1@host1:1234");
        ssh.setHost("host2");
        assertEquals(ssh.getDisplayHost(), "user1@host2");
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Test
public void testProperties() throws IOException {
    try (final SSHClient ssh = new SSHClient()) {
        assertEquals(ssh.getHost(), null);
        assertEquals(ssh.getPort(), 22);
        assertEquals(ssh.getUser(), null);
        assertEquals(ssh.getDisplayHost(), "N/A");
        ssh.setHost("host1");
        assertEquals(ssh.getHost(), "host1");
        assertEquals(ssh.getDisplayHost(), "host1");
        ssh.setHost("host1", 1234);
        assertEquals(ssh.getPort(), 1234);
        assertEquals(ssh.getDisplayHost(), "host1:1234");
        ssh.setUser("user1");
        assertEquals(ssh.getUser(), "user1");
        assertEquals(ssh.getDisplayHost(), "user1@host1:1234");
        ssh.setHost("host2");
        assertEquals(ssh.getDisplayHost(), "user1@host2");
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    window.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType((VmType) model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((Integer) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setRunAndPause(((Boolean) model.getIsRunAndPause().getEntity()));
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions((Boolean) model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType((VmType) model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((Integer) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setRunAndPause(((Boolean) model.getIsRunAndPause().getEntity()));
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions((Boolean) model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        RunVmParams tempVar = new RunVmParams(a.getId());
        if (!a.isInitialized() && AsyncDataProvider.isWindowsOsType(a.getVmOsId())) {
            tempVar.setInitializationType(InitializationType.Sysprep);
        } else if (!a.isInitialized() && AsyncDataProvider.isLinuxOsType(a.getVmOsId())) {
            tempVar.setInitializationType(InitializationType.CloudInit);
        } else {
            tempVar.setInitializationType(InitializationType.None);
        }
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onSave() {
    final VmNetworkCreatingManager defaultNetworkCreatingManager = new VmNetworkCreatingManager(new VmNetworkCreatingManager.PostNetworkCreatedCallback() {

        @Override
        public void networkCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType((VmType) model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setVmOs((Integer) model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription((String) model.getDescription().getEntity());
    getcurrentVm().setComment((String) model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl((String) model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setPriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmNetworkCreatingManager addVmFromScratchNetworkManager = new VmNetworkCreatingManager(new VmNetworkCreatingManager.PostNetworkCreatedCallback() {

                @Override
                public void networkCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new NetworkCreateFrontendAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, param, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                        param.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void executed(FrontendMultipleActionAsyncResult result) {
                                VmListModel vmListModel1 = (VmListModel) result.getState();
                                vmListModel1.getWindow().stopProgress();
                                vmListModel1.cancel();
                            }
                        }, vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.RunAction(VdcActionType.AddVm, params, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType((VmType) model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setVmOs((Integer) model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription((String) model.getDescription().getEntity());
    getcurrentVm().setComment((String) model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl((String) model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setPriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && !model.getCpuSharesAmount().getEntity().toString().equals("")) {
        // $NON-NLS-1$
        try {
            getcurrentVm().setCpuShares(Integer.parseInt(model.getCpuSharesAmount().getEntity().toString()));
        } catch (NumberFormatException ignored) {
        }
    }
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.RunAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
            Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.StopVm));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
private void transmitMultipleQueries(final List<VdcOperation<?, ?>> queriesList) {
    if (queriesList.size() > 1 || (queriesList.size() == 1 && queriesList.get(0).getCallback() instanceof VdcOperationCallbackList)) {
        List<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
        for (VdcOperation<?, ?> operation : queriesList) {
            queryTypes.add((VdcQueryType) operation.getOperation());
            parameters.add((VdcQueryParametersBase) operation.getParameter());
        }
        getService().RunMultipleQueries((ArrayList<VdcQueryType>) queryTypes, (ArrayList<VdcQueryParametersBase>) parameters, new AsyncCallback<ArrayList<VdcQueryReturnValue>>() {

            @Override
            public void onFailure(final Throwable exception) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onFailure(callbackMap.get(callback), exception);
                    } else {
                        ((VdcOperationCallback) callback).onFailure(callbackMap.get(callback).get(0), exception);
                    }
                }
            }

            @Override
            public void onSuccess(final ArrayList<VdcQueryReturnValue> result) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    List<VdcQueryReturnValue> queryResult = (List<VdcQueryReturnValue>) getOperationResult(callbackMap.get(callback), queriesList, result);
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onSuccess(callbackMap.get(callback), queryResult);
                    } else {
                        ((VdcOperationCallback) callback).onSuccess(callbackMap.get(callback).get(0), queryResult.get(0));
                    }
                }
            }
        });
    } else {
        transmitOperation(queriesList.get(0));
    }
}
#method_after
private void transmitMultipleQueries(final List<VdcOperation<?, ?>> queriesList) {
    if (queriesList.size() > 1 || (queriesList.size() == 1 && queriesList.get(0).getCallback() instanceof VdcOperationCallbackList)) {
        List<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
        for (VdcOperation<?, ?> operation : new ArrayList<VdcOperation<?, ?>>(queriesList)) {
            if (operation.isPublic()) {
                queriesList.remove(operation);
                runPublicQuery(operation);
            } else {
                queryTypes.add((VdcQueryType) operation.getOperation());
                parameters.add((VdcQueryParametersBase) operation.getParameter());
            }
        }
        getService().RunMultipleQueries((ArrayList<VdcQueryType>) queryTypes, (ArrayList<VdcQueryParametersBase>) parameters, new AsyncCallback<ArrayList<VdcQueryReturnValue>>() {

            @Override
            public void onFailure(final Throwable exception) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onFailure(callbackMap.get(callback), exception);
                    } else {
                        ((VdcOperationCallback) callback).onFailure(callbackMap.get(callback).get(0), exception);
                    }
                }
            }

            @Override
            public void onSuccess(final ArrayList<VdcQueryReturnValue> result) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    List<VdcQueryReturnValue> queryResult = (List<VdcQueryReturnValue>) getOperationResult(callbackMap.get(callback), queriesList, result);
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onSuccess(callbackMap.get(callback), queryResult);
                    } else {
                        ((VdcOperationCallback) callback).onSuccess(callbackMap.get(callback).get(0), queryResult.get(0));
                    }
                }
            }
        });
    } else {
        transmitOperation(queriesList.get(0));
    }
}
#end_block

#method_before
List<?> getOperationResult(final List<VdcOperation<?, ?>> operationList, final List<VdcOperation<?, ?>> allOperations, final List<?> allResults) {
    List result = new ArrayList();
    for (VdcOperation<?, ?> operation : operationList) {
        int index = allOperations.indexOf(operation);
        if (index > -1) {
            result.add(allResults.get(index));
        }
    }
    return result;
}
#method_after
List<?> getOperationResult(final List<VdcOperation<?, ?>> operationList, final List<VdcOperation<?, ?>> allOperations, final List<?> allResults) {
    List result = new ArrayList();
    for (VdcOperation<?, ?> operation : operationList) {
        int index = allOperations.indexOf(operation);
        if (index > -1 && index < allResults.size()) {
            result.add(allResults.get(index));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void logout(final Object userObject, final VdcUserCallback callback) {
    getService().logOff((VdcUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            callback.onSuccess(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            callback.onFailure(caught);
        }
    });
}
#method_after
@Override
public void logout(final Object userObject, final UserCallback callback) {
    getService().logOff((DbUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            callback.onSuccess(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            callback.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    model.setMessage(ConstantsManager.getInstance().getConstants().templatesMsg());
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    template.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#method_after
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    if (isPublic) {
        getInstance().getOperationManager().addPublicOperation(operation);
    } else {
        getInstance().getOperationManager().addOperation(operation);
    }
}
#method_after
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking runQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    if (isPublic) {
        getInstance().getOperationManager().addPublicOperation(operation);
    } else {
        getInstance().getOperationManager().addOperation(operation);
    }
}
#end_block

#method_before
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final String context) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from RunMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            raiseQueryCompleteEvent(queryTypeList, context);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunPublicQuery: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                raiseQueryCompleteEvent(queryTypeList, context);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, multiCallback));
    }
    raiseQueryStartedEvent(queryTypeList, context);
    getInstance().getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final String context) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            raiseQueryCompleteEvent(queryTypeList, context);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                raiseQueryCompleteEvent(queryTypeList, context);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, multiCallback));
    }
    raiseQueryStartedEvent(queryTypeList, context);
    getInstance().getOperationManager().addOperationList(operationList);
}
#end_block

#method_before
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed RunAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
        }
    });
    getInstance().getOperationManager().addOperation(operation);
}
#method_after
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
        }
    });
    getInstance().getOperationManager().addOperation(operation);
}
#end_block

#method_before
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed RunAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, multiCallback);
        operationList.add(operation);
    }
    getInstance().getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, multiCallback);
        operationList.add(operation);
    }
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<VdcReturnValueBase>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#end_block

#method_before
@Deprecated
public static void RunMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    getInstance().runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, List<IFrontendActionAsyncCallback> callbacks) {
    RunMultipleActions(actionType, parameters, callbacks, null);
}
#end_block

#method_before
@Deprecated
public static void RunMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    VdcActionType[] actionTypes = new VdcActionType[n];
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    Arrays.fill(actionTypes, actionType);
    callbacks[n - 1] = successCallback;
    RunMultipleActions(new LinkedList<VdcActionType>(Arrays.asList(actionTypes)), parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), null, state);
}
#method_after
@Deprecated
public static void RunMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    RunMultipleActions(actionType, parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), state);
}
#end_block

#method_before
public void loginAsync(final String userName, final String password, final String domain, final boolean isAdmin, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    LoginUserParameters params = new LoginUserParameters(userName, password, domain, null, null, null);
    VdcActionType action = isAdmin ? VdcActionType.LoginAdminUser : VdcActionType.LoginUser;
    VdcOperation<VdcActionType, LoginUserParameters> loginOperation = new // Public action.
    VdcOperation<VdcActionType, LoginUserParameters>(// Public action.
    action, // Public action.
    params, // Public action.
    true, new VdcOperationCallback<VdcOperation<VdcActionType, LoginUserParameters>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, LoginUserParameters> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            getInstance().setLoggedInUser((VdcUser) result.getActionReturnValue());
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null && result.getSucceeded()) {
                getInstance().getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, LoginUserParameters> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                getInstance().setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
    getInstance().getOperationManager().loginUser(loginOperation);
}
#method_after
public void loginAsync(final String userName, final String password, final String domain, final boolean isAdmin, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    LoginUserParameters params = new LoginUserParameters(userName, password, domain, null, null, null);
    VdcActionType action = isAdmin ? VdcActionType.LoginAdminUser : VdcActionType.LoginUser;
    VdcOperation<VdcActionType, LoginUserParameters> loginOperation = new // Public action.
    VdcOperation<VdcActionType, LoginUserParameters>(// Public action.
    action, // Public action.
    params, // Public action.
    true, new VdcOperationCallback<VdcOperation<VdcActionType, LoginUserParameters>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, LoginUserParameters> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            getInstance().setLoggedInUser((DbUser) result.getActionReturnValue());
            result.setCanDoActionMessages((ArrayList<String>) translateError(result));
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null && result.getSucceeded()) {
                getInstance().getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, LoginUserParameters> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to login: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            clearLoggedInUser();
            if (callback.isHandleFailure()) {
                getInstance().setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
    getInstance().getOperationManager().loginUser(loginOperation);
}
#end_block

#method_before
@Deprecated
public static void LogoffAsync(final VdcUser vdcUser, final AsyncQuery callback) {
    getInstance().logoffAsync(vdcUser, callback);
}
#method_after
@Deprecated
public static void LogoffAsync(final DbUser dbUser, final AsyncQuery callback) {
    getInstance().logoffAsync(dbUser, callback);
}
#end_block

#method_before
public void logoffAsync(final VdcUser vdcUser, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Logoff.");
    getInstance().getOperationManager().logoutUser(vdcUser, new VdcUserCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Logoff.");
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null) {
                getInstance().getLoginHandler().onLogout();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute Logoff: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            callback.getDel().onSuccess(callback.getModel(), null);
        }
    });
}
#method_after
public void logoffAsync(final DbUser dbUser, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async logoff.");
    getInstance().getOperationManager().logoutUser(dbUser, new UserCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from logoff.");
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null) {
                getInstance().getLoginHandler().onLogout();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute logoff: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            callback.getDel().onSuccess(callback.getModel(), null);
        }
    });
}
#end_block

#method_before
public VdcUser getLoggedInUser() {
    return currentUser;
}
#method_after
public DbUser getLoggedInUser() {
    return currentUser;
}
#end_block

#method_before
public void setLoggedInUser(final VdcUser loggedInUser) {
    this.currentUser = loggedInUser;
    if (currentUser != null) {
        getOperationManager().setLoggedIn(true);
    } else {
        getOperationManager().setLoggedIn(false);
    }
}
#method_after
public void setLoggedInUser(final DbUser loggedInUser) {
    this.currentUser = loggedInUser;
    if (currentUser != null) {
        getOperationManager().setLoggedIn(true);
    } else {
        getOperationManager().setLoggedIn(false);
    }
}
#end_block

#method_before
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bind(GenericApiGWTServiceAsync.class).asEagerSingleton();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(OperationProcessor.class).asEagerSingleton();
    bind(VdcOperationManager.class).asEagerSingleton();
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(Frontend.class).asEagerSingleton();
    bind(RootPresenter.class).asEagerSingleton();
    bind(PlaceManager.class).to(placeManager).in(Singleton.class);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AppErrors.class).in(Singleton.class);
    bind(VdsmErrors.class).in(Singleton.class);
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bind(GenericApiGWTServiceAsync.class).asEagerSingleton();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(OperationProcessor.class).asEagerSingleton();
    bind(VdcOperationManager.class).asEagerSingleton();
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(Frontend.class).asEagerSingleton();
    bind(RootPresenter.class).asEagerSingleton();
    bind(PlaceManager.class).to(placeManager);
    bind(placeManager).in(Singleton.class);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AppErrors.class).in(Singleton.class);
    bind(VdsmErrors.class).in(Singleton.class);
}
#end_block

#method_before
public ListModel getPluginType() {
    return pluginType;
}
#method_after
public ListModel getPluginType() {
    return getNeutronAgentModel().getPluginType();
}
#end_block

#method_before
private String getDefaultUrl(ProviderType type) {
    if (type == null) {
        return new String();
    }
    switch(type) {
        case OPENSTACK_NETWORK:
            // $NON-NLS-1$
            return "http://localhost:9696";
        case OPENSTACK_IMAGE:
            // $NON-NLS-1$
            return "http://localhost:9292";
        case FOREMAN:
        default:
            // $NON-NLS-1$
            return "http://localhost";
    }
}
#method_after
private String getDefaultUrl(ProviderType type) {
    if (type == null) {
        // $NON-NLS-1$
        return "";
    }
    switch(type) {
        case OPENSTACK_NETWORK:
            // $NON-NLS-1$
            return "http://localhost:9696";
        case OPENSTACK_IMAGE:
            // $NON-NLS-1$
            return "http://localhost:9292";
        case FOREMAN:
        default:
            // $NON-NLS-1$
            return "http://localhost";
    }
}
#end_block

#method_before
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getPluginType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getNeutronAgentModel().validate();
    return getName().getIsValid() && getType().getIsValid() && getPluginType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getNeutronAgentModel().getIsValid();
}
#method_after
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getNeutronAgentModel().validate();
    return getName().getIsValid() && getType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getNeutronAgentModel().getIsValid();
}
#end_block

#method_before
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        OpenstackNetworkProviderProperties properties = new OpenstackNetworkProviderProperties();
        properties.setPluginType(NeutronPluginTranslator.getPluginNameForDisplayString((String) getPluginType().getSelectedItem()));
        properties.setAgentConfiguration(getNeutronAgentModel().flush());
        provider.setAdditionalProperties(properties);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenstackImageProviderProperties());
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) getUsername().getEntity());
        provider.setPassword((String) getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName((String) getTenantName().getEntity());
        }
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
    }
}
#method_after
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        getNeutronAgentModel().flush(provider);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) getUsername().getEntity());
        provider.setPassword((String) getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName((String) getTenantName().getEntity());
        }
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
    }
}
#end_block

#method_before
protected void actualSave() {
    flush();
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            sourceListModel.getSearchCommand().execute();
        }
    });
    cancel();
}
#method_after
protected void actualSave() {
    flush();
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (result.getReturnValue() == null || !result.getReturnValue().getSucceeded()) {
                return;
            }
            sourceListModel.getSearchCommand().execute();
            cancel();
        }
    });
}
#end_block

#method_before
private void takeVm() {
    VmPool entity = (VmPool) getItem().getEntity();
    VmPoolUserParameters params = new VmPoolUserParameters(entity.getVmPoolId(), Frontend.getInstance().getLoggedInUser(), false);
    params.setReinitialize(!getItem().isInitialized() && AsyncDataProvider.isWindowsOsType(getItem().getOsId()));
    Frontend.RunAction(VdcActionType.AttachUserToVmFromPoolAndRun, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                return;
            }
        }
    }, this);
}
#method_after
private void takeVm() {
    VmPool entity = (VmPool) getItem().getEntity();
    VmPoolUserParameters params = new VmPoolUserParameters(entity.getVmPoolId(), Frontend.getInstance().getLoggedInUser(), false);
    Frontend.RunAction(VdcActionType.AttachUserToVmFromPoolAndRun, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                return;
            }
        }
    }, this);
}
#end_block

#method_before
private void updateProperties() {
    VmPool entity = (VmPool) getItem().getEntity();
    getItem().setName(entity.getName());
    getItem().setDescription(entity.getVmPoolDescription());
    getItem().setIsPool(true);
    getItem().setIsServer(false);
    getItem().setStatus(VMStatus.Down);
    getItem().setIsFromPool(false);
    getItem().setPoolType(entity.getVmPoolType());
    if (poolToOsType.containsKey(entity.getVmPoolId())) {
        getItem().setOsId(poolToOsType.get(entity.getVmPoolId()));
    }
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(entity.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            PoolItemBehavior behavior = (PoolItemBehavior) target;
            if (returnValue != null) {
                VM vm = (VM) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (vm == null) {
                    return;
                }
                UserPortalItemModel model = behavior.getItem();
                model.setOsId(vm.getVmOsId());
                model.setSpiceDriverVersion(vm.getSpiceDriverVersion());
                model.setInitialized(vm.isInitialized());
                poolToOsType.put(((VmPool) model.getEntity()).getVmPoolId(), vm.getVmOsId());
            }
        }
    }));
}
#method_after
private void updateProperties() {
    VmPool entity = (VmPool) getItem().getEntity();
    getItem().setName(entity.getName());
    getItem().setDescription(entity.getVmPoolDescription());
    getItem().setIsPool(true);
    getItem().setIsServer(false);
    getItem().setStatus(VMStatus.Down);
    getItem().setIsFromPool(false);
    getItem().setPoolType(entity.getVmPoolType());
    if (poolToOsType.containsKey(entity.getVmPoolId())) {
        getItem().setOsId(poolToOsType.get(entity.getVmPoolId()));
    }
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(entity.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            PoolItemBehavior behavior = (PoolItemBehavior) target;
            if (returnValue != null) {
                VM vm = (VM) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (vm == null) {
                    return;
                }
                UserPortalItemModel model = behavior.getItem();
                model.setOsId(vm.getVmOsId());
                model.setSpiceDriverVersion(vm.getSpiceDriverVersion());
                poolToOsType.put(((VmPool) model.getEntity()).getVmPoolId(), vm.getVmOsId());
            }
        }
    }));
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return;
    }
    DisplayType type = (DisplayType) entityModel.getEntity();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
private StoragePool findDataCenterById(List<StoragePool> list, Guid id) {
    for (StoragePool dc : list) {
        if (dc.getId().equals(id)) {
            return dc;
        }
    }
    return null;
}
#method_after
private StoragePool findDataCenterById(List<StoragePool> list, Guid id) {
    if (id == null) {
        return null;
    }
    for (StoragePool dc : list) {
        if (dc.getId().equals(id)) {
            return dc;
        }
    }
    return null;
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = (Integer) getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && ((Boolean) getIsAutoAssign().getEntity()) == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && behavior.validate() && customPropertySheetValid && getQuota().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = (Integer) getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && ((Boolean) getIsAutoAssign().getEntity()) == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behavior.validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getInstance().getLoggedInUser().getUserId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    HasAdElementReconnectPermissionParameters params = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((Boolean) ((VdcQueryReturnValue) result).getReturnValue());
            if (returnValue) {
                command.execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, params, query);
}
#method_after
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getInstance().getLoggedInUser().getId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    final HasAdElementReconnectPermissionParameters consoleUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    final HasAdElementReconnectPermissionParameters portalUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(Frontend.getInstance().getLoggedInUser().getId(), vm.getId());
    final AsyncQuery portalUserReconnectPermissionQuery = new AsyncQuery();
    portalUserReconnectPermissionQuery.setModel(this);
    portalUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                displayConsoleConnectConfirmPopup(command);
            } else {
                // user will be stopped by backend validation
                command.execute();
            }
        }
    };
    final AsyncQuery consoleUserReconnectPermissionQuery = new AsyncQuery();
    consoleUserReconnectPermissionQuery.setModel(this);
    consoleUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                command.execute();
            } else {
                Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, portalUserReconnectPermParams, portalUserReconnectPermissionQuery);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, consoleUserReconnectPermParams, consoleUserReconnectPermissionQuery);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getHostPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider externalProvider = (Provider) model.getExternalProviders().getSelectedItem();
        if (externalProvider != null) {
            parameters.setProvider(externalProvider.getId());
            parameters.setNetworkMappings((String) model.getNeutronAgentModel().getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    Collections.sort((List<VDS>) getSelectedItems(), new Linq.VdsSPMPriorityComparer());
    for (VDS vds : (List<VDS>) getSelectedItems()) {
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        VdcUser vdcUser = Frontend.getInstance().getLoggedInUser();
        if (vdcUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(vdcUser.getUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            frontend.setLoggedInUser(null);
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    Frontend.LogoffAsync(frontend.getLoggedInUser(), query);
}
#method_after
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            frontend.clearLoggedInUser();
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    frontend.logoffAsync(frontend.getLoggedInUser(), query);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
void processAvailableOperations(final VdcOperationManager manager) {
    List<VdcOperation<?, ?>> operations = new ArrayList<VdcOperation<?, ?>>();
    Map<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>> usedCallbacks = new HashMap<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>>();
    VdcOperation<?, ?> operation;
    while ((operation = manager.pollOperation()) != null) {
        if (!operation.allowDuplicates() && (pending.contains(operation) || operations.contains(operation))) {
            // Skip this one as the result is pending.
            continue;
        }
        VdcOperationCallback<?, ?> newCallback = usedCallbacks.get(operation.getCallback());
        if (newCallback == null) {
            // into an unknown callback sequence, otherwise use an existing one.
            if (!(operation.getCallback() instanceof VdcOperationCallbackList)) {
                newCallback = new VdcOperationCallback<VdcOperation<?, ?>, Object>() {

                    @Override
                    public void onSuccess(final VdcOperation<?, ?> operation, final Object result) {
                        // Do nothing more than call original callback.
                        VdcOperation<?, ?> originalOperation = getOriginalOperation(operation);
                        originalOperation.getCallback().onSuccess(originalOperation, result);
                        removePending(operation);
                        // Finished, check for more operations.
                        processOperation(manager);
                    }

                    @Override
                    public void onFailure(final VdcOperation<?, ?> operation, final Throwable exception) {
                        // Remove pending, so it won't accidentally stop the re-add if possible.
                        removePending(operation);
                        // If the failure is recoverable, then add the request back into the queue.
                        if (!operation.allowDuplicates() && operation.getCopyCount() < THRESHOLD) {
                            manager.addOperation(operation);
                        } else {
                            VdcOperation<?, ?> originalOperation = getOriginalOperation(operation);
                            originalOperation.getCallback().onFailure(originalOperation, exception);
                        }
                        // Finished, check for more operations.
                        processOperation(manager);
                    }
                };
            } else {
                newCallback = new VdcOperationCallbackList<VdcOperation<?, ?>, Object>() {

                    @Override
                    public void onSuccess(final List<VdcOperation<?, ?>> operationList, final Object result) {
                        if (!operationList.isEmpty()) {
                            // All the call-backs in the list are the same, just have to call one.
                            VdcOperation<?, ?> originalOperation = getOriginalOperation(operationList.get(0));
                            VdcOperationCallback<List<VdcOperation<?, ?>>, Object> originalCallback = originalOperation.getCallback();
                            originalCallback.onSuccess(operationList, result);
                            removePending(operationList);
                            // Finished, check for more operations.
                            processOperation(manager);
                        }
                    }

                    @Override
                    public void onFailure(final List<VdcOperation<?, ?>> operationList, final Throwable exception) {
                        // If the failure is recoverable, then add the request back into the queue.
                        removePending(operationList);
                        VdcOperation<?, ?> originalOperation = getOriginalOperation(operationList.get(0));
                        // If the operation allows duplicates, it means we shouldn't retry the operation.
                        if (!operationList.get(0).allowDuplicates() && operationList.get(0).getCopyCount() < THRESHOLD) {
                            manager.addOperationList(operationList);
                        } else {
                            VdcOperationCallbackList<VdcOperation<?, ?>, Object> originalCallback = (VdcOperationCallbackList<VdcOperation<?, ?>, Object>) originalOperation.getCallback();
                            originalCallback.onFailure(operationList, exception);
                        }
                        // Finished, check for more operations.
                        processOperation(manager);
                    }
                };
            }
            usedCallbacks.put(operation.getCallback(), (VdcOperationCallback<VdcOperation<?, ?>, ?>) newCallback);
        }
        operations.add(new VdcOperation(operation, newCallback));
    }
    // Mark the operations pending.
    addPending(operations);
    communicationProvider.transmitOperationList(operations);
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
void processAvailableOperations(final VdcOperationManager manager) {
    List<VdcOperation<?, ?>> operations = new ArrayList<VdcOperation<?, ?>>();
    Map<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>> usedCallbacks = new HashMap<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>>();
    VdcOperation<?, ?> operation;
    while ((operation = manager.pollOperation()) != null) {
        if (!operation.allowDuplicates() && (pending.contains(operation) || operations.contains(operation))) {
            // Skip this one as the result is pending.
            continue;
        }
        // Check if the original callback from the operation has been replaced already. This happens only in
        // the case where the original operation is part of an operation list.
        VdcOperationCallback<?, ?> replacementCallback = usedCallbacks.get(operation.getCallback());
        if (replacementCallback == null) {
            // operation before. Re-use existing wrapper callback from the usedCallback map.
            if (!(operation.getCallback() instanceof VdcOperationCallbackList)) {
                replacementCallback = createCallback(manager);
            } else {
                replacementCallback = createListCallback(manager);
            }
            usedCallbacks.put(operation.getCallback(), (VdcOperationCallback<VdcOperation<?, ?>, ?>) replacementCallback);
        }
        operations.add(new VdcOperation(operation, replacementCallback));
    }
    // Mark the operations pending.
    addPending(operations);
    communicationProvider.transmitOperationList(operations);
}
#end_block

#method_before
public void loginUser(VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    communicationProvider.login(loginOperation);
}
#method_after
public void loginUser(final VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    communicationProvider.login(loginOperation);
}
#end_block

#method_before
public void logoutUser(final Object userObject, final VdcUserCallback<?> callback) {
    communicationProvider.logout(userObject, callback);
}
#method_after
public void logoutUser(final Object userObject, final UserCallback<?> callback) {
    communicationProvider.logout(userObject, callback);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapUser a = (LdapUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setId(a.getUserId());
                    tempVar.setFirstName(a.getName());
                    tempVar.setLastName(a.getSurName());
                    tempVar.setLoginName(a.getUserName());
                    tempVar.setDomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
private void onUserAndAdGroupsLoaded(AdElementListModel adElementListModel) {
    if (adElementListModel.getusers() != null && adElementListModel.getgroups() != null) {
        getSearchInProgress().setEntity(false);
        ArrayList<EntityModel> items = new ArrayList<EntityModel>();
        items.addAll(getusers());
        items.addAll(getgroups());
        adElementListModel.getSelectAll().setEntity(false);
        adElementListModel.setItems(items);
        setusers(null);
        setgroups(getusers());
        setIsEmpty(items.isEmpty());
    }
}
#method_after
protected void onUserAndAdGroupsLoaded(AdElementListModel adElementListModel) {
    if (adElementListModel.getusers() != null && adElementListModel.getgroups() != null) {
        getSearchInProgress().setEntity(false);
        ArrayList<EntityModel> items = new ArrayList<EntityModel>();
        items.addAll(getusers());
        items.addAll(getgroups());
        adElementListModel.getSelectAll().setEntity(false);
        adElementListModel.setItems(items);
        setusers(null);
        setgroups(getusers());
        setIsEmpty(items.isEmpty());
    }
}
#end_block

#method_before
private void updateOptionsPostData() {
    if (nics == null || disks == null) {
        return;
    }
    // Add NIC action.
    // $NON-NLS-1$
    UICommand addNicAction = new UICommand("AddNetwork", this);
    if (nics.isEmpty()) {
        addNicAction.setTitle(VmConfigureNetworkInterfacesAction);
        getCompulsoryActions().add(addNicAction);
    } else {
        addNicAction.setTitle(VmAddAnotherNetworkInterfaceAction);
        getOptionalActions().add(addNicAction);
    }
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsPostData(Collection<Disk> disks) {
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        updateOptionsData();
    }
}
#method_after
public void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                updateOptionsPostData((Collection<Disk>) returnValue);
            }
        }), getEntity().getId());
    }
}
#end_block

#method_before
public void addDisk() {
    if (getEntity() == null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(getEntity());
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
public void addDisk() {
    if (getEntity() == null) {
        return;
    }
    NewDiskModel model = new NewGuideDiskModel(this);
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(getEntity());
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
public void cancel() {
    resetData();
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#method_after
public void cancel() {
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddNetwork")) {
        addNetwork();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddDisk")) {
        addDisk();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddDisk")) {
        addDisk();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#end_block

#method_before
public VdcUser getParametersCurrentUser() {
    return parametersCurrentUser;
}
#method_after
public DbUser getParametersCurrentUser() {
    return parametersCurrentUser;
}
#end_block

#method_before
public void setParametersCurrentUser(VdcUser value) {
    parametersCurrentUser = value;
}
#method_after
public void setParametersCurrentUser(DbUser value) {
    parametersCurrentUser = value;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder(50);
    // $NON-NLS-1$
    builder.append("commandId: ");
    builder.append(getCommandId());
    // $NON-NLS-1$
    builder.append(", user: ");
    if (getParametersCurrentUser() != null) {
        builder.append(getParametersCurrentUser().getUserName());
    }
    // $NON-NLS-1$
    builder.append(", commandType: ");
    builder.append(getCommandType());
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder(50);
    // $NON-NLS-1$
    builder.append("commandId: ");
    builder.append(getCommandId());
    // $NON-NLS-1$
    builder.append(", user: ");
    if (getParametersCurrentUser() != null) {
        builder.append(getParametersCurrentUser().getLoginName());
    }
    // $NON-NLS-1$
    builder.append(", commandType: ");
    builder.append(getCommandType());
    return builder.toString();
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    VdcUser loggedUser = loginModel.getLoggedUser();
    // UiCommon login preparation
    frontend.setLoggedInUser(loggedUser);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
    // Initialize specific UI dependencies for search
    SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(AsyncDataProvider.getOsUniqueOsNames()));
}
#method_after
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
}
#end_block

#method_before
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final VdcUser vdcUser = autoLoginData.getVdcUser();
    frontend.setLoggedInUser(vdcUser);
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(vdcUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#method_after
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser vdcUser = autoLoginData.getVdcUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(vdcUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#end_block

#method_before
@Test
public void testLoginAsync_404_failure() {
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#method_after
@Test
public void testLoginAsync_404_failure() {
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#end_block

#method_before
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
@Test
public void testLogoffAsync_ignored_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler, never()).runQueryFailed(null);
    verify(mockAsyncCallback, never()).onSuccess(model, null);
}
#method_after
@Test
public void testLogoffAsync_ignored_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler, never()).runQueryFailed(null);
    verify(mockAsyncCallback, never()).onSuccess(model, null);
}
#end_block

#method_before
@Test
public void testLogoffAsync_404_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockAsyncCallback).onSuccess(model, null);
}
#method_after
@Test
public void testLogoffAsync_404_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockAsyncCallback).onSuccess(model, null);
}
#end_block

#method_before
@Test
public void testLogoffAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLogout();
}
#method_after
@Test
public void testLogoffAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLogout();
}
#end_block

#method_before
public VdcUser getLoggedUser() {
    return privateLoggedUser;
}
#method_after
public DbUser getLoggedUser() {
    return privateLoggedUser;
}
#end_block

#method_before
protected void setLoggedUser(VdcUser value) {
    privateLoggedUser = value;
}
#method_after
protected void setLoggedUser(DbUser value) {
    privateLoggedUser = value;
}
#end_block

#method_before
public void login() {
    if (!validate()) {
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            VdcUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (VdcUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, true, _asyncQuery);
}
#method_after
public void login() {
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            DbUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (DbUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, true, _asyncQuery);
}
#end_block

#method_before
public void autoLogin(VdcUser user) {
    loggingInAutomatically = true;
    getUserName().setEntity(user.getUserName());
    getDomain().setSelectedItem(user.getDomainControler());
    disableLoginScreen();
    setLoggedUser(user);
    raiseLoggedInEvent();
}
#method_after
public void autoLogin(DbUser user) {
    loggingInAutomatically = true;
    getUserName().setEntity(user.getLoginName());
    getDomain().setSelectedItem(user.getDomain());
    disableLoginScreen();
    setLoggedUser(user);
    Frontend.getInstance().setLoggedInUser(user);
    raiseLoggedInEvent();
}
#end_block

#method_before
@Override
public VdcUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSessionId());
    queryParams.setHttpSessionId(getSessionId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (VdcUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#method_after
@Override
public DbUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSessionId());
    queryParams.setHttpSessionId(getSessionId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (DbUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#end_block

#method_before
@Override
public VdcReturnValueBase logOff(VdcUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getUserId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#end_block

#method_before
private void updateDataCenterAlert() {
    if (getDataCenter().getSelectedItem() != null && !UnassignedDataCenterId.equals(((StoragePool) getDataCenter().getSelectedItem()).getId()) && ((StoragePool) getDataCenter().getSelectedItem()).getstatus() == StoragePoolStatus.Uninitialized) {
        getDataCenterAlert().setIsAvailable(true);
        getDataCenterAlert().setEntity(ConstantsManager.getInstance().getConstants().dataCenterUninitializedAlert());
    } else {
        getDataCenterAlert().setIsAvailable(false);
        getDataCenterAlert().setEntity("");
    }
}
#method_after
private void updateDataCenterAlert() {
    if (getDataCenter().getSelectedItem() != null && !UnassignedDataCenterId.equals(((StoragePool) getDataCenter().getSelectedItem()).getId()) && ((StoragePool) getDataCenter().getSelectedItem()).getStatus() == StoragePoolStatus.Uninitialized) {
        getDataCenterAlert().setIsAvailable(true);
        getDataCenterAlert().setEntity(ConstantsManager.getInstance().getConstants().dataCenterUninitializedAlert());
    } else {
        getDataCenterAlert().setIsAvailable(false);
        getDataCenterAlert().setEntity("");
    }
}
#end_block

#method_before
private void initDataCenter() {
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    // $NON-NLS-1$
                    getDataCenter().setInfo("Cannot choose Storage's Data Center in tree context");
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    // $NON-NLS-1$
                    getHost().setInfo("Cannot choose Storage's Host in tree context");
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    // $NON-NLS-1$
                    getDataCenter().setInfo("Cannot choose Storage's Data Center in tree context");
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getDataCenterList(new AsyncQuery(new Object[] { this, behavior }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    StorageModel storageModel = (StorageModel) array[0];
                    StorageModelBehavior storageModelBehavior = (StorageModelBehavior) array[1];
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = (StoragePool) storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }, getHash()));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }, getHash()), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getDataCenterList(new AsyncQuery(new Object[] { this, behavior }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    StorageModel storageModel = (StorageModel) array[0];
                    StorageModelBehavior storageModelBehavior = (StorageModelBehavior) array[1];
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = (StoragePool) storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }, getHash()));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }, getHash()), getStorage().getId());
        }
    }
}
#end_block

#method_before
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        hosts = Collections.singletonList(getSPM(hosts));
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#method_after
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
public boolean isExtendImageSizeEnabled() {
    return (getEntity() != null) ? VdcActionUtils.CanExecute(Arrays.asList(getEntity()), VM.class, VdcActionType.ExtendImageSize) : false;
}
#method_after
public boolean isExtendImageSizeEnabled() {
    return (getEntity() != null) ? VdcActionUtils.canExecute(Arrays.asList(getEntity()), VM.class, VdcActionType.ExtendImageSize) : false;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        if (disk.getPlugged() == plug || isLocked || (disk.getDiskInterface() == DiskInterface.IDE && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        boolean isDiskHotpluggableInterface = false;
        if (getEntity() != null) {
            isDiskHotpluggableInterface = AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface());
        }
        if (disk.getPlugged() == plug || isLocked || (!isDiskHotpluggableInterface && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, clusterCompatibilityVersion.toString()));
    }
}
#method_after
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) !AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), clusterCompatibilityVersion).isEmpty());
    }
}
#end_block

#method_before
private boolean isLocalDataCenterEmpty(StoragePool dataCenter) {
    if (dataCenter != null && dataCenter.getStorageType() == StorageType.LOCALFS && dataCenter.getstatus() == StoragePoolStatus.Uninitialized) {
        return true;
    }
    return false;
}
#method_after
private boolean isLocalDataCenterEmpty(StoragePool dataCenter) {
    if (dataCenter != null && dataCenter.getStorageType() == StorageType.LOCALFS && dataCenter.getStatus() == StoragePoolStatus.Uninitialized) {
        return true;
    }
    return false;
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setInfo(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    model.setMessage(ConstantsManager.getInstance().getConstants().clustersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#method_after
private void onSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
        checkForNonResponsiveHosts(confirmModel);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#end_block

#method_before
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!((Boolean) model.getVersionSupportsCpuThreads().getEntity() && (Boolean) model.getCountThreadsAsCores().getEntity()) && ((VDSGroup) getSelectedItem()).getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveInternal();
    }
}
#method_after
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!((Boolean) model.getVersionSupportsCpuThreads().getEntity() && (Boolean) model.getCountThreadsAsCores().getEntity()) && ((VDSGroup) getSelectedItem()).getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuLevel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuLevel();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuLevel")) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
            updateQuota(datacenter);
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            for (Disk disk : disks) {
                if (disk.isBoot() && !disk.equals(getDisk())) {
                    diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                    diskModel.getIsBootable().setEntity(false);
                    diskModel.getIsBootable().setIsChangable(false);
                    break;
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(getVm() != null && getVm().isDown());
    }
}
#method_after
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#end_block

#method_before
public void updateInterface(Version clusterVersion) {
    getDiskInterface().setItems(AsyncDataProvider.getDiskInterfaceList(clusterVersion));
}
#method_after
public void updateInterface(final Version clusterVersion) {
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue1) {
                final boolean isVirtioScsiDisabled = Boolean.FALSE.equals(returnValue1);
                AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue2) {
                        ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue2;
                        if (isVirtioScsiDisabled) {
                            diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                        }
                        setInterfaces(diskInterfaces);
                    }
                });
                AsyncDataProvider.getDiskInterfaceList(getVm().getOs(), clusterVersion, asyncQuery);
            }
        }), getVm().getId());
    } else {
        setInterfaces(AsyncDataProvider.getDiskInterfaceList());
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
@Override
public void setEntity(Object value) {
    if (value == null || !value.equals(getEntity())) {
        super.setEntity(value);
    }
}
#method_after
@Override
public void setEntity(Object value) {
    if (value == null || !value.equals(getEntity())) {
        super.setEntity(value);
        updateActionAvailability();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    StorageDomain storageDomain = (StorageDomain) getEntity();
    @SuppressWarnings("unchecked")
    ArrayList<RepoImage> selectedImages = getSelectedItems() != null ? (ArrayList<RepoImage>) getSelectedItems() : new ArrayList<RepoImage>();
    getImportImagesCommand().setIsExecutionAllowed(storageDomain != null && storageDomain.getStorageType() == StorageType.GLANCE && selectedImages.size() > 0);
}
#method_after
private void updateActionAvailability() {
    StorageDomain storageDomain = (StorageDomain) getEntity();
    @SuppressWarnings("unchecked")
    ArrayList<RepoImage> selectedImages = getSelectedItems() != null ? (ArrayList<RepoImage>) getSelectedItems() : new ArrayList<RepoImage>();
    if (storageDomain != null && storageDomain.getStorageType() == StorageType.GLANCE) {
        getImportImagesCommand().setIsAvailable(true);
        getImportImagesCommand().setIsExecutionAllowed(selectedImages.size() > 0);
    } else {
        getImportImagesCommand().setIsAvailable(false);
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setIsAvailable(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setIsAvailable(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((operationType == null) ? 0 : operationType.hashCode());
    result = prime * result + ((operationCallback == null) ? 0 : operationCallback.hashCode());
    result = prime * result + ((parameter == null) ? 0 : parameter.hashCode());
    result = prime * result + ((source == null) ? 0 : source.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((operationType == null) ? 0 : operationType.hashCode());
    result = prime * result + ((parameter == null) ? 0 : parameter.hashCode());
    result = prime * result + ((source == null) ? 0 : source.hashCode());
    return result;
}
#end_block

#method_before
public void setThreshold(final int threshouldCount) {
    threshold = threshouldCount;
}
#method_after
public void setThreshold(final int thresholdCount) {
    threshold = thresholdCount;
}
#end_block

#method_before
@Override
public void scheduleDeferred(ScheduledCommand cmd) {
    callCount++;
    if (callCount >= threshold) {
        cmd.execute();
    }
}
#method_after
@Override
public void scheduleDeferred(ScheduledCommand cmd) {
    callCount++;
    if (callCount >= threshold) {
        // threshold matched, execute the command.
        cmd.execute();
    }
}
#end_block

#method_before
@Override
public void scheduleEntry(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleEntry(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleEntry(ScheduledCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleEntry(ScheduledCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFinally(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFinally(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFinally(ScheduledCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFinally(ScheduledCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFixedDelay(RepeatingCommand cmd, int delayMs) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFixedDelay(RepeatingCommand cmd, int delayMs) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFixedPeriod(RepeatingCommand cmd, int delayMs) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFixedPeriod(RepeatingCommand cmd, int delayMs) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleIncremental(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleIncremental(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    dataCenterList.setIsAvailable(!getHasSelectedTags());
    clusterList.setIsAvailable(!getHasSelectedTags());
    hostList.setIsAvailable(true);
    storageList.setIsAvailable(!getHasSelectedTags());
    vmList.setIsAvailable(true);
    volumeList.setIsAvailable(true);
    poolList.setIsAvailable(!getHasSelectedTags());
    templateList.setIsAvailable(!getHasSelectedTags());
    userList.setIsAvailable(true);
    eventList.setIsAvailable(!getHasSelectedTags());
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && !getHasSelectedTags());
    networkList.setIsAvailable(!getHasSelectedTags());
    providerList.setIsAvailable(!getHasSelectedTags());
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#method_after
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        hostList.setIsAvailable(true);
        vmList.setIsAvailable(true);
        userList.setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#end_block

#method_before
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    for (SearchableListModel item : getItems()) {
        item.setIsAvailable(true);
    }
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#method_after
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    // the main tabs that should appear when a bookmark is selected should
    // be the exact same main tabs that are displayed when the "System" node
    // in the system tree is selected.
    updateAvailability(SystemTreeItemType.System, null);
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#end_block

#method_before
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    // Update items availability depending on system tree selection.
    dataCenterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenters);
    clusterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Clusters || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    hostList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Hosts || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    volumeList.setIsAvailable(model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Volume || model.getType() == SystemTreeItemType.Volumes || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster) {
        volumeList.setIsAvailable(false);
    }
    storageList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storages || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System);
    quotaList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter);
    boolean isDataStorage = false;
    if (model.getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) model.getEntity();
        isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
    }
    diskList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || isDataStorage || model.getType() == SystemTreeItemType.System);
    vmList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.VMs || model.getType() == SystemTreeItemType.System);
    poolList.setIsAvailable(model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster);
    templateList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.Templates || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster_Gluster) {
        VDSGroup cluster = (VDSGroup) model.getEntity();
        if (!cluster.supportsVirtService()) {
            vmList.setIsAvailable(false);
            templateList.setIsAvailable(false);
            storageList.setIsAvailable(false);
            poolList.setIsAvailable(false);
        }
    }
    userList.setIsAvailable(model.getType() == SystemTreeItemType.System);
    eventList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.Volume);
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && ReportInit.getInstance().getDashboard(model.getType().toString()) != null);
    networkList.setIsAvailable(model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.Networks || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Host);
    providerList.setIsAvailable(model.getType() == SystemTreeItemType.Providers || model.getType() == SystemTreeItemType.Provider);
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#method_after
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    updateAvailability(model.getType(), model.getEntity());
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#end_block

#method_before
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model).getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#method_after
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "VnicProfile: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        SystemTreeItemModel ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (ancestor == null) {
                            ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + ancestor.getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "VnicProfile : network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#end_block

#method_before
public VdcUser getLoggedInUser() {
    return loggedInUser;
}
#method_after
public DbUser getLoggedInUser() {
    return loggedInUser;
}
#end_block

#method_before
public void setLoggedInUser(VdcUser value) {
    if (loggedInUser != value) {
        loggedInUser = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("LoggedInUser"));
    }
}
#method_after
public void setLoggedInUser(DbUser value) {
    if (loggedInUser != value) {
        loggedInUser = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("LoggedInUser"));
    }
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && storage.getStatus() == StorageDomainStatus.Maintenance);
    }
    return false;
}
#method_after
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && (storage.getStatus() == StorageDomainStatus.Maintenance || storage.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached));
    }
    return false;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToRemoveTheStorageDomainMsg());
    model.getFormat().setIsAvailable(false);
    AsyncDataProvider.getHostListByStatus(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), VDSStatus.Up);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getDestroyCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance);
    boolean isDataDomain = (storageDomain.getStorageDomainType() == StorageDomainType.Data) || (storageDomain.getStorageDomainType() == StorageDomainType.Master);
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || (isInMaintenance && isDataDomain);
    return isEditAvailable;
}
#method_after
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
    boolean isDataDomain = (storageDomain.getStorageDomainType() == StorageDomainType.Data) || (storageDomain.getStorageDomainType() == StorageDomainType.Master);
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#end_block

#method_before
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    Guid storagePoolId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
        storagePoolId = host.getStoragePoolId();
    }
    IStorageModel storageModel = model.getSelectedItem();
    connection = new StorageServerConnections();
    connection.setid(storageDomain.getStorage());
    connection.setconnection(path);
    connection.setstorage_type(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel.getType().equals(StorageType.POSIXFS)) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    parameters.setStoragePoolId(storagePoolId);
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#method_after
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
    }
    IStorageModel storageModel = model.getSelectedItem();
    connection = new StorageServerConnections();
    connection.setid(storageDomain.getStorage());
    connection.setconnection(path);
    connection.setstorage_type(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel.getType().equals(StorageType.POSIXFS)) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                }
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
private UICommand createCancelCommand(String commandName) {
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand(commandName, this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    return command;
}
#method_after
private UICommand createCancelCommand(String commandName) {
    UICommand command;
    command = new UICommand(commandName, this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    return command;
}
#end_block

#method_before
public void addOperation(final VdcOperation<?, ?> operation) {
    addOperation(operation, false);
}
#method_after
public boolean addOperation(final VdcOperation<?, ?> operation) {
    return addOperation(operation, false);
}
#end_block

#method_before
private void addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    if ((loggedIn || isPublic) && (!operationQueue.contains(operation) || operation.allowDuplicates()) && operationQueue.add(operation)) {
        processor.processOperation(this);
    }
}
#method_after
private boolean addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // If the user is logged in, or the user is not logged in and the operation does not allow duplicates (aka
    // it is a query, and not an action). And the operation is not already in the queue || the operation is
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    final boolean isAllowedToExecute = loggedIn || isPublic;
    final boolean operationCanBeAdded = !operationQueue.contains(operation) || operation.allowDuplicates();
    if (isAllowedToExecute) {
        if (operationCanBeAdded && operationQueue.add(operation)) {
            processor.processOperation(this);
        }
    }
    return isAllowedToExecute;
}
#end_block

#method_before
public void addOperationList(final List<VdcOperation<?, ?>> operationList) {
    for (VdcOperation<?, ?> operation : operationList) {
        addOperation(operation, false);
    }
    // Call the processor.
    processor.processOperation(this);
}
#method_after
public boolean addOperationList(final List<VdcOperation<?, ?>> operationList) {
    boolean allowed = true;
    for (VdcOperation<?, ?> operation : operationList) {
        if (!addOperation(operation, false)) {
            allowed = false;
        }
    }
    // Call the processor.
    processor.processOperation(this);
    return allowed;
}
#end_block

#method_before
public void logoutUser(final Object userObject, final VdcUserCallback<?> callback) {
    loggedIn = false;
    processor.logoutUser(userObject, callback);
}
#method_after
public void logoutUser(final Object userObject, final UserCallback<?> callback) {
    loggedIn = false;
    processor.logoutUser(userObject, callback);
}
#end_block

#method_before
@Override
public VdcUser getLoggedUser() {
    privateLoggedUser.setPassword((String) getPassword().getEntity());
    return privateLoggedUser;
}
#method_after
@Override
public DbUser getLoggedUser() {
    return privateLoggedUser;
}
#end_block

#method_before
@Override
protected void setLoggedUser(VdcUser value) {
    privateLoggedUser = value;
}
#method_after
@Override
protected void setLoggedUser(DbUser value) {
    privateLoggedUser = value;
}
#end_block

#method_before
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(final Object model, final Object result) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) model;
            VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                loginModel.setLoggedUser((VdcUser) returnValue.getActionReturnValue());
                loginModel.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                loginModel.getPassword().setEntity("");
                if (returnValue != null) {
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                loginModel.getUserName().setIsChangable(true);
                loginModel.getPassword().setIsChangable(true);
                loginModel.getDomain().setIsChangable(true);
                loginModel.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    };
    Frontend.LoginAsync((String) getUserName().getEntity(), (String) getPassword().getEntity(), (String) getDomain().getSelectedItem(), false, asyncQuery);
}
#method_after
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(final Object model, final Object result) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) model;
            VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                loginModel.setLoggedUser((DbUser) returnValue.getActionReturnValue());
                loginModel.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                loginModel.getPassword().setEntity("");
                if (returnValue != null) {
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                loginModel.getUserName().setIsChangable(true);
                loginModel.getPassword().setIsChangable(true);
                loginModel.getDomain().setIsChangable(true);
                loginModel.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    };
    Frontend.LoginAsync((String) getUserName().getEntity(), (String) getPassword().getEntity(), (String) getDomain().getSelectedItem(), false, asyncQuery);
}
#end_block

#method_before
// Update IsENGINEUser flag.
public void updateIsENGINEUser(VdcUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.getRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            // a user 'stays' a user if he has consume quota action group.
            // so we need to apply the same logic to this ActionGroup as for
            // engine user role's action group.
            loginModel.getENGINEUserActionGroupList().add(ConsumeQuotaActionGroup);
            loginModel.getUserRoles(loginModel);
        }
    }), ApplicationGuids.engineUser.asGuid());
}
#method_after
// Update IsENGINEUser flag.
public void updateIsENGINEUser(DbUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.getRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            // a user 'stays' a user if he has consume quota action group.
            // so we need to apply the same logic to this ActionGroup as for
            // engine user role's action group.
            loginModel.getENGINEUserActionGroupList().add(ConsumeQuotaActionGroup);
            loginModel.getUserRoles(loginModel);
        }
    }), ApplicationGuids.engineUser.asGuid());
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveyoneNetworUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneNetworUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.networkUser.asGuid());
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getUserId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        if (disk.getPlugged() == plug || isLocked || (!AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface()) && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        boolean isDiskHotpluggableInterface = false;
        if (getEntity() != null) {
            isDiskHotpluggableInterface = AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface());
        }
        if (disk.getPlugged() == plug || isLocked || (!isDiskHotpluggableInterface && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, clusterCompatibilityVersion.toString()));
    }
}
#method_after
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) !AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), clusterCompatibilityVersion).isEmpty());
    }
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, ArrayList<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, ArrayList<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#method_after
public static Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#end_block

#method_before
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getDiskHotpluggableInterfacesMap().containsKey(pair)) {
        List<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(pair);
        if (diskHotpluggableInterfaces != null && !diskHotpluggableInterfaces.isEmpty()) {
            Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
            for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
                diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
            }
            return diskInterfaces;
        }
    }
    return Collections.emptyList();
}
#method_after
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter<GlusterVolumeTaskStatusEntity>() {

        @Override
        public GlusterVolumeTaskStatusEntity Convert(Object source, AsyncQuery _asyncQuery) {
            return (GlusterVolumeTaskStatusEntity) source;
        }
    };
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
@Override
public void init(final ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    if (getServletConfig() != null) {
        // we use %{x} convention to avoid conflict with jboss properties
        targetContext = ServletUtils.getAsAbsoluteContext(getServletContext().getContextPath(), EngineLocalConfig.getInstance().expandString(config.getInitParameter(CONTEXT_PARAM).replaceAll("%\\{", "\\${")));
        uri = getInitParameter(URI_PARAM);
    }
    if (targetContext == null) {
        // $NON-NLS-1$
        throw new ServletException("Target context not defined in web.xml");
    }
}
#method_after
@Override
public void init(final ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    targetContext = config.getInitParameter(CONTEXT_PARAM);
    if (targetContext == null) {
        // $NON-NLS-1$
        throw new ServletException("Target context not defined in web.xml");
    }
    uri = config.getInitParameter(URI_PARAM);
    if (uri == null) {
        // $NON-NLS-1$
        throw new ServletException("Target URI not defined in web.xml");
    }
    // we use %{x} convention to avoid conflict with jboss properties
    EngineLocalConfig engineLocalConfig = EngineLocalConfig.getInstance();
    targetContext = ServletUtils.getAsAbsoluteContext(getServletContext().getContextPath(), engineLocalConfig.expandString(targetContext.replaceAll("%\\{", "\\${")));
    uri = engineLocalConfig.expandString(uri.replaceAll("%\\{", "\\${"));
}
#end_block

#method_before
public static String getSpiceBaseURL() {
    // $NON-NLS-1$
    return FrontendUrlUtils.getRootURL() + "ovirt-engine/services/files/spice/";
}
#method_after
public static String getSpiceBaseURL() {
    return FrontendUrlUtils.getRootURL() + HostPageConfiguration.getInstance().getBaseContextPath() + // $NON-NLS-1$
    "services/files/spice/";
}
#end_block

#method_before
public void updateUsbFilter() {
    // $NON-NLS-1$
    fetchFile("/ovirt-engine/services/files/usbfilter.txt", usbFilterFileFetchedEvent);
}
#method_after
public void updateUsbFilter() {
    fetchFile(HostPageConfiguration.getInstance().getBaseContextPath() + "services/files/usbfilter.txt", // $NON-NLS-1$
    usbFilterFileFetchedEvent);
}
#end_block

#method_before
private String replaceLocaleWithUSLocale(String originalString, Locale locale) {
    return replaceLocaleWithOtherLocale(originalString, locale, Locale.US);
}
#method_after
private String replaceLocaleWithUSLocale(String originalString, Locale locale) {
    return replaceLocaleWithOtherLocale(// $NON-NLS-1$
    originalString != null ? originalString : "", locale, Locale.US);
}
#end_block

#method_before
private void updateOptionsPostData() {
    if (disks == null) {
        return;
    }
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsPostData(Collection<Disk> disks) {
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        updateOptionsData();
    }
}
#method_after
public void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                updateOptionsPostData((Collection<Disk>) returnValue);
            }
        }), getEntity().getId());
    }
}
#end_block

#method_before
public void cancel() {
    resetData();
    setWindow(null);
    Frontend.Unsubscribe();
}
#method_after
public void cancel() {
    setWindow(null);
    Frontend.Unsubscribe();
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter<GlusterVolumeTaskStatusEntity>() {

        @Override
        public GlusterVolumeTaskStatusEntity Convert(Object source, AsyncQuery _asyncQuery) {
            return (GlusterVolumeTaskStatusEntity) source;
        }
    };
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
        case Maintenance:
            return true;
        default:
            return false;
    }
}
#method_after
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    doReturn(null).when(storageDomainDAOMock).get(storageDomain.getId());
    doReturn(Collections.emptyList()).when(storageDomainDAOMock).getAllForStorageDomain(storageDomain.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    doReturn(null).when(storageDomainDAOMock).get(storageDomain.getId());
    doReturn(Collections.emptyList()).when(storageDomainDAOMock).getAllForStorageDomain(storageDomain.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction shouldn't be possible for a non-existent storage domain", command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testCDANonExistingVds() {
    doReturn(null).when(vdsDAOMock).get(vdsId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.VDS_NOT_EXIST);
}
#method_after
@Test
public void testCDANonExistingVds() {
    doReturn(null).when(vdsDAOMock).get(vdsId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail for non existing VDS", command, VdcBllMessages.VDS_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testCDAVdsNotUp() {
    vds.setStatus(VDSStatus.Down);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
}
#method_after
@Test
public void testCDAVdsNotUp() {
    vds.setStatus(VDSStatus.Down);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail for a VDS with a status different from UP", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolValid() {
    vds.setId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
}
#method_after
@Test
public void testCDAStoragePoolValid() {
    vds.setId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on mismatch Storage Pool", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
}
#end_block

#method_before
@Test
public void testCDAVdsIsSPM() {
    vds.setSpmStatus(VdsSpmStatus.SPM);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
}
#method_after
@Test
public void testCDAVdsIsSPM() {
    vds.setSpmStatus(VdsSpmStatus.SPM);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a VDS that is already set as SPM", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
}
#end_block

#method_before
@Test
public void testCDAVdsSPMPrioritySetToNever() {
    vds.setVdsSpmPriority(BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
}
#method_after
@Test
public void testCDAVdsSPMPrioritySetToNever() {
    vds.setVdsSpmPriority(BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a VDS that is set to never be elected as SPM", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
}
#method_after
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a Storage Pool which is not up", command, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolHasTasks() {
    List<Guid> tasks = Arrays.asList(Guid.newGuid());
    doReturn(tasks).when(asyncTaskDAOMock).getAsyncTaskIdsByStoragePoolId(storagePoolId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
}
#method_after
@Test
public void testCDAStoragePoolHasTasks() {
    List<Guid> tasks = Arrays.asList(Guid.newGuid());
    doReturn(tasks).when(asyncTaskDAOMock).getAsyncTaskIdsByStoragePoolId(storagePoolId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a Storage Pool with running tasks", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerException
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerException
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction shouldn't be possible for a non-existent storage domain", command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(command, message);
}
#method_after
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    return runAndAssertCanDoActionFailure("", command, message);
}
#end_block

#method_before
public static List<String> runAndAssertCanDoActionFailure(CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(command, message);
}
#method_after
public static List<String> runAndAssertCanDoActionFailure(String assertionMessage, CommandBase<?> command, VdcBllMessages message) {
    assertFalse("Command's canDoAction expected to fail, but succeeded", command.canDoAction());
    return assertCanDoActionMessages(assertionMessage, command, message);
}
#end_block

#method_before
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#method_after
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    return runAndAssertSetActionMessageParameters("", command, messages);
}
#end_block

#method_before
public static List<String> runAndAssertSetActionMessageParameters(CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#method_after
public static List<String> runAndAssertSetActionMessageParameters(String assertionMessage, CommandBase<?> command, VdcBllMessages... messages) {
    command.setActionMessageParameters();
    for (VdcBllMessages message : messages) {
        assertCanDoActionMessages(assertionMessage, command, message);
    }
    return command.getReturnValue().getCanDoActionMessages();
}
#end_block

#method_before
private static List<String> assertCanDoActionMessages(CommandBase<?> command, VdcBllMessages message) {
    List<String> canDoActionMessages = command.getReturnValue().getCanDoActionMessages();
    assertTrue(MessageFormat.format("canDoAction messages doesn''t contain expected message: {0}, messages are: {1}", message.name(), canDoActionMessages), canDoActionMessages.contains(message.name()));
    return canDoActionMessages;
}
#method_after
private static List<String> assertCanDoActionMessages(String assertionMessage, CommandBase<?> command, VdcBllMessages message) {
    List<String> canDoActionMessages = command.getReturnValue().getCanDoActionMessages();
    assertTrue(MessageFormat.format("{0}canDoAction messages doesn''t contain expected message: {1}, messages are: {2}", optionalMessage(assertionMessage), message.name(), canDoActionMessages), canDoActionMessages.contains(message.name()));
    return canDoActionMessages;
}
#end_block

#method_before
@Override
public String render(T size) {
    if (size.longValue() > SizeConverter.BYTES_IN_GB) {
        return messages.rebalanceFileSizeGb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.GB).longValue());
    } else if (size.longValue() > SizeConverter.BYTES_IN_MB) {
        return messages.rebalanceFileSizeMb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.MB).longValue());
    } else if (size.longValue() > SizeConverter.BYTES_IN_KB) {
        return messages.rebalanceFileSizeKb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.KB).longValue());
    } else {
        return messages.rebalanceFileSizeBytes(size.longValue());
    }
}
#method_after
@Override
public String render(T size) {
    if (size.longValue() > SizeConverter.BYTES_IN_GB) {
        return messages.rebalanceFileSizeGb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.GB).doubleValue()));
    } else if (size.longValue() > SizeConverter.BYTES_IN_MB) {
        return messages.rebalanceFileSizeMb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.MB).doubleValue()));
    } else if (size.longValue() > SizeConverter.BYTES_IN_KB) {
        return messages.rebalanceFileSizeKb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.KB).doubleValue()));
    } else {
        return messages.rebalanceFileSizeBytes(formatSize(size.doubleValue()));
    }
}
#end_block

#method_before
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startedTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new UptimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            // TODO Auto-generated method stub
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#method_after
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startedTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#end_block

#method_before
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#method_after
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#end_block

#method_before
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            showStatus(rebalanceStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if (rebalanceStatusEntity != null) {
                showStatus(rebalanceStatusEntity);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid vdsId = null;
            Guid storagePoolId = null;
            String vdsName = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            vdsId = _vds.getId();
                            vdsName = _vds.getName();
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(_vds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    t.setName("org.ovirt.thread." + t.getName());
    if (log.isDebugEnabled()) {
        log.debug("About to run task " + r.getClass().getName() + " from ", new Exception());
    }
    if (getQueue().size() > 0) {
        log.warn("Executing a command, but note that there are " + getQueue().size() + " tasks in the queue.");
    }
}
#method_after
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    t.setName("org.ovirt.thread." + t.getName());
    if (log.isDebugEnabled()) {
        log.debug("About to run task " + r.getClass().getName() + " from ", new Exception());
    }
    if (getQueue().size() > 0) {
        log.warn("Executing a command: " + r.getClass().getName() + " , but note that there are " + getQueue().size() + " tasks in the queue.");
    }
}
#end_block

#method_before
@Override
public void run() {
    ThreadLocalParamsContainer.setVdcUser(vdcUser);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    job.run();
}
#method_after
@Override
public void run() {
    ThreadLocalParamsContainer.setUser(user);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    job.run();
}
#end_block

#method_before
@Override
public V call() throws Exception {
    ThreadLocalParamsContainer.setVdcUser(vdcUser);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    return job.call();
}
#method_after
@Override
public V call() throws Exception {
    ThreadLocalParamsContainer.setUser(user);
    ThreadLocalParamsContainer.setHttpSessionId(httpSessionId);
    ThreadLocalParamsContainer.setCorrelationId(correlationId);
    return job.call();
}
#end_block

#method_before
public static void execute(Runnable command) {
    try {
        es.submit(new InternalWrapperRunnable(command, ThreadLocalParamsContainer.getVdcUser(), ThreadLocalParamsContainer.getHttpSessionId(), ThreadLocalParamsContainer.getCorrelationId()));
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#method_after
public static void execute(Runnable command) {
    try {
        es.submit(new InternalWrapperRunnable(command, ThreadLocalParamsContainer.getUser(), ThreadLocalParamsContainer.getHttpSessionId(), ThreadLocalParamsContainer.getCorrelationId()));
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStatus(volumeName);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStop(volumeName);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    String volumeName = getParameters().getVolumeName();
    result = getBroker().glusterVolumeRebalanceStatus(volumeName);
    proceedProxyReturnValue();
    // Set the current engine time as status time
    GlusterVolumeTaskStatusEntity entity = result.getStatusDetails();
    entity.setStatusTime(new Date());
    setReturnValue(entity);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    String volumeName = getParameters().getVolumeName();
    result = getBroker().glusterVolumeRebalanceStop(volumeName);
    proceedProxyReturnValue();
    // Set the current engine time as status time
    GlusterVolumeTaskStatusEntity entity = result.getStatusDetails();
    entity.setStatusTime(new Date());
    setReturnValue(entity);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (JobExecutionStatus.FINISHED.equals(stepStatus)) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), true);
    } else {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (stepStatus != null && JobExecutionStatus.FINISHED.equals(stepStatus)) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), true);
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
public VmDevice readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (isManaged) {
        vmDevice.setIsManaged(true);
        vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
    return vmDevice;
}
#method_after
public VmDevice readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(node.SelectSingleNode(OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).InnerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_CUSTOM_PROP, _xmlNS).InnerText)));
    }
    if (isManaged) {
        vmDevice.setIsManaged(true);
        vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
    return vmDevice;
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#method_after
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    // Remove brick task is marked completed only if committed or aborted.
    if (JobExecutionStatus.ABORTED == task.getStatus() || (JobExecutionStatus.FINISHED == task.getStatus() && task.getType() != GlusterTaskType.REMOVE_BRICK) || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#end_block

#method_before
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    values.put("status", task.getStatus().toString());
    values.put("info", task.getMessage());
    return values;
}
#method_after
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.valueOf((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    return task;
}
#method_after
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    task.getTaskParameters().setBricks(getBrickNames(map.get(BRICK_NAMES)));
    return task;
}
#end_block

#method_before
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getconnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDAO.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDAO.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#method_after
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getconnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDAO.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDAO.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#end_block

#method_before
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#method_after
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDAO.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (isReadOnly ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (isReadOnly ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    result = prime * result + (snapshotId == null ? 0 : snapshotId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && isReadOnly == other.isReadOnly && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && isReadOnly == other.isReadOnly && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties) && ObjectUtils.objectsEqual(snapshotId, other.snapshotId));
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("VmDevice {");
    sb.append("vmId=");
    sb.append(id.getVmId());
    sb.append(", deviceId=");
    sb.append(id.getDeviceId());
    sb.append(", device=");
    sb.append(getDevice());
    sb.append(", type=");
    sb.append(getType());
    sb.append(", bootOrder=");
    sb.append(getBootOrder());
    sb.append(", specParams=");
    sb.append(getSpecParams());
    sb.append(", address=");
    sb.append(getAddress());
    sb.append(", managed=");
    sb.append(getIsManaged());
    sb.append(", plugged=");
    sb.append(getIsPlugged());
    sb.append(", readOnly=");
    sb.append(getIsReadOnly());
    sb.append(", deviceAlias=");
    sb.append(getAlias());
    sb.append(", customProperties=");
    sb.append(getCustomProperties());
    sb.append("}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("VmDevice {");
    sb.append("vmId=");
    sb.append(id.getVmId());
    sb.append(", deviceId=");
    sb.append(id.getDeviceId());
    sb.append(", device=");
    sb.append(getDevice());
    sb.append(", type=");
    sb.append(getType());
    sb.append(", bootOrder=");
    sb.append(getBootOrder());
    sb.append(", specParams=");
    sb.append(getSpecParams());
    sb.append(", address=");
    sb.append(getAddress());
    sb.append(", managed=");
    sb.append(getIsManaged());
    sb.append(", plugged=");
    sb.append(getIsPlugged());
    sb.append(", readOnly=");
    sb.append(getIsReadOnly());
    sb.append(", deviceAlias=");
    sb.append(getAlias());
    sb.append(", customProperties=");
    sb.append(getCustomProperties());
    sb.append(", snapshotId=");
    sb.append(getSnapshotId());
    sb.append("}");
    return sb.toString();
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk((Guid) getParameters().getDiskId());
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk((Guid) getParameters().getDiskId(), true);
    }
    return listVms;
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDAO().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDAO().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<VMWithPlugInfo> vms = getVmsWithPlugInfo(id);
    for (VMWithPlugInfo vm : vms) {
        MultiValueMapUtils.addToMap(vm.isPlugged(), vm.getVM(), result);
    }
    return result;
}
#method_after
@Override
public Map<Boolean, List<VM>> getForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    for (Pair<VM, VmDevice> pair : vms) {
        VmDevice device = pair.getSecond();
        if (includeVmsSnapshotAttachedTo || device.getSnapshotId() == null) {
            MultiValueMapUtils.addToMap(device.getIsPlugged(), pair.getFirst(), result);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public List<VM> getVmsListForDisk(Guid id) {
    List<VM> result = new ArrayList<VM>();
    List<VMWithPlugInfo> vms = getVmsWithPlugInfo(id);
    for (VMWithPlugInfo vm : vms) {
        result.add(vm.getVM());
    }
    return result;
}
#method_after
@Override
public List<VM> getVmsListForDisk(Guid id, boolean includeVmsSnapshotAttachedTo) {
    List<VM> result = new ArrayList<>();
    List<Pair<VM, VmDevice>> vms = getVmsWithPlugInfo(id);
    for (Pair<VM, VmDevice> pair : vms) {
        if (includeVmsSnapshotAttachedTo || pair.getSecond().getSnapshotId() == null) {
            result.add(pair.getFirst());
        }
    }
    return result;
}
#end_block

#method_before
private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id));
}
#method_after
public List<Pair<VM, VmDevice>> getVmsWithPlugInfo(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id));
}
#end_block

#method_before
@Override
public VMWithPlugInfo mapRow(ResultSet rs, int rowNum) throws SQLException {
    @SuppressWarnings("synthetic-access")
    VMWithPlugInfo entity = new VMWithPlugInfo();
    entity.setPlugged(rs.getBoolean("is_plugged"));
    entity.setVM(VMRowMapper.instance.mapRow(rs, rowNum));
    return entity;
}
#method_after
@Override
public Pair<VM, VmDevice> mapRow(ResultSet rs, int rowNum) throws SQLException {
    @SuppressWarnings("synthetic-access")
    Pair<VM, VmDevice> entity = new Pair<>();
    entity.setFirst(VMRowMapper.instance.mapRow(rs, rowNum));
    entity.setSecond(VmDeviceDAODbFacadeImpl.VmDeviceRowMapper.instance.mapRow(rs, rowNum));
    return entity;
}
#end_block

#method_before
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessage(String.format("$domainNames %1$s", domains.get(0).getStorageName()));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getstorage_type().isFileDomain()) {
        boolean isConnectionEditable = isDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addCanDoActionMessage(String.format("$domainNames %1$s", domains.get(0).getStorageName()));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDAO().getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addCanDoActionMessage(String.format("$vmNames %1$s", prepareEntityNamesForMessage(problematicVMNames)));
                addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addCanDoActionMessage(String.format("$domainNames %1$s", prepareEntityNamesForMessage(problematicDomainNames)));
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_DOMAINS_STATUS);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, java.util.ArrayList<VDSDomainsData> vdsDomainData) {
    IrsProxyData proxy = _irsProxyData.get(storagePoolId);
    if (proxy != null) {
        proxy.UpdateVdsDomainsData(vdsId, vdsName, vdsDomainData);
    }
}
#method_after
public static void UpdateVdsDomainsData(VDS vds, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    if (vds.getStatus() == VDSStatus.Up) {
        IrsProxyData proxy = _irsProxyData.get(storagePoolId);
        if (proxy != null) {
            proxy.UpdateVdsDomainsData(vds.getId(), vds.getName(), vdsDomainData);
        }
    }
}
#end_block

#method_before
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > MacPoolManager.getInstance().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, ImagesHandler.getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false));
    copyAllMemoryImages(getVm().getId());
}
#method_after
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false, true));
    copyAllMemoryImages(getVm().getId());
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#method_after
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#end_block

#method_before
private List<GlusterClientInfo> getClientList(int listSize) {
    ArrayList<GlusterClientInfo> list = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < listSize; i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        clientInfo.setBytesRead(RandomUtils.instance().nextInt());
        clientInfo.setBytesWritten(RandomUtils.instance().nextInt());
        clientInfo.setClientPort(RandomUtils.instance().nextInt());
        clientInfo.setHostname(RandomUtils.instance().nextString(7));
        list.add(clientInfo);
    }
    return list;
}
#method_after
private List<GlusterClientInfo> getClientList(int listSize) {
    ArrayList<GlusterClientInfo> list = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < listSize; i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        clientInfo.setBytesRead(RandomUtils.instance().nextLong());
        clientInfo.setBytesWritten(RandomUtils.instance().nextLong());
        clientInfo.setClientPort(RandomUtils.instance().nextInt());
        clientInfo.setHostname(RandomUtils.instance().nextString(7));
        list.add(clientInfo);
    }
    return list;
}
#end_block

#method_before
@Override
protected void removeNodeSpi() {
    throw new UnsupportedOperationException("Not supported for sake of simplicity, non blocking API");
}
#method_after
@Override
protected void removeNodeSpi() {
    if (parent() == null) {
        throw new IllegalArgumentException("Cannot remove root node");
    }
    parent().remove(this.name());
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.nameQuotaPopup());
    descriptionEditor.setLabel(constants.descriptionQuotaPopup());
    dataCenterEditor.setLabel(constants.dataCenterQuotaPopup());
    memAndCpuLabel.setText(constants.memAndCpuQuotaPopup());
    storageLabel.setText(constants.storageQuotaPopup());
    globalClusterQuotaRadioButtonEditor.setLabel(constants.ultQuotaForAllClustersQuotaPopup());
    specificClusterQuotaRadioButtonEditor.setLabel(constants.useQuotaSpecificClusterQuotaPopup());
    globalStorageQuotaRadioButtonEditor.setLabel(constants.utlQuotaAllStoragesQuotaPopup());
    specificStorageQuotaRadioButtonEditor.setLabel(constants.usedQuotaSpecStoragesQuotaPopup());
    clusterGraceLabel.setText(constants.quotaClusterGrace());
    clusterThresholdLabel.setText(constants.quotaClusterThreshold());
    storageGraceLabel.setText(constants.quotaStorageGrace());
    storageThresholdLabel.setText(constants.quotaStorageThreshold());
}
#method_after
void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.nameQuotaPopup());
    descriptionEditor.setLabel(constants.descriptionQuotaPopup());
    dataCenterEditor.setLabel(constants.dataCenterQuotaPopup());
    copyPermissionsEditor.setLabel(constants.copyQuotaPermissionsQuotaPopup());
    memAndCpuLabel.setText(constants.memAndCpuQuotaPopup());
    storageLabel.setText(constants.storageQuotaPopup());
    globalClusterQuotaRadioButtonEditor.setLabel(constants.ultQuotaForAllClustersQuotaPopup());
    specificClusterQuotaRadioButtonEditor.setLabel(constants.useQuotaSpecificClusterQuotaPopup());
    globalStorageQuotaRadioButtonEditor.setLabel(constants.utlQuotaAllStoragesQuotaPopup());
    specificStorageQuotaRadioButtonEditor.setLabel(constants.usedQuotaSpecStoragesQuotaPopup());
    clusterGraceLabel.setText(constants.quotaClusterGrace());
    clusterThresholdLabel.setText(constants.quotaClusterThreshold());
    storageGraceLabel.setText(constants.quotaStorageGrace());
    storageThresholdLabel.setText(constants.quotaStorageThreshold());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId());
}
#end_block

#method_before
@Override
protected RowMapper<VmDevice> createEntityRowMapper() {
    return vmDeviceRowMapper;
}
#method_after
@Override
protected RowMapper<VmDevice> createEntityRowMapper() {
    return VmDeviceRowMapper.instance;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    return vmDevice;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<VmDevice> getBatchMapper() {
    return new MapSqlParameterMapper<VmDevice>() {

        @Override
        public MapSqlParameterSource map(VmDevice entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("device_id", entity.getDeviceId()).addValue("vm_id", entity.getVmId()).addValue("address", entity.getAddress()).addValue("alias", entity.getAlias()).addValue("type", entity.getType()).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("spec_params", entity.getSpecParams()).addValue("boot_order", entity.getBootOrder()).addValue("device", entity.getDevice());
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<VmDevice> getBatchMapper() {
    return new MapSqlParameterMapper<VmDevice>() {

        @Override
        public MapSqlParameterSource map(VmDevice entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("device_id", entity.getDeviceId()).addValue("vm_id", entity.getVmId()).addValue("address", entity.getAddress()).addValue("alias", entity.getAlias()).addValue("type", entity.getType()).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("spec_params", entity.getSpecParams()).addValue("boot_order", entity.getBootOrder()).addValue("snapshot_id", entity.getSnapshotId()).addValue("device", entity.getDevice());
            return paramValue;
        }
    };
}
#end_block

#method_before
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.error("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#end_block

#method_before
@Override
protected VmDevice generateNewEntity() {
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "value1");
    return new VmDevice(new VmDeviceId(Guid.newGuid(), EXISTING_VM_ID), VmDeviceGeneralType.DISK, "floppy", "type:'drive', controller:'0', bus:'0', unit:'1'", 2, new HashMap<String, Object>(), true, false, false, "alias", customProp);
}
#method_after
@Override
protected VmDevice generateNewEntity() {
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "value1");
    return new VmDevice(new VmDeviceId(Guid.newGuid(), EXISTING_VM_ID), VmDeviceGeneralType.DISK, "floppy", "type:'drive', controller:'0', bus:'0', unit:'1'", 2, new HashMap<String, Object>(), true, false, false, "alias", customProp, null);
}
#end_block

#method_before
protected Response performAction(VdcActionType task, VdcActionParametersBase params, Action action, boolean getEntityWhenDone) {
    try {
        if (isAsync() || expectNonBlocking()) {
            getCurrent().get(MetaData.class).set("async", true);
            return performNonBlockingAction(task, params, action);
        } else {
            doAction(task, params);
            if (action == null) {
                action = new Action();
            }
            action.setStatus(StatusUtils.create(CreationStatus.COMPLETE));
            if (getEntityWhenDone) {
                setActionItem(action, getEntity());
            }
            return Response.ok().entity(action).build();
        }
    } catch (Exception e) {
        return handleError(Response.class, e, false);
    }
}
#method_after
protected Response performAction(VdcActionType task, VdcActionParametersBase params, Action action, boolean getEntityWhenDone) {
    try {
        if (isAsync() || expectNonBlocking()) {
            getCurrent().get(MetaData.class).set("async", true);
            return performNonBlockingAction(task, params, action);
        } else {
            VdcReturnValueBase actionResult = doAction(task, params);
            if (actionResult.getJobId() != null) {
                setJobLink(action, actionResult);
            }
            if (action == null) {
                action = new Action();
            }
            action.setStatus(StatusUtils.create(CreationStatus.COMPLETE));
            if (getEntityWhenDone) {
                setActionItem(action, getEntity());
            }
            return Response.ok().entity(action).build();
        }
    } catch (Exception e) {
        return handleError(Response.class, e, false);
    }
}
#end_block

#method_before
protected <E> Validator<E> getValidator(Class<E> validatedClass) {
    return (Validator<E>) getValidatorLocator().getValidator(validatedClass);
}
#method_after
protected <E> Validator<E> getValidator(Class<E> validatedClass) {
    return getValidatorLocator().getValidator(validatedClass);
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean copySnapshotDevices) {
    Guid id;
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            VDSGroup cluster = DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId());
            if (cluster != null) {
                addSoundCard(vmBase, cluster.getcompatibility_version());
            }
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = (vmBase.getDefaultDisplayType() == DisplayType.vnc) ? Math.max(1, vmBase.getNumOfMonitors()) : vmBase.getSingleQxlPci() ? 1 : vmBase.getNumOfMonitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = DbFacade.getInstance().getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupHostTabAvailability(object);
            } else if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    // only for non local storage available
    setupHostTabAvailability(object);
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || (Boolean) object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = (Boolean) object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(constants.notAvailableWithNoUpDC());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles().getItems());
    object.getNicsWithLogicalNetworks().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles().getItems());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupHostTabAvailability(object);
            } else if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    // only for non local storage available
    setupHostTabAvailability(object);
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || (Boolean) object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = (Boolean) object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(constants.notAvailableWithNoUpDC());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    profilesInstanceTypeEditor.edit(object.getNicsWithLogicalNetworks(), object.getVnicProfiles());
}
#end_block

#method_before
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        vmsDiskSnapshotPluggedTo = new LinkedList<>();
        vmsDiskPluggedTo = new LinkedList<>();
        vmsDiskOrSnapshotPluggedTo = new LinkedList<>();
        vmsDiskOrSnapshotAttachedTo = new LinkedList<>();
        List<Pair<VM, VmDevice>> attachedVmsInfo = getVmDAO().getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#method_after
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = getVmDAO().getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#end_block

#method_before
public String formatSize(double size) {
    String sSize = String.valueOf(size);
    // $NON-NLS-1$
    int dotIndex = sSize.indexOf(".");
    if (dotIndex != -1) {
        return sSize.substring(0, dotIndex + 3);
    } else {
        // $NON-NLS-1$
        return sSize.concat(".00");
    }
}
#method_after
public String formatSize(double size) {
    // $NON-NLS-1$
    return NumberFormat.getFormat("#.##").format(size);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(new VolumeBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    setBrickListModel(new VolumeBrickListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(getBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setMessage(ConstantsManager.getInstance().getConstants().removeVolumesMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    getBrickListModel().setEntity(provideDetailModelEntity(getSelectedItem()));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    }
}
#end_block

#method_before
private void stopRebalance() {
    if (getWindow() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(volume.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRebalance() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.StopRebalanceGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean status = ((VdcQueryReturnValue) returnValue).getSucceeded();
            cModel.stopProgress();
            if (status) {
                GlusterVolumeTaskStatusEntity rebalanceStatusEntity = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if ((rebalanceStatusEntity == null) || (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.UNKNOWN)) {
                    cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusConfirmationMessage(volumeEntity.getName()));
                    cModel.getCommands().add(rebalanceStatusOk);
                } else {
                    setConfirmWindow(null);
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setMessage(ConstantsManager.getInstance().getConstants().removeVolumesMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Test
public void canDoActionFailsOnNull() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTaskCompleted, getBricks(volumeWithRemoveBricksTaskCompleted, 2))));
    prepareMocks(cmd);
    assertFalse(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionFailsOnNull() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(null, getBricks(volumeWithRemoveBricksTaskCompleted, 2))));
    prepareMocks(cmd);
    assertFalse(cmd.canDoAction());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks().isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED) || GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    releaseVolumeLock();
    getDbUtils().removeBricksFromVolumeInDb(volume, getParameters().getBricks(), getParameters().getReplicaCount());
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    getDbUtils().removeBricksFromVolumeInDb(volume, getParameters().getBricks(), getParameters().getReplicaCount());
    getGlusterVolumeDao().updateVolumeTask(volume.getId(), null);
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks(), getParameters().getReplicaCount());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks(), replicaCount);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    if (message == null) {
        setMessageToDefault();
    } else {
        super.setMessage(message);
    }
}
#method_after
@Override
public void setMessage(String message) {
    super.setMessage(message == null ? constants.removeConfirmationPopupMessage() : message);
}
#end_block

#method_before
@Override
protected void restore() {
    super.restore();
    if (getWindow() != null) {
        return;
    }
    ImportVmModel model = getImportModel();
    setWindow(model);
    model.startProgress(null);
    UICommand restoreCommand;
    // $NON-NLS-1$
    restoreCommand = new UICommand("OnRestore", this);
    restoreCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    restoreCommand.setIsDefault(true);
    model.getCommands().add(restoreCommand);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    model.getCommands().add(tempVar3);
    model.setItems(getSelectedItems());
    model.init(getEntity().getId());
    // Add 'Close' command
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsDefault(true);
    closeCommand.setIsCancel(true);
    model.setCloseCommand(closeCommand);
}
#method_after
@Override
protected void restore() {
    super.restore();
    if (getWindow() != null) {
        return;
    }
    ImportVmModel model = getImportModel();
    setWindow(model);
    model.startProgress(null);
    UICommand restoreCommand;
    // $NON-NLS-1$
    restoreCommand = new UICommand("OnRestore", this);
    restoreCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    restoreCommand.setIsDefault(true);
    model.getCommands().add(restoreCommand);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    model.getCommands().add(tempVar3);
    model.init(getSelectedItems(), getEntity().getId());
    // Add 'Close' command
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsDefault(true);
    closeCommand.setIsCancel(true);
    model.setCloseCommand(closeCommand);
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getVdsGroupName());
}
#method_after
private void checkUpServerAndAddBricks() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity == null) {
        return;
    }
    AsyncDataProvider.isAnyHostUpInCluster(new AsyncQuery(volumeEntity, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object entity, Object returnValue) {
            boolean clusterHasUpHost = (Boolean) returnValue;
            if (clusterHasUpHost) {
                addBricks((GlusterVolumeEntity) entity);
            } else {
                ConfirmationModel model = new ConfirmationModel();
                setWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().cannotAddBricksNoUpServerFound());
                // $NON-NLS-1$
                model.setHashName("cannot_add_bricks");
                // $NON-NLS-1$
                UICommand command = new UICommand("Cancel", VolumeBrickListModel.this);
                command.setTitle(ConstantsManager.getInstance().getConstants().close());
                command.setIsCancel(true);
                model.getCommands().add(command);
                return;
            }
        }
    }), volumeEntity.getVdsGroupName());
}
#end_block

#method_before
private void addBricks(GlusterVolumeEntity volumeEntity) {
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#method_after
private void addBricks(GlusterVolumeEntity volumeEntity) {
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.getServers().setItems(hostList);
                }
            };
            AsyncDataProvider.getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("OnAddBricks", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    volumeBrickModel.getCommands().add(command);
}
#end_block

#method_before
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#end_block

#method_before
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setWindow(removeBrickStatusModel);
    removeBrickStatusModel.startProgress(null);
    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
    // $NON-NLS-1$
    UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand RetainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    RetainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    RetainBricksFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addRetainBricksCommand(RetainBricksFromStatus);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            removeBrickStatusModel.stopProgress();
            GlusterVolumeTaskStatusEntity removeBrickStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            removeBrickStatusModel.showStatus(removeBrickStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    removeBrickStatusModel.getCommands().add(cancelCommand);
}
#method_after
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setWindow(removeBrickStatusModel);
    removeBrickStatusModel.startProgress(null);
    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
    // $NON-NLS-1$
    UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
    // $NON-NLS-1$
    UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            removeBrickStatusModel.stopProgress();
            GlusterVolumeTaskStatusEntity removeBrickStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            removeBrickStatusModel.showStatus(removeBrickStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    removeBrickStatusModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && volumeTask != null && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeEntity getVolumeByGlusterTask(Guid taskId) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByGlusterTaskId", volumeRowMapper, getCustomMapSqlParameterSource().addValue("task_id", taskId));
    return volume;
}
#method_after
@Override
public GlusterVolumeEntity getVolumeByGlusterTask(Guid taskId) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByGlusterTaskId", volumeRowMapper, getCustomMapSqlParameterSource().addValue("task_id", taskId));
    fetchRelatedEntities(volume);
    return volume;
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getStepId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#end_block

#method_before
protected void endStepJob(JobExecutionStatus status, Map<String, String> stepMessageMap) {
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    // Gluster Task will be associated with only one step ( REBALANCING_VOLUME or REMOVING_BRICK)
    Step step = getStepDao().getStepsByExternalId(asyncTask.getTaskId()).get(0);
    step.markStepEnded(status);
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(getStepType(), stepMessageMap));
    JobRepositoryFactory.getJobRepository().updateStep(step);
    ExecutionContext finalContext = ExecutionHandler.createFinalizingContext(step.getId());
    ExecutionHandler.endTaskJob(finalContext, false);
}
#method_after
protected void endStepJob(JobExecutionStatus status, Map<String, String> stepMessageMap, boolean exitStatus) {
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    // Gluster Task will be associated with only one step ( REBALANCING_VOLUME or REMOVING_BRICK)
    Step step = getStepDao().getStepsByExternalId(asyncTask.getTaskId()).get(0);
    step.markStepEnded(status);
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(getStepType(), stepMessageMap));
    JobRepositoryFactory.getJobRepository().updateStep(step);
    ExecutionContext finalContext = ExecutionHandler.createFinalizingContext(step.getId());
    ExecutionHandler.endTaskJob(finalContext, exitStatus);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJob(JobExecutionStatus.FINISHED, getStepMessageMap(JobExecutionStatus.FINISHED));
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#method_after
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    // Remove brick task is marked completed only if committed or aborted.
    if (JobExecutionStatus.ABORTED == task.getStatus() || (JobExecutionStatus.FINISHED == task.getStatus() && task.getType() != GlusterTaskType.REMOVE_BRICK) || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#end_block

#method_before
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    values.put(GlusterConstants.JOB_STATUS, task.getStatus().toString());
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#method_after
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void mockBackend(boolean succeeded, VdcBllErrors errorCode) {
    when(cmd.getBackend()).thenReturn(backend);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(new HashMap<String, String>()).when(cmd).getStepMessageMap(any(JobExecutionStatus.class));
    doNothing().when(cmd).endStepJob(any(JobExecutionStatus.class), any(Map.class));
    doNothing().when(cmd).releaseVolumeLock();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setSucceeded(succeeded);
    if (!succeeded) {
        vdsReturnValue.setVdsError(new VDSError(errorCode, ""));
    }
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.CommitRemoveGlusterVolumeBricks), argThat(anyGlusterVolumeVDS()))).thenReturn(vdsReturnValue);
}
#method_after
@SuppressWarnings("unchecked")
private void mockBackend(boolean succeeded, VdcBllErrors errorCode) {
    when(cmd.getBackend()).thenReturn(backend);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doNothing().when(cmd).endStepJobCommitted();
    doNothing().when(cmd).releaseVolumeLock();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setSucceeded(succeeded);
    if (!succeeded) {
        vdsReturnValue.setVdsError(new VDSError(errorCode, ""));
    }
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.CommitRemoveGlusterVolumeBricks), argThat(anyGlusterVolumeVDS()))).thenReturn(vdsReturnValue);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testExecuteCommand() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJob(any(JobExecutionStatus.class), any(Map.class));
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testExecuteCommand() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJobCommitted();
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT);
}
#end_block

#method_before
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(false, VdcBllErrors.GlusterVolumeRemoveBricksCommitFailed);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, never()).endStepJob();
    verify(cmd, never()).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED);
}
#method_after
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(false, VdcBllErrors.GlusterVolumeRemoveBricksCommitFailed);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, never()).endStepJobAborted();
    verify(cmd, never()).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    getSearchCommand().execute();
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        VdcUser vdcUser = Frontend.getLoggedInUser();
        if (vdcUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(vdcUser.getUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getQueryStartedEvent().addListener(this);
    Frontend.getQueryCompleteEvent().addListener(this);
    Frontend.subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getQueryStartedEvent().addListener(this);
    Frontend.getQueryCompleteEvent().addListener(this);
    Frontend.subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
            updateQuota(datacenter);
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            for (Disk disk : disks) {
                if (disk.isBoot() && !disk.equals(getDisk())) {
                    diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                    diskModel.getIsBootable().setEntity(false);
                    diskModel.getIsBootable().setIsChangable(false);
                    break;
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
public void updateInterface(int osId, Version clusterVersion, AsyncQuery chainedAsyncQuery) {
    final INewAsyncCallback chainedCallback = chainedAsyncQuery.asyncCallback;
    if (clusterVersion == null) {
        ArrayList<DiskInterface> diskInterfaces = AsyncDataProvider.getDiskInterfaceList();
        getDiskInterface().setItems(diskInterfaces);
        chainedCallback.onSuccess(this, null);
    } else {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getDiskInterface().setItems((List<DiskInterface>) returnValue);
                chainedCallback.onSuccess(model, returnValue);
            }
        };
        AsyncDataProvider.getDiskInterfaceList(osId, clusterVersion, asyncQuery);
    }
}
#method_after
public void updateInterface(final Version clusterVersion) {
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue1) {
                final boolean isVirtioScsiDisabled = Boolean.FALSE.equals(returnValue1);
                AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue2) {
                        ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue2;
                        if (isVirtioScsiDisabled) {
                            diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                        }
                        setInterfaces(diskInterfaces);
                    }
                });
                AsyncDataProvider.getDiskInterfaceList(getVm().getOs(), clusterVersion, asyncQuery);
            }
        }), getVm().getId());
    } else {
        setInterfaces(AsyncDataProvider.getDiskInterfaceList());
    }
}
#end_block

#method_before
private void datacenter_SelectedItemChanged() {
    StoragePool datacenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean isInternal = getIsInternal().getEntity() != null ? (Boolean) getIsInternal().getEntity() : false;
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateVolumeType(datacenter.getStorageType());
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    if (isInVm) {
        updateInterface(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    } else {
        updateInterface(0, null);
    }
    if (isInternal) {
        updateStorageDomains(datacenter);
    } else {
        updateHosts(datacenter);
    }
}
#method_after
private void datacenter_SelectedItemChanged() {
    StoragePool datacenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean isInternal = getIsInternal().getEntity() != null ? (Boolean) getIsInternal().getEntity() : false;
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateVolumeType(datacenter.getStorageType());
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getVdsGroupCompatibilityVersion() : null);
    if (isInternal) {
        updateStorageDomains(datacenter);
    } else {
        updateHosts(datacenter);
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void hasSpiceSupport(int osId, Version version, AsyncQuery callback) {
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupport, osId, version), callback);
}
#method_after
public static Boolean hasSpiceSupport(int osId, Version version) {
    return spiceSupportMatrix.get(osId).get(version);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
@JsonIgnore
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#method_after
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    mockVmDevice(false);
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#end_block

#method_before
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class))).thenReturn(vmList);
}
#method_after
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#end_block

#method_before
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    return disk;
}
#method_after
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#end_block

#method_before
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(false);
}
#method_after
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm().getId(), disk, vmDevice));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#end_block

#method_before
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (!diskInfo.isDiskSnapshot() && diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot() && !disk.isDiskSnapshot()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isInterfaceSupportedForPlugUnPlug(Disk disk) {
    boolean retVal = true;
    List<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    if (diskHotpluggableInterfaces == null || diskHotpluggableInterfaces.isEmpty()) {
        retVal = false;
    }
    if (retVal) {
        Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
        for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
            diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
        }
        if (!diskInterfaces.contains(disk.getDiskInterface())) {
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return retVal;
}
#method_after
protected boolean isInterfaceSupportedForPlugUnPlug(Disk disk) {
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(disk.getDiskInterface().toString())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private boolean isDiskExistInVm(Disk disk) {
    List<VM> listVms = getVmDAO().getVmsListForDisk(disk.getId());
    for (VM vm : listVms) {
        if (vm.getId().equals(getVmId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isDiskExistInVm(Disk disk) {
    List<VM> listVms = getVmDAO().getVmsListForDisk(disk.getId(), true);
    for (VM vm : listVms) {
        if (vm.getId().equals(getVmId())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(true);
}
#method_after
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(true);
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(jobId, ExecutionMessageDirector.resolveStepMessage(StepEnum.EXECUTING, null), StepEnum.EXECUTING));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid execStepId = (Guid) result.getActionReturnValue();
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        // acquire lock on volume
        acquireLock(vol.getId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks == null) {
                return;
            }
            List<GlusterBrickEntity> brickEntities = new ArrayList<>();
            for (String brick : bricks) {
                String[] brickParts = brick.split(":", -1);
                String hostnameOrIp = brickParts[0];
                String brickDir = brickParts[1];
                GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                if (server == null) {
                    log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                } else {
                    brickEntity.setServerId(server.getId());
                    brickEntity.setBrickDirectory(brickDir);
                    brickEntity.setAsyncTask(new GlusterAsyncTask());
                    brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                    brickEntities.add(brickEntity);
                }
            }
            getBrickDao().updateAllBrickTasksByHostIdBrickDir(brickEntities);
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#method_after
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        // acquire lock on volume
        acquireLock(vol.getId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks == null) {
                return;
            }
            List<GlusterBrickEntity> brickEntities = new ArrayList<>();
            for (String brick : bricks) {
                String[] brickParts = brick.split(":", -1);
                String hostnameOrIp = brickParts[0];
                String brickDir = brickParts[1];
                GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                if (server == null) {
                    log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                } else {
                    brickEntity.setServerId(server.getId());
                    brickEntity.setBrickDirectory(brickDir);
                    brickEntity.setAsyncTask(new GlusterAsyncTask());
                    brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                    brickEntities.add(brickEntity);
                }
            }
            getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    if (map.get(BRICK_NAMES) != null) {
        task.getTaskParameters().setBricks((String[]) map.get(BRICK_NAMES));
    }
    return task;
}
#method_after
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.fromValue((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    task.getTaskParameters().setBricks(getBrickNames(map.get(BRICK_NAMES)));
    return task;
}
#end_block

#method_before
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.debug("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#end_block

#method_before
protected Object resolveCreated(VdcReturnValueBase result, EntityResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        return entityResolver.resolve((Guid) result.getActionReturnValue());
    } catch (Exception e) {
        // already succeeded
        return null;
    }
}
#method_after
protected Object resolveCreated(VdcReturnValueBase result, EntityResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        return entityResolver.resolve(result.getActionReturnValue());
    } catch (Exception e) {
        // already succeeded
        return null;
    }
}
#end_block

#method_before
protected static void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
        for (DiskImage diskSnapshot : diskSnapshots) {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
                compensationContext.stateChanged();
                return null;
            }
        });
    } else {
        DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
    }
}
#method_after
protected static void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
        for (DiskImage diskSnapshot : diskSnapshots) {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
                compensationContext.stateChanged();
                return null;
            }
        });
    } else {
        updateAllDiskImageSnapshotsStatus(diskId, status);
    }
}
#end_block

#method_before
protected Guid findImageForSameDrive(SnapshotType snapshotType) {
    return findImageForSameDrive(getSnapshotDao().getId(getVmDAO().getVmsListForDisk(getImage().getId()).get(0).getId(), snapshotType));
}
#method_after
protected Guid findImageForSameDrive(SnapshotType snapshotType) {
    return findImageForSameDrive(getSnapshotDao().getId(getVmDAO().getVmsListForDisk(getImage().getId(), false).get(0).getId(), snapshotType));
}
#end_block

#method_before
private VM getVmForNonShareableDiskImage(DiskImage disk) {
    if (!disk.isShareable()) {
        List<VM> vms = getVmDAO().getVmsListForDisk(disk.getId());
        if (!vms.isEmpty()) {
            return vms.get(0);
        }
    }
    return null;
}
#method_after
private VM getVmForNonShareableDiskImage(DiskImage disk) {
    if (!disk.isShareable()) {
        List<VM> vms = getVmDAO().getVmsListForDisk(disk.getId(), false);
        if (!vms.isEmpty()) {
            return vms.get(0);
        }
    }
    return null;
}
#end_block

#method_before
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
            ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.OK, null, null);
            return null;
        }
    });
}
#method_after
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
            ImagesHandler.updateAllDiskImageSnapshotsStatus(getRelevantDiskImage().getId(), getRelevantDiskImage().getImageStatus());
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void lockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
}
#method_after
@Override
protected void lockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, getRelevantDiskImage().getImageStatus(), getCompensationContext());
}
#end_block

#method_before
@Override
protected void unLockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.OK, null, null);
}
#method_after
@Override
protected void unLockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatus(getRelevantDiskImage().getId(), ImageStatus.OK);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setQuotaParameter();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getQuotaDAO().save(getQuota());
            copyQuotaPermissions();
            getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
protected void executeCommand() {
    setQuotaParameter();
    if (getParameters().isCopyPermissions()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                return executeAddQutoa();
            }
        });
    } else {
        executeAddQutoa();
    }
}
#end_block

#method_before
private void copyQuotaPermissions() {
    if (!getParameters().isCopyPermissions()) {
        return;
    }
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getCurrentUser().getUserId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), VdcObjectType.Quota);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#method_after
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getCurrentUser().getId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    final int nextTabIndex = setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
    if (object.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) object.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                setButtonsTabIndex(nextTabIndex);
            }
        });
    }
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public HasUiCommandClickHandlers addFooterButton(String label, String uniqueId) {
    AbstractUiCommandButton button = createCommandButton(label, uniqueId);
    asWidget().addFooterButton(button);
    buttonsMap.put(label, (UiCommandButton) button);
    // Set button element ID for better accessibility
    button.asWidget().getElement().setId(ElementIdUtils.createElementId(elementId, uniqueId));
    return button;
}
#method_after
@Override
public HasUiCommandClickHandlers addFooterButton(String label, String uniqueId) {
    AbstractUiCommandButton button = createCommandButton(label, uniqueId);
    asWidget().addFooterButton(button);
    focusableButtons.add(0, button);
    // Set button element ID for better accessibility
    button.asWidget().getElement().setId(ElementIdUtils.createElementId(elementId, uniqueId));
    return button;
}
#end_block

#method_before
@Override
public void removeButtons() {
    asWidget().removeFooterButtons();
}
#method_after
@Override
public void removeButtons() {
    asWidget().removeFooterButtons();
    focusableButtons.clear();
}
#end_block

#method_before
@Override
public void stopProgress() {
    // Set dialog content to the actual popup content widget
    asWidget().setContent(popupContent);
    // Show dialog buttons when stopping progress
    asWidget().setFooterPanelVisible(true);
    // Now that the panel is visible we can try to focus
    focusInput();
}
#method_after
@Override
public void stopProgress() {
    // Set dialog content to the actual popup content widget
    asWidget().setContent(popupContent);
    // Show dialog buttons when stopping progress
    asWidget().setFooterPanelVisible(true);
    // Update tab index values
    updateTabIndexes();
    // Now that the panel is visible we can try to focus
    focusInput();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
        if (!validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : new ArrayList<VDS>();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#method_after
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    // Find the image corresponding to the status of the volume:
    GlusterStatus status = volume.getStatus();
    ImageResource statusImage = null;
    String tooltip;
    Boolean brickWarn = false;
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getStatus() == GlusterStatus.DOWN) {
            brickWarn = true;
        }
    }
    if (!brickWarn) {
        switch(status) {
            case DOWN:
                statusImage = resources.downImage();
                tooltip = constants.down();
                break;
            case UP:
                statusImage = resources.upImage();
                tooltip = constants.up();
                break;
            default:
                statusImage = resources.downImage();
                tooltip = constants.down();
        }
    } else {
        statusImage = resources.volumeBrickWarning();
        tooltip = constants.brickWarning();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    int brickCount = volume.getBricks().size();
    int count = 0;
    // Find the image corresponding to the status of the volume:
    GlusterStatus status = volume.getStatus();
    ImageResource statusImage = null;
    String tooltip;
    switch(status) {
        case DOWN:
            statusImage = resources.downImage();
            tooltip = constants.down();
            break;
        case UP:
            count = countDownBricks(volume);
            if (count == 0) {
                statusImage = resources.upImage();
                tooltip = constants.up();
            } else if (count < brickCount) {
                statusImage = resources.volumeBricksDownWarning();
                tooltip = constants.volumeBricksDown();
            } else {
                statusImage = resources.volumeAllBricksDownWarning();
                tooltip = constants.volumeAllBricksDown();
            }
            break;
        default:
            statusImage = resources.downImage();
            tooltip = constants.down();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#end_block

#method_before
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().isStoragePoolMasterUp(_storagePoolId)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool, _isSpmStartCalled);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent - ", exp);
            }
        }
    });
}
#method_after
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().isStoragePoolMasterUp(_storagePoolId)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent - ", exp);
            }
        }
    });
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsAvailable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getIsSingleQxlEnabled().setEntity(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    if (getSelectedCluster() != null) {
        getIsSingleQxlEnabled().setEntity(getIsLinuxOS() && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0);
    } else {
        getIsSingleQxlEnabled().setEntity(false);
    }
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return;
    }
    DisplayType type = (DisplayType) entityModel.getEntity();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    getBehavior().updateSingleQxl(type == DisplayType.qxl);
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = (Boolean) getIsPm().getEntity();
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable((Boolean) getIsPm().getEntity());
    Object proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    // $NON-NLS-1$
    String version = "general";
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = (String) getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    String pmSecondaryType = (String) getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = (Boolean) getIsPm().getEntity();
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable((Boolean) getIsPm().getEntity());
    Object proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    String version = AsyncDataProvider.getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = (String) getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    String pmSecondaryType = (String) getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String version = ((GetAgentFenceOptionsQueryParameters) getParameters()).getVersion();
    VdsFenceOptions options = new VdsFenceOptions(version);
    HashMap<String, HashMap<String, String>> map = options.getFencingOptionMappingMap();
    getQueryReturnValue().setReturnValue(map);
    getQueryReturnValue().setSucceeded(map.size() > 0);
}
#method_after
@Override
protected void executeQueryCommand() {
    String version = getParameters().getVersion();
    VdsFenceOptions options = new VdsFenceOptions(version);
    HashMap<String, HashMap<String, String>> map = options.getFencingOptionMappingMap();
    getQueryReturnValue().setReturnValue(map);
    getQueryReturnValue().setSucceeded(map.size() > 0);
}
#end_block

#method_before
private void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName((String) getName().getEntity());
    VnicProfileView profile = (VnicProfileView) getProfile().getSelectedItem();
    nic.setVnicProfileId(profile != null ? profile.getId() : null);
    nic.setLinked((Boolean) getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(((VmInterfaceType) getNicType().getSelectedItem()).getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged((Boolean) getPlugged().getEntity());
    startProgress(null);
    Frontend.RunAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#method_after
private void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName((String) getName().getEntity());
    VnicProfileView profile = (VnicProfileView) getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked((Boolean) getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(((VmInterfaceType) getNicType().getSelectedItem()).getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged((Boolean) getPlugged().getEntity());
    startProgress(null);
    Frontend.RunAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#end_block

#method_before
private void postNicInit() {
    initSelectedType();
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!hotPlugSupported) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().hotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    initCommands();
}
#method_after
private void postNicInit() {
    initSelectedType();
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(allowPlug());
    initCommands();
}
#end_block

#method_before
private void postNicInit() {
    initSelectedType();
    getName().setEntity(AsyncDataProvider.getNewNicName(getVmNicList()));
    initMAC();
    if (!hotPlugSupported) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().hotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    getPlugged().setEntity(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    initLinked();
    initProfiles();
    initCommands();
}
#method_after
private void postNicInit() {
    initSelectedType();
    getName().setEntity(AsyncDataProvider.getNewNicName(getVmNicList()));
    initMAC();
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(allowPlug());
    getPlugged().setEntity(allowPlug());
    initLinked();
    initProfiles();
    initCommands();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasSpiceSupport:
            setReturnValue(osRepository.hasSpiceSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetSpiceSupportMatrix:
            setReturnValue(osRepository.getSpiceSupportMatrix());
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initNicHotplugSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (HashMap<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static HashMap<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#method_after
public static Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void hasSpiceSupport(int osId, Version version, AsyncQuery callback) {
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupport, osId, version), callback);
}
#method_after
public static Boolean hasSpiceSupport(int osId, Version version) {
    return spiceSupportMatrix.get(osId).get(version);
}
#end_block

#method_before
public static <T extends Disk> boolean checkPciAndIdeLimit(int monitorsNumber, List<VmNic> interfaces, List<T> disks, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    }).isEmpty() ? 0 : 1;
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#method_after
public static <T extends Disk> boolean checkPciAndIdeLimit(int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#end_block

#method_before
protected void removeVmNetwork() {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), (getSnapshotName() == null) ? "" : getSnapshotName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), StringUtils.defaultString(getSnapshotName()));
    }
    return jobProperties;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID.toString());
        }
        if (clusterId == null) {
            clusterId = volume.getClusterId();
        }
        asyncTask = volume.getAsyncTask();
        getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID.toString());
        }
        if (clusterId == null) {
            clusterId = volume.getClusterId();
        }
        getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
    }
}
#end_block

#method_before
private GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
    if (stepsList != null && !stepsList.isEmpty()) {
        entity.setStartTime(stepsList.get(0).getStartTime());
    }
    return entity;
}
#method_after
private GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null) {
        Guid taskId = asyncTask.getTaskId();
        if (taskId != null) {
            List<Step> stepsList = getStepDao().getStepsByExternalId(taskId);
            if (stepsList != null && !stepsList.isEmpty()) {
                entity.setStartTime(stepsList.get(0).getStartTime());
            }
        }
    }
    // Set the host ip in status details
    updateHostIP(entity);
    return entity;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Locate the requested file:
    File originalFile = ServletUtils.makeFileFromSanePath(request.getPathInfo(), base);
    Locale locale = getLocaleFromRequest(request);
    File file = determineActualFile(request, locale);
    file = checkForIndex(request, response, file, request.getPathInfo());
    if (file == null) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else if (!response.isCommitted()) {
        // If the response is committed, we have already redirected.
        boolean languagePageShown = isLangPageShown(request);
        if (!file.equals(originalFile) && !file.getAbsolutePath().equals(replaceLocaleWithOtherLocale(originalFile.getAbsolutePath(), locale, locale))) {
            // We determined that we are going to redirect the user to the English version URI.
            String redirect = request.getServletPath() + replaceLocaleWithUSLocale(request.getPathInfo(), locale);
            if (!languagePageShown) {
                setLangPageShown(response, true);
                request.setAttribute(LocaleFilter.LOCALE, locale);
                request.setAttribute(ENGLISH_HREF, redirect);
                RequestDispatcher dispatcher = request.getRequestDispatcher(LANG_JSP);
                if (dispatcher != null) {
                    dispatcher.include(request, response);
                }
            } else {
                // Redirect to English version of the document
                response.sendRedirect(redirect);
            }
        } else {
            // Send the content of the file:
            // type is the default MIME type of the Servlet(passed in through WebInit parameter).
            ServletUtils.sendFile(request, response, file, type);
        }
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Locate the requested file:
    File originalFile = ServletUtils.makeFileFromSanePath(request.getPathInfo(), base);
    Locale locale = getLocaleFromRequest(request);
    File file = determineActualFile(request, locale);
    file = checkForIndex(request, response, file, request.getPathInfo());
    if (file == null) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else if (!response.isCommitted()) {
        // If the response is committed, we have already redirected.
        boolean languagePageShown = isLangPageShown(request);
        if (!file.equals(originalFile) && !file.getAbsolutePath().equals(replaceLocaleWithOtherLocale(originalFile.getAbsolutePath(), locale, locale))) {
            // We determined that we are going to redirect the user to the English version URI.
            String redirect = request.getServletPath() + replaceLocaleWithUSLocale(request.getPathInfo(), locale);
            if (!languagePageShown) {
                setLangPageShown(response, true);
                request.setAttribute(LocaleFilter.LOCALE, locale);
                request.setAttribute(ENGLISH_HREF, redirect);
                final ServletContext forwardContext = getServletContext().getContext(localeDocsMissing);
                if (forwardContext != null) {
                    final RequestDispatcher dispatcher = forwardContext.getRequestDispatcher(localeDocsMissing);
                    if (dispatcher != null) {
                        dispatcher.forward(request, response);
                    } else {
                        log.error("Unable to determine dispatcher");
                        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "unable to determine dispatcher");
                    }
                } else {
                    log.error("Unable to determine forwarding context");
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "unable to determine forward context");
                }
            } else {
                // Redirect to English version of the document
                response.sendRedirect(redirect);
            }
        } else {
            // Send the content of the file:
            // type is the default MIME type of the Servlet(passed in through WebInit parameter).
            ServletUtils.sendFile(request, response, file, type);
        }
    }
}
#end_block

#method_before
private GlusterVolumeTaskStatusEntity fetchRemobeBricksStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null) {
        Guid taskId = asyncTask.getTaskId();
        if (taskId != null) {
            List<Step> stepsList = getStepDao().getStepsByExternalId(taskId);
            if (stepsList != null && !stepsList.isEmpty()) {
                entity.setStartTime(stepsList.get(0).getStartTime());
            }
        }
    }
    return entity;
}
#method_after
private GlusterVolumeTaskStatusEntity fetchRemobeBricksStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            entity.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return entity;
}
#end_block

#method_before
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    return brick;
}
#method_after
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuid(rs, "task_id"));
    return brick;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("task_id", entity.getAsyncTask() != null ? entity.getAsyncTask().getTaskId().toString() : "");
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("task_id", entity.getAsyncTask().getTaskId() != null ? entity.getAsyncTask().getTaskId().toString() : "");
            return paramValue;
        }
    };
}
#end_block

#method_before
@Test
public void testUpdateAllBrickTasksByHostIdBrickDir() {
    GlusterBrickEntity existingBrick = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity existingBrick2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID2);
    GlusterAsyncTask asyncTask = new GlusterAsyncTask();
    asyncTask.setTaskId(FixturesTool.GLUSTER_ASYNC_TASK_ID1);
    // assertNull(existingBrick.getAsyncTask());
    GlusterBrickEntity updateBrick = new GlusterBrickEntity();
    updateBrick.setBrickDirectory(existingBrick.getBrickDirectory());
    updateBrick.setServerId(existingBrick.getServerId());
    updateBrick.setAsyncTask(asyncTask);
    GlusterBrickEntity updateBrick2 = new GlusterBrickEntity();
    updateBrick2.setBrickDirectory(existingBrick2.getBrickDirectory());
    updateBrick2.setServerId(existingBrick2.getServerId());
    updateBrick2.setAsyncTask(asyncTask);
    List<GlusterBrickEntity> bricks = new ArrayList<>();
    bricks.add(updateBrick);
    bricks.add(updateBrick2);
    dao.updateAllBrickTasksByHostIdBrickDir(bricks);
    GlusterBrickEntity newEntity1 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity newEntity2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity1.getAsyncTask().getTaskId());
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity2.getAsyncTask().getTaskId());
}
#method_after
@Test
public void testUpdateAllBrickTasksByHostIdBrickDir() {
    GlusterBrickEntity existingBrick = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity existingBrick2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID2);
    GlusterAsyncTask asyncTask = new GlusterAsyncTask();
    asyncTask.setTaskId(FixturesTool.GLUSTER_ASYNC_TASK_ID1);
    GlusterBrickEntity updateBrick = new GlusterBrickEntity();
    updateBrick.setBrickDirectory(existingBrick.getBrickDirectory());
    updateBrick.setServerId(existingBrick.getServerId());
    updateBrick.setAsyncTask(asyncTask);
    GlusterBrickEntity updateBrick2 = new GlusterBrickEntity();
    updateBrick2.setBrickDirectory(existingBrick2.getBrickDirectory());
    updateBrick2.setServerId(existingBrick2.getServerId());
    updateBrick2.setAsyncTask(asyncTask);
    List<GlusterBrickEntity> bricks = new ArrayList<>();
    bricks.add(updateBrick);
    bricks.add(updateBrick2);
    dao.updateAllBrickTasksByHostIdBrickDirInBatch(bricks);
    GlusterBrickEntity newEntity1 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity newEntity2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity1.getAsyncTask().getTaskId());
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity2.getAsyncTask().getTaskId());
}
#end_block

#method_before
protected void validateContainerFormat(Image glanceImage) {
    if (!glanceImage.getContainerFormat().equals(GlanceImageContainer.BARE.getValue())) {
        throw new RuntimeException("Unsupported container format");
    }
}
#method_after
protected void validateContainerFormat(Image glanceImage) {
    if (!glanceImage.getContainerFormat().equals(GlanceImageContainer.BARE.getValue())) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_CONTAINER_FORMAT, "Unsupported container format: " + glanceImage.getContainerFormat());
    }
}
#end_block

#method_before
public List<RepoImage> getAllImagesAsRepoImages() {
    ArrayList<RepoImage> repoImages = new ArrayList<>();
    long currentTime = System.currentTimeMillis();
    Integer listSize = Config.<Integer>GetValue(ConfigValues.GlanceImageListSize);
    Integer totalListSize = Config.<Integer>GetValue(ConfigValues.GlanceImageTotalListSize);
    Images images = null;
    do {
        OpenStackRequest<Images> listRequest = getClient().images().list(true).queryParam("limit", Integer.valueOf(listSize)).queryParam("sort_key", "name").queryParam("sort_dir", "asc");
        if (images != null) {
            listRequest.queryParam("marker", images.getList().get(images.getList().size() - 1).getId());
        }
        images = listRequest.execute();
        for (Image glanceImage : images) {
            RepoImage repoImage = imageToRepoImage(glanceImage);
            repoImage.setLastRefreshed(currentTime);
            repoImages.add(repoImage);
        }
    } while ((images.getList().size() >= listSize) && repoImages.size() < totalListSize);
    return repoImages;
}
#method_after
public List<RepoImage> getAllImagesAsRepoImages(Integer listSize, Integer totalListSize) {
    ArrayList<RepoImage> repoImages = new ArrayList<>();
    long currentTime = System.currentTimeMillis();
    Images images = null;
    do {
        OpenStackRequest<Images> listRequest = getClient().images().list(true).queryParam("limit", listSize).queryParam("sort_key", "name").queryParam("sort_dir", "asc");
        if (images != null) {
            listRequest.queryParam("marker", images.getList().get(images.getList().size() - 1).getId());
        }
        images = listRequest.execute();
        for (Image glanceImage : images) {
            RepoImage repoImage = imageToRepoImage(glanceImage);
            repoImage.setLastRefreshed(currentTime);
            repoImages.add(repoImage);
        }
    } while ((images.getList().size() >= listSize) && (totalListSize != null && repoImages.size() < totalListSize));
    return repoImages;
}
#end_block

#method_before
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    diskImage.setDiskAlias("GlanceDisk-" + shortHash);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new RuntimeException("Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#method_after
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    diskImage.setDiskAlias("GlanceDisk-" + shortHash);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#end_block

#method_before
public String createImageFromDiskImage(DiskImage diskImage) {
    Image glanceImage = new Image();
    glanceImage.setName(diskImage.getDiskAlias());
    if (diskImage.getVolumeFormat() == VolumeFormat.RAW) {
        glanceImage.setDiskFormat(GlanceImageFormat.RAW.getValue());
    } else if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
        glanceImage.setDiskFormat(GlanceImageFormat.COW.getValue());
    } else {
        throw new RuntimeException("Unknown disk format: " + diskImage.getVolumeFormat());
    }
    glanceImage.setContainerFormat(GlanceImageContainer.BARE.getValue());
    Image retGlanceImage = getClient().images().create(glanceImage).execute();
    return retGlanceImage.getId();
}
#method_after
public String createImageFromDiskImage(DiskImage diskImage) {
    Image glanceImage = new Image();
    glanceImage.setName(diskImage.getDiskAlias());
    if (diskImage.getVolumeFormat() == VolumeFormat.RAW) {
        glanceImage.setDiskFormat(GlanceImageFormat.RAW.getValue());
    } else if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
        glanceImage.setDiskFormat(GlanceImageFormat.COW.getValue());
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + diskImage.getVolumeFormat());
    }
    glanceImage.setContainerFormat(GlanceImageContainer.BARE.getValue());
    Image retGlanceImage = getClient().images().create(glanceImage).execute();
    return retGlanceImage.getId();
}
#end_block

#method_before
private long getCowVirtualSize(String id) throws IOException {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(id).execute();
    try {
        int bytesRead = downloadImage.getInputStream().read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new RuntimeException("Unable to read image header: " + bytesRead);
        }
    } finally {
        downloadImage.getInputStream().close();
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    if (b.getInt() == QCOW2_SIGNATURE && b.getInt() == QCOW2_VERSION) {
        b.position(QCOW2_SIZE_OFFSET);
        return b.getLong();
    }
    throw new RuntimeException("Unable to recognize QCOW2 format");
}
#method_after
private long getCowVirtualSize(String id) {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(id).execute();
    try {
        int bytesRead = downloadImage.getInputStream().read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to read image header: " + bytesRead);
        }
    } catch (IOException e) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to download image");
    } finally {
        try {
            downloadImage.getInputStream().close();
        } catch (IOException e) {
        // Silently skip errors on close
        }
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    if (b.getInt() == QCOW2_SIGNATURE && b.getInt() == QCOW2_VERSION) {
        b.position(QCOW2_SIZE_OFFSET);
        return b.getLong();
    }
    throw new OpenStackImageException(OpenStackImageException.ErrorType.UNRECOGNIZED_IMAGE_FORMAT, "Unable to recognize QCOW2 format");
}
#end_block

#method_before
protected long getImageVirtualSize(Image glanceImage) {
    validateContainerFormat(glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue()) || glanceImage.getDiskFormat().equals(GlanceImageFormat.ISO.getValue())) {
        return glanceImage.getSize();
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        try {
            return getCowVirtualSize(glanceImage.getId());
        } catch (IOException e) {
            throw new RuntimeException("Unsupported image format");
        }
    }
    throw new RuntimeException("Unsupported image format");
}
#method_after
protected long getImageVirtualSize(Image glanceImage) {
    validateContainerFormat(glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue()) || glanceImage.getDiskFormat().equals(GlanceImageFormat.ISO.getValue())) {
        return glanceImage.getSize();
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        return getCowVirtualSize(glanceImage.getId());
    }
    throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
}
#end_block

#method_before
public int getHighlyAvailableScore() {
    return this.mVdsDynamic.getHighlyAvailableScore();
}
#method_after
public Integer getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#end_block

#method_before
public void setHighlyAvailableScore(int value) {
    this.mVdsDynamic.setHighlyAvailableScore(value);
}
#method_after
public void setHighlyAvailableScore(Integer value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // through all filters -> use it
        if (vdsList != null) {
            for (VDS vds : vdsList) {
                if (vds.getId().equals(destHostId)) {
                    return destHostId;
                }
            }
        }
        if (vdsList != null && vdsList.contains(destHostId)) {
            return destHostId;
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // through all filters -> use it
        if (vdsList != null) {
            for (VDS vds : vdsList) {
                if (vds.getId().equals(destHostId)) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#end_block

#method_before
protected boolean formatStorage(StorageDomain dom, VDS vds) {
    try {
        return getVdsBroker().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vds.getId(), dom.getId())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getVdsError().getCode() != VdcBllErrors.StorageDomainDoesNotExist) {
            throw e;
        }
        log.warnFormat("Storage Domain {0} which was about to be formatted was not exists in VDS id {1}", vds.getId(), dom.getId());
        return true;
    }
}
#method_after
protected boolean formatStorage(StorageDomain dom, VDS vds) {
    try {
        return getVdsBroker().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vds.getId(), dom.getId())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() != VdcBllErrors.StorageDomainDoesNotExist) {
            throw e;
        }
        log.warnFormat("Storage Domain {0} which was about to be formatted does not exist in VDS {1}", dom.getName(), vds.getName());
        return true;
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        } else {
            // update status in step table
            for (Step step : steps) {
                if (step.getEndTime() != null) {
                    // we have already processed the task
                    continue;
                }
                step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
                if (hasTaskCompleted(task)) {
                    step.markStepEnded(task.getStatus());
                    endStepJob(step);
                    releaseVolumeLock(task.getTaskId());
                } else {
                    getJobRepository().updateStep(step);
                }
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can't find any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        }
        if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks())) {
            return false;
        }
        setStoragePoolId(getVmTemplate().getStoragePoolId());
        if (!checkStorageDomain() || !checkStorageDomainStatus(StorageDomainStatus.Active)) {
            return false;
        }
        long actualDiskSize = Double.valueOf(getVmTemplate().getActualDiskSize()).longValue();
        if (!checkFreeSpaceOnDestinationDomain(getStorageDomain(), actualDiskSize)) {
            return false;
        }
        try {
            if (atLeastOneImageFoundInStorageDomain(getTemplateDisks(), getStorageDomain().getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_CONTAINS_DISK);
            }
        } catch (RuntimeException e) {
            // There is nothing to do in case of VDSM failure to retrieve images from the given storage domain
            // except of writing the log file. The command itself will probably fail during the execution
            // and then user will get meaningful error message
            log.error("Failed to validate if target storage domain already contains one of the template disks! " + e.getMessage());
        }
        StoragePoolIsoMapId storagePoolIsoMapId = new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId().getValue());
        if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(storagePoolIsoMapId) == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskTemplateMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getStoragePoolId());
            retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkFreeSpaceOnDestinationDomain(StorageDomain domain, long requestedSizeGB) {
    return validate(new StorageDomainValidator(domain).isDomainHasSpaceForRequest(requestedSizeGB));
}
#method_after
private boolean checkFreeSpaceOnDestinationDomain(StorageDomain domain, int requestedSizeGB) {
    return validate(new StorageDomainValidator(domain).isDomainHasSpaceForRequest(requestedSizeGB));
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
                p.setParentCommand(getActionType());
                p.setEntityId(getParameters().getEntityId());
                p.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
                p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
            }
            return null;
        }
    });
}
#method_after
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), buildModeOrCopyImageGroupParameters(containerID, disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }

        private MoveOrCopyImageGroupParameters buildModeOrCopyImageGroupParameters(final Guid containerID, DiskImage disk) {
            MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
            params.setParentCommand(getActionType());
            params.setEntityInfo(getParameters().getEntityInfo());
            params.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
            params.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            params.setParentParameters(getParameters());
            return params;
        }
    });
}
#end_block

#method_before
protected void fillMacAddressIfMissing(VmNetworkInterface iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && (MacPoolManager.getInstance().getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
}
#method_after
protected void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && (MacPoolManager.getInstance().getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
}
#end_block

#method_before
protected boolean validateMacAddress(List<VmNetworkInterface> ifaces) {
    int freeMacs = 0;
    for (VmNetworkInterface iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessage("$IfaceName " + iface.getName());
                addCanDoActionMessage("$MacAddress " + iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(MacPoolManager.getInstance().getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
protected boolean validateMacAddress(List<VmNic> ifaces) {
    int freeMacs = 0;
    for (VmNic iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessage("$IfaceName " + iface.getName());
                addCanDoActionMessage("$MacAddress " + iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(MacPoolManager.getInstance().getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
private void mockGetStorageDomainList(int availableDiskSizeFirstDomain, int availableDiskSizeSecondDomain) {
    // Mock Dao
    storageDomainsList = getStorageDomainList(availableDiskSizeFirstDomain, availableDiskSizeSecondDomain);
    mockDiskImageDAO();
    mockStorageDomainDAO(storageDomainsList);
}
#method_after
protected void mockGetStorageDomainList(int availableDiskSizeFirstDomain, int availableDiskSizeSecondDomain) {
    // Mock Dao
    storageDomainsList = getStorageDomainList(availableDiskSizeFirstDomain, availableDiskSizeSecondDomain);
    mockDiskImageDAO();
    mockStorageDomainDAO(storageDomainsList);
}
#end_block

#method_before
private StoragePool mockStoragePool() {
    StoragePool storagePool = new StoragePool();
    storagePool.setstatus(StoragePoolStatus.Up);
    return storagePool;
}
#method_after
private StoragePool mockStoragePool() {
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    return storagePool;
}
#end_block

#method_before
private static void setDiskList(VmTemplate vmTemplate) {
    for (DiskImage diskImage : getDiskImageList()) {
        vmTemplate.getDiskList().add(diskImage);
    }
    Map<Guid, DiskImage> diskImageTemplate = getDiskImageTempalteList();
    for (Guid key : diskImageTemplate.keySet()) {
        vmTemplate.getDiskMap().put(key, diskImageTemplate.get(key));
    }
}
#method_after
private static void setDiskList(VmTemplate vmTemplate) {
    for (DiskImage diskImage : getDiskImageList()) {
        vmTemplate.getDiskList().add(diskImage);
    }
    Map<Guid, DiskImage> diskImageTemplate = getDiskImageTempalteList();
    vmTemplate.getDiskTemplateMap().putAll(diskImageTemplate);
}
#end_block

#method_before
private static List<DiskImage> getDiskImageList() {
    List<DiskImage> diskList = new ArrayList<DiskImage>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.NewGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskImage = new DiskImage();
    diskImage.setId(Guid.NewGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    return diskList;
}
#method_after
private static List<DiskImage> getDiskImageList() {
    List<DiskImage> diskList = new ArrayList<DiskImage>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    return diskList;
}
#end_block

#method_before
private static Map<Guid, DiskImage> getDiskImageTempalteList() {
    Map<Guid, DiskImage> diskTemplateList = new HashMap<Guid, DiskImage>();
    DiskImage diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.NewGuid());
    diskImageTemplate.setImageId(Guid.NewGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.NewGuid());
    diskImageTemplate.setImageId(Guid.NewGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    return diskTemplateList;
}
#method_after
private static Map<Guid, DiskImage> getDiskImageTempalteList() {
    Map<Guid, DiskImage> diskTemplateList = new HashMap<Guid, DiskImage>();
    DiskImage diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.newGuid());
    diskImageTemplate.setImageId(Guid.newGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.newGuid());
    diskImageTemplate.setImageId(Guid.newGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    return diskTemplateList;
}
#end_block

#method_before
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOs(VmOsType.Unassigned);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#method_after
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#end_block

#method_before
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskTemplateMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#end_block

#method_before
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#method_after
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#end_block

#method_before
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.newGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.NewGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#method_after
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#end_block

#method_before
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.NewGuid());
        disksMap.put(Guid.NewGuid(), diskImageTempalte);
    }
}
#method_after
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.newGuid());
        disksMap.put(Guid.newGuid(), diskImageTempalte);
    }
}
#end_block

#method_before
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.NewGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#method_after
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.newGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#end_block

#method_before
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<NGuid>any(NGuid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskMap().put(image.getImageId(), image);
        Map<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.NewGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.NewGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.newGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#end_block

#method_before
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
}
#method_after
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
    mcr.mockConfigValue(ConfigValues.VirtIoScsiEnabled, Version.v3_3, true);
}
#end_block

#method_before
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.NewGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    return vm;
}
#method_after
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.newGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    vm.setSingleQxlPci(false);
    return vm;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskMap().size();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskTemplateMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    spy.setVmTemplateId(Guid.NewGuid());
}
#method_after
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskTemplateMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#end_block

#method_before
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.newGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.NewGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#method_after
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#end_block

#method_before
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.NewGuid());
        disksMap.put(Guid.NewGuid(), diskImageTempalte);
    }
}
#method_after
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.newGuid());
        disksMap.put(Guid.newGuid(), diskImageTempalte);
    }
}
#end_block

#method_before
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.NewGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#method_after
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.newGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#end_block

#method_before
private void mockBackend(AddVmCommand<?> cmd) {
    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
    returnValue.setReturnValue(Boolean.FALSE);
    when(backend.runInternalQuery(Matchers.<VdcQueryType>any(VdcQueryType.class), Matchers.any(VdcQueryParametersBase.class))).thenReturn(returnValue);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(backend).when(cmd).getBackend();
}
#method_after
private void mockBackend(AddVmCommand<?> cmd) {
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(backend).when(cmd).getBackend();
}
#end_block

#method_before
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<NGuid>any(NGuid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskMap().put(image.getImageId(), image);
        Map<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.NewGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.NewGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.newGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#end_block

#method_before
private void mockGetImageDomainsListVdsCommand() {
    ArrayList<Guid> guids = new ArrayList<Guid>(1);
    guids.add(Guid.NewGuid());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(guids);
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GetImageDomainsList), Matchers.<VDSParametersBase>any(VDSParametersBase.class))).thenReturn(returnValue);
}
#method_after
private void mockGetImageDomainsListVdsCommand() {
    ArrayList<Guid> guids = new ArrayList<Guid>(1);
    guids.add(Guid.newGuid());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(guids);
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GetImageDomainsList), Matchers.<VDSParametersBase>any(VDSParametersBase.class))).thenReturn(returnValue);
}
#end_block

#method_before
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
}
#method_after
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
    mcr.mockConfigValue(ConfigValues.VirtIoScsiEnabled, Version.v3_3, true);
}
#end_block

#method_before
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.NewGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    return vm;
}
#method_after
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.newGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    vm.setSingleQxlPci(false);
    return vm;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskTemplateMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    spy.setVmTemplateId(Guid.NewGuid());
}
#method_after
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
protected InstanceType getInstanceType() {
    if (instanceType == null && instanceTypeId != null) {
        instanceType = getVmTemplateDAO().getInstanceType(instanceTypeId.getValue());
    }
    return instanceType;
}
#method_after
protected InstanceType getInstanceType() {
    if (instanceType == null && instanceTypeId != null) {
        instanceType = getVmTemplateDAO().getInstanceType(instanceTypeId);
    }
    return instanceType;
}
#end_block

#method_before
protected ImageType getImageType() {
    if (imageType == null && imageTypeId != null) {
        imageType = getVmTemplateDAO().getImageType(imageTypeId.getValue());
    }
    return imageType;
}
#method_after
protected ImageType getImageType() {
    if (imageType == null && imageTypeId != null) {
        imageType = getVmTemplateDAO().getImageType(imageTypeId);
    }
    return imageType;
}
#end_block

#method_before
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId().getValue() : Guid.Empty);
    }
}
#method_after
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId() : Guid.Empty);
    }
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId().getValue(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                    return false;
                }
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return vmDisksSource.getStoragePoolId().getValue();
}
#method_after
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return vmDisksSource.getStoragePoolId();
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>GetValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning if the check haven't failed yet
    if (returnValue) {
        VM vmFromParams = getParameters().getVm();
        returnValue = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData());
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (returnValue && instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (returnValue && imageTypeId != null && getImageType() == null) {
        // invalid image type
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return vmDisksSource.getDiskMap().values();
}
#method_after
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return vmDisksSource.getDiskTemplateMap().values();
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId().getValue()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = verifyAddVM(reasons, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (StorageDomain storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.VerifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions(newDiskImages);
                    // these devices can't be changed if using instance type
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), newDiskImages, _vmInterfaces);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled());
}
#end_block

#method_before
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = vmStaticData.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST || !vmStaticData.isAutoStartup();
        if (!returnValue) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        }
        if (!returnValue) {
            returnValue = returnValue && IsLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        }
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOs(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version().toString());
    }
    return returnValue;
}
#method_after
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.NewGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getVdsmTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#end_block

#method_before
protected void removeVmRelatedEntitiesFromDb() {
    removeVmUsers();
    removeVmNetwork();
    new SnapshotsManager().removeSnapshots(getVmId());
    removeVmStatic();
}
#method_after
protected void removeVmRelatedEntitiesFromDb() {
    removeVmUsers();
    removeVmNetwork();
    // Note that currently newly added vm never have memory state
    // In case it will be changed (clone vm from snapshot will clone the memory state),
    // we'll need to remove the memory state images here as well.
    removeVmSnapshots();
    removeVmStatic();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(GuidUtils.getGuidValue(disk.getStorageIds().get(0)), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    // if using instance type, need create instance
    if (getInstanceType() != null) {
        permissionList.add(new PermissionSubject(instanceTypeId.getValue(), VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    // if using image type, need create instance
    if (getImageType() != null) {
        permissionList.add(new PermissionSubject(imageTypeId.getValue(), VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(disk.getStorageIds().get(0), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    // if using instance type, need create instance
    if (getInstanceType() != null) {
        permissionList.add(new PermissionSubject(instanceTypeId, VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    // if using image type, need create instance
    if (getImageType() != null) {
        permissionList.add(new PermissionSubject(imageTypeId, VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#end_block

#method_before
protected void addVmPermission() {
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissions perms = new permissions(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
        MultiLevelAdministrationHandler.addPermission(perms);
        getCompensationContext().snapshotNewEntity(perms);
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
protected void addDiskPermissions(List<DiskImage> newDiskImages) {
    permissions[] permsArray = new permissions[newDiskImages.size()];
    for (int i = 0; i < newDiskImages.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImages.get(i).getId(), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.NewGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#method_after
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.newGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // TODO: this handle sound card, will be available soon
        // use sound card only if instance type has it
        // List<VmDevice> list =
        // getVmDeviceDao()
        // .getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceType.SOUND.getName());
        // getParameters().setSoundDeviceEnabled(!list.isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOs(imageType.getOs());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return PermitType.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return PermitType.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return PermitType.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return PermitType.CREATE_INSTANCE;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CREATE_STORAGE_POOL_NETWORK:
            return PermitType.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return PermitType.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return PermitType.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_HOOK:
            return PermitType.MANIPULATE_GLUSTER_HOOK;
        case CREATE_DISK:
            return PermitType.CREATE_DISK;
        case ATTACH_DISK:
            return PermitType.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return PermitType.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return PermitType.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return PermitType.DELETE_DISK;
        case PORT_MIRRORING:
            return PermitType.PORT_MIRRORING;
        case LOGIN:
            return PermitType.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return PermitType.INJECT_EXTERNAL_EVENTS;
        case MANIPULATE_GLUSTER_SERVICE:
            return PermitType.MANIPULATE_GLUSTER_SERVICE;
        default:
            return null;
    }
}
#method_after
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return PermitType.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return PermitType.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return PermitType.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return PermitType.CREATE_INSTANCE;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CREATE_STORAGE_POOL_NETWORK:
            return PermitType.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return PermitType.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return PermitType.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_HOOK:
            return PermitType.MANIPULATE_GLUSTER_HOOK;
        case CREATE_DISK:
            return PermitType.CREATE_DISK;
        case ATTACH_DISK:
            return PermitType.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return PermitType.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return PermitType.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return PermitType.DELETE_DISK;
        case CONFIGURE_NETWORK_VNIC_PROFILE:
            return PermitType.CONFIGURE_NETWORK_VNIC_PROFILE;
        case CREATE_NETWORK_VNIC_PROFILE:
            return PermitType.CREATE_NETWORK_VNIC_PROFILE;
        case DELETE_NETWORK_VNIC_PROFILE:
            return PermitType.DELETE_NETWORK_VNIC_PROFILE;
        case LOGIN:
            return PermitType.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return PermitType.INJECT_EXTERNAL_EVENTS;
        case MANIPULATE_GLUSTER_SERVICE:
            return PermitType.MANIPULATE_GLUSTER_SERVICE;
        case CONFIGURE_SCSI_GENERIC_IO:
            return PermitType.CONFIGURE_SCSI_GENERIC_IO;
        case INJECT_EXTERNAL_TASKS:
            return PermitType.INJECT_EXTERNAL_TASKS;
        case ACCESS_IMAGE_STORAGE:
            return PermitType.ACCESS_IMAGE_STORAGE;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = PermitType.class, to = ActionGroup.class)
public static ActionGroup map(PermitType entity, ActionGroup template) {
    switch(entity) {
        case CREATE_VM:
            return ActionGroup.CREATE_VM;
        case DELETE_VM:
            return ActionGroup.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return ActionGroup.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return ActionGroup.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return ActionGroup.CHANGE_VM_CD;
        case MIGRATE_VM:
            return ActionGroup.MIGRATE_VM;
        case CONNECT_TO_VM:
            return ActionGroup.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return ActionGroup.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return ActionGroup.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return ActionGroup.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return ActionGroup.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return ActionGroup.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return ActionGroup.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return ActionGroup.CREATE_INSTANCE;
        case CREATE_HOST:
            return ActionGroup.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return ActionGroup.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return ActionGroup.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return ActionGroup.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return ActionGroup.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return ActionGroup.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return ActionGroup.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return ActionGroup.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return ActionGroup.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return ActionGroup.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return ActionGroup.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return ActionGroup.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return ActionGroup.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return ActionGroup.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return ActionGroup.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return ActionGroup.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return ActionGroup.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return ActionGroup.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return ActionGroup.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return ActionGroup.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return ActionGroup.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return ActionGroup.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return ActionGroup.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return ActionGroup.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return ActionGroup.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return ActionGroup.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_RHEVM:
            return ActionGroup.CONFIGURE_ENGINE;
        case CONFIGURE_QUOTA:
            return ActionGroup.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return ActionGroup.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return ActionGroup.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return ActionGroup.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return ActionGroup.DELETE_GLUSTER_VOLUME;
        case CREATE_DISK:
            return ActionGroup.CREATE_DISK;
        case ATTACH_DISK:
            return ActionGroup.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return ActionGroup.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return ActionGroup.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return ActionGroup.DELETE_DISK;
        case PORT_MIRRORING:
            return ActionGroup.PORT_MIRRORING;
        case LOGIN:
            return ActionGroup.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return ActionGroup.INJECT_EXTERNAL_EVENTS;
        case CREATE_STORAGE_POOL_NETWORK:
            return ActionGroup.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return ActionGroup.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return ActionGroup.ASSIGN_CLUSTER_NETWORK;
        default:
            return null;
    }
}
#method_after
@Mapping(from = PermitType.class, to = ActionGroup.class)
public static ActionGroup map(PermitType entity, ActionGroup template) {
    switch(entity) {
        case CREATE_VM:
            return ActionGroup.CREATE_VM;
        case DELETE_VM:
            return ActionGroup.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return ActionGroup.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return ActionGroup.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return ActionGroup.CHANGE_VM_CD;
        case MIGRATE_VM:
            return ActionGroup.MIGRATE_VM;
        case CONNECT_TO_VM:
            return ActionGroup.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return ActionGroup.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return ActionGroup.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return ActionGroup.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return ActionGroup.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return ActionGroup.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return ActionGroup.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return ActionGroup.CREATE_INSTANCE;
        case CREATE_HOST:
            return ActionGroup.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return ActionGroup.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return ActionGroup.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return ActionGroup.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return ActionGroup.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return ActionGroup.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return ActionGroup.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return ActionGroup.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return ActionGroup.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return ActionGroup.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return ActionGroup.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return ActionGroup.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return ActionGroup.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return ActionGroup.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return ActionGroup.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return ActionGroup.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return ActionGroup.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return ActionGroup.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return ActionGroup.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return ActionGroup.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return ActionGroup.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return ActionGroup.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return ActionGroup.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return ActionGroup.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return ActionGroup.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return ActionGroup.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_RHEVM:
            return ActionGroup.CONFIGURE_ENGINE;
        case CONFIGURE_QUOTA:
            return ActionGroup.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return ActionGroup.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return ActionGroup.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return ActionGroup.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return ActionGroup.DELETE_GLUSTER_VOLUME;
        case CREATE_DISK:
            return ActionGroup.CREATE_DISK;
        case ATTACH_DISK:
            return ActionGroup.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return ActionGroup.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return ActionGroup.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return ActionGroup.DELETE_DISK;
        case CONFIGURE_NETWORK_VNIC_PROFILE:
            return ActionGroup.CONFIGURE_NETWORK_VNIC_PROFILE;
        case CREATE_NETWORK_VNIC_PROFILE:
            return ActionGroup.CREATE_NETWORK_VNIC_PROFILE;
        case DELETE_NETWORK_VNIC_PROFILE:
            return ActionGroup.DELETE_NETWORK_VNIC_PROFILE;
        case LOGIN:
            return ActionGroup.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return ActionGroup.INJECT_EXTERNAL_EVENTS;
        case CREATE_STORAGE_POOL_NETWORK:
            return ActionGroup.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return ActionGroup.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return ActionGroup.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_SCSI_GENERIC_IO:
            return ActionGroup.CONFIGURE_SCSI_GENERIC_IO;
        case INJECT_EXTERNAL_TASKS:
            return ActionGroup.INJECT_EXTERNAL_TASKS;
        case ACCESS_IMAGE_STORAGE:
            return ActionGroup.ACCESS_IMAGE_STORAGE;
        default:
            return null;
    }
}
#end_block

#method_before
protected void updateVmDisks() {
    VmHandler.updateDisksFromDb(getVm());
}
#method_after
protected void updateVmDisks() {
    VmHandler.updateDisksFromDb(getVm());
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), newDiskImages, vmInterfaces);
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOs(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
        for (DiskImage image : mImages) {
            MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
            if (!diskInfoDestinationMap.containsKey(image.getId())) {
                Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getStorageIds().get(0);
                ArrayList<Guid> storageIds = new ArrayList<Guid>();
                storageIds.add(destStorageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
            }
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType() == StorageDomainType.ImportExport || storage.getStorageDomainType() == StorageDomainType.ISO) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType() == StorageDomainType.ImportExport || storage.getStorageDomainType() == StorageDomainType.ISO) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected void addVmInterfaces(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        getVmNicDao().save(iDynamic);
        srcDeviceIdToTargetDeviceIdMapping.put(iface.getId(), iDynamic.getId());
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.UnLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#method_after
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.unLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getStoragePoolId() == null ? null : getVdsGroup().getStoragePoolId().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        // host-specific parameters can be changed by administration role only
        if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        // host-specific parameters can be changed by administration role only
        if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
private void addPermission() {
    addPermissionForTemplate(getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    }
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
private void addPermissionForTemplate(Guid userId, PredefinedRoles role) {
    permissions perms = new permissions();
    perms.setad_element_id(userId);
    perms.setObjectType(VdcObjectType.VmTemplate);
    perms.setObjectId(getParameters().getVmTemplateId());
    perms.setrole_id(role.getId());
    MultiLevelAdministrationHandler.addPermission(perms);
}
#method_after
private void addPermissionForTemplate(UniquePermissionsSet permissionsToAdd, Guid userId, PredefinedRoles role) {
    permissionsToAdd.addPermission(userId, role.getId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmTemplateDao();
    existingTemplate = dao.get(new Guid("1b85420c-b84c-4f29-997e-0eb674b40b79"));
    newVmTemplate = new VmTemplate();
    newVmTemplate.setId(Guid.NewGuid());
    newVmTemplate.setName("NewVmTemplate");
    newVmTemplate.setVdsGroupId(VDS_GROUP_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmTemplateDao();
    existingTemplate = dao.get(new Guid("1b85420c-b84c-4f29-997e-0eb674b40b79"));
    newVmTemplate = new VmTemplate();
    newVmTemplate.setId(Guid.newGuid());
    newVmTemplate.setName("NewVmTemplate");
    newVmTemplate.setVdsGroupId(VDS_GROUP_ID);
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    VmTemplate result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    VmTemplate result = dao.get(Guid.newGuid());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetImageType() {
    InstanceType result = dao.getInstanceType(EXISTING_IMAGE_TYPE_ID);
    assertNotNull(result);
    assertEquals(EXISTING_IMAGE_TYPE_ID, result.getId());
}
#method_after
@Test
public void testGetImageType() {
    ImageType result = dao.getImageType(EXISTING_IMAGE_TYPE_ID);
    assertNotNull(result);
    assertEquals(EXISTING_IMAGE_TYPE_ID, result.getId());
}
#end_block

#method_before
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != TemplateType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#end_block

#method_before
public ImageType getImageType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != TemplateType.IMAGE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public ImageType getImageType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.IMAGE_TYPE) {
        result = null;
    }
    return result;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOs()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("is_auto_suspend", template.isAutoSuspend()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("template_type", template.getTemplateType().name());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOs(VmOsType.forValue(rs.getInt("os")));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTemplateType(TemplateType.valueOf(rs.getString("entity_type")));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    return entity;
}
#end_block

#method_before
public VmTemplateStatus getStatus() {
    return status;
}
#method_after
@Override
public VmTemplateStatus getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#method_after
@Override
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#end_block

#method_before
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#method_after
public Guid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
public void setStoragePoolId(NGuid value) {
    storagePoolId = value;
}
#method_after
public void setStoragePoolId(Guid value) {
    storagePoolId = value;
}
#end_block

#method_before
@JsonIgnore
public Map<Guid, DiskImage> getDiskImageMap() {
    return diskMap;
}
#method_after
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskImageMap;
}
#end_block

#method_before
public void setDiskImageMap(Map<Guid, DiskImage> value) {
    diskMap = value;
}
#method_after
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskImageMap = value;
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
public VmTemplateStatus getStatus() {
    return status;
}
#method_after
@Override
public VmTemplateStatus getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#method_after
@Override
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#end_block

#method_before
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#method_after
public Guid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
public void setStoragePoolId(NGuid value) {
    storagePoolId = value;
}
#method_after
public void setStoragePoolId(Guid value) {
    storagePoolId = value;
}
#end_block

#method_before
@JsonIgnore
public Map<Guid, DiskImage> getDiskImageMap() {
    return diskMap;
}
#method_after
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskImageMap;
}
#end_block

#method_before
public void setDiskImageMap(Map<Guid, DiskImage> value) {
    diskMap = value;
}
#method_after
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskImageMap = value;
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
@Override
public List<VM> getAllForVmPool(NGuid vmPoolId) {
    return getCallsHandler().executeReadList("GetVmsByVmPoolId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vm_pool_id", vmPoolId));
}
#method_after
@Override
public List<VM> getAllForVmPool(Guid vmPoolId) {
    return getCallsHandler().executeReadList("GetVmsByVmPoolId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vm_pool_id", vmPoolId));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setInstanceTypeId(NGuid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(NGuid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOs()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("is_auto_suspend", template.isAutoSuspend()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("template_type", template.getTemplateType().name());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOs(VmOsType.forValue(rs.getInt("os")));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTemplateType(TemplateType.valueOf(rs.getString("entity_type")));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    return entity;
}
#end_block

#method_before
public VmOsType getOs() {
    return this.getVmOs();
}
#method_after
public int getOs() {
    return this.getVmOsId();
}
#end_block

#method_before
public void setVmOs(VmOsType value) {
    this.vmStatic.setOs(value);
}
#method_after
public void setVmOs(int value) {
    this.vmStatic.setOsId(value);
}
#end_block

#method_before
public NGuid getDedicatedVmForVds() {
    return vmStatic.getDedicatedVmForVds();
}
#method_after
public Guid getDedicatedVmForVds() {
    return vmStatic.getDedicatedVmForVds();
}
#end_block

#method_before
public void setDedicatedVmForVds(NGuid value) {
    vmStatic.setDedicatedVmForVds(value);
}
#method_after
public void setDedicatedVmForVds(Guid value) {
    vmStatic.setDedicatedVmForVds(value);
}
#end_block

#method_before
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#method_after
@Override
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#end_block

#method_before
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#method_after
@Override
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#end_block

#method_before
public NGuid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#method_after
public Guid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#end_block

#method_before
public void setConsoleUserId(NGuid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#method_after
public void setConsoleUserId(Guid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#end_block

#method_before
public NGuid getRunOnVds() {
    return this.vmDynamic.getRunOnVds();
}
#method_after
public Guid getRunOnVds() {
    return this.vmDynamic.getRunOnVds();
}
#end_block

#method_before
public void setRunOnVds(NGuid value) {
    this.vmDynamic.setRunOnVds(value);
}
#method_after
public void setRunOnVds(Guid value) {
    this.vmDynamic.setRunOnVds(value);
}
#end_block

#method_before
public NGuid getMigratingToVds() {
    return this.vmDynamic.getMigratingToVds();
}
#method_after
public Guid getMigratingToVds() {
    return this.vmDynamic.getMigratingToVds();
}
#end_block

#method_before
public void setMigratingToVds(NGuid value) {
    this.vmDynamic.setMigratingToVds(value);
}
#method_after
public void setMigratingToVds(Guid value) {
    this.vmDynamic.setMigratingToVds(value);
}
#end_block

#method_before
public NGuid getLastVdsRunOn() {
    return this.vmDynamic.getLastVdsRunOn();
}
#method_after
public Guid getLastVdsRunOn() {
    return this.vmDynamic.getLastVdsRunOn();
}
#end_block

#method_before
public void setLastVdsRunOn(NGuid value) {
    this.vmDynamic.setLastVdsRunOn(value);
}
#method_after
public void setLastVdsRunOn(Guid value) {
    this.vmDynamic.setLastVdsRunOn(value);
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((selectionAlgorithm == null) ? 0 : selectionAlgorithm.hashCode());
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + (useSysPrep ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + ((vmtOs == null) ? 0 : vmtOs.hashCode());
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
public NGuid getVmPoolId() {
    return vmPoolId;
}
#method_after
public Guid getVmPoolId() {
    return vmPoolId;
}
#end_block

#method_before
public void setVmPoolId(NGuid value) {
    vmPoolId = value;
}
#method_after
public void setVmPoolId(Guid value) {
    vmPoolId = value;
}
#end_block

#method_before
public void setRunOnce(boolean value) {
    runOnce = value;
}
#method_after
public void setRunOnce(boolean value) {
    vmDynamic.setRunOnce(value);
}
#end_block

#method_before
public boolean isRunOnce() {
    return runOnce;
}
#method_after
public boolean isRunOnce() {
    return vmDynamic.isRunOnce();
}
#end_block

#method_before
public NGuid getInstanceTypeId() {
    return vmStatic.getInstanceTypeId();
}
#method_after
public Guid getInstanceTypeId() {
    return vmStatic.getInstanceTypeId();
}
#end_block

#method_before
public void setInstanceTypeId(NGuid instanceTypeId) {
    vmStatic.setInstanceTypeId(instanceTypeId);
}
#method_after
public void setInstanceTypeId(Guid instanceTypeId) {
    vmStatic.setInstanceTypeId(instanceTypeId);
}
#end_block

#method_before
public NGuid getImageTypeId() {
    return vmStatic.getImageTypeId();
}
#method_after
public Guid getImageTypeId() {
    return vmStatic.getImageTypeId();
}
#end_block

#method_before
public void setImageTypeId(NGuid ImageTypeId) {
    vmStatic.setImageTypeId(ImageTypeId);
}
#method_after
public void setImageTypeId(Guid ImageTypeId) {
    vmStatic.setImageTypeId(ImageTypeId);
}
#end_block

#method_before
public NGuid getInstanceTypeId() {
    return instanceTypeId;
}
#method_after
public Guid getInstanceTypeId() {
    return instanceTypeId;
}
#end_block

#method_before
public void setInstanceTypeId(NGuid instanceTypeId) {
    this.instanceTypeId = instanceTypeId;
}
#method_after
public void setInstanceTypeId(Guid instanceTypeId) {
    this.instanceTypeId = instanceTypeId;
}
#end_block

#method_before
public NGuid getImageTypeId() {
    return imageTypeId;
}
#method_after
public Guid getImageTypeId() {
    return imageTypeId;
}
#end_block

#method_before
public void setImageTypeId(NGuid imageTypeId) {
    this.imageTypeId = imageTypeId;
}
#method_after
public void setImageTypeId(Guid imageTypeId) {
    this.imageTypeId = imageTypeId;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId());
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(NGuid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(NGuid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#end_block

